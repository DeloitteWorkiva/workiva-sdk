"""Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT."""

from .basesdk import BaseSDK
from .httpclient import AsyncHttpClient, ClientOwner, HttpClient, close_clients
from .sdkconfiguration import SDKConfiguration
from .utils.logger import Logger, get_default_logger
from .utils.retries import RetryConfig
import httpx
import importlib
import sys
from typing import Callable, Dict, Optional, TYPE_CHECKING, Union, cast
import weakref
from workiva import models, utils
from workiva._hooks import SDKHooks
from workiva.types import OptionalNullable, UNSET

if TYPE_CHECKING:
    from workiva.activities import Activities
    from workiva.admin import Admin
    from workiva.chains import Chains
    from workiva.content import Content
    from workiva.documents import Documents
    from workiva.files import Files
    from workiva.graph import Graph
    from workiva.iam import Iam
    from workiva.milestones import Milestones
    from workiva.operations import Operations
    from workiva.permissions import Permissions
    from workiva.presentations import Presentations
    from workiva.reports import Reports
    from workiva.spreadsheets import Spreadsheets
    from workiva.sustainability import Sustainability
    from workiva.tasks import Tasks
    from workiva.test_forms import TestForms
    from workiva.wdata import Wdata


class SDK(BaseSDK):
    r"""Workiva API: 2026-01-01 Version of the Workiva API
    https://developers.workiva.com - Developer documentation for Workiva Inc.
    """

    chains: "Chains"
    wdata: "Wdata"
    activities: "Activities"
    r"""Activities enable you to retrieve a list of actions performed in the organization or a specific workspace, such as: <ul> <li>User logins</li> <li>Added users</li> <li>Changes to roles</li> <li>Changes to organization or workspace settings</li> </ul> These activities are also available in the Workiva platform and can be exported from Organization Admin or Workspace Settings. <br /><br /> To access activities through this API or in Workiva, a user must have a valid admin role: <ul> <li>Org User Admin</li> <li>Org Workspace Admin</li> <li>Org Security Admin, for organization activities</li> <li>Workspace Owner, for workspace activities</li> </ul> Learn more about these roles [here](https://support.workiva.com/hc/en-us/articles/360036006051-Organization-roles) and Workiva activities [here](https://support.workiva.com/hc/en-us/articles/360035646392-View-organization-activities).

    """
    content: "Content"
    r"""Endpoints for reading and writing Workiva content. See [**Introduction to Content Endpoints**](ref:content-guide) for more information."""
    milestones: "Milestones"
    r"""Endpoints for working with Milestones. See [**Introduction to Milestones Endpoints**](ref:milestones-guide) for more information."""
    sustainability: "Sustainability"
    r"""Endpoints to manage Sustainability Programs"""
    admin: "Admin"
    r"""Endpoints to manage organizations, workspaces, groups, and users"""
    reports: "Reports"
    r"""Endpoints used to generate Admin reports"""
    iam: "Iam"
    r"""Before your application can access private data using other Workiva APIs, it must obtain an access token that grants access to those APIs.

    Use the IAM REST API endpoint to exchange your OAuth credentials (clientID and clientSecret) for a token.

    """
    documents: "Documents"
    r"""Documents enable you to organize and review data in collaborative files with linked text, documents, and images. Use these endpoints to manage documents and their sections in the Workiva Platform."""
    files: "Files"
    r"""Endpoints to manage files and folders."""
    graph: "Graph"
    r"""The Graph endpoints enable access to Integrated Risk workspaces, such as to pull reports and records, create and edit records, and more. <br /><br /> Please refer to the [Graph Guides](ref:graph-guide) for further documentation and examples."""
    operations: "Operations"
    r"""Use these endpoints to manage operations, such as to check their status."""
    permissions: "Permissions"
    r"""Endpoints to manage Permissions"""
    presentations: "Presentations"
    r"""Endpoints to manage presentations"""
    spreadsheets: "Spreadsheets"
    r"""Spreadsheets enable you to work with large, complex data in a familiar, collaborative, and controlled environment. Use these endpoints to manage spreadsheets and their sheets in the Workiva platform."""
    tasks: "Tasks"
    r"""Tasks enable users to manage projects, organize responsibilities, and meet deadlines in the Workiva platform. Use these endpoints to create and manage tasks.

    """
    test_forms: "TestForms"
    r"""These endpoints are used to manage test forms, test phases, and matrices. They are also used to manage attachments on test phases, matrices, and samples.

    """
    _sub_sdk_map = {
        "chains": ("workiva.chains", "Chains"),
        "wdata": ("workiva.wdata", "Wdata"),
        "activities": ("workiva.activities", "Activities"),
        "content": ("workiva.content", "Content"),
        "milestones": ("workiva.milestones", "Milestones"),
        "sustainability": ("workiva.sustainability", "Sustainability"),
        "admin": ("workiva.admin", "Admin"),
        "reports": ("workiva.reports", "Reports"),
        "iam": ("workiva.iam", "Iam"),
        "documents": ("workiva.documents", "Documents"),
        "files": ("workiva.files", "Files"),
        "graph": ("workiva.graph", "Graph"),
        "operations": ("workiva.operations", "Operations"),
        "permissions": ("workiva.permissions", "Permissions"),
        "presentations": ("workiva.presentations", "Presentations"),
        "spreadsheets": ("workiva.spreadsheets", "Spreadsheets"),
        "tasks": ("workiva.tasks", "Tasks"),
        "test_forms": ("workiva.test_forms", "TestForms"),
    }

    def __init__(
        self,
        security: Optional[
            Union[models.Security, Callable[[], models.Security]]
        ] = None,
        server_idx: Optional[int] = None,
        server_url: Optional[str] = None,
        url_params: Optional[Dict[str, str]] = None,
        client: Optional[HttpClient] = None,
        async_client: Optional[AsyncHttpClient] = None,
        retry_config: OptionalNullable[RetryConfig] = UNSET,
        timeout_ms: Optional[int] = None,
        debug_logger: Optional[Logger] = None,
    ) -> None:
        r"""Instantiates the SDK configuring it with the provided parameters.

        :param security: The security details required for authentication
        :param server_idx: The index of the server to use for all methods
        :param server_url: The server URL to use for all methods
        :param url_params: Parameters to optionally template the server URL with
        :param client: The HTTP client to use for all synchronous methods
        :param async_client: The Async HTTP client to use for all asynchronous methods
        :param retry_config: The retry configuration to use for all supported methods
        :param timeout_ms: Optional request timeout applied to each operation in milliseconds
        """
        client_supplied = True
        if client is None:
            client = httpx.Client(follow_redirects=True)
            client_supplied = False

        assert issubclass(
            type(client), HttpClient
        ), "The provided client must implement the HttpClient protocol."

        async_client_supplied = True
        if async_client is None:
            async_client = httpx.AsyncClient(follow_redirects=True)
            async_client_supplied = False

        if debug_logger is None:
            debug_logger = get_default_logger()

        assert issubclass(
            type(async_client), AsyncHttpClient
        ), "The provided async_client must implement the AsyncHttpClient protocol."

        if server_url is not None:
            if url_params is not None:
                server_url = utils.template_url(server_url, url_params)

        BaseSDK.__init__(
            self,
            SDKConfiguration(
                client=client,
                client_supplied=client_supplied,
                async_client=async_client,
                async_client_supplied=async_client_supplied,
                security=security,
                server_url=server_url,
                server_idx=server_idx,
                retry_config=retry_config,
                timeout_ms=timeout_ms,
                debug_logger=debug_logger,
            ),
            parent_ref=self,
        )

        hooks = SDKHooks()

        # pylint: disable=protected-access
        self.sdk_configuration.__dict__["_hooks"] = hooks

        self.sdk_configuration = hooks.sdk_init(self.sdk_configuration)

        weakref.finalize(
            self,
            close_clients,
            cast(ClientOwner, self.sdk_configuration),
            self.sdk_configuration.client,
            self.sdk_configuration.client_supplied,
            self.sdk_configuration.async_client,
            self.sdk_configuration.async_client_supplied,
        )

    def dynamic_import(self, modname, retries=3):
        for attempt in range(retries):
            try:
                return importlib.import_module(modname)
            except KeyError:
                # Clear any half-initialized module and retry
                sys.modules.pop(modname, None)
                if attempt == retries - 1:
                    break
        raise KeyError(f"Failed to import module '{modname}' after {retries} attempts")

    def __getattr__(self, name: str):
        if name in self._sub_sdk_map:
            module_path, class_name = self._sub_sdk_map[name]
            try:
                module = self.dynamic_import(module_path)
                klass = getattr(module, class_name)
                instance = klass(self.sdk_configuration, parent_ref=self)
                setattr(self, name, instance)
                return instance
            except ImportError as e:
                raise AttributeError(
                    f"Failed to import module {module_path} for attribute {name}: {e}"
                ) from e
            except AttributeError as e:
                raise AttributeError(
                    f"Failed to find class {class_name} in module {module_path} for attribute {name}: {e}"
                ) from e

        raise AttributeError(
            f"'{type(self).__name__}' object has no attribute '{name}'"
        )

    def __dir__(self):
        default_attrs = list(super().__dir__())
        lazy_attrs = list(self._sub_sdk_map.keys())
        return sorted(list(set(default_attrs + lazy_attrs)))

    def __enter__(self):
        return self

    async def __aenter__(self):
        return self

    def __exit__(self, exc_type, exc_val, exc_tb):
        if (
            self.sdk_configuration.client is not None
            and not self.sdk_configuration.client_supplied
        ):
            self.sdk_configuration.client.close()
        self.sdk_configuration.client = None

    async def __aexit__(self, exc_type, exc_val, exc_tb):
        if (
            self.sdk_configuration.async_client is not None
            and not self.sdk_configuration.async_client_supplied
        ):
            await self.sdk_configuration.async_client.aclose()
        self.sdk_configuration.async_client = None
