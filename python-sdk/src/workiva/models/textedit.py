"""Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT."""

from __future__ import annotations
from .applicabletextformat import ApplicableTextFormat, ApplicableTextFormatTypedDict
from .caret import Caret, CaretTypedDict
from .paragraphselection import ParagraphSelection, ParagraphSelectionTypedDict
from .richtextbaselineshift import RichTextBaselineShift
from .richtextselection import RichTextSelection, RichTextSelectionTypedDict
from enum import Enum
import pydantic
from pydantic import model_serializer
from typing import Optional
from typing_extensions import Annotated, NotRequired, TypedDict
from workiva.types import BaseModel, Nullable, OptionalNullable, UNSET, UNSET_SENTINEL


class ClearListFormatTypedDict(TypedDict):
    r"""An edit to clear list formatting from a range of paragraphs in rich text. Not supported when the parent batch has isolated edits turned on."""

    selection: ParagraphSelectionTypedDict
    r"""A selection of one or more paragraphs, starting from the start paragraph and ending with the stop paragraph. Both start and stop paragraph indexes are inclusive.

    """
    clear_all: NotRequired[bool]
    r"""Whether to clear all list formats. This is the same as setting every other option to true. When new list formats are added to the api those will also be cleared. When true, all other clear option values are ignored."""
    clear_prefix: NotRequired[bool]
    r"""Whether to clear the list prefix."""
    clear_start_at: NotRequired[bool]
    r"""Whether to clear the start number of the list."""
    clear_style: NotRequired[bool]
    r"""Whether to clear the list style."""
    clear_suffix: NotRequired[bool]
    r"""Whether to clear the list suffix."""


class ClearListFormat(BaseModel):
    r"""An edit to clear list formatting from a range of paragraphs in rich text. Not supported when the parent batch has isolated edits turned on."""

    selection: ParagraphSelection
    r"""A selection of one or more paragraphs, starting from the start paragraph and ending with the stop paragraph. Both start and stop paragraph indexes are inclusive.

    """

    clear_all: Annotated[Optional[bool], pydantic.Field(alias="clearAll")] = False
    r"""Whether to clear all list formats. This is the same as setting every other option to true. When new list formats are added to the api those will also be cleared. When true, all other clear option values are ignored."""

    clear_prefix: Annotated[Optional[bool], pydantic.Field(alias="clearPrefix")] = False
    r"""Whether to clear the list prefix."""

    clear_start_at: Annotated[Optional[bool], pydantic.Field(alias="clearStartAt")] = (
        False
    )
    r"""Whether to clear the start number of the list."""

    clear_style: Annotated[Optional[bool], pydantic.Field(alias="clearStyle")] = False
    r"""Whether to clear the list style."""

    clear_suffix: Annotated[Optional[bool], pydantic.Field(alias="clearSuffix")] = False
    r"""Whether to clear the list suffix."""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            ["clearAll", "clearPrefix", "clearStartAt", "clearStyle", "clearSuffix"]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class ClearParagraphPropertiesTypedDict(TypedDict):
    r"""An edit to clear paragraph properties from a range of paragraphs in rich text."""

    selection: ParagraphSelectionTypedDict
    r"""A selection of one or more paragraphs, starting from the start paragraph and ending with the stop paragraph. Both start and stop paragraph indexes are inclusive.

    """
    clear_alignment: NotRequired[bool]
    r"""Whether to clear the alignment."""
    clear_all: NotRequired[bool]
    r"""Whether to clear all paragraph properties. This is the same as setting every other option to true. When new paragraph properties are added those will also be cleared. When true, all other clear option values are ignored."""
    clear_end_indent: NotRequired[bool]
    r"""Whether to clear the end indent."""
    clear_first_line_indent: NotRequired[bool]
    r"""Whether to clear the first line indent."""
    clear_line_spacing: NotRequired[bool]
    r"""Whether to clear the line spacing."""
    clear_page_break_before: NotRequired[bool]
    r"""Whether to clear page break before."""
    clear_space_after_paragraph: NotRequired[bool]
    r"""Whether to clear the space after paragraph."""
    clear_space_before_paragraph: NotRequired[bool]
    r"""Whether to clear the space before paragraph."""
    clear_start_indent: NotRequired[bool]
    r"""Whether to clear the start indent."""


class ClearParagraphProperties(BaseModel):
    r"""An edit to clear paragraph properties from a range of paragraphs in rich text."""

    selection: ParagraphSelection
    r"""A selection of one or more paragraphs, starting from the start paragraph and ending with the stop paragraph. Both start and stop paragraph indexes are inclusive.

    """

    clear_alignment: Annotated[
        Optional[bool], pydantic.Field(alias="clearAlignment")
    ] = False
    r"""Whether to clear the alignment."""

    clear_all: Annotated[Optional[bool], pydantic.Field(alias="clearAll")] = False
    r"""Whether to clear all paragraph properties. This is the same as setting every other option to true. When new paragraph properties are added those will also be cleared. When true, all other clear option values are ignored."""

    clear_end_indent: Annotated[
        Optional[bool], pydantic.Field(alias="clearEndIndent")
    ] = False
    r"""Whether to clear the end indent."""

    clear_first_line_indent: Annotated[
        Optional[bool], pydantic.Field(alias="clearFirstLineIndent")
    ] = False
    r"""Whether to clear the first line indent."""

    clear_line_spacing: Annotated[
        Optional[bool], pydantic.Field(alias="clearLineSpacing")
    ] = False
    r"""Whether to clear the line spacing."""

    clear_page_break_before: Annotated[
        Optional[bool], pydantic.Field(alias="clearPageBreakBefore")
    ] = False
    r"""Whether to clear page break before."""

    clear_space_after_paragraph: Annotated[
        Optional[bool], pydantic.Field(alias="clearSpaceAfterParagraph")
    ] = False
    r"""Whether to clear the space after paragraph."""

    clear_space_before_paragraph: Annotated[
        Optional[bool], pydantic.Field(alias="clearSpaceBeforeParagraph")
    ] = False
    r"""Whether to clear the space before paragraph."""

    clear_start_indent: Annotated[
        Optional[bool], pydantic.Field(alias="clearStartIndent")
    ] = False
    r"""Whether to clear the start indent."""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            [
                "clearAlignment",
                "clearAll",
                "clearEndIndent",
                "clearFirstLineIndent",
                "clearLineSpacing",
                "clearPageBreakBefore",
                "clearSpaceAfterParagraph",
                "clearSpaceBeforeParagraph",
                "clearStartIndent",
            ]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class ClearTextFormatTypedDict(TypedDict):
    r"""An edit to clear formatting from a range of rich text. This will not clear out styles nor hyperlinks."""

    selection: RichTextSelectionTypedDict
    r"""Describes a selection within piece of rich text"""
    clear_all: NotRequired[bool]
    r"""Whether to clear all text formats. This is the same as setting every other option to true. When new text formats are added those will also be cleared. When true, all other clear option values are ignored."""
    clear_background_color: NotRequired[bool]
    r"""Whether to clear the background color."""
    clear_baseline_shift: NotRequired[bool]
    r"""Whether to clear the baseline shift."""
    clear_bold: NotRequired[bool]
    r"""Whether to clear bold."""
    clear_character_spacing: NotRequired[bool]
    r"""Whether to clear the character spacing."""
    clear_font: NotRequired[bool]
    r"""Whether to clear the font."""
    clear_italic: NotRequired[bool]
    r"""Whether to clear italic."""
    clear_size: NotRequired[bool]
    r"""Whether to clear the font size."""
    clear_strikethrough: NotRequired[bool]
    r"""Whether to clear strikethrough."""
    clear_text_color: NotRequired[bool]
    r"""Whether to clear the text color."""
    clear_underline: NotRequired[bool]
    r"""Whether to clear underline."""


class ClearTextFormat(BaseModel):
    r"""An edit to clear formatting from a range of rich text. This will not clear out styles nor hyperlinks."""

    selection: RichTextSelection
    r"""Describes a selection within piece of rich text"""

    clear_all: Annotated[Optional[bool], pydantic.Field(alias="clearAll")] = False
    r"""Whether to clear all text formats. This is the same as setting every other option to true. When new text formats are added those will also be cleared. When true, all other clear option values are ignored."""

    clear_background_color: Annotated[
        Optional[bool], pydantic.Field(alias="clearBackgroundColor")
    ] = False
    r"""Whether to clear the background color."""

    clear_baseline_shift: Annotated[
        Optional[bool], pydantic.Field(alias="clearBaselineShift")
    ] = False
    r"""Whether to clear the baseline shift."""

    clear_bold: Annotated[Optional[bool], pydantic.Field(alias="clearBold")] = False
    r"""Whether to clear bold."""

    clear_character_spacing: Annotated[
        Optional[bool], pydantic.Field(alias="clearCharacterSpacing")
    ] = False
    r"""Whether to clear the character spacing."""

    clear_font: Annotated[Optional[bool], pydantic.Field(alias="clearFont")] = False
    r"""Whether to clear the font."""

    clear_italic: Annotated[Optional[bool], pydantic.Field(alias="clearItalic")] = False
    r"""Whether to clear italic."""

    clear_size: Annotated[Optional[bool], pydantic.Field(alias="clearSize")] = False
    r"""Whether to clear the font size."""

    clear_strikethrough: Annotated[
        Optional[bool], pydantic.Field(alias="clearStrikethrough")
    ] = False
    r"""Whether to clear strikethrough."""

    clear_text_color: Annotated[
        Optional[bool], pydantic.Field(alias="clearTextColor")
    ] = False
    r"""Whether to clear the text color."""

    clear_underline: Annotated[
        Optional[bool], pydantic.Field(alias="clearUnderline")
    ] = False
    r"""Whether to clear underline."""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            [
                "clearAll",
                "clearBackgroundColor",
                "clearBaselineShift",
                "clearBold",
                "clearCharacterSpacing",
                "clearFont",
                "clearItalic",
                "clearSize",
                "clearStrikethrough",
                "clearTextColor",
                "clearUnderline",
            ]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class DeleteTextTypedDict(TypedDict):
    r"""An edit to delete text from a range of rich text.  Note that all content, such as tables, images, charts, or footnotes, will also be deleted. Links must be removed from the selection using a [`RemoveLinks`](ref:content#removelinks) [links edit](ref:richtextlinksbatchedit) before deleting a selection containing links."""

    selection: RichTextSelectionTypedDict
    r"""Describes a selection within piece of rich text"""


class DeleteText(BaseModel):
    r"""An edit to delete text from a range of rich text.  Note that all content, such as tables, images, charts, or footnotes, will also be deleted. Links must be removed from the selection using a [`RemoveLinks`](ref:content#removelinks) [links edit](ref:richtextlinksbatchedit) before deleting a selection containing links."""

    selection: RichTextSelection
    r"""Describes a selection within piece of rich text"""


class TextEditBackgroundColorTypedDict(TypedDict):
    r"""Represents a color."""

    blue: int
    r"""The blue component of the color."""
    green: int
    r"""The green component of the color."""
    red: int
    r"""The red component of the color."""


class TextEditBackgroundColor(BaseModel):
    r"""Represents a color."""

    blue: int
    r"""The blue component of the color."""

    green: int
    r"""The green component of the color."""

    red: int
    r"""The red component of the color."""


class TextEditTextColorTypedDict(TypedDict):
    r"""Represents a color."""

    blue: int
    r"""The blue component of the color."""
    green: int
    r"""The green component of the color."""
    red: int
    r"""The red component of the color."""


class TextEditTextColor(BaseModel):
    r"""Represents a color."""

    blue: int
    r"""The blue component of the color."""

    green: int
    r"""The green component of the color."""

    red: int
    r"""The red component of the color."""


class FormatTextTypedDict(TypedDict):
    r"""An edit to format a range of rich text."""

    selection: RichTextSelectionTypedDict
    r"""Describes a selection within piece of rich text"""
    background_color: NotRequired[Nullable[TextEditBackgroundColorTypedDict]]
    baseline_shift: NotRequired[Nullable[RichTextBaselineShift]]
    r"""Indicates the offset from the baseline of the characters. The baseline is the imaginary bottom line for a line of text which the bottom of the characters are placed, not including any descender such as g, j, p, and y have. `superscript` shifts the baseline up and reduces the rendered font size to 65% of the specified font size. `subscript` works the same as `superscript` except it moves the baseline down. `baseline` uses the default size and baseline for regular text. type: string

    """
    bold: NotRequired[Nullable[bool]]
    r"""Whether or not the text is bold"""
    character_spacing: NotRequired[Nullable[int]]
    r"""The amount of space between characters in thousanths of an em.

    """
    font: NotRequired[Nullable[str]]
    r"""The name of the font"""
    italic: NotRequired[Nullable[bool]]
    r"""Whether or not the text is italicized"""
    size: NotRequired[Nullable[float]]
    r"""The font size of the characters in points"""
    strikethrough: NotRequired[Nullable[bool]]
    r"""Whether or not the text is struck through"""
    text_color: NotRequired[Nullable[TextEditTextColorTypedDict]]
    underline: NotRequired[Nullable[bool]]
    r"""Whether or not the text is underlined"""


class FormatText(BaseModel):
    r"""An edit to format a range of rich text."""

    selection: RichTextSelection
    r"""Describes a selection within piece of rich text"""

    background_color: Annotated[
        OptionalNullable[TextEditBackgroundColor],
        pydantic.Field(alias="backgroundColor"),
    ] = UNSET

    baseline_shift: Annotated[
        OptionalNullable[RichTextBaselineShift], pydantic.Field(alias="baselineShift")
    ] = UNSET
    r"""Indicates the offset from the baseline of the characters. The baseline is the imaginary bottom line for a line of text which the bottom of the characters are placed, not including any descender such as g, j, p, and y have. `superscript` shifts the baseline up and reduces the rendered font size to 65% of the specified font size. `subscript` works the same as `superscript` except it moves the baseline down. `baseline` uses the default size and baseline for regular text. type: string

    """

    bold: OptionalNullable[bool] = False
    r"""Whether or not the text is bold"""

    character_spacing: Annotated[
        OptionalNullable[int], pydantic.Field(alias="characterSpacing")
    ] = UNSET
    r"""The amount of space between characters in thousanths of an em.

    """

    font: OptionalNullable[str] = UNSET
    r"""The name of the font"""

    italic: OptionalNullable[bool] = False
    r"""Whether or not the text is italicized"""

    size: OptionalNullable[float] = 12
    r"""The font size of the characters in points"""

    strikethrough: OptionalNullable[bool] = False
    r"""Whether or not the text is struck through"""

    text_color: Annotated[
        OptionalNullable[TextEditTextColor], pydantic.Field(alias="textColor")
    ] = UNSET

    underline: OptionalNullable[bool] = False
    r"""Whether or not the text is underlined"""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            [
                "backgroundColor",
                "baselineShift",
                "bold",
                "characterSpacing",
                "font",
                "italic",
                "size",
                "strikethrough",
                "textColor",
                "underline",
            ]
        )
        nullable_fields = set(
            [
                "backgroundColor",
                "baselineShift",
                "bold",
                "characterSpacing",
                "font",
                "italic",
                "size",
                "strikethrough",
                "textColor",
                "underline",
            ]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            is_nullable_and_explicitly_set = (
                k in nullable_fields
                and (self.__pydantic_fields_set__.intersection({n}))  # pylint: disable=no-member
            )

            if val != UNSET_SENTINEL:
                if (
                    val is not None
                    or k not in optional_fields
                    or is_nullable_and_explicitly_set
                ):
                    m[k] = val

        return m


class InsertFootnoteTypedDict(TypedDict):
    r"""A text edit for inserting a footnote into rich text. The created rich text id associated with the footnote annotation area can be retrieved from the rich text edit operation results. This edit is not supported in table rich cell edits."""

    insert_at: CaretTypedDict
    r"""A caret (as in Caret Navigation) is a location between two characters in a paragraph."""


class InsertFootnote(BaseModel):
    r"""A text edit for inserting a footnote into rich text. The created rich text id associated with the footnote annotation area can be retrieved from the rich text edit operation results. This edit is not supported in table rich cell edits."""

    insert_at: Annotated[Caret, pydantic.Field(alias="insertAt")]
    r"""A caret (as in Caret Navigation) is a location between two characters in a paragraph."""


class TextEditDimensionsTypedDict(TypedDict):
    r"""The dimensions of the inserted image."""

    height: float
    r"""The vertical measurement in points."""
    width: float
    r"""The horizontal measurement in points."""


class TextEditDimensions(BaseModel):
    r"""The dimensions of the inserted image."""

    height: float
    r"""The vertical measurement in points."""

    width: float
    r"""The horizontal measurement in points."""


class InsertImageTypedDict(TypedDict):
    r"""A text edit for inserting an image into rich text."""

    dimensions: TextEditDimensionsTypedDict
    r"""The dimensions of the inserted image."""
    image: str
    r"""The unique identifier of the image to insert. Each image can only be inserted into content once."""
    insert_at: CaretTypedDict
    r"""A caret (as in Caret Navigation) is a location between two characters in a paragraph."""


class InsertImage(BaseModel):
    r"""A text edit for inserting an image into rich text."""

    dimensions: TextEditDimensions
    r"""The dimensions of the inserted image."""

    image: str
    r"""The unique identifier of the image to insert. Each image can only be inserted into content once."""

    insert_at: Annotated[Caret, pydantic.Field(alias="insertAt")]
    r"""A caret (as in Caret Navigation) is a location between two characters in a paragraph."""


class InsertPageNumberTypedDict(TypedDict):
    r"""A text edit for inserting a page number into header or footer text."""

    insert_at: CaretTypedDict
    r"""A caret (as in Caret Navigation) is a location between two characters in a paragraph."""


class InsertPageNumber(BaseModel):
    r"""A text edit for inserting a page number into header or footer text."""

    insert_at: Annotated[Caret, pydantic.Field(alias="insertAt")]
    r"""A caret (as in Caret Navigation) is a location between two characters in a paragraph."""


class InsertParagraphTypedDict(TypedDict):
    r"""A text edit for inserting a new paragraph."""

    insert_at: CaretTypedDict
    r"""A caret (as in Caret Navigation) is a location between two characters in a paragraph."""


class InsertParagraph(BaseModel):
    r"""A text edit for inserting a new paragraph."""

    insert_at: Annotated[Caret, pydantic.Field(alias="insertAt")]
    r"""A caret (as in Caret Navigation) is a location between two characters in a paragraph."""


class InsertSoftReturnTypedDict(TypedDict):
    r"""A text edit for inserting a soft return into text. This moves the following text elements to a new line without creating a new paragraph."""

    insert_at: CaretTypedDict
    r"""A caret (as in Caret Navigation) is a location between two characters in a paragraph."""


class InsertSoftReturn(BaseModel):
    r"""A text edit for inserting a soft return into text. This moves the following text elements to a new line without creating a new paragraph."""

    insert_at: Annotated[Caret, pydantic.Field(alias="insertAt")]
    r"""A caret (as in Caret Navigation) is a location between two characters in a paragraph."""


class TextEditSchemasDimensionsTypedDict(TypedDict):
    r"""The dimensions of the inserted table. If a width or height are omitted the width or height will be defaulted based off the number of columns or rows."""

    height: NotRequired[Nullable[float]]
    r"""The vertical measurement in points."""
    width: NotRequired[Nullable[float]]
    r"""The horizontal measurement in points."""


class TextEditSchemasDimensions(BaseModel):
    r"""The dimensions of the inserted table. If a width or height are omitted the width or height will be defaulted based off the number of columns or rows."""

    height: OptionalNullable[float] = UNSET
    r"""The vertical measurement in points."""

    width: OptionalNullable[float] = UNSET
    r"""The horizontal measurement in points."""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["height", "width"])
        nullable_fields = set(["height", "width"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            is_nullable_and_explicitly_set = (
                k in nullable_fields
                and (self.__pydantic_fields_set__.intersection({n}))  # pylint: disable=no-member
            )

            if val != UNSET_SENTINEL:
                if (
                    val is not None
                    or k not in optional_fields
                    or is_nullable_and_explicitly_set
                ):
                    m[k] = val

        return m


class InsertTableTypedDict(TypedDict):
    r"""A text edit for inserting an embedded table into rich text. If a dimensions property is set it will be respected unless it forces a cell to shrink beyond a minimum width. The created table id associated with the embedded table can be retrieved from the rich text edit operation results. This edit is not supported in table rich cell edits."""

    insert_at: CaretTypedDict
    r"""A caret (as in Caret Navigation) is a location between two characters in a paragraph."""
    column_count: NotRequired[int]
    r"""The number of columns in the table."""
    dimensions: NotRequired[TextEditSchemasDimensionsTypedDict]
    r"""The dimensions of the inserted table. If a width or height are omitted the width or height will be defaulted based off the number of columns or rows.

    """
    row_count: NotRequired[int]
    r"""The number of rows in the table."""


class InsertTable(BaseModel):
    r"""A text edit for inserting an embedded table into rich text. If a dimensions property is set it will be respected unless it forces a cell to shrink beyond a minimum width. The created table id associated with the embedded table can be retrieved from the rich text edit operation results. This edit is not supported in table rich cell edits."""

    insert_at: Annotated[Caret, pydantic.Field(alias="insertAt")]
    r"""A caret (as in Caret Navigation) is a location between two characters in a paragraph."""

    column_count: Annotated[Optional[int], pydantic.Field(alias="columnCount")] = 5
    r"""The number of columns in the table."""

    dimensions: Optional[TextEditSchemasDimensions] = None
    r"""The dimensions of the inserted table. If a width or height are omitted the width or height will be defaulted based off the number of columns or rows.

    """

    row_count: Annotated[Optional[int], pydantic.Field(alias="rowCount")] = 10
    r"""The number of rows in the table."""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["columnCount", "dimensions", "rowCount"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class InsertTextTypedDict(TypedDict):
    r"""A text edit for inserting new rich text."""

    insert_at: CaretTypedDict
    r"""A caret (as in Caret Navigation) is a location between two characters in a paragraph."""
    text: str
    r"""The text to insert."""
    format_: NotRequired[Nullable[ApplicableTextFormatTypedDict]]
    r"""Formatting options to be applied to rich text elements"""
    inherit_formats: NotRequired[bool]
    r"""Indicates if this text should use the formats from the text around where this new text is being inserted at. The specified formats will override inherited formats.

    """
    style: NotRequired[Nullable[str]]
    r"""The unique identifier of a style."""


class InsertText(BaseModel):
    r"""A text edit for inserting new rich text."""

    insert_at: Annotated[Caret, pydantic.Field(alias="insertAt")]
    r"""A caret (as in Caret Navigation) is a location between two characters in a paragraph."""

    text: str
    r"""The text to insert."""

    format_: Annotated[
        OptionalNullable[ApplicableTextFormat], pydantic.Field(alias="format")
    ] = UNSET
    r"""Formatting options to be applied to rich text elements"""

    inherit_formats: Annotated[
        Optional[bool], pydantic.Field(alias="inheritFormats")
    ] = True
    r"""Indicates if this text should use the formats from the text around where this new text is being inserted at. The specified formats will override inherited formats.

    """

    style: OptionalNullable[str] = UNSET
    r"""The unique identifier of a style."""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["format", "inheritFormats", "style"])
        nullable_fields = set(["format", "style"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            is_nullable_and_explicitly_set = (
                k in nullable_fields
                and (self.__pydantic_fields_set__.intersection({n}))  # pylint: disable=no-member
            )

            if val != UNSET_SENTINEL:
                if (
                    val is not None
                    or k not in optional_fields
                    or is_nullable_and_explicitly_set
                ):
                    m[k] = val

        return m


class SelectionTypedDict(TypedDict):
    r"""The selection where the hyperlinks will be removed. All hyperlinks within the selection will be removed."""

    start: CaretTypedDict
    r"""A caret (as in Caret Navigation) is a location between two characters in a paragraph."""
    stop: CaretTypedDict
    r"""A caret (as in Caret Navigation) is a location between two characters in a paragraph."""


class Selection(BaseModel):
    r"""The selection where the hyperlinks will be removed. All hyperlinks within the selection will be removed."""

    start: Caret
    r"""A caret (as in Caret Navigation) is a location between two characters in a paragraph."""

    stop: Caret
    r"""A caret (as in Caret Navigation) is a location between two characters in a paragraph."""


class RemoveHyperlinksTypedDict(TypedDict):
    r"""Removes hyperlinks from a range of text. If a selection starts or stops in the middle of an existing hyperlink the selection will be expanded to include the start and stop of the existing hyperlink."""

    selection: SelectionTypedDict
    r"""The selection where the hyperlinks will be removed. All hyperlinks within the selection will be removed.

    """


class RemoveHyperlinks(BaseModel):
    r"""Removes hyperlinks from a range of text. If a selection starts or stops in the middle of an existing hyperlink the selection will be expanded to include the start and stop of the existing hyperlink."""

    selection: Selection
    r"""The selection where the hyperlinks will be removed. All hyperlinks within the selection will be removed.

    """


class TextEditSectionTypedDict(TypedDict):
    r"""The document and section ids associated with the section hyperlink"""

    document: NotRequired[str]
    r"""The document id associated with the section hyperlink"""
    section: NotRequired[str]
    r"""The section id associated with the section hyperlink"""


class TextEditSection(BaseModel):
    r"""The document and section ids associated with the section hyperlink"""

    document: Optional[str] = None
    r"""The document id associated with the section hyperlink"""

    section: Optional[str] = None
    r"""The section id associated with the section hyperlink"""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["document", "section"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class TextEditSelectionTypedDict(TypedDict):
    r"""The selection where the hyperlink will be applied. The selection range cannot contain any new lines, source links,
    destination links, embedded content (tables, images, charts, etc.), footnotes, or any dynamic references (page numbers,
    list item references, etc.)

    """

    start: CaretTypedDict
    r"""A caret (as in Caret Navigation) is a location between two characters in a paragraph."""
    stop: CaretTypedDict
    r"""A caret (as in Caret Navigation) is a location between two characters in a paragraph."""


class TextEditSelection(BaseModel):
    r"""The selection where the hyperlink will be applied. The selection range cannot contain any new lines, source links,
    destination links, embedded content (tables, images, charts, etc.), footnotes, or any dynamic references (page numbers,
    list item references, etc.)

    """

    start: Caret
    r"""A caret (as in Caret Navigation) is a location between two characters in a paragraph."""

    stop: Caret
    r"""A caret (as in Caret Navigation) is a location between two characters in a paragraph."""


class TextEditSheetTypedDict(TypedDict):
    r"""The spreadsheet and sheet ids associated with the sheet hyperlink"""

    sheet: NotRequired[str]
    r"""The sheet id associated with the sheet hyperlink"""
    spreadsheet: NotRequired[str]
    r"""The spreadsheet id associated with the sheet hyperlink"""


class TextEditSheet(BaseModel):
    r"""The spreadsheet and sheet ids associated with the sheet hyperlink"""

    sheet: Optional[str] = None
    r"""The sheet id associated with the sheet hyperlink"""

    spreadsheet: Optional[str] = None
    r"""The spreadsheet id associated with the sheet hyperlink"""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["sheet", "spreadsheet"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class TextEditSlideTypedDict(TypedDict):
    r"""The presentation and slide ids associated with the slide hyperlink"""

    presentation: NotRequired[str]
    r"""The presentation id associated with the slide hyperlink"""
    slide: NotRequired[str]
    r"""The slide id associated with the slide hyperlink"""


class TextEditSlide(BaseModel):
    r"""The presentation and slide ids associated with the slide hyperlink"""

    presentation: Optional[str] = None
    r"""The presentation id associated with the slide hyperlink"""

    slide: Optional[str] = None
    r"""The slide id associated with the slide hyperlink"""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["presentation", "slide"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class TextEditSchemasType(str, Enum):
    r"""The type of hyperlink to create. The property associated with this hyperlink type is required."""

    DOCUMENT = "document"
    SECTION = "section"
    PRESENTATION = "presentation"
    SLIDE = "slide"
    SPREADSHEET = "spreadsheet"
    SHEET = "sheet"
    URL = "url"


class SetHyperlinkTypedDict(TypedDict):
    r"""Applies a hyperlink to a range of text. Any existing hyperlinks in a selection will be overwritten to point to the new hyperlink associated with this edit. If a selection starts or stops in the middle of an existing hyperlink the selection will be expanded to include the start and stop of the existing hyperlink."""

    selection: TextEditSelectionTypedDict
    r"""The selection where the hyperlink will be applied. The selection range cannot contain any new lines, source links,
    destination links, embedded content (tables, images, charts, etc.), footnotes, or any dynamic references (page numbers,
    list item references, etc.)

    """
    type: TextEditSchemasType
    r"""The type of hyperlink to create. The property associated with this hyperlink type is required."""
    document: NotRequired[Nullable[str]]
    r"""The document id associated with the document hyperlink"""
    presentation: NotRequired[Nullable[str]]
    r"""The presentation id associated with the presentation hyperlink"""
    section: NotRequired[Nullable[TextEditSectionTypedDict]]
    r"""The document and section ids associated with the section hyperlink"""
    sheet: NotRequired[Nullable[TextEditSheetTypedDict]]
    r"""The spreadsheet and sheet ids associated with the sheet hyperlink"""
    slide: NotRequired[Nullable[TextEditSlideTypedDict]]
    r"""The presentation and slide ids associated with the slide hyperlink"""
    spreadsheet: NotRequired[Nullable[str]]
    r"""The spreadsheet id associated with the spreadsheet hyperlink"""
    url: NotRequired[Nullable[str]]
    r"""The raw URL associated with the URL hyperlink"""


class SetHyperlink(BaseModel):
    r"""Applies a hyperlink to a range of text. Any existing hyperlinks in a selection will be overwritten to point to the new hyperlink associated with this edit. If a selection starts or stops in the middle of an existing hyperlink the selection will be expanded to include the start and stop of the existing hyperlink."""

    selection: TextEditSelection
    r"""The selection where the hyperlink will be applied. The selection range cannot contain any new lines, source links,
    destination links, embedded content (tables, images, charts, etc.), footnotes, or any dynamic references (page numbers,
    list item references, etc.)

    """

    type: TextEditSchemasType
    r"""The type of hyperlink to create. The property associated with this hyperlink type is required."""

    document: OptionalNullable[str] = UNSET
    r"""The document id associated with the document hyperlink"""

    presentation: OptionalNullable[str] = UNSET
    r"""The presentation id associated with the presentation hyperlink"""

    section: OptionalNullable[TextEditSection] = UNSET
    r"""The document and section ids associated with the section hyperlink"""

    sheet: OptionalNullable[TextEditSheet] = UNSET
    r"""The spreadsheet and sheet ids associated with the sheet hyperlink"""

    slide: OptionalNullable[TextEditSlide] = UNSET
    r"""The presentation and slide ids associated with the slide hyperlink"""

    spreadsheet: OptionalNullable[str] = UNSET
    r"""The spreadsheet id associated with the spreadsheet hyperlink"""

    url: OptionalNullable[str] = UNSET
    r"""The raw URL associated with the URL hyperlink"""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            [
                "document",
                "presentation",
                "section",
                "sheet",
                "slide",
                "spreadsheet",
                "url",
            ]
        )
        nullable_fields = set(
            [
                "document",
                "presentation",
                "section",
                "sheet",
                "slide",
                "spreadsheet",
                "url",
            ]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            is_nullable_and_explicitly_set = (
                k in nullable_fields
                and (self.__pydantic_fields_set__.intersection({n}))  # pylint: disable=no-member
            )

            if val != UNSET_SENTINEL:
                if (
                    val is not None
                    or k not in optional_fields
                    or is_nullable_and_explicitly_set
                ):
                    m[k] = val

        return m


class SetListFormatTypedDict(TypedDict):
    r"""An edit to set list formats on a range of paragraphs in rich text. Not supported when the parent batch has isolated edits turned on."""

    selection: ParagraphSelectionTypedDict
    r"""A selection of one or more paragraphs, starting from the start paragraph and ending with the stop paragraph. Both start and stop paragraph indexes are inclusive.

    """
    level: NotRequired[Nullable[int]]
    r"""The list level to apply to each list paragraph in the selection. Ignored if null.  Ignored for non-list paragraphs in the selection.

    """
    prefix: NotRequired[Nullable[str]]
    r"""The prefix for each list paragraph in the selection. Ignored if null.  Ignored for non-list paragraphs in the selection.

    """
    start_at: NotRequired[Nullable[int]]
    r"""The starting number for each list paragraph in the selection. Ignored if null.  Ignored for non-list paragraphs in the selection. Can only be set on ordered lists.

    """
    style: NotRequired[Nullable[str]]
    r"""Identifier for a style. The list style to apply to the selection. Ignored if null. Will make all normal paragraphs in the selection list paragraphs.

    """
    suffix: NotRequired[Nullable[str]]
    r"""The suffix for each list paragraph in the selection. Ignored if null.  Ignored for non-list paragraphs in the selection.

    """


class SetListFormat(BaseModel):
    r"""An edit to set list formats on a range of paragraphs in rich text. Not supported when the parent batch has isolated edits turned on."""

    selection: ParagraphSelection
    r"""A selection of one or more paragraphs, starting from the start paragraph and ending with the stop paragraph. Both start and stop paragraph indexes are inclusive.

    """

    level: OptionalNullable[int] = UNSET
    r"""The list level to apply to each list paragraph in the selection. Ignored if null.  Ignored for non-list paragraphs in the selection.

    """

    prefix: OptionalNullable[str] = UNSET
    r"""The prefix for each list paragraph in the selection. Ignored if null.  Ignored for non-list paragraphs in the selection.

    """

    start_at: Annotated[OptionalNullable[int], pydantic.Field(alias="startAt")] = UNSET
    r"""The starting number for each list paragraph in the selection. Ignored if null.  Ignored for non-list paragraphs in the selection. Can only be set on ordered lists.

    """

    style: OptionalNullable[str] = UNSET
    r"""Identifier for a style. The list style to apply to the selection. Ignored if null. Will make all normal paragraphs in the selection list paragraphs.

    """

    suffix: OptionalNullable[str] = UNSET
    r"""The suffix for each list paragraph in the selection. Ignored if null.  Ignored for non-list paragraphs in the selection.

    """

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["level", "prefix", "startAt", "style", "suffix"])
        nullable_fields = set(["level", "prefix", "startAt", "style", "suffix"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            is_nullable_and_explicitly_set = (
                k in nullable_fields
                and (self.__pydantic_fields_set__.intersection({n}))  # pylint: disable=no-member
            )

            if val != UNSET_SENTINEL:
                if (
                    val is not None
                    or k not in optional_fields
                    or is_nullable_and_explicitly_set
                ):
                    m[k] = val

        return m


class Alignment(str, Enum):
    r"""The alignment of the paragraph."""

    LEFT = "left"
    CENTER = "center"
    RIGHT = "right"
    JUSTIFIED = "justified"


class TextEditUnit(str, Enum):
    r"""The unit of the line spacing value."""

    PERCENT = "percent"
    POINTS = "points"


class TextEditLineSpacingTypedDict(TypedDict):
    r"""Defines the line spacing of a paragraph."""

    unit: NotRequired[TextEditUnit]
    r"""The unit of the line spacing value."""
    value: NotRequired[float]
    r"""The line spacing value. Valid percent range: 80% - 720% Valid points range: 1 - 400 points

    """


class TextEditLineSpacing(BaseModel):
    r"""Defines the line spacing of a paragraph."""

    unit: Optional[TextEditUnit] = None
    r"""The unit of the line spacing value."""

    value: Optional[float] = None
    r"""The line spacing value. Valid percent range: 80% - 720% Valid points range: 1 - 400 points

    """

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["unit", "value"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class SetParagraphPropertiesTypedDict(TypedDict):
    r"""An edit to set properties on a range of paragraphs in rich text. Null properties are ignored."""

    selection: ParagraphSelectionTypedDict
    r"""A selection of one or more paragraphs, starting from the start paragraph and ending with the stop paragraph. Both start and stop paragraph indexes are inclusive.

    """
    alignment: NotRequired[Nullable[Alignment]]
    r"""The alignment of the paragraph.

    """
    end_indent: NotRequired[Nullable[float]]
    r"""The amount of indent, in points, from the margin to apply to all the lines of a paragraph  at the end of each line. Positive is towards the center of the page.

    """
    first_line_indent: NotRequired[Nullable[float]]
    r"""The amount of indent, in points, from the margin to apply to the first line of a paragraph  in addition to the start indent. Positive is towards the center of the page.

    """
    line_spacing: NotRequired[Nullable[TextEditLineSpacingTypedDict]]
    page_break_before: NotRequired[Nullable[bool]]
    r"""Whether the paragraph starts a new page. Cannot be set for rich text cells.

    """
    space_after_paragraph: NotRequired[Nullable[float]]
    r"""The amount of space, in points, after the paragraph.

    """
    space_before_paragraph: NotRequired[Nullable[float]]
    r"""The amount of space, in points, before the paragraph.

    """
    start_indent: NotRequired[Nullable[float]]
    r"""The amount of indent, in points, from the margin to apply to all the lines of a paragraph  from the start of each line. Positive is towards the center of the page.

    """


class SetParagraphProperties(BaseModel):
    r"""An edit to set properties on a range of paragraphs in rich text. Null properties are ignored."""

    selection: ParagraphSelection
    r"""A selection of one or more paragraphs, starting from the start paragraph and ending with the stop paragraph. Both start and stop paragraph indexes are inclusive.

    """

    alignment: OptionalNullable[Alignment] = UNSET
    r"""The alignment of the paragraph.

    """

    end_indent: Annotated[
        OptionalNullable[float], pydantic.Field(alias="endIndent")
    ] = UNSET
    r"""The amount of indent, in points, from the margin to apply to all the lines of a paragraph  at the end of each line. Positive is towards the center of the page.

    """

    first_line_indent: Annotated[
        OptionalNullable[float], pydantic.Field(alias="firstLineIndent")
    ] = UNSET
    r"""The amount of indent, in points, from the margin to apply to the first line of a paragraph  in addition to the start indent. Positive is towards the center of the page.

    """

    line_spacing: Annotated[
        OptionalNullable[TextEditLineSpacing], pydantic.Field(alias="lineSpacing")
    ] = UNSET

    page_break_before: Annotated[
        OptionalNullable[bool], pydantic.Field(alias="pageBreakBefore")
    ] = UNSET
    r"""Whether the paragraph starts a new page. Cannot be set for rich text cells.

    """

    space_after_paragraph: Annotated[
        OptionalNullable[float], pydantic.Field(alias="spaceAfterParagraph")
    ] = UNSET
    r"""The amount of space, in points, after the paragraph.

    """

    space_before_paragraph: Annotated[
        OptionalNullable[float], pydantic.Field(alias="spaceBeforeParagraph")
    ] = UNSET
    r"""The amount of space, in points, before the paragraph.

    """

    start_indent: Annotated[
        OptionalNullable[float], pydantic.Field(alias="startIndent")
    ] = UNSET
    r"""The amount of indent, in points, from the margin to apply to all the lines of a paragraph  from the start of each line. Positive is towards the center of the page.

    """

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            [
                "alignment",
                "endIndent",
                "firstLineIndent",
                "lineSpacing",
                "pageBreakBefore",
                "spaceAfterParagraph",
                "spaceBeforeParagraph",
                "startIndent",
            ]
        )
        nullable_fields = set(
            [
                "alignment",
                "endIndent",
                "firstLineIndent",
                "lineSpacing",
                "pageBreakBefore",
                "spaceAfterParagraph",
                "spaceBeforeParagraph",
                "startIndent",
            ]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            is_nullable_and_explicitly_set = (
                k in nullable_fields
                and (self.__pydantic_fields_set__.intersection({n}))  # pylint: disable=no-member
            )

            if val != UNSET_SENTINEL:
                if (
                    val is not None
                    or k not in optional_fields
                    or is_nullable_and_explicitly_set
                ):
                    m[k] = val

        return m


class SetParagraphStyleTypedDict(TypedDict):
    r"""Applies a text or table style to a range of paragraphs.
    The  \"Table (Normal)\" style can only be applied to text in table cells. Likewise, the \"Normal\" style can only be applied to non-table text.

    """

    selection: ParagraphSelectionTypedDict
    r"""A selection of one or more paragraphs, starting from the start paragraph and ending with the stop paragraph. Both start and stop paragraph indexes are inclusive.

    """
    style: str
    r"""The unique identifier of a style."""


class SetParagraphStyle(BaseModel):
    r"""Applies a text or table style to a range of paragraphs.
    The  \"Table (Normal)\" style can only be applied to text in table cells. Likewise, the \"Normal\" style can only be applied to non-table text.

    """

    selection: ParagraphSelection
    r"""A selection of one or more paragraphs, starting from the start paragraph and ending with the stop paragraph. Both start and stop paragraph indexes are inclusive.

    """

    style: str
    r"""The unique identifier of a style."""


class TextEditSchemasSetTablePropertiesType(str, Enum):
    r"""The type of table breaking"""

    NEVER_BREAK = "neverBreak"
    ALWAYS_BREAK = "alwaysBreak"
    BREAK_WHEN_EXCEEDS = "breakWhenExceeds"


class TextEditTableBreakingTypedDict(TypedDict):
    r"""The property that will dictate how the table will break across pages"""

    breaking_percentage: NotRequired[Nullable[int]]
    r"""The percentage the table will break at, only set when type is breakWhenExceeds"""
    type: NotRequired[Nullable[TextEditSchemasSetTablePropertiesType]]
    r"""The type of table breaking"""


class TextEditTableBreaking(BaseModel):
    r"""The property that will dictate how the table will break across pages"""

    breaking_percentage: Annotated[
        OptionalNullable[int], pydantic.Field(alias="breakingPercentage")
    ] = UNSET
    r"""The percentage the table will break at, only set when type is breakWhenExceeds"""

    type: OptionalNullable[TextEditSchemasSetTablePropertiesType] = UNSET
    r"""The type of table breaking"""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["breakingPercentage", "type"])
        nullable_fields = set(["breakingPercentage", "type"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            is_nullable_and_explicitly_set = (
                k in nullable_fields
                and (self.__pydantic_fields_set__.intersection({n}))  # pylint: disable=no-member
            )

            if val != UNSET_SENTINEL:
                if (
                    val is not None
                    or k not in optional_fields
                    or is_nullable_and_explicitly_set
                ):
                    m[k] = val

        return m


class SetTablePropertiesTypedDict(TypedDict):
    r"""An edit for configuring table behavior when the table spans multiple pages. If a property is null in the request, then it will be ignored."""

    selection: RichTextSelectionTypedDict
    r"""Describes a selection within piece of rich text"""
    header_rows: NotRequired[Nullable[int]]
    r"""The rows that are going to be headers. The value must be smaller than the row size minus 2."""
    table_breaking: NotRequired[Nullable[TextEditTableBreakingTypedDict]]
    r"""The property that will dictate how the table will break across pages"""
    title_row: NotRequired[Nullable[bool]]
    r"""Whether the title row displays on each page"""
    title_suffix: NotRequired[Nullable[str]]
    r"""The table title suffix"""


class SetTableProperties(BaseModel):
    r"""An edit for configuring table behavior when the table spans multiple pages. If a property is null in the request, then it will be ignored."""

    selection: RichTextSelection
    r"""Describes a selection within piece of rich text"""

    header_rows: Annotated[
        OptionalNullable[int], pydantic.Field(alias="headerRows")
    ] = UNSET
    r"""The rows that are going to be headers. The value must be smaller than the row size minus 2."""

    table_breaking: Annotated[
        OptionalNullable[TextEditTableBreaking], pydantic.Field(alias="tableBreaking")
    ] = UNSET
    r"""The property that will dictate how the table will break across pages"""

    title_row: Annotated[OptionalNullable[bool], pydantic.Field(alias="titleRow")] = (
        UNSET
    )
    r"""Whether the title row displays on each page"""

    title_suffix: Annotated[
        OptionalNullable[str], pydantic.Field(alias="titleSuffix")
    ] = UNSET
    r"""The table title suffix"""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            ["headerRows", "tableBreaking", "titleRow", "titleSuffix"]
        )
        nullable_fields = set(
            ["headerRows", "tableBreaking", "titleRow", "titleSuffix"]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            is_nullable_and_explicitly_set = (
                k in nullable_fields
                and (self.__pydantic_fields_set__.intersection({n}))  # pylint: disable=no-member
            )

            if val != UNSET_SENTINEL:
                if (
                    val is not None
                    or k not in optional_fields
                    or is_nullable_and_explicitly_set
                ):
                    m[k] = val

        return m


class StyleTextTypedDict(TypedDict):
    r"""Applies a text/table style to a range of text. Table styles can only be applied to cells. Likewise, the \"Normal\" text style can only be applied to non-table text and the \"Table (Normal)\" style can only be applied to table text."""

    selection: RichTextSelectionTypedDict
    r"""Describes a selection within piece of rich text"""
    style: str
    r"""The unique identifier of a style."""


class StyleText(BaseModel):
    r"""Applies a text/table style to a range of text. Table styles can only be applied to cells. Likewise, the \"Normal\" text style can only be applied to non-table text and the \"Table (Normal)\" style can only be applied to table text."""

    selection: RichTextSelection
    r"""Describes a selection within piece of rich text"""

    style: str
    r"""The unique identifier of a style."""


class TextEditType(str, Enum):
    r"""The type of rich text edit."""

    CLEAR_LIST_FORMAT = "clearListFormat"
    CLEAR_PARAGRAPH_PROPERTIES = "clearParagraphProperties"
    CLEAR_TEXT_FORMAT = "clearTextFormat"
    DELETE_TEXT = "deleteText"
    FORMAT_TEXT = "formatText"
    INSERT_FOOTNOTE = "insertFootnote"
    INSERT_IMAGE = "insertImage"
    INSERT_PAGE_NUMBER = "insertPageNumber"
    INSERT_PARAGRAPH = "insertParagraph"
    INSERT_SOFT_RETURN = "insertSoftReturn"
    INSERT_TABLE = "insertTable"
    INSERT_TEXT = "insertText"
    REMOVE_HYPERLINKS = "removeHyperlinks"
    SET_HYPERLINK = "setHyperlink"
    SET_LIST_FORMAT = "setListFormat"
    SET_PARAGRAPH_PROPERTIES = "setParagraphProperties"
    SET_PARAGRAPH_STYLE = "setParagraphStyle"
    SET_TABLE_PROPERTIES = "setTableProperties"
    STYLE_TEXT = "styleText"


class TextEditTypedDict(TypedDict):
    r"""An edit for modifying rich text.  The `type` of the edit is required. Any edit property that doesn't correspond to its specified type will be ignored."""

    type: TextEditType
    r"""The type of rich text edit."""
    clear_list_format: NotRequired[Nullable[ClearListFormatTypedDict]]
    clear_paragraph_properties: NotRequired[Nullable[ClearParagraphPropertiesTypedDict]]
    clear_text_format: NotRequired[Nullable[ClearTextFormatTypedDict]]
    delete_text: NotRequired[Nullable[DeleteTextTypedDict]]
    format_text: NotRequired[Nullable[FormatTextTypedDict]]
    insert_footnote: NotRequired[Nullable[InsertFootnoteTypedDict]]
    insert_image: NotRequired[Nullable[InsertImageTypedDict]]
    insert_page_number: NotRequired[Nullable[InsertPageNumberTypedDict]]
    insert_paragraph: NotRequired[Nullable[InsertParagraphTypedDict]]
    insert_soft_return: NotRequired[Nullable[InsertSoftReturnTypedDict]]
    insert_table: NotRequired[Nullable[InsertTableTypedDict]]
    insert_text: NotRequired[Nullable[InsertTextTypedDict]]
    remove_hyperlinks: NotRequired[Nullable[RemoveHyperlinksTypedDict]]
    set_hyperlink: NotRequired[Nullable[SetHyperlinkTypedDict]]
    set_list_format: NotRequired[Nullable[SetListFormatTypedDict]]
    set_paragraph_properties: NotRequired[Nullable[SetParagraphPropertiesTypedDict]]
    set_paragraph_style: NotRequired[Nullable[SetParagraphStyleTypedDict]]
    set_table_properties: NotRequired[Nullable[SetTablePropertiesTypedDict]]
    style_text: NotRequired[Nullable[StyleTextTypedDict]]


class TextEdit(BaseModel):
    r"""An edit for modifying rich text.  The `type` of the edit is required. Any edit property that doesn't correspond to its specified type will be ignored."""

    type: TextEditType
    r"""The type of rich text edit."""

    clear_list_format: Annotated[
        OptionalNullable[ClearListFormat], pydantic.Field(alias="clearListFormat")
    ] = UNSET

    clear_paragraph_properties: Annotated[
        OptionalNullable[ClearParagraphProperties],
        pydantic.Field(alias="clearParagraphProperties"),
    ] = UNSET

    clear_text_format: Annotated[
        OptionalNullable[ClearTextFormat], pydantic.Field(alias="clearTextFormat")
    ] = UNSET

    delete_text: Annotated[
        OptionalNullable[DeleteText], pydantic.Field(alias="deleteText")
    ] = UNSET

    format_text: Annotated[
        OptionalNullable[FormatText], pydantic.Field(alias="formatText")
    ] = UNSET

    insert_footnote: Annotated[
        OptionalNullable[InsertFootnote], pydantic.Field(alias="insertFootnote")
    ] = UNSET

    insert_image: Annotated[
        OptionalNullable[InsertImage], pydantic.Field(alias="insertImage")
    ] = UNSET

    insert_page_number: Annotated[
        OptionalNullable[InsertPageNumber], pydantic.Field(alias="insertPageNumber")
    ] = UNSET

    insert_paragraph: Annotated[
        OptionalNullable[InsertParagraph], pydantic.Field(alias="insertParagraph")
    ] = UNSET

    insert_soft_return: Annotated[
        OptionalNullable[InsertSoftReturn], pydantic.Field(alias="insertSoftReturn")
    ] = UNSET

    insert_table: Annotated[
        OptionalNullable[InsertTable], pydantic.Field(alias="insertTable")
    ] = UNSET

    insert_text: Annotated[
        OptionalNullable[InsertText], pydantic.Field(alias="insertText")
    ] = UNSET

    remove_hyperlinks: Annotated[
        OptionalNullable[RemoveHyperlinks], pydantic.Field(alias="removeHyperlinks")
    ] = UNSET

    set_hyperlink: Annotated[
        OptionalNullable[SetHyperlink], pydantic.Field(alias="setHyperlink")
    ] = UNSET

    set_list_format: Annotated[
        OptionalNullable[SetListFormat], pydantic.Field(alias="setListFormat")
    ] = UNSET

    set_paragraph_properties: Annotated[
        OptionalNullable[SetParagraphProperties],
        pydantic.Field(alias="setParagraphProperties"),
    ] = UNSET

    set_paragraph_style: Annotated[
        OptionalNullable[SetParagraphStyle], pydantic.Field(alias="setParagraphStyle")
    ] = UNSET

    set_table_properties: Annotated[
        OptionalNullable[SetTableProperties], pydantic.Field(alias="setTableProperties")
    ] = UNSET

    style_text: Annotated[
        OptionalNullable[StyleText], pydantic.Field(alias="styleText")
    ] = UNSET

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            [
                "clearListFormat",
                "clearParagraphProperties",
                "clearTextFormat",
                "deleteText",
                "formatText",
                "insertFootnote",
                "insertImage",
                "insertPageNumber",
                "insertParagraph",
                "insertSoftReturn",
                "insertTable",
                "insertText",
                "removeHyperlinks",
                "setHyperlink",
                "setListFormat",
                "setParagraphProperties",
                "setParagraphStyle",
                "setTableProperties",
                "styleText",
            ]
        )
        nullable_fields = set(
            [
                "clearListFormat",
                "clearParagraphProperties",
                "clearTextFormat",
                "deleteText",
                "formatText",
                "insertFootnote",
                "insertImage",
                "insertPageNumber",
                "insertParagraph",
                "insertSoftReturn",
                "insertTable",
                "insertText",
                "removeHyperlinks",
                "setHyperlink",
                "setListFormat",
                "setParagraphProperties",
                "setParagraphStyle",
                "setTableProperties",
                "styleText",
            ]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            is_nullable_and_explicitly_set = (
                k in nullable_fields
                and (self.__pydantic_fields_set__.intersection({n}))  # pylint: disable=no-member
            )

            if val != UNSET_SENTINEL:
                if (
                    val is not None
                    or k not in optional_fields
                    or is_nullable_and_explicitly_set
                ):
                    m[k] = val

        return m
