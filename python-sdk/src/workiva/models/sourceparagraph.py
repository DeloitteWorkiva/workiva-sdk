"""Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT."""

from __future__ import annotations
from .linespacing import LineSpacing, LineSpacingTypedDict
from .paragraphpropertiesalignment import ParagraphPropertiesAlignment
from .richtextbaselineshift import RichTextBaselineShift
from .sourcetextelement import SourceTextElement, SourceTextElementTypedDict
from .styleref import StyleRef, StyleRefTypedDict
import pydantic
from pydantic import field_serializer, model_serializer
from typing import List, Optional
from typing_extensions import Annotated, NotRequired, TypedDict
from workiva import models
from workiva.types import BaseModel, Nullable, OptionalNullable, UNSET, UNSET_SENTINEL


class SourceParagraphBackgroundColorTypedDict(TypedDict):
    r"""The background color in RGB format"""

    blue: int
    r"""The blue component of the color."""
    green: int
    r"""The green component of the color."""
    red: int
    r"""The red component of the color."""


class SourceParagraphBackgroundColor(BaseModel):
    r"""The background color in RGB format"""

    blue: int
    r"""The blue component of the color."""

    green: int
    r"""The green component of the color."""

    red: int
    r"""The red component of the color."""


class SourceParagraphTextColorTypedDict(TypedDict):
    r"""The text color in RGB format"""

    blue: int
    r"""The blue component of the color."""
    green: int
    r"""The green component of the color."""
    red: int
    r"""The red component of the color."""


class SourceParagraphTextColor(BaseModel):
    r"""The text color in RGB format"""

    blue: int
    r"""The blue component of the color."""

    green: int
    r"""The green component of the color."""

    red: int
    r"""The red component of the color."""


class FormatTypedDict(TypedDict):
    r"""The formatting options applied to rich text elements."""

    background_color: NotRequired[Nullable[SourceParagraphBackgroundColorTypedDict]]
    r"""The background color in RGB format"""
    baseline_shift: NotRequired[Nullable[RichTextBaselineShift]]
    r"""Indicates the offset from the baseline of the characters. The baseline is the imaginary bottom line for a line of text which the bottom of the characters are placed, not including any descender such as g, j, p, and y have. `superscript` shifts the baseline up and reduces the rendered font size to 65% of the specified font size. `subscript` works the same as `superscript` except it moves the baseline down. `baseline` uses the default size and baseline for regular text. type: string

    """
    bold: NotRequired[Nullable[bool]]
    r"""Whether or not the text is bold"""
    character_spacing: NotRequired[Nullable[int]]
    r"""The amount of space, in 1/1000 of an em, between characters."""
    font: NotRequired[Nullable[str]]
    r"""The name of the font"""
    italic: NotRequired[Nullable[bool]]
    r"""Whether or not the text is italicized"""
    size: NotRequired[Nullable[float]]
    r"""The font size of the characters in points"""
    strikethrough: NotRequired[Nullable[bool]]
    r"""Whether or not the text is struck through"""
    text_color: NotRequired[Nullable[SourceParagraphTextColorTypedDict]]
    r"""The text color in RGB format"""
    underline: NotRequired[Nullable[bool]]
    r"""Whether or not the text is underlined"""


class Format(BaseModel):
    r"""The formatting options applied to rich text elements."""

    background_color: Annotated[
        OptionalNullable[SourceParagraphBackgroundColor],
        pydantic.Field(alias="backgroundColor"),
    ] = UNSET
    r"""The background color in RGB format"""

    baseline_shift: Annotated[
        OptionalNullable[RichTextBaselineShift], pydantic.Field(alias="baselineShift")
    ] = UNSET
    r"""Indicates the offset from the baseline of the characters. The baseline is the imaginary bottom line for a line of text which the bottom of the characters are placed, not including any descender such as g, j, p, and y have. `superscript` shifts the baseline up and reduces the rendered font size to 65% of the specified font size. `subscript` works the same as `superscript` except it moves the baseline down. `baseline` uses the default size and baseline for regular text. type: string

    """

    bold: OptionalNullable[bool] = UNSET
    r"""Whether or not the text is bold"""

    character_spacing: Annotated[
        OptionalNullable[int], pydantic.Field(alias="characterSpacing")
    ] = UNSET
    r"""The amount of space, in 1/1000 of an em, between characters."""

    font: OptionalNullable[str] = UNSET
    r"""The name of the font"""

    italic: OptionalNullable[bool] = UNSET
    r"""Whether or not the text is italicized"""

    size: OptionalNullable[float] = UNSET
    r"""The font size of the characters in points"""

    strikethrough: OptionalNullable[bool] = UNSET
    r"""Whether or not the text is struck through"""

    text_color: Annotated[
        OptionalNullable[SourceParagraphTextColor], pydantic.Field(alias="textColor")
    ] = UNSET
    r"""The text color in RGB format"""

    underline: OptionalNullable[bool] = UNSET
    r"""Whether or not the text is underlined"""

    @field_serializer("baseline_shift")
    def serialize_baseline_shift(self, value):
        if isinstance(value, str):
            try:
                return models.RichTextBaselineShift(value)
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            [
                "backgroundColor",
                "baselineShift",
                "bold",
                "characterSpacing",
                "font",
                "italic",
                "size",
                "strikethrough",
                "textColor",
                "underline",
            ]
        )
        nullable_fields = set(
            [
                "backgroundColor",
                "baselineShift",
                "bold",
                "characterSpacing",
                "font",
                "italic",
                "size",
                "strikethrough",
                "textColor",
                "underline",
            ]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            is_nullable_and_explicitly_set = (
                k in nullable_fields
                and (self.__pydantic_fields_set__.intersection({n}))  # pylint: disable=no-member
            )

            if val != UNSET_SENTINEL:
                if (
                    val is not None
                    or k not in optional_fields
                    or is_nullable_and_explicitly_set
                ):
                    m[k] = val

        return m


class ListTTypedDict(TypedDict):
    r"""The list formatting options applied to the given paragraph."""

    level: NotRequired[int]
    r"""The list level associated with the list."""
    prefix: NotRequired[Nullable[str]]
    r"""The list value prefix"""
    start_at: NotRequired[Nullable[int]]
    r"""The value the list starts at (for ordered lists). Null indicates that the list continues from the previous item."""
    style: NotRequired[StyleRefTypedDict]
    r"""A reference to a style."""
    suffix: NotRequired[Nullable[str]]
    r"""The list value suffix"""


class ListT(BaseModel):
    r"""The list formatting options applied to the given paragraph."""

    level: Optional[int] = None
    r"""The list level associated with the list."""

    prefix: OptionalNullable[str] = UNSET
    r"""The list value prefix"""

    start_at: Annotated[OptionalNullable[int], pydantic.Field(alias="startAt")] = UNSET
    r"""The value the list starts at (for ordered lists). Null indicates that the list continues from the previous item."""

    style: Optional[StyleRef] = None
    r"""A reference to a style."""

    suffix: OptionalNullable[str] = UNSET
    r"""The list value suffix"""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["level", "prefix", "startAt", "style", "suffix"])
        nullable_fields = set(["prefix", "startAt", "suffix"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            is_nullable_and_explicitly_set = (
                k in nullable_fields
                and (self.__pydantic_fields_set__.intersection({n}))  # pylint: disable=no-member
            )

            if val != UNSET_SENTINEL:
                if (
                    val is not None
                    or k not in optional_fields
                    or is_nullable_and_explicitly_set
                ):
                    m[k] = val

        return m


class SourceParagraphPropertiesTypedDict(TypedDict):
    r"""The properties for rich-text paragraphs. Null values indicate that the format is inheriting from style or the container when reading."""

    alignment: NotRequired[Nullable[ParagraphPropertiesAlignment]]
    r"""Indicates the horizontal alignment of the text within a paragraph"""
    end_indent: NotRequired[Nullable[float]]
    r"""The amount of indent, in points, from the margin to apply to all the lines of a paragraph at the end of each line. Positive is towards the enter of the page.

    """
    first_line_indent: NotRequired[Nullable[float]]
    r"""The amount of indent, in points, from the margin to apply to the first line of a paragraph in addition to the start indent. Positive is towards the center of the page.

    """
    line_spacing: NotRequired[LineSpacingTypedDict]
    r"""Defines the line spacing of a paragraph.

    """
    page_break_before: NotRequired[Nullable[bool]]
    r"""Whether or not this paragraph starts on a new page"""
    space_after_paragraph: NotRequired[Nullable[float]]
    r"""The amount space, in points, after the paragraph."""
    space_before_paragraph: NotRequired[Nullable[float]]
    r"""The amount of space, in points, before the paragraph."""
    start_indent: NotRequired[Nullable[float]]
    r"""The amount of indent, in points, from the margin to apply to all the lines of a paragraph from the start of each line. Positive is towards the center of the page.

    """


class SourceParagraphProperties(BaseModel):
    r"""The properties for rich-text paragraphs. Null values indicate that the format is inheriting from style or the container when reading."""

    alignment: OptionalNullable[ParagraphPropertiesAlignment] = (
        ParagraphPropertiesAlignment.LEFT
    )
    r"""Indicates the horizontal alignment of the text within a paragraph"""

    end_indent: Annotated[
        OptionalNullable[float], pydantic.Field(alias="endIndent")
    ] = UNSET
    r"""The amount of indent, in points, from the margin to apply to all the lines of a paragraph at the end of each line. Positive is towards the enter of the page.

    """

    first_line_indent: Annotated[
        OptionalNullable[float], pydantic.Field(alias="firstLineIndent")
    ] = UNSET
    r"""The amount of indent, in points, from the margin to apply to the first line of a paragraph in addition to the start indent. Positive is towards the center of the page.

    """

    line_spacing: Annotated[
        Optional[LineSpacing], pydantic.Field(alias="lineSpacing")
    ] = None
    r"""Defines the line spacing of a paragraph.

    """

    page_break_before: Annotated[
        OptionalNullable[bool], pydantic.Field(alias="pageBreakBefore")
    ] = False
    r"""Whether or not this paragraph starts on a new page"""

    space_after_paragraph: Annotated[
        OptionalNullable[float], pydantic.Field(alias="spaceAfterParagraph")
    ] = UNSET
    r"""The amount space, in points, after the paragraph."""

    space_before_paragraph: Annotated[
        OptionalNullable[float], pydantic.Field(alias="spaceBeforeParagraph")
    ] = UNSET
    r"""The amount of space, in points, before the paragraph."""

    start_indent: Annotated[
        OptionalNullable[float], pydantic.Field(alias="startIndent")
    ] = UNSET
    r"""The amount of indent, in points, from the margin to apply to all the lines of a paragraph from the start of each line. Positive is towards the center of the page.

    """

    @field_serializer("alignment")
    def serialize_alignment(self, value):
        if isinstance(value, str):
            try:
                return models.ParagraphPropertiesAlignment(value)
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            [
                "alignment",
                "endIndent",
                "firstLineIndent",
                "lineSpacing",
                "pageBreakBefore",
                "spaceAfterParagraph",
                "spaceBeforeParagraph",
                "startIndent",
            ]
        )
        nullable_fields = set(
            [
                "alignment",
                "endIndent",
                "firstLineIndent",
                "pageBreakBefore",
                "spaceAfterParagraph",
                "spaceBeforeParagraph",
                "startIndent",
            ]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            is_nullable_and_explicitly_set = (
                k in nullable_fields
                and (self.__pydantic_fields_set__.intersection({n}))  # pylint: disable=no-member
            )

            if val != UNSET_SENTINEL:
                if (
                    val is not None
                    or k not in optional_fields
                    or is_nullable_and_explicitly_set
                ):
                    m[k] = val

        return m


class SourceParagraphTypedDict(TypedDict):
    r"""A paragraph of rich text content that is from a source link."""

    elements: List[SourceTextElementTypedDict]
    r"""Elements contained in this paragraph."""
    format_: Nullable[FormatTypedDict]
    properties: Nullable[SourceParagraphPropertiesTypedDict]
    style: StyleRefTypedDict
    r"""A reference to a style."""
    list: NotRequired[Nullable[ListTTypedDict]]


class SourceParagraph(BaseModel):
    r"""A paragraph of rich text content that is from a source link."""

    elements: List[SourceTextElement]
    r"""Elements contained in this paragraph."""

    format_: Annotated[Nullable[Format], pydantic.Field(alias="format")]

    properties: Nullable[SourceParagraphProperties]

    style: StyleRef
    r"""A reference to a style."""

    list: OptionalNullable[ListT] = UNSET

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["list"])
        nullable_fields = set(["format", "list", "properties"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            is_nullable_and_explicitly_set = (
                k in nullable_fields
                and (self.__pydantic_fields_set__.intersection({n}))  # pylint: disable=no-member
            )

            if val != UNSET_SENTINEL:
                if (
                    val is not None
                    or k not in optional_fields
                    or is_nullable_and_explicitly_set
                ):
                    m[k] = val

        return m
