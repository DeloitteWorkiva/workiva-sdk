"""Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT."""

from __future__ import annotations
from .columnrange import ColumnRange, ColumnRangeTypedDict
from .rowrange import RowRange, RowRangeTypedDict
from enum import Enum
import pydantic
from pydantic import model_serializer
from typing import Optional
from typing_extensions import Annotated, NotRequired, TypedDict
from workiva.types import BaseModel, Nullable, OptionalNullable, UNSET, UNSET_SENTINEL


class DeleteColumnsTypedDict(TypedDict):
    r"""Delete one or more columns from the table"""

    columns: NotRequired[Nullable[ColumnRangeTypedDict]]
    r"""Describes a column range

    """


class DeleteColumns(BaseModel):
    r"""Delete one or more columns from the table"""

    columns: OptionalNullable[ColumnRange] = UNSET
    r"""Describes a column range

    """

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["columns"])
        nullable_fields = set(["columns"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            is_nullable_and_explicitly_set = (
                k in nullable_fields
                and (self.__pydantic_fields_set__.intersection({n}))  # pylint: disable=no-member
            )

            if val != UNSET_SENTINEL:
                if (
                    val is not None
                    or k not in optional_fields
                    or is_nullable_and_explicitly_set
                ):
                    m[k] = val

        return m


class DeleteRowsTypedDict(TypedDict):
    r"""Delete one or more rows from the table"""

    rows: NotRequired[Nullable[RowRangeTypedDict]]
    r"""Describes a row range

    """


class DeleteRows(BaseModel):
    r"""Delete one or more rows from the table"""

    rows: OptionalNullable[RowRange] = UNSET
    r"""Describes a row range

    """

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["rows"])
        nullable_fields = set(["rows"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            is_nullable_and_explicitly_set = (
                k in nullable_fields
                and (self.__pydantic_fields_set__.intersection({n}))  # pylint: disable=no-member
            )

            if val != UNSET_SENTINEL:
                if (
                    val is not None
                    or k not in optional_fields
                    or is_nullable_and_explicitly_set
                ):
                    m[k] = val

        return m


class Side(str, Enum):
    r"""The direction where to insert nextTo"""

    PUT_AFTER = "putAfter"
    PUT_BEFORE = "putBefore"


class InsertColumnsTypedDict(TypedDict):
    r"""Insert one or more columns into the table next to the given column on specified side"""

    count: NotRequired[int]
    r"""The number of columns to insert"""
    next_to: NotRequired[int]
    r"""The position after which to insert the columns"""
    side: NotRequired[Side]
    r"""The direction where to insert nextTo"""


class InsertColumns(BaseModel):
    r"""Insert one or more columns into the table next to the given column on specified side"""

    count: Optional[int] = None
    r"""The number of columns to insert"""

    next_to: Annotated[Optional[int], pydantic.Field(alias="nextTo")] = None
    r"""The position after which to insert the columns"""

    side: Optional[Side] = None
    r"""The direction where to insert nextTo"""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["count", "nextTo", "side"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class TableEditSide(str, Enum):
    r"""The direction where to insert nextTo"""

    PUT_AFTER = "putAfter"
    PUT_BEFORE = "putBefore"


class InsertRowsTypedDict(TypedDict):
    r"""Insert one or more rows into the table next to the given row on specified side"""

    count: NotRequired[int]
    r"""The number of rows to insert"""
    next_to: NotRequired[int]
    r"""The position after which to insert the rows"""
    side: NotRequired[TableEditSide]
    r"""The direction where to insert nextTo"""


class InsertRows(BaseModel):
    r"""Insert one or more rows into the table next to the given row on specified side"""

    count: Optional[int] = None
    r"""The number of rows to insert"""

    next_to: Annotated[Optional[int], pydantic.Field(alias="nextTo")] = None
    r"""The position after which to insert the rows"""

    side: Optional[TableEditSide] = None
    r"""The direction where to insert nextTo"""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["count", "nextTo", "side"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class TableEditSchemasSide(str, Enum):
    r"""The direction where to move from nextTo"""

    PUT_AFTER = "putAfter"
    PUT_BEFORE = "putBefore"


class MoveColumnsTypedDict(TypedDict):
    r"""Moves one or more columns from one location in the table to next to the given column on the specified side of that column. The column to move the other columns next to may not be within the set of columns to move."""

    move: NotRequired[Nullable[ColumnRangeTypedDict]]
    r"""Describes a column range

    """
    next_to: NotRequired[int]
    r"""The position after which to move the columns"""
    side: NotRequired[TableEditSchemasSide]
    r"""The direction where to move from nextTo"""


class MoveColumns(BaseModel):
    r"""Moves one or more columns from one location in the table to next to the given column on the specified side of that column. The column to move the other columns next to may not be within the set of columns to move."""

    move: OptionalNullable[ColumnRange] = UNSET
    r"""Describes a column range

    """

    next_to: Annotated[Optional[int], pydantic.Field(alias="nextTo")] = None
    r"""The position after which to move the columns"""

    side: Optional[TableEditSchemasSide] = None
    r"""The direction where to move from nextTo"""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["move", "nextTo", "side"])
        nullable_fields = set(["move"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            is_nullable_and_explicitly_set = (
                k in nullable_fields
                and (self.__pydantic_fields_set__.intersection({n}))  # pylint: disable=no-member
            )

            if val != UNSET_SENTINEL:
                if (
                    val is not None
                    or k not in optional_fields
                    or is_nullable_and_explicitly_set
                ):
                    m[k] = val

        return m


class TableEditSchemasMoveRowsSide(str, Enum):
    r"""The direction where to move from nextTo"""

    PUT_AFTER = "putAfter"
    PUT_BEFORE = "putBefore"


class MoveRowsTypedDict(TypedDict):
    r"""Move one or more row from one location in the table to next to the given row on the specified side"""

    move: NotRequired[Nullable[RowRangeTypedDict]]
    r"""Describes a row range

    """
    next_to: NotRequired[int]
    r"""The position after which to move the rows"""
    side: NotRequired[TableEditSchemasMoveRowsSide]
    r"""The direction where to move from nextTo"""


class MoveRows(BaseModel):
    r"""Move one or more row from one location in the table to next to the given row on the specified side"""

    move: OptionalNullable[RowRange] = UNSET
    r"""Describes a row range

    """

    next_to: Annotated[Optional[int], pydantic.Field(alias="nextTo")] = None
    r"""The position after which to move the rows"""

    side: Optional[TableEditSchemasMoveRowsSide] = None
    r"""The direction where to move from nextTo"""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["move", "nextTo", "side"])
        nullable_fields = set(["move"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            is_nullable_and_explicitly_set = (
                k in nullable_fields
                and (self.__pydantic_fields_set__.intersection({n}))  # pylint: disable=no-member
            )

            if val != UNSET_SENTINEL:
                if (
                    val is not None
                    or k not in optional_fields
                    or is_nullable_and_explicitly_set
                ):
                    m[k] = val

        return m


class TableEditType(str, Enum):
    r"""The type of edit operation to perform on the table"""

    DELETE_COLUMNS = "deleteColumns"
    DELETE_ROWS = "deleteRows"
    MOVE_COLUMNS = "moveColumns"
    MOVE_ROWS = "moveRows"
    INSERT_COLUMNS = "insertColumns"
    INSERT_ROWS = "insertRows"


class TableEditTypedDict(TypedDict):
    r"""A table edit for modifying a table. The edit property associated with the edit type is required. Any edit property that doesn't correspond to its type will be ignored."""

    type: TableEditType
    r"""The type of edit operation to perform on the table"""
    delete_columns: NotRequired[Nullable[DeleteColumnsTypedDict]]
    delete_rows: NotRequired[Nullable[DeleteRowsTypedDict]]
    insert_columns: NotRequired[Nullable[InsertColumnsTypedDict]]
    insert_rows: NotRequired[Nullable[InsertRowsTypedDict]]
    move_columns: NotRequired[Nullable[MoveColumnsTypedDict]]
    move_rows: NotRequired[Nullable[MoveRowsTypedDict]]


class TableEdit(BaseModel):
    r"""A table edit for modifying a table. The edit property associated with the edit type is required. Any edit property that doesn't correspond to its type will be ignored."""

    type: TableEditType
    r"""The type of edit operation to perform on the table"""

    delete_columns: Annotated[
        OptionalNullable[DeleteColumns], pydantic.Field(alias="deleteColumns")
    ] = UNSET

    delete_rows: Annotated[
        OptionalNullable[DeleteRows], pydantic.Field(alias="deleteRows")
    ] = UNSET

    insert_columns: Annotated[
        OptionalNullable[InsertColumns], pydantic.Field(alias="insertColumns")
    ] = UNSET

    insert_rows: Annotated[
        OptionalNullable[InsertRows], pydantic.Field(alias="insertRows")
    ] = UNSET

    move_columns: Annotated[
        OptionalNullable[MoveColumns], pydantic.Field(alias="moveColumns")
    ] = UNSET

    move_rows: Annotated[
        OptionalNullable[MoveRows], pydantic.Field(alias="moveRows")
    ] = UNSET

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            [
                "deleteColumns",
                "deleteRows",
                "insertColumns",
                "insertRows",
                "moveColumns",
                "moveRows",
            ]
        )
        nullable_fields = set(
            [
                "deleteColumns",
                "deleteRows",
                "insertColumns",
                "insertRows",
                "moveColumns",
                "moveRows",
            ]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            is_nullable_and_explicitly_set = (
                k in nullable_fields
                and (self.__pydantic_fields_set__.intersection({n}))  # pylint: disable=no-member
            )

            if val != UNSET_SENTINEL:
                if (
                    val is not None
                    or k not in optional_fields
                    or is_nullable_and_explicitly_set
                ):
                    m[k] = val

        return m
