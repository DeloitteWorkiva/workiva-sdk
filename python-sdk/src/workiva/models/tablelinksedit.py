"""Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT."""

from __future__ import annotations
from .cell import Cell, CellTypedDict
from .cellrange import CellRange, CellRangeTypedDict
from .textlinkedit import TextLinkEdit, TextLinkEditTypedDict
from enum import Enum
import pydantic
from pydantic import model_serializer
from typing import List, Optional
from typing_extensions import Annotated, NotRequired, TypedDict
from workiva.types import BaseModel, Nullable, OptionalNullable, UNSET, UNSET_SENTINEL


class InsertCellDestinationLinkTypedDict(TypedDict):
    r"""Inserts a destination link at the provided cell. Creates a source link at the source anchor if one doesn't already exist. The destination link will reference the latest published revision of the source link."""

    insert_at: CellTypedDict
    r"""A cell indicates a single cell in a table. All indexes are zero based.

    """
    source_anchor: str
    r"""The unique identifier for the source anchor."""


class InsertCellDestinationLink(BaseModel):
    r"""Inserts a destination link at the provided cell. Creates a source link at the source anchor if one doesn't already exist. The destination link will reference the latest published revision of the source link."""

    insert_at: Annotated[Cell, pydantic.Field(alias="insertAt")]
    r"""A cell indicates a single cell in a table. All indexes are zero based.

    """

    source_anchor: Annotated[str, pydantic.Field(alias="sourceAnchor")]
    r"""The unique identifier for the source anchor."""


class RemoveCellsLinkTypedDict(TypedDict):
    r"""Removes source and destination links in a table range. This operation will be a no-op if no cell links exist within the table range."""

    ranges: List[CellRangeTypedDict]
    r"""The ranges to remove links from."""


class RemoveCellsLink(BaseModel):
    r"""Removes source and destination links in a table range. This operation will be a no-op if no cell links exist within the table range."""

    ranges: List[CellRange]
    r"""The ranges to remove links from."""


class RichCellLinkBatchEditTypedDict(TypedDict):
    r"""A collection of edits to perform on the rich text links of a cell in table content."""

    cell: CellTypedDict
    r"""A cell indicates a single cell in a table. All indexes are zero based.

    """
    data: List[TextLinkEditTypedDict]
    r"""The link edits to apply."""
    isolate_edits: NotRequired[bool]
    r"""Whether the edits in a batch should be isolated from one-another. The edits will still be applied in order, but subsequent edits are unaffected by the previous edits in the same batch. For example, if one edit inserts some content, the next edits will act as if the content doesn't exist yet. Or if an edit deletes some content, the next edits will act as if the content is still there. This mode makes it easier to apply many edits on existing content because you don't need to manually keep track of how the previous edits have moved the content. For example, if you want to replace all instances of one word with another it will be easier to do this with isolated edits.

    """


class RichCellLinkBatchEdit(BaseModel):
    r"""A collection of edits to perform on the rich text links of a cell in table content."""

    cell: Cell
    r"""A cell indicates a single cell in a table. All indexes are zero based.

    """

    data: List[TextLinkEdit]
    r"""The link edits to apply."""

    isolate_edits: Annotated[Optional[bool], pydantic.Field(alias="isolateEdits")] = (
        False
    )
    r"""Whether the edits in a batch should be isolated from one-another. The edits will still be applied in order, but subsequent edits are unaffected by the previous edits in the same batch. For example, if one edit inserts some content, the next edits will act as if the content doesn't exist yet. Or if an edit deletes some content, the next edits will act as if the content is still there. This mode makes it easier to apply many edits on existing content because you don't need to manually keep track of how the previous edits have moved the content. For example, if you want to replace all instances of one word with another it will be easier to do this with isolated edits.

    """

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["isolateEdits"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class TableLinksEditType(str, Enum):
    r"""The type of the table links edit"""

    INSERT_CELL_DESTINATION_LINK = "insertCellDestinationLink"
    REMOVE_CELLS_LINK = "removeCellsLink"
    RICH_CELL_LINK_BATCH_EDIT = "richCellLinkBatchEdit"


class TableLinksEditTypedDict(TypedDict):
    r"""An edit for modifying a link in a table.  The edit property associated with the edit type is required. Any edit property that doesn't correspond to its type will be ignored."""

    type: TableLinksEditType
    r"""The type of the table links edit"""
    insert_cell_destination_link: NotRequired[
        Nullable[InsertCellDestinationLinkTypedDict]
    ]
    remove_cells_link: NotRequired[Nullable[RemoveCellsLinkTypedDict]]
    rich_cell_link_batch_edit: NotRequired[Nullable[RichCellLinkBatchEditTypedDict]]


class TableLinksEdit(BaseModel):
    r"""An edit for modifying a link in a table.  The edit property associated with the edit type is required. Any edit property that doesn't correspond to its type will be ignored."""

    type: TableLinksEditType
    r"""The type of the table links edit"""

    insert_cell_destination_link: Annotated[
        OptionalNullable[InsertCellDestinationLink],
        pydantic.Field(alias="insertCellDestinationLink"),
    ] = UNSET

    remove_cells_link: Annotated[
        OptionalNullable[RemoveCellsLink], pydantic.Field(alias="removeCellsLink")
    ] = UNSET

    rich_cell_link_batch_edit: Annotated[
        OptionalNullable[RichCellLinkBatchEdit],
        pydantic.Field(alias="richCellLinkBatchEdit"),
    ] = UNSET

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            ["insertCellDestinationLink", "removeCellsLink", "richCellLinkBatchEdit"]
        )
        nullable_fields = set(
            ["insertCellDestinationLink", "removeCellsLink", "richCellLinkBatchEdit"]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            is_nullable_and_explicitly_set = (
                k in nullable_fields
                and (self.__pydantic_fields_set__.intersection({n}))  # pylint: disable=no-member
            )

            if val != UNSET_SENTINEL:
                if (
                    val is not None
                    or k not in optional_fields
                    or is_nullable_and_explicitly_set
                ):
                    m[k] = val

        return m
