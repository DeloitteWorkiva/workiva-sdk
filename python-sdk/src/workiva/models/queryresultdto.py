"""Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT."""

from __future__ import annotations
from .columninfodto import ColumnInfoDto, ColumnInfoDtoTypedDict
from .querydto import QueryDto, QueryDtoTypedDict
from .queryparameterdto import QueryParameterDto, QueryParameterDtoTypedDict
from datetime import datetime
from enum import Enum
import pydantic
from pydantic import model_serializer
from typing import Any, Dict, List, Optional
from typing_extensions import Annotated, NotRequired, TypedDict
from workiva.types import BaseModel, UNSET_SENTINEL


class PivotStatus(str, Enum):
    r"""The current status of the pivot execution"""

    NOT_STARTED = "NOT_STARTED"
    RUNNING = "RUNNING"
    COMPLETE = "COMPLETE"
    ERROR = "ERROR"
    CANCELLED = "CANCELLED"
    RUNNING_QUERY = "RUNNING_QUERY"
    PIVOT_QUEUED = "PIVOT_QUEUED"
    RUNNING_PIVOT = "RUNNING_PIVOT"
    QUERY_COMPLETE = "QUERY_COMPLETE"
    NOT_APPLICABLE = "NOT_APPLICABLE"
    PIVOT_ERROR = "PIVOT_ERROR"


class QueryResultDtoStatus(str, Enum):
    r"""The current status of the query execution"""

    NOT_STARTED = "NOT_STARTED"
    RUNNING = "RUNNING"
    COMPLETE = "COMPLETE"
    ERROR = "ERROR"
    CANCELLED = "CANCELLED"


class QueryResultDtoTypedDict(TypedDict):
    query_id: str
    r"""The identifier of the original query"""
    bytes_scanned: NotRequired[int]
    r"""The number of bytes scanned"""
    columns: NotRequired[List[ColumnInfoDtoTypedDict]]
    r"""If the query has successfully completed, contains a list of columns and their associated computed types from the query."""
    created: NotRequired[datetime]
    r"""When the entity was created"""
    duration: NotRequired[int]
    r"""The duration of time it took to execute the query"""
    error: NotRequired[str]
    r"""If an error was encountered during the query, this field will be populated with
    error text.
    """
    id: NotRequired[str]
    r"""The entity's unique identifier"""
    is_explain: NotRequired[bool]
    r"""Determines if this query is to be explained and not executed"""
    parameters: NotRequired[Dict[str, Any]]
    r"""The query parameter map"""
    pivot_status: NotRequired[PivotStatus]
    r"""The current status of the pivot execution"""
    query_dto: NotRequired[QueryDtoTypedDict]
    query_parameters: NotRequired[List[QueryParameterDtoTypedDict]]
    r"""Contains the parameters available to the query at the time it was run. This allows consumers to go back in time and view the state of the query at runtime. For older query runs, this value may not be populated."""
    query_text: NotRequired[str]
    rows_returned: NotRequired[int]
    r"""Contains the number of rows returned from the query."""
    size: NotRequired[int]
    r"""Contains the size of the query results in bytes. This can be used to determine how
    best to download the file and if it's reasonable to open it in a browser or other
    application. This may be 0 if there are no results or the query results were gathered
    before we started collecting this metric.
    """
    status: NotRequired[QueryResultDtoStatus]
    r"""The current status of the query execution"""
    updated: NotRequired[datetime]
    r"""When the entity was last updated"""
    user_id: NotRequired[str]
    r"""The owner of the entity"""
    version: NotRequired[int]
    r"""The version of the current representation of the entity"""


class QueryResultDto(BaseModel):
    query_id: Annotated[str, pydantic.Field(alias="queryId")]
    r"""The identifier of the original query"""

    bytes_scanned: Annotated[Optional[int], pydantic.Field(alias="bytesScanned")] = None
    r"""The number of bytes scanned"""

    columns: Optional[List[ColumnInfoDto]] = None
    r"""If the query has successfully completed, contains a list of columns and their associated computed types from the query."""

    created: Optional[datetime] = None
    r"""When the entity was created"""

    duration: Optional[int] = None
    r"""The duration of time it took to execute the query"""

    error: Optional[str] = None
    r"""If an error was encountered during the query, this field will be populated with
    error text.
    """

    id: Optional[str] = None
    r"""The entity's unique identifier"""

    is_explain: Annotated[Optional[bool], pydantic.Field(alias="isExplain")] = None
    r"""Determines if this query is to be explained and not executed"""

    parameters: Optional[Dict[str, Any]] = None
    r"""The query parameter map"""

    pivot_status: Annotated[
        Optional[PivotStatus], pydantic.Field(alias="pivotStatus")
    ] = None
    r"""The current status of the pivot execution"""

    query_dto: Annotated[Optional[QueryDto], pydantic.Field(alias="queryDto")] = None

    query_parameters: Annotated[
        Optional[List[QueryParameterDto]], pydantic.Field(alias="queryParameters")
    ] = None
    r"""Contains the parameters available to the query at the time it was run. This allows consumers to go back in time and view the state of the query at runtime. For older query runs, this value may not be populated."""

    query_text: Annotated[Optional[str], pydantic.Field(alias="queryText")] = None

    rows_returned: Annotated[Optional[int], pydantic.Field(alias="rowsReturned")] = None
    r"""Contains the number of rows returned from the query."""

    size: Optional[int] = None
    r"""Contains the size of the query results in bytes. This can be used to determine how
    best to download the file and if it's reasonable to open it in a browser or other
    application. This may be 0 if there are no results or the query results were gathered
    before we started collecting this metric.
    """

    status: Optional[QueryResultDtoStatus] = None
    r"""The current status of the query execution"""

    updated: Optional[datetime] = None
    r"""When the entity was last updated"""

    user_id: Annotated[Optional[str], pydantic.Field(alias="userId")] = None
    r"""The owner of the entity"""

    version: Optional[int] = None
    r"""The version of the current representation of the entity"""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            [
                "bytesScanned",
                "columns",
                "created",
                "duration",
                "error",
                "id",
                "isExplain",
                "parameters",
                "pivotStatus",
                "queryDto",
                "queryParameters",
                "queryText",
                "rowsReturned",
                "size",
                "status",
                "updated",
                "userId",
                "version",
            ]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m
