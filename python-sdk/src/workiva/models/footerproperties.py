"""Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT."""

from __future__ import annotations
import pydantic
from pydantic import model_serializer
from typing import Optional
from typing_extensions import Annotated, NotRequired, TypedDict
from workiva.types import BaseModel, Nullable, OptionalNullable, UNSET, UNSET_SENTINEL


class MarginTypedDict(TypedDict):
    r"""Properties related to the margins of a header and footer"""

    left: NotRequired[Nullable[float]]
    r"""The left edge margin in points"""
    right: NotRequired[Nullable[float]]
    r"""The right edge margin in points"""


class Margin(BaseModel):
    r"""Properties related to the margins of a header and footer"""

    left: OptionalNullable[float] = UNSET
    r"""The left edge margin in points"""

    right: OptionalNullable[float] = UNSET
    r"""The right edge margin in points"""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["left", "right"])
        nullable_fields = set(["left", "right"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            is_nullable_and_explicitly_set = (
                k in nullable_fields
                and (self.__pydantic_fields_set__.intersection({n}))  # pylint: disable=no-member
            )

            if val != UNSET_SENTINEL:
                if (
                    val is not None
                    or k not in optional_fields
                    or is_nullable_and_explicitly_set
                ):
                    m[k] = val

        return m


class FooterPropertiesTypedDict(TypedDict):
    r"""Properties for footer of a section"""

    alternating_page: NotRequired[bool]
    r"""Do the headers/footers alternate between even and odd, otherwise the odd header/footer is shown for both even and odd pages.

    """
    different_first_page: NotRequired[bool]
    r"""If the first page has different header/footer value"""
    different_last_page: NotRequired[bool]
    r"""If the last page has different header/footer value"""
    margin: NotRequired[Nullable[MarginTypedDict]]
    r"""Properties related to the margins of a header and footer"""
    match_section_margins: NotRequired[bool]
    r"""Whether the margins match the section margins"""
    same_as_previous: NotRequired[bool]
    r"""Whether the previous section's headers/footers shown on this section"""
    position_from_bottom: NotRequired[Nullable[float]]
    r"""The position from the bottom for footer in points"""


class FooterProperties(BaseModel):
    r"""Properties for footer of a section"""

    alternating_page: Annotated[
        Optional[bool], pydantic.Field(alias="alternatingPage")
    ] = False
    r"""Do the headers/footers alternate between even and odd, otherwise the odd header/footer is shown for both even and odd pages.

    """

    different_first_page: Annotated[
        Optional[bool], pydantic.Field(alias="differentFirstPage")
    ] = False
    r"""If the first page has different header/footer value"""

    different_last_page: Annotated[
        Optional[bool], pydantic.Field(alias="differentLastPage")
    ] = False
    r"""If the last page has different header/footer value"""

    margin: OptionalNullable[Margin] = UNSET
    r"""Properties related to the margins of a header and footer"""

    match_section_margins: Annotated[
        Optional[bool], pydantic.Field(alias="matchSectionMargins")
    ] = False
    r"""Whether the margins match the section margins"""

    same_as_previous: Annotated[
        Optional[bool], pydantic.Field(alias="sameAsPrevious")
    ] = False
    r"""Whether the previous section's headers/footers shown on this section"""

    position_from_bottom: Annotated[
        OptionalNullable[float], pydantic.Field(alias="positionFromBottom")
    ] = UNSET
    r"""The position from the bottom for footer in points"""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            [
                "alternatingPage",
                "differentFirstPage",
                "differentLastPage",
                "margin",
                "matchSectionMargins",
                "sameAsPrevious",
                "positionFromBottom",
            ]
        )
        nullable_fields = set(["margin", "positionFromBottom"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            is_nullable_and_explicitly_set = (
                k in nullable_fields
                and (self.__pydantic_fields_set__.intersection({n}))  # pylint: disable=no-member
            )

            if val != UNSET_SENTINEL:
                if (
                    val is not None
                    or k not in optional_fields
                    or is_nullable_and_explicitly_set
                ):
                    m[k] = val

        return m
