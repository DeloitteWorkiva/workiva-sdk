"""Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT."""

from __future__ import annotations
from enum import Enum
import pydantic
from pydantic import field_serializer, model_serializer
from typing import Any, Dict, List, Optional
from typing_extensions import Annotated, NotRequired, TypedDict
from workiva import models, utils
from workiva.types import BaseModel, Nullable, OptionalNullable, UNSET, UNSET_SENTINEL


class WorkspaceMembershipsTypedDict(TypedDict):
    id: NotRequired[str]
    r"""The Workspace ID"""
    workspace_name: NotRequired[Nullable[str]]
    workspace_roles: NotRequired[Nullable[List[str]]]


class WorkspaceMemberships(BaseModel):
    id: Optional[str] = None
    r"""The Workspace ID"""

    workspace_name: Annotated[
        OptionalNullable[str], pydantic.Field(alias="workspaceName")
    ] = UNSET

    workspace_roles: Annotated[
        OptionalNullable[List[str]], pydantic.Field(alias="workspaceRoles")
    ] = UNSET

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["id", "workspaceName", "workspaceRoles"])
        nullable_fields = set(["workspaceName", "workspaceRoles"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            is_nullable_and_explicitly_set = (
                k in nullable_fields
                and (self.__pydantic_fields_set__.intersection({n}))  # pylint: disable=no-member
            )

            if val != UNSET_SENTINEL:
                if (
                    val is not None
                    or k not in optional_fields
                    or is_nullable_and_explicitly_set
                ):
                    m[k] = val

        return m


class AttributesTypedDict(TypedDict):
    active: NotRequired[Nullable[bool]]
    display_name: NotRequired[Nullable[str]]
    email: NotRequired[Nullable[str]]
    first_name: NotRequired[Nullable[str]]
    last_login: NotRequired[Nullable[str]]
    last_name: NotRequired[Nullable[str]]
    licenses: NotRequired[Nullable[List[str]]]
    organization_roles: NotRequired[Nullable[List[str]]]
    saml_id: NotRequired[Nullable[str]]
    user_name: NotRequired[Nullable[str]]
    workspace_memberships: NotRequired[Nullable[List[WorkspaceMembershipsTypedDict]]]


class Attributes(BaseModel):
    active: OptionalNullable[bool] = UNSET

    display_name: Annotated[
        OptionalNullable[str], pydantic.Field(alias="displayName")
    ] = UNSET

    email: OptionalNullable[str] = UNSET

    first_name: Annotated[OptionalNullable[str], pydantic.Field(alias="firstName")] = (
        UNSET
    )

    last_login: Annotated[OptionalNullable[str], pydantic.Field(alias="lastLogin")] = (
        UNSET
    )

    last_name: Annotated[OptionalNullable[str], pydantic.Field(alias="lastName")] = (
        UNSET
    )

    licenses: OptionalNullable[List[str]] = UNSET

    organization_roles: Annotated[
        OptionalNullable[List[str]], pydantic.Field(alias="organizationRoles")
    ] = UNSET

    saml_id: Annotated[OptionalNullable[str], pydantic.Field(alias="samlId")] = UNSET

    user_name: Annotated[OptionalNullable[str], pydantic.Field(alias="userName")] = (
        UNSET
    )

    workspace_memberships: Annotated[
        OptionalNullable[List[WorkspaceMemberships]],
        pydantic.Field(alias="workspaceMemberships"),
    ] = UNSET

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            [
                "active",
                "displayName",
                "email",
                "firstName",
                "lastLogin",
                "lastName",
                "licenses",
                "organizationRoles",
                "samlId",
                "userName",
                "workspaceMemberships",
            ]
        )
        nullable_fields = set(
            [
                "active",
                "displayName",
                "email",
                "firstName",
                "lastLogin",
                "lastName",
                "licenses",
                "organizationRoles",
                "samlId",
                "userName",
                "workspaceMemberships",
            ]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            is_nullable_and_explicitly_set = (
                k in nullable_fields
                and (self.__pydantic_fields_set__.intersection({n}))  # pylint: disable=no-member
            )

            if val != UNSET_SENTINEL:
                if (
                    val is not None
                    or k not in optional_fields
                    or is_nullable_and_explicitly_set
                ):
                    m[k] = val

        return m


class RelationshipsTypedDict(TypedDict):
    pass


class Relationships(BaseModel):
    pass


class GetOrgReportUsersResponseType(str, Enum, metaclass=utils.OpenEnumMeta):
    r"""The resource type (File)"""

    ORG_REPORT_USER = "orgReportUser"
    FILE = "File"


class GetOrgReportUsersResponseDataTypedDict(TypedDict):
    attributes: NotRequired[AttributesTypedDict]
    id: NotRequired[str]
    r"""The resource ID"""
    links: NotRequired[Nullable[Dict[str, Any]]]
    r"""A list of URLs."""
    relationships: NotRequired[Nullable[RelationshipsTypedDict]]
    type: NotRequired[GetOrgReportUsersResponseType]
    r"""The resource type (File)"""


class GetOrgReportUsersResponseData(BaseModel):
    attributes: Optional[Attributes] = None

    id: Optional[str] = None
    r"""The resource ID"""

    links: OptionalNullable[Dict[str, Any]] = UNSET
    r"""A list of URLs."""

    relationships: OptionalNullable[Relationships] = UNSET

    type: Optional[GetOrgReportUsersResponseType] = None
    r"""The resource type (File)"""

    @field_serializer("type")
    def serialize_type(self, value):
        if isinstance(value, str):
            try:
                return models.GetOrgReportUsersResponseType(value)
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["attributes", "id", "links", "relationships", "type"])
        nullable_fields = set(["links", "relationships"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            is_nullable_and_explicitly_set = (
                k in nullable_fields
                and (self.__pydantic_fields_set__.intersection({n}))  # pylint: disable=no-member
            )

            if val != UNSET_SENTINEL:
                if (
                    val is not None
                    or k not in optional_fields
                    or is_nullable_and_explicitly_set
                ):
                    m[k] = val

        return m


class IncludedTypedDict(TypedDict):
    attributes: NotRequired[Dict[str, Any]]
    id: NotRequired[str]
    r"""The resource ID"""
    type: NotRequired[str]
    r"""The resource type"""


class Included(BaseModel):
    attributes: Optional[Dict[str, Any]] = None

    id: Optional[str] = None
    r"""The resource ID"""

    type: Optional[str] = None
    r"""The resource type"""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["attributes", "id", "type"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class JsonapiTypedDict(TypedDict):
    version: NotRequired[str]


class Jsonapi(BaseModel):
    version: Optional[str] = None

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["version"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class LinksTypedDict(TypedDict):
    next: NotRequired[Nullable[str]]
    r"""The next page of data"""


class Links(BaseModel):
    next: OptionalNullable[str] = UNSET
    r"""The next page of data"""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["next"])
        nullable_fields = set(["next"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            is_nullable_and_explicitly_set = (
                k in nullable_fields
                and (self.__pydantic_fields_set__.intersection({n}))  # pylint: disable=no-member
            )

            if val != UNSET_SENTINEL:
                if (
                    val is not None
                    or k not in optional_fields
                    or is_nullable_and_explicitly_set
                ):
                    m[k] = val

        return m


class GetOrgReportUsersResponseTypedDict(TypedDict):
    r"""A report of Organization Users"""

    data: List[GetOrgReportUsersResponseDataTypedDict]
    included: NotRequired[Nullable[List[IncludedTypedDict]]]
    r"""Any additional included resources"""
    jsonapi: NotRequired[Nullable[JsonapiTypedDict]]
    links: NotRequired[LinksTypedDict]
    meta: NotRequired[Nullable[Dict[str, Any]]]
    r"""Non-standard meta-information that cannot be represented as an attribute or relationship."""


class GetOrgReportUsersResponse(BaseModel):
    r"""A report of Organization Users"""

    data: List[GetOrgReportUsersResponseData]

    included: OptionalNullable[List[Included]] = UNSET
    r"""Any additional included resources"""

    jsonapi: OptionalNullable[Jsonapi] = UNSET

    links: Optional[Links] = None

    meta: OptionalNullable[Dict[str, Any]] = UNSET
    r"""Non-standard meta-information that cannot be represented as an attribute or relationship."""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["included", "jsonapi", "links", "meta"])
        nullable_fields = set(["included", "jsonapi", "meta"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            is_nullable_and_explicitly_set = (
                k in nullable_fields
                and (self.__pydantic_fields_set__.intersection({n}))  # pylint: disable=no-member
            )

            if val != UNSET_SENTINEL:
                if (
                    val is not None
                    or k not in optional_fields
                    or is_nullable_and_explicitly_set
                ):
                    m[k] = val

        return m
