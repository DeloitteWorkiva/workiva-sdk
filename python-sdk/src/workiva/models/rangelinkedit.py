"""Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT."""

from __future__ import annotations
from .cellrange import CellRange, CellRangeTypedDict
from enum import Enum
import pydantic
from pydantic import model_serializer
from typing import Optional
from typing_extensions import Annotated, NotRequired, TypedDict
from workiva.types import BaseModel, Nullable, OptionalNullable, UNSET, UNSET_SENTINEL


class ChangeSourceRangeTypedDict(TypedDict):
    r"""Changes a source links range"""

    range: CellRangeTypedDict
    r"""A range of cells in a table. If any field is omitted or null, the range is unbounded in that direction. All indexes  are zero based.

    """
    range_link: str
    r"""The unique identifier of a range link."""


class ChangeSourceRange(BaseModel):
    r"""Changes a source links range"""

    range: CellRange
    r"""A range of cells in a table. If any field is omitted or null, the range is unbounded in that direction. All indexes  are zero based.

    """

    range_link: Annotated[str, pydantic.Field(alias="rangeLink")]
    r"""The unique identifier of a range link."""


class CreateDestinationTypedDict(TypedDict):
    r"""Creates a range destination link on the provided range"""

    source_range_link: str
    r"""The unique identifier of a range link."""
    source_table: str
    r"""The unique identifier for the source table."""
    apply_column_width: NotRequired[bool]
    r"""Whether to inherit column widths from the source."""
    apply_formatting: NotRequired[bool]
    r"""Whether to inherit formatting from the source."""


class CreateDestination(BaseModel):
    r"""Creates a range destination link on the provided range"""

    source_range_link: Annotated[str, pydantic.Field(alias="sourceRangeLink")]
    r"""The unique identifier of a range link."""

    source_table: Annotated[str, pydantic.Field(alias="sourceTable")]
    r"""The unique identifier for the source table."""

    apply_column_width: Annotated[
        Optional[bool], pydantic.Field(alias="applyColumnWidth")
    ] = True
    r"""Whether to inherit column widths from the source."""

    apply_formatting: Annotated[
        Optional[bool], pydantic.Field(alias="applyFormatting")
    ] = True
    r"""Whether to inherit formatting from the source."""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["applyColumnWidth", "applyFormatting"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class CreateSourceTypedDict(TypedDict):
    r"""Creates a range source link on the provided range"""

    range: CellRangeTypedDict
    r"""A range of cells in a table. If any field is omitted or null, the range is unbounded in that direction. All indexes  are zero based.

    """


class CreateSource(BaseModel):
    r"""Creates a range source link on the provided range"""

    range: CellRange
    r"""A range of cells in a table. If any field is omitted or null, the range is unbounded in that direction. All indexes  are zero based.

    """


class RemoveDestinationTypedDict(TypedDict):
    r"""Removes a range destination link on the provided range"""

    range_link: str
    r"""The unique identifier of a range link."""


class RemoveDestination(BaseModel):
    r"""Removes a range destination link on the provided range"""

    range_link: Annotated[str, pydantic.Field(alias="rangeLink")]
    r"""The unique identifier of a range link."""


class RemoveSourceTypedDict(TypedDict):
    r"""Removes a range source link on the provided range"""

    range_link: str
    r"""The unique identifier of a range link."""


class RemoveSource(BaseModel):
    r"""Removes a range source link on the provided range"""

    range_link: Annotated[str, pydantic.Field(alias="rangeLink")]
    r"""The unique identifier of a range link."""


class RangeLinkEditType(str, Enum):
    r"""The type of the table range links edit"""

    CREATE_SOURCE = "createSource"
    CREATE_DESTINATION = "createDestination"
    REMOVE_SOURCE = "removeSource"
    REMOVE_DESTINATION = "removeDestination"
    CHANGE_SOURCE_RANGE = "changeSourceRange"


class RangeLinkEditTypedDict(TypedDict):
    r"""An edit for modifying, creating, removing a range link over a table The edit property associated with the edit type is required. Any edit property that doesn''t correspond to its type will be ignored."""

    type: RangeLinkEditType
    r"""The type of the table range links edit"""
    change_source_range: NotRequired[Nullable[ChangeSourceRangeTypedDict]]
    create_destination: NotRequired[Nullable[CreateDestinationTypedDict]]
    create_source: NotRequired[Nullable[CreateSourceTypedDict]]
    remove_destination: NotRequired[Nullable[RemoveDestinationTypedDict]]
    remove_source: NotRequired[Nullable[RemoveSourceTypedDict]]


class RangeLinkEdit(BaseModel):
    r"""An edit for modifying, creating, removing a range link over a table The edit property associated with the edit type is required. Any edit property that doesn''t correspond to its type will be ignored."""

    type: RangeLinkEditType
    r"""The type of the table range links edit"""

    change_source_range: Annotated[
        OptionalNullable[ChangeSourceRange], pydantic.Field(alias="changeSourceRange")
    ] = UNSET

    create_destination: Annotated[
        OptionalNullable[CreateDestination], pydantic.Field(alias="createDestination")
    ] = UNSET

    create_source: Annotated[
        OptionalNullable[CreateSource], pydantic.Field(alias="createSource")
    ] = UNSET

    remove_destination: Annotated[
        OptionalNullable[RemoveDestination], pydantic.Field(alias="removeDestination")
    ] = UNSET

    remove_source: Annotated[
        OptionalNullable[RemoveSource], pydantic.Field(alias="removeSource")
    ] = UNSET

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            [
                "changeSourceRange",
                "createDestination",
                "createSource",
                "removeDestination",
                "removeSource",
            ]
        )
        nullable_fields = set(
            [
                "changeSourceRange",
                "createDestination",
                "createSource",
                "removeDestination",
                "removeSource",
            ]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            is_nullable_and_explicitly_set = (
                k in nullable_fields
                and (self.__pydantic_fields_set__.intersection({n}))  # pylint: disable=no-member
            )

            if val != UNSET_SENTINEL:
                if (
                    val is not None
                    or k not in optional_fields
                    or is_nullable_and_explicitly_set
                ):
                    m[k] = val

        return m
