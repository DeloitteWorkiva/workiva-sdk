"""Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT."""

from __future__ import annotations
from .border import Border, BorderTypedDict
from enum import Enum
import pydantic
from pydantic import model_serializer
from typing_extensions import Annotated, NotRequired, TypedDict
from workiva.types import BaseModel, Nullable, OptionalNullable, UNSET, UNSET_SENTINEL


class BordersTypedDict(TypedDict):
    r"""The borders applied to a cell. Borders may be set by setting `applyBorders`"""

    bottom: NotRequired[Nullable[BorderTypedDict]]
    r"""The type of border that should be applied"""
    left: NotRequired[Nullable[BorderTypedDict]]
    r"""The type of border that should be applied"""
    right: NotRequired[Nullable[BorderTypedDict]]
    r"""The type of border that should be applied"""
    top: NotRequired[Nullable[BorderTypedDict]]
    r"""The type of border that should be applied"""


class Borders(BaseModel):
    r"""The borders applied to a cell. Borders may be set by setting `applyBorders`"""

    bottom: OptionalNullable[Border] = UNSET
    r"""The type of border that should be applied"""

    left: OptionalNullable[Border] = UNSET
    r"""The type of border that should be applied"""

    right: OptionalNullable[Border] = UNSET
    r"""The type of border that should be applied"""

    top: OptionalNullable[Border] = UNSET
    r"""The type of border that should be applied"""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["bottom", "left", "right", "top"])
        nullable_fields = set(["bottom", "left", "right", "top"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            is_nullable_and_explicitly_set = (
                k in nullable_fields
                and (self.__pydantic_fields_set__.intersection({n}))  # pylint: disable=no-member
            )

            if val != UNSET_SENTINEL:
                if (
                    val is not None
                    or k not in optional_fields
                    or is_nullable_and_explicitly_set
                ):
                    m[k] = val

        return m


class HorizontalAlign(str, Enum):
    r"""The horizontal alignment of the content in the cell"""

    LEFT = "LEFT"
    RIGHT = "RIGHT"
    CENTER = "CENTER"
    JUSTIFIED = "JUSTIFIED"


class CellFormatUnit(str, Enum):
    r"""The unit of the size"""

    INCHES = "INCHES"
    CENTIMETERS = "CENTIMETERS"


class IndentTypedDict(TypedDict):
    r"""Indentation of content in the cell"""

    unit: CellFormatUnit
    r"""The unit of the size"""
    value: float
    r"""The size of the indent"""


class Indent(BaseModel):
    r"""Indentation of content in the cell"""

    unit: CellFormatUnit
    r"""The unit of the size"""

    value: float
    r"""The size of the indent"""


class LeaderDots(str, Enum):
    r"""The leader dot pattern to show on the cell"""

    NARROW = "NARROW"
    WIDE = "WIDE"


class TextRotation(str, Enum):
    r"""The text orientation"""

    HORIZONTAL = "HORIZONTAL"
    ASCENDING = "ASCENDING"
    DESCENDING = "DESCENDING"


class VerticalAlign(str, Enum):
    r"""The vertical alignment of the content in the cell"""

    TOP = "TOP"
    MIDDLE = "MIDDLE"
    BOTTOM = "BOTTOM"


class CellFormatTypedDict(TypedDict):
    r"""Cell Formats. Fields that are omitted will be ignored."""

    background_color: NotRequired[Nullable[str]]
    r"""A hex color code"""
    borders: NotRequired[Nullable[BordersTypedDict]]
    r"""The borders applied to a cell. Borders may be set by setting `applyBorders`"""
    horizontal_align: NotRequired[Nullable[HorizontalAlign]]
    r"""The horizontal alignment of the content in the cell"""
    indent: NotRequired[Nullable[IndentTypedDict]]
    r"""Indentation of content in the cell"""
    leader_dots: NotRequired[Nullable[LeaderDots]]
    r"""The leader dot pattern to show on the cell"""
    text_rotation: NotRequired[Nullable[TextRotation]]
    r"""The text orientation"""
    vertical_align: NotRequired[Nullable[VerticalAlign]]
    r"""The vertical alignment of the content in the cell"""


class CellFormat(BaseModel):
    r"""Cell Formats. Fields that are omitted will be ignored."""

    background_color: Annotated[
        OptionalNullable[str], pydantic.Field(alias="backgroundColor")
    ] = "#000000"
    r"""A hex color code"""

    borders: OptionalNullable[Borders] = UNSET
    r"""The borders applied to a cell. Borders may be set by setting `applyBorders`"""

    horizontal_align: Annotated[
        OptionalNullable[HorizontalAlign], pydantic.Field(alias="horizontalAlign")
    ] = UNSET
    r"""The horizontal alignment of the content in the cell"""

    indent: OptionalNullable[Indent] = UNSET
    r"""Indentation of content in the cell"""

    leader_dots: Annotated[
        OptionalNullable[LeaderDots], pydantic.Field(alias="leaderDots")
    ] = UNSET
    r"""The leader dot pattern to show on the cell"""

    text_rotation: Annotated[
        OptionalNullable[TextRotation], pydantic.Field(alias="textRotation")
    ] = UNSET
    r"""The text orientation"""

    vertical_align: Annotated[
        OptionalNullable[VerticalAlign], pydantic.Field(alias="verticalAlign")
    ] = UNSET
    r"""The vertical alignment of the content in the cell"""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            [
                "backgroundColor",
                "borders",
                "horizontalAlign",
                "indent",
                "leaderDots",
                "textRotation",
                "verticalAlign",
            ]
        )
        nullable_fields = set(
            [
                "backgroundColor",
                "borders",
                "horizontalAlign",
                "indent",
                "leaderDots",
                "textRotation",
                "verticalAlign",
            ]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            is_nullable_and_explicitly_set = (
                k in nullable_fields
                and (self.__pydantic_fields_set__.intersection({n}))  # pylint: disable=no-member
            )

            if val != UNSET_SENTINEL:
                if (
                    val is not None
                    or k not in optional_fields
                    or is_nullable_and_explicitly_set
                ):
                    m[k] = val

        return m


class CellFormatInputTypedDict(TypedDict):
    r"""Cell Formats. Fields that are omitted will be ignored."""

    background_color: NotRequired[Nullable[str]]
    r"""A hex color code"""
    horizontal_align: NotRequired[Nullable[HorizontalAlign]]
    r"""The horizontal alignment of the content in the cell"""
    indent: NotRequired[Nullable[IndentTypedDict]]
    r"""Indentation of content in the cell"""
    leader_dots: NotRequired[Nullable[LeaderDots]]
    r"""The leader dot pattern to show on the cell"""
    text_rotation: NotRequired[Nullable[TextRotation]]
    r"""The text orientation"""
    vertical_align: NotRequired[Nullable[VerticalAlign]]
    r"""The vertical alignment of the content in the cell"""


class CellFormatInput(BaseModel):
    r"""Cell Formats. Fields that are omitted will be ignored."""

    background_color: Annotated[
        OptionalNullable[str], pydantic.Field(alias="backgroundColor")
    ] = "#000000"
    r"""A hex color code"""

    horizontal_align: Annotated[
        OptionalNullable[HorizontalAlign], pydantic.Field(alias="horizontalAlign")
    ] = UNSET
    r"""The horizontal alignment of the content in the cell"""

    indent: OptionalNullable[Indent] = UNSET
    r"""Indentation of content in the cell"""

    leader_dots: Annotated[
        OptionalNullable[LeaderDots], pydantic.Field(alias="leaderDots")
    ] = UNSET
    r"""The leader dot pattern to show on the cell"""

    text_rotation: Annotated[
        OptionalNullable[TextRotation], pydantic.Field(alias="textRotation")
    ] = UNSET
    r"""The text orientation"""

    vertical_align: Annotated[
        OptionalNullable[VerticalAlign], pydantic.Field(alias="verticalAlign")
    ] = UNSET
    r"""The vertical alignment of the content in the cell"""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            [
                "backgroundColor",
                "horizontalAlign",
                "indent",
                "leaderDots",
                "textRotation",
                "verticalAlign",
            ]
        )
        nullable_fields = set(
            [
                "backgroundColor",
                "horizontalAlign",
                "indent",
                "leaderDots",
                "textRotation",
                "verticalAlign",
            ]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            is_nullable_and_explicitly_set = (
                k in nullable_fields
                and (self.__pydantic_fields_set__.intersection({n}))  # pylint: disable=no-member
            )

            if val != UNSET_SENTINEL:
                if (
                    val is not None
                    or k not in optional_fields
                    or is_nullable_and_explicitly_set
                ):
                    m[k] = val

        return m
