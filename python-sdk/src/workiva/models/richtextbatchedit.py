"""Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT."""

from __future__ import annotations
from .textedit import TextEdit, TextEditTypedDict
import pydantic
from pydantic import model_serializer
from typing import List, Optional
from typing_extensions import Annotated, NotRequired, TypedDict
from workiva.types import BaseModel, Nullable, OptionalNullable, UNSET, UNSET_SENTINEL


class RichTextBatchEditTypedDict(TypedDict):
    r"""A collection of edits to apply to rich text."""

    data: List[TextEditTypedDict]
    r"""The edits to apply to the rich text."""
    islolate_edits: NotRequired[bool]
    r"""Whether the edits in a batch should be isolated from one-another. The edits will still be applied in order, but subsequent edits are unaffected by the previous edits in the same batch. For example, if one edit inserts some content, the next edits will act as if the content doesn't exist yet. Or if an edit deletes some content, the next edits will act as if the content is still there. This mode makes it easier to apply many edits on existing content because you don't need to manually keep track of how the previous edits have moved the content. For example, if you want to replace all instances of one word with another it will be easier to do this with isolated edits.

    """
    revision: NotRequired[Nullable[str]]


class RichTextBatchEdit(BaseModel):
    r"""A collection of edits to apply to rich text."""

    data: List[TextEdit]
    r"""The edits to apply to the rich text."""

    islolate_edits: Annotated[Optional[bool], pydantic.Field(alias="islolateEdits")] = (
        False
    )
    r"""Whether the edits in a batch should be isolated from one-another. The edits will still be applied in order, but subsequent edits are unaffected by the previous edits in the same batch. For example, if one edit inserts some content, the next edits will act as if the content doesn't exist yet. Or if an edit deletes some content, the next edits will act as if the content is still there. This mode makes it easier to apply many edits on existing content because you don't need to manually keep track of how the previous edits have moved the content. For example, if you want to replace all instances of one word with another it will be easier to do this with isolated edits.

    """

    revision: OptionalNullable[str] = UNSET

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["islolateEdits", "revision"])
        nullable_fields = set(["revision"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            is_nullable_and_explicitly_set = (
                k in nullable_fields
                and (self.__pydantic_fields_set__.intersection({n}))  # pylint: disable=no-member
            )

            if val != UNSET_SENTINEL:
                if (
                    val is not None
                    or k not in optional_fields
                    or is_nullable_and_explicitly_set
                ):
                    m[k] = val

        return m
