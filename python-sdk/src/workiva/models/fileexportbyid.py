"""Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT."""

from __future__ import annotations
from enum import Enum
import pydantic
from pydantic import model_serializer
from typing import List, Optional
from typing_extensions import Annotated, NotRequired, TypedDict
from workiva.types import BaseModel, Nullable, OptionalNullable, UNSET, UNSET_SENTINEL


class FileExportByIDDocxOptionsTypedDict(TypedDict):
    r"""Optional options to export the document as a Microsoft Word document (.DOCX). If no options are provided, all options default to False."""

    include_leader_dots: NotRequired[bool]
    r"""Whether to include leader dots when exporting to .DOCX. False by default."""
    show_table_cell_shading: NotRequired[bool]
    r"""Whether to show table cell shading when exporting to .DOCX. False by default."""


class FileExportByIDDocxOptions(BaseModel):
    r"""Optional options to export the document as a Microsoft Word document (.DOCX). If no options are provided, all options default to False."""

    include_leader_dots: Annotated[
        Optional[bool], pydantic.Field(alias="includeLeaderDots")
    ] = False
    r"""Whether to include leader dots when exporting to .DOCX. False by default."""

    show_table_cell_shading: Annotated[
        Optional[bool], pydantic.Field(alias="showTableCellShading")
    ] = False
    r"""Whether to show table cell shading when exporting to .DOCX. False by default."""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["includeLeaderDots", "showTableCellShading"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class FileExportByIDFormat(str, Enum):
    r"""The file format to export the document as."""

    PDF = "pdf"
    DOCX = "docx"
    XHTML = "xhtml"


class FileExportByIDPdfOptionsTypedDict(TypedDict):
    r"""Optional options to export the document as a portable document file (.PDF). If no options are provided, all options default to False."""

    include_alternate_row_fill: NotRequired[bool]
    r"""Whether to include alternate row fill when exporting to .PDF. False by default."""
    include_attachment_labels: NotRequired[bool]
    r"""Whether to include attachment labels when exporting to .PDF. False by default."""
    include_comments: NotRequired[bool]
    r"""Whether to include comments when exporting to .PDF. False by default. When True, all comments are included, even those already resolved."""
    include_draft_watermark: NotRequired[bool]
    r"""Whether to include a \"Draft\" watermark when exporting to .PDF. False by default."""
    include_hyperlinks: NotRequired[bool]
    r"""Whether to include hyperlinks when exporting to .PDF. False by default."""
    include_leader_dots: NotRequired[bool]
    r"""Whether to include leader dots when exporting to .PDF. False by default."""
    include_track_changes: NotRequired[bool]
    r"""Whether to include track changes when exporting to .PDF. False by default."""
    remove_space_from_partial_export: NotRequired[bool]
    r"""Whether to remove space from partial exports when exporting to .PDF. False by default."""
    tag_for_web_accessibility: NotRequired[bool]
    r"""Whether to tag for web accessibility when exporting to .PDF. False by default."""
    use_cmyk_colorspace: NotRequired[bool]
    r"""Whether to use CMYK colorspace when exporting to .PDF. False by default."""


class FileExportByIDPdfOptions(BaseModel):
    r"""Optional options to export the document as a portable document file (.PDF). If no options are provided, all options default to False."""

    include_alternate_row_fill: Annotated[
        Optional[bool], pydantic.Field(alias="includeAlternateRowFill")
    ] = False
    r"""Whether to include alternate row fill when exporting to .PDF. False by default."""

    include_attachment_labels: Annotated[
        Optional[bool], pydantic.Field(alias="includeAttachmentLabels")
    ] = False
    r"""Whether to include attachment labels when exporting to .PDF. False by default."""

    include_comments: Annotated[
        Optional[bool], pydantic.Field(alias="includeComments")
    ] = False
    r"""Whether to include comments when exporting to .PDF. False by default. When True, all comments are included, even those already resolved."""

    include_draft_watermark: Annotated[
        Optional[bool], pydantic.Field(alias="includeDraftWatermark")
    ] = False
    r"""Whether to include a \"Draft\" watermark when exporting to .PDF. False by default."""

    include_hyperlinks: Annotated[
        Optional[bool], pydantic.Field(alias="includeHyperlinks")
    ] = False
    r"""Whether to include hyperlinks when exporting to .PDF. False by default."""

    include_leader_dots: Annotated[
        Optional[bool], pydantic.Field(alias="includeLeaderDots")
    ] = False
    r"""Whether to include leader dots when exporting to .PDF. False by default."""

    include_track_changes: Annotated[
        Optional[bool], pydantic.Field(alias="includeTrackChanges")
    ] = False
    r"""Whether to include track changes when exporting to .PDF. False by default."""

    remove_space_from_partial_export: Annotated[
        Optional[bool], pydantic.Field(alias="removeSpaceFromPartialExport")
    ] = False
    r"""Whether to remove space from partial exports when exporting to .PDF. False by default."""

    tag_for_web_accessibility: Annotated[
        Optional[bool], pydantic.Field(alias="tagForWebAccessibility")
    ] = False
    r"""Whether to tag for web accessibility when exporting to .PDF. False by default."""

    use_cmyk_colorspace: Annotated[
        Optional[bool], pydantic.Field(alias="useCmykColorspace")
    ] = False
    r"""Whether to use CMYK colorspace when exporting to .PDF. False by default."""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            [
                "includeAlternateRowFill",
                "includeAttachmentLabels",
                "includeComments",
                "includeDraftWatermark",
                "includeHyperlinks",
                "includeLeaderDots",
                "includeTrackChanges",
                "removeSpaceFromPartialExport",
                "tagForWebAccessibility",
                "useCmykColorspace",
            ]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class FileExportByIDXhtmlOptionsTypedDict(TypedDict):
    r"""Optional options to export the document as .XHTML. If no options are provided, `editableXhtml` will be true and all other options will be false."""

    editable_simple: NotRequired[bool]
    r"""Whether to produce simplified editable XHTML. This option produces editable XHTML that is simpler than the  editableXHTML option. Use this option when you only need the textual and numeric content of a document, but not  any of the images or complex formatting. When this option is true, all other XHTML export options must be false.

    """
    editable_xhtml: NotRequired[bool]
    r"""Whether the resulting XHTML is editable when exporting to .XHTML. False by default. If set to true, other options must be false.
    When exporting XHTML that you plan to edit or modify, use this option. Otherwise, the export retains fidelity so it visually matches the document as it appears in the browser.

    """
    include_external_hyperlinks: NotRequired[bool]
    r"""Whether to include external hyperlinks when exporting to .XHTML. False by default."""
    include_headers_and_footers: NotRequired[bool]
    r"""Whether to include the headers and footers when exporting to .XHTML. False by default."""


class FileExportByIDXhtmlOptions(BaseModel):
    r"""Optional options to export the document as .XHTML. If no options are provided, `editableXhtml` will be true and all other options will be false."""

    editable_simple: Annotated[
        Optional[bool], pydantic.Field(alias="editableSimple")
    ] = False
    r"""Whether to produce simplified editable XHTML. This option produces editable XHTML that is simpler than the  editableXHTML option. Use this option when you only need the textual and numeric content of a document, but not  any of the images or complex formatting. When this option is true, all other XHTML export options must be false.

    """

    editable_xhtml: Annotated[Optional[bool], pydantic.Field(alias="editableXhtml")] = (
        False
    )
    r"""Whether the resulting XHTML is editable when exporting to .XHTML. False by default. If set to true, other options must be false.
    When exporting XHTML that you plan to edit or modify, use this option. Otherwise, the export retains fidelity so it visually matches the document as it appears in the browser.

    """

    include_external_hyperlinks: Annotated[
        Optional[bool], pydantic.Field(alias="includeExternalHyperlinks")
    ] = False
    r"""Whether to include external hyperlinks when exporting to .XHTML. False by default."""

    include_headers_and_footers: Annotated[
        Optional[bool], pydantic.Field(alias="includeHeadersAndFooters")
    ] = False
    r"""Whether to include the headers and footers when exporting to .XHTML. False by default."""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            [
                "editableSimple",
                "editableXhtml",
                "includeExternalHyperlinks",
                "includeHeadersAndFooters",
            ]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class FileExportByIDDocumentExportTypedDict(TypedDict):
    r"""Details about the document export, including its format and options"""

    format_: FileExportByIDFormat
    r"""The file format to export the document as."""
    docx_options: NotRequired[Nullable[FileExportByIDDocxOptionsTypedDict]]
    pdf_options: NotRequired[Nullable[FileExportByIDPdfOptionsTypedDict]]
    sections: NotRequired[List[str]]
    r"""The IDs of the sections of the document to export. Omit to export the entire document."""
    xhtml_options: NotRequired[Nullable[FileExportByIDXhtmlOptionsTypedDict]]


class FileExportByIDDocumentExport(BaseModel):
    r"""Details about the document export, including its format and options"""

    format_: Annotated[FileExportByIDFormat, pydantic.Field(alias="format")]
    r"""The file format to export the document as."""

    docx_options: Annotated[
        OptionalNullable[FileExportByIDDocxOptions], pydantic.Field(alias="docxOptions")
    ] = UNSET

    pdf_options: Annotated[
        OptionalNullable[FileExportByIDPdfOptions], pydantic.Field(alias="pdfOptions")
    ] = UNSET

    sections: Optional[List[str]] = None
    r"""The IDs of the sections of the document to export. Omit to export the entire document."""

    xhtml_options: Annotated[
        OptionalNullable[FileExportByIDXhtmlOptions],
        pydantic.Field(alias="xhtmlOptions"),
    ] = UNSET

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["docxOptions", "pdfOptions", "sections", "xhtmlOptions"])
        nullable_fields = set(["docxOptions", "pdfOptions", "xhtmlOptions"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            is_nullable_and_explicitly_set = (
                k in nullable_fields
                and (self.__pydantic_fields_set__.intersection({n}))  # pylint: disable=no-member
            )

            if val != UNSET_SENTINEL:
                if (
                    val is not None
                    or k not in optional_fields
                    or is_nullable_and_explicitly_set
                ):
                    m[k] = val

        return m


class FolderExportTypedDict(TypedDict):
    r"""Details about the folder export, including its options"""

    email_on_complete: NotRequired[bool]
    r"""Whether or not to email the authorized user when this upload is complete."""
    include_attachments: NotRequired[bool]
    r"""Whether to preserve attachments for exported content."""
    include_comments: NotRequired[bool]
    r"""Whether to preserve comments for exported content."""
    include_custom_field_values: NotRequired[bool]
    r"""Whether to preserve custom field values for exported content."""
    include_document_markup: NotRequired[bool]
    r"""Whether to preserve document markup for exported content."""
    include_input_cell_values: NotRequired[bool]
    r"""Whether to preserve input cell values for exported content."""
    include_outline_labels: NotRequired[bool]
    r"""Whether to preserve outline labels for exported content."""
    include_smart_link_metadata: NotRequired[bool]
    r"""Whether to include smart link metadata for exported content."""
    include_wdata_incoming_connections: NotRequired[bool]
    r"""Whether to preserve incoming wdata connections for exported content."""
    include_wdata_outgoing_connections: NotRequired[bool]
    r"""Whether to preserve outgoing wdata connections for exported content."""
    include_xbrl: NotRequired[bool]
    r"""Whether to preserve XBRL for exported content."""
    include_xbrl_disconnected: NotRequired[bool]
    r"""Whether to preserve disconnected XBRL for exported content."""
    keep_input_mode_enabled: NotRequired[bool]
    r"""Whether to preserve input mode for exported content."""
    remove_grc_links: NotRequired[bool]
    r"""Whether to remove any connections to original GRC database, preserving only the textual or value representation of these links."""
    remove_links: NotRequired[bool]
    r"""Whether to remove any links from sources that are not part of the operation, preserving only the textual or value representation of these links."""


class FolderExport(BaseModel):
    r"""Details about the folder export, including its options"""

    email_on_complete: Annotated[
        Optional[bool], pydantic.Field(alias="emailOnComplete")
    ] = False
    r"""Whether or not to email the authorized user when this upload is complete."""

    include_attachments: Annotated[
        Optional[bool], pydantic.Field(alias="includeAttachments")
    ] = False
    r"""Whether to preserve attachments for exported content."""

    include_comments: Annotated[
        Optional[bool], pydantic.Field(alias="includeComments")
    ] = False
    r"""Whether to preserve comments for exported content."""

    include_custom_field_values: Annotated[
        Optional[bool], pydantic.Field(alias="includeCustomFieldValues")
    ] = False
    r"""Whether to preserve custom field values for exported content."""

    include_document_markup: Annotated[
        Optional[bool], pydantic.Field(alias="includeDocumentMarkup")
    ] = False
    r"""Whether to preserve document markup for exported content."""

    include_input_cell_values: Annotated[
        Optional[bool], pydantic.Field(alias="includeInputCellValues")
    ] = False
    r"""Whether to preserve input cell values for exported content."""

    include_outline_labels: Annotated[
        Optional[bool], pydantic.Field(alias="includeOutlineLabels")
    ] = False
    r"""Whether to preserve outline labels for exported content."""

    include_smart_link_metadata: Annotated[
        Optional[bool], pydantic.Field(alias="includeSmartLinkMetadata")
    ] = False
    r"""Whether to include smart link metadata for exported content."""

    include_wdata_incoming_connections: Annotated[
        Optional[bool], pydantic.Field(alias="includeWdataIncomingConnections")
    ] = False
    r"""Whether to preserve incoming wdata connections for exported content."""

    include_wdata_outgoing_connections: Annotated[
        Optional[bool], pydantic.Field(alias="includeWdataOutgoingConnections")
    ] = False
    r"""Whether to preserve outgoing wdata connections for exported content."""

    include_xbrl: Annotated[Optional[bool], pydantic.Field(alias="includeXBRL")] = False
    r"""Whether to preserve XBRL for exported content."""

    include_xbrl_disconnected: Annotated[
        Optional[bool], pydantic.Field(alias="includeXBRLDisconnected")
    ] = False
    r"""Whether to preserve disconnected XBRL for exported content."""

    keep_input_mode_enabled: Annotated[
        Optional[bool], pydantic.Field(alias="keepInputModeEnabled")
    ] = False
    r"""Whether to preserve input mode for exported content."""

    remove_grc_links: Annotated[
        Optional[bool], pydantic.Field(alias="removeGRCLinks")
    ] = False
    r"""Whether to remove any connections to original GRC database, preserving only the textual or value representation of these links."""

    remove_links: Annotated[Optional[bool], pydantic.Field(alias="removeLinks")] = False
    r"""Whether to remove any links from sources that are not part of the operation, preserving only the textual or value representation of these links."""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            [
                "emailOnComplete",
                "includeAttachments",
                "includeComments",
                "includeCustomFieldValues",
                "includeDocumentMarkup",
                "includeInputCellValues",
                "includeOutlineLabels",
                "includeSmartLinkMetadata",
                "includeWdataIncomingConnections",
                "includeWdataOutgoingConnections",
                "includeXBRL",
                "includeXBRLDisconnected",
                "keepInputModeEnabled",
                "removeGRCLinks",
                "removeLinks",
            ]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class FileExportByIDKind(str, Enum):
    r"""Kind (Type) of the file which will be exported."""

    DOCUMENT = "Document"
    SPREADSHEET = "Spreadsheet"
    PRESENTATION = "Presentation"
    SUPPORTING_DOCUMENT = "SupportingDocument"
    FOLDER = "Folder"


class FileExportByIDSchemasFormat(str, Enum):
    r"""The file format to export the presentation as - .PDF or .PPTX."""

    PDF = "pdf"
    PPTX = "pptx"


class FileExportByIDSchemasPdfOptionsTypedDict(TypedDict):
    r"""Optional options to export the presentation as a portable document file (.PDF). If no options are provided, all options default to False."""

    include_alternate_row_fill: NotRequired[bool]
    r"""Whether to include alternate row fill in the presentation's tables when exporting to .PDF. False by default."""
    include_comments: NotRequired[bool]
    r"""Whether to include comments when exporting to .PDF. False by default. When True, all comments are included, even those already resolved."""
    include_draft_watermark: NotRequired[bool]
    r"""Whether to include a \"Draft\" watermark when exporting to .PDF. False by default."""
    include_hyperlinks: NotRequired[bool]
    r"""Whether to include hyperlinks when exporting to .PDF. False by default."""
    include_leader_dots: NotRequired[bool]
    r"""Whether to include leader dots when exporting to .PDF. False by default."""
    tag_for_web_accessibility: NotRequired[bool]
    r"""Whether to tag for web accessibility when exporting to .PDF. False by default."""
    use_cmyk_colorspace: NotRequired[bool]
    r"""Whether to use CMYK colorspace when exporting to .PDF. False by default."""


class FileExportByIDSchemasPdfOptions(BaseModel):
    r"""Optional options to export the presentation as a portable document file (.PDF). If no options are provided, all options default to False."""

    include_alternate_row_fill: Annotated[
        Optional[bool], pydantic.Field(alias="includeAlternateRowFill")
    ] = False
    r"""Whether to include alternate row fill in the presentation's tables when exporting to .PDF. False by default."""

    include_comments: Annotated[
        Optional[bool], pydantic.Field(alias="includeComments")
    ] = False
    r"""Whether to include comments when exporting to .PDF. False by default. When True, all comments are included, even those already resolved."""

    include_draft_watermark: Annotated[
        Optional[bool], pydantic.Field(alias="includeDraftWatermark")
    ] = False
    r"""Whether to include a \"Draft\" watermark when exporting to .PDF. False by default."""

    include_hyperlinks: Annotated[
        Optional[bool], pydantic.Field(alias="includeHyperlinks")
    ] = False
    r"""Whether to include hyperlinks when exporting to .PDF. False by default."""

    include_leader_dots: Annotated[
        Optional[bool], pydantic.Field(alias="includeLeaderDots")
    ] = False
    r"""Whether to include leader dots when exporting to .PDF. False by default."""

    tag_for_web_accessibility: Annotated[
        Optional[bool], pydantic.Field(alias="tagForWebAccessibility")
    ] = False
    r"""Whether to tag for web accessibility when exporting to .PDF. False by default."""

    use_cmyk_colorspace: Annotated[
        Optional[bool], pydantic.Field(alias="useCmykColorspace")
    ] = False
    r"""Whether to use CMYK colorspace when exporting to .PDF. False by default."""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            [
                "includeAlternateRowFill",
                "includeComments",
                "includeDraftWatermark",
                "includeHyperlinks",
                "includeLeaderDots",
                "tagForWebAccessibility",
                "useCmykColorspace",
            ]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class FileExportByIDPptxOptionsTypedDict(TypedDict):
    r"""Optional options to export the presentation as a Microsoft Powerpoint File (.pptx). If no options are provided, all options default to False."""

    include_unused_layout_slides: NotRequired[bool]
    r"""Whether to include unused layout slides. False by default."""


class FileExportByIDPptxOptions(BaseModel):
    r"""Optional options to export the presentation as a Microsoft Powerpoint File (.pptx). If no options are provided, all options default to False."""

    include_unused_layout_slides: Annotated[
        Optional[bool], pydantic.Field(alias="includeUnusedLayoutSlides")
    ] = False
    r"""Whether to include unused layout slides. False by default."""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["includeUnusedLayoutSlides"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class FileExportByIDPresentationExportTypedDict(TypedDict):
    r"""Details about the presentation export, including its format and options"""

    format_: FileExportByIDSchemasFormat
    r"""The file format to export the presentation as - .PDF or .PPTX."""
    pdf_options: NotRequired[Nullable[FileExportByIDSchemasPdfOptionsTypedDict]]
    pptx_options: NotRequired[Nullable[FileExportByIDPptxOptionsTypedDict]]
    slides: NotRequired[List[str]]
    r"""The IDs of the slides of the presentation to export. Omit to export the entire presentation."""


class FileExportByIDPresentationExport(BaseModel):
    r"""Details about the presentation export, including its format and options"""

    format_: Annotated[FileExportByIDSchemasFormat, pydantic.Field(alias="format")]
    r"""The file format to export the presentation as - .PDF or .PPTX."""

    pdf_options: Annotated[
        OptionalNullable[FileExportByIDSchemasPdfOptions],
        pydantic.Field(alias="pdfOptions"),
    ] = UNSET

    pptx_options: Annotated[
        OptionalNullable[FileExportByIDPptxOptions], pydantic.Field(alias="pptxOptions")
    ] = UNSET

    slides: Optional[List[str]] = None
    r"""The IDs of the slides of the presentation to export. Omit to export the entire presentation."""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["pdfOptions", "pptxOptions", "slides"])
        nullable_fields = set(["pdfOptions", "pptxOptions"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            is_nullable_and_explicitly_set = (
                k in nullable_fields
                and (self.__pydantic_fields_set__.intersection({n}))  # pylint: disable=no-member
            )

            if val != UNSET_SENTINEL:
                if (
                    val is not None
                    or k not in optional_fields
                    or is_nullable_and_explicitly_set
                ):
                    m[k] = val

        return m


class FileExportByIDCsvOptionsTypedDict(TypedDict):
    r"""Optional options to export the spreadsheet as a comma-separated values (.CSV) file. If no options are provided, `exportAsFormulas` defaults to False."""

    export_as_formulas: NotRequired[bool]
    r"""Whether to export cells containing formulas as the formula or the formula result. False by default."""


class FileExportByIDCsvOptions(BaseModel):
    r"""Optional options to export the spreadsheet as a comma-separated values (.CSV) file. If no options are provided, `exportAsFormulas` defaults to False."""

    export_as_formulas: Annotated[
        Optional[bool], pydantic.Field(alias="exportAsFormulas")
    ] = False
    r"""Whether to export cells containing formulas as the formula or the formula result. False by default."""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["exportAsFormulas"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class FileExportByIDSchemasSpreadsheetExportFormat(str, Enum):
    r"""The file format to export the spreadsheet as."""

    PDF = "pdf"
    XLSX = "xlsx"
    CSV = "csv"


class FileExportByIDPageOrientation(str, Enum):
    r"""The orientation of the exported .PDF, such as \"portrait\" or \"landscape\". \"portrait\" by default."""

    PORTRAIT = "portrait"
    LANDSCAPE = "landscape"


class FileExportByIDPageScale(str, Enum):
    r"""The scale of the exported .PDF. \"actualSize\" by default."""

    ACTUAL_SIZE = "actualSize"
    FIT_TO_WIDTH = "fitToWidth"


class FileExportByIDSchemasSpreadsheetExportPdfOptionsTypedDict(TypedDict):
    r"""Optional options to export the spreadsheet as a portable document file (.PDF). If no options are provided, all options default to False except:
    - `pageHeight`, which defaults to 11
    - `pageWidth`, which defaults to 8.5
    - `pageOrientation`, which defaults to \"portrait\"
    - `pageScale`, which defaults to \"actualSize\"
    """

    include_comments: NotRequired[bool]
    r"""Whether to include comments when exporting to .PDF False by default."""
    include_draft_watermark: NotRequired[bool]
    r"""Whether to include draft watermark when exporting to .PDF. False by default."""
    include_hyperlinks: NotRequired[bool]
    r"""Whether to include hyperlinks when exporting to .PDF. False by default."""
    include_leader_dots: NotRequired[bool]
    r"""Whether to include leader dots when exporting to .PDF. False by default."""
    include_track_changes: NotRequired[bool]
    r"""Whether to include track changes when exporting to .PDF. False by default."""
    only_export_print_areas: NotRequired[bool]
    r"""Whether to only export print areas when exporting to .PDF. False by default."""
    page_height: NotRequired[float]
    r"""The height of the exported .PDF, in inches. 11 by default."""
    page_orientation: NotRequired[FileExportByIDPageOrientation]
    r"""The orientation of the exported .PDF, such as \"portrait\" or \"landscape\". \"portrait\" by default.

    """
    page_scale: NotRequired[FileExportByIDPageScale]
    r"""The scale of the exported .PDF. \"actualSize\" by default."""
    page_width: NotRequired[float]
    r"""The width of the exported .PDF, in inches. 8.5 by default."""
    show_cell_fills: NotRequired[bool]
    r"""Whether to show cell fills when exporting to .PDF. False by default."""
    show_gridlines: NotRequired[bool]
    r"""Whether to show gridlines when exporting to .PDF. False by default."""
    use_cmyk_colorspace: NotRequired[bool]
    r"""Whether to use CMYK colorspace when exporting to .PDF. False by default."""


class FileExportByIDSchemasSpreadsheetExportPdfOptions(BaseModel):
    r"""Optional options to export the spreadsheet as a portable document file (.PDF). If no options are provided, all options default to False except:
    - `pageHeight`, which defaults to 11
    - `pageWidth`, which defaults to 8.5
    - `pageOrientation`, which defaults to \"portrait\"
    - `pageScale`, which defaults to \"actualSize\"
    """

    include_comments: Annotated[
        Optional[bool], pydantic.Field(alias="includeComments")
    ] = False
    r"""Whether to include comments when exporting to .PDF False by default."""

    include_draft_watermark: Annotated[
        Optional[bool], pydantic.Field(alias="includeDraftWatermark")
    ] = False
    r"""Whether to include draft watermark when exporting to .PDF. False by default."""

    include_hyperlinks: Annotated[
        Optional[bool], pydantic.Field(alias="includeHyperlinks")
    ] = False
    r"""Whether to include hyperlinks when exporting to .PDF. False by default."""

    include_leader_dots: Annotated[
        Optional[bool], pydantic.Field(alias="includeLeaderDots")
    ] = False
    r"""Whether to include leader dots when exporting to .PDF. False by default."""

    include_track_changes: Annotated[
        Optional[bool], pydantic.Field(alias="includeTrackChanges")
    ] = False
    r"""Whether to include track changes when exporting to .PDF. False by default."""

    only_export_print_areas: Annotated[
        Optional[bool], pydantic.Field(alias="onlyExportPrintAreas")
    ] = False
    r"""Whether to only export print areas when exporting to .PDF. False by default."""

    page_height: Annotated[Optional[float], pydantic.Field(alias="pageHeight")] = 11
    r"""The height of the exported .PDF, in inches. 11 by default."""

    page_orientation: Annotated[
        Optional[FileExportByIDPageOrientation], pydantic.Field(alias="pageOrientation")
    ] = FileExportByIDPageOrientation.PORTRAIT
    r"""The orientation of the exported .PDF, such as \"portrait\" or \"landscape\". \"portrait\" by default.

    """

    page_scale: Annotated[
        Optional[FileExportByIDPageScale], pydantic.Field(alias="pageScale")
    ] = FileExportByIDPageScale.ACTUAL_SIZE
    r"""The scale of the exported .PDF. \"actualSize\" by default."""

    page_width: Annotated[Optional[float], pydantic.Field(alias="pageWidth")] = 8.5
    r"""The width of the exported .PDF, in inches. 8.5 by default."""

    show_cell_fills: Annotated[
        Optional[bool], pydantic.Field(alias="showCellFills")
    ] = False
    r"""Whether to show cell fills when exporting to .PDF. False by default."""

    show_gridlines: Annotated[Optional[bool], pydantic.Field(alias="showGridlines")] = (
        False
    )
    r"""Whether to show gridlines when exporting to .PDF. False by default."""

    use_cmyk_colorspace: Annotated[
        Optional[bool], pydantic.Field(alias="useCmykColorspace")
    ] = False
    r"""Whether to use CMYK colorspace when exporting to .PDF. False by default."""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            [
                "includeComments",
                "includeDraftWatermark",
                "includeHyperlinks",
                "includeLeaderDots",
                "includeTrackChanges",
                "onlyExportPrintAreas",
                "pageHeight",
                "pageOrientation",
                "pageScale",
                "pageWidth",
                "showCellFills",
                "showGridlines",
                "useCmykColorspace",
            ]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class FileExportByIDExportPrecision(str, Enum):
    r"""How to export values in the sheet when exporting to .XLSX \"fullPrecision\" by default."""

    FULL_PRECISION = "fullPrecision"
    ROUNDED = "rounded"
    DISPLAYED = "displayed"


class FileExportByIDXlsxOptionsTypedDict(TypedDict):
    r"""Optional options to export the spreadsheet as a Microsoft Excel (.XLSX) file. If no options are provided, `exportAsFormulas` defaults to False, and `exportPrecision` defaults to `fullPrecision`."""

    export_as_formulas: NotRequired[bool]
    r"""Whether to export cells that contain formulas as the formula or its result when exporting to .XLSX. False by default."""
    export_precision: NotRequired[FileExportByIDExportPrecision]
    r"""How to export values in the sheet when exporting to .XLSX \"fullPrecision\" by default.

    """


class FileExportByIDXlsxOptions(BaseModel):
    r"""Optional options to export the spreadsheet as a Microsoft Excel (.XLSX) file. If no options are provided, `exportAsFormulas` defaults to False, and `exportPrecision` defaults to `fullPrecision`."""

    export_as_formulas: Annotated[
        Optional[bool], pydantic.Field(alias="exportAsFormulas")
    ] = False
    r"""Whether to export cells that contain formulas as the formula or its result when exporting to .XLSX. False by default."""

    export_precision: Annotated[
        Optional[FileExportByIDExportPrecision], pydantic.Field(alias="exportPrecision")
    ] = FileExportByIDExportPrecision.FULL_PRECISION
    r"""How to export values in the sheet when exporting to .XLSX \"fullPrecision\" by default.

    """

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["exportAsFormulas", "exportPrecision"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class FileExportByIDSpreadsheetExportTypedDict(TypedDict):
    r"""Details about a spreadsheet export."""

    format_: FileExportByIDSchemasSpreadsheetExportFormat
    r"""The file format to export the spreadsheet as."""
    csv_options: NotRequired[Nullable[FileExportByIDCsvOptionsTypedDict]]
    pdf_options: NotRequired[
        Nullable[FileExportByIDSchemasSpreadsheetExportPdfOptionsTypedDict]
    ]
    sheets: NotRequired[List[str]]
    r"""The IDs of the sheets within the spreadsheet to export. Omit to export the entire spreadsheet.

    Note: When exporting to .CSV, you can export only the entire spreadsheet or a single sheet. When exporting the entire spreadsheet, the resulting file is a .ZIP of .CSV files, with one .CSV file per sheet.
    """
    xlsx_options: NotRequired[Nullable[FileExportByIDXlsxOptionsTypedDict]]


class FileExportByIDSpreadsheetExport(BaseModel):
    r"""Details about a spreadsheet export."""

    format_: Annotated[
        FileExportByIDSchemasSpreadsheetExportFormat, pydantic.Field(alias="format")
    ]
    r"""The file format to export the spreadsheet as."""

    csv_options: Annotated[
        OptionalNullable[FileExportByIDCsvOptions], pydantic.Field(alias="csvOptions")
    ] = UNSET

    pdf_options: Annotated[
        OptionalNullable[FileExportByIDSchemasSpreadsheetExportPdfOptions],
        pydantic.Field(alias="pdfOptions"),
    ] = UNSET

    sheets: Optional[List[str]] = None
    r"""The IDs of the sheets within the spreadsheet to export. Omit to export the entire spreadsheet.

    Note: When exporting to .CSV, you can export only the entire spreadsheet or a single sheet. When exporting the entire spreadsheet, the resulting file is a .ZIP of .CSV files, with one .CSV file per sheet.
    """

    xlsx_options: Annotated[
        OptionalNullable[FileExportByIDXlsxOptions], pydantic.Field(alias="xlsxOptions")
    ] = UNSET

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["csvOptions", "pdfOptions", "sheets", "xlsxOptions"])
        nullable_fields = set(["csvOptions", "pdfOptions", "xlsxOptions"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            is_nullable_and_explicitly_set = (
                k in nullable_fields
                and (self.__pydantic_fields_set__.intersection({n}))  # pylint: disable=no-member
            )

            if val != UNSET_SENTINEL:
                if (
                    val is not None
                    or k not in optional_fields
                    or is_nullable_and_explicitly_set
                ):
                    m[k] = val

        return m


class FileExportByIDTypedDict(TypedDict):
    r"""Details about a file export including the target type."""

    document_export: NotRequired[Nullable[FileExportByIDDocumentExportTypedDict]]
    folder_export: NotRequired[Nullable[FolderExportTypedDict]]
    kind: NotRequired[FileExportByIDKind]
    r"""Kind (Type) of the file which will be exported."""
    presentation_export: NotRequired[
        Nullable[FileExportByIDPresentationExportTypedDict]
    ]
    spreadsheet_export: NotRequired[Nullable[FileExportByIDSpreadsheetExportTypedDict]]


class FileExportByID(BaseModel):
    r"""Details about a file export including the target type."""

    document_export: Annotated[
        OptionalNullable[FileExportByIDDocumentExport],
        pydantic.Field(alias="documentExport"),
    ] = UNSET

    folder_export: Annotated[
        OptionalNullable[FolderExport], pydantic.Field(alias="folderExport")
    ] = UNSET

    kind: Optional[FileExportByIDKind] = None
    r"""Kind (Type) of the file which will be exported."""

    presentation_export: Annotated[
        OptionalNullable[FileExportByIDPresentationExport],
        pydantic.Field(alias="presentationExport"),
    ] = UNSET

    spreadsheet_export: Annotated[
        OptionalNullable[FileExportByIDSpreadsheetExport],
        pydantic.Field(alias="spreadsheetExport"),
    ] = UNSET

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            [
                "documentExport",
                "folderExport",
                "kind",
                "presentationExport",
                "spreadsheetExport",
            ]
        )
        nullable_fields = set(
            [
                "documentExport",
                "folderExport",
                "presentationExport",
                "spreadsheetExport",
            ]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            is_nullable_and_explicitly_set = (
                k in nullable_fields
                and (self.__pydantic_fields_set__.intersection({n}))  # pylint: disable=no-member
            )

            if val != UNSET_SENTINEL:
                if (
                    val is not None
                    or k not in optional_fields
                    or is_nullable_and_explicitly_set
                ):
                    m[k] = val

        return m
