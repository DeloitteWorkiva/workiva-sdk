"""Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT."""

from __future__ import annotations
from .rangevalueslistresult import RangeValuesListResult, RangeValuesListResultTypedDict
from .valuestyle import ValueStyle
import pydantic
from pydantic import model_serializer
from typing import Awaitable, Callable, Optional, Union
from typing_extensions import Annotated, NotRequired, TypedDict
from workiva.types import BaseModel, Nullable, UNSET_SENTINEL
from workiva.utils import FieldMetadata, PathParamMetadata, QueryParamMetadata


class GetValuesByRangeRequestTypedDict(TypedDict):
    range: Nullable[str]
    r"""The range of values, in A1-style notation"""
    sheet_id: str
    r"""The unique identifier of the sheet"""
    spreadsheet_id: str
    r"""The unique identifier of the spreadsheet"""
    maxcellsperpage: NotRequired[int]
    r"""The maximum number of cells to retrieve. The default is 50000. The maximum allowed value is 50000."""
    next: NotRequired[str]
    r"""Pagination cursor for next set of results."""
    valuestyle: NotRequired[ValueStyle]
    r"""Whether to retrieve `raw` or `calculated` cell values. For example, if a cell's value is `=1+1`, `raw` retrieves the value `=1+1`, while `calculated` retrieves `2`."""


class GetValuesByRangeRequest(BaseModel):
    range: Annotated[
        Nullable[str],
        FieldMetadata(path=PathParamMetadata(style="simple", explode=False)),
    ]
    r"""The range of values, in A1-style notation"""

    sheet_id: Annotated[
        str,
        pydantic.Field(alias="sheetId"),
        FieldMetadata(path=PathParamMetadata(style="simple", explode=False)),
    ]
    r"""The unique identifier of the sheet"""

    spreadsheet_id: Annotated[
        str,
        pydantic.Field(alias="spreadsheetId"),
        FieldMetadata(path=PathParamMetadata(style="simple", explode=False)),
    ]
    r"""The unique identifier of the spreadsheet"""

    maxcellsperpage: Annotated[
        Optional[int],
        pydantic.Field(alias="$maxcellsperpage"),
        FieldMetadata(query=QueryParamMetadata(style="form", explode=True)),
    ] = 50000
    r"""The maximum number of cells to retrieve. The default is 50000. The maximum allowed value is 50000."""

    next: Annotated[
        Optional[str],
        pydantic.Field(alias="$next"),
        FieldMetadata(query=QueryParamMetadata(style="form", explode=True)),
    ] = None
    r"""Pagination cursor for next set of results."""

    valuestyle: Annotated[
        Optional[ValueStyle],
        pydantic.Field(alias="$valuestyle"),
        FieldMetadata(query=QueryParamMetadata(style="form", explode=True)),
    ] = ValueStyle.CALCULATED
    r"""Whether to retrieve `raw` or `calculated` cell values. For example, if a cell's value is `=1+1`, `raw` retrieves the value `=1+1`, while `calculated` retrieves `2`."""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["maxcellsperpage", "next", "valuestyle"])
        nullable_fields = set(["range"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            is_nullable_and_explicitly_set = (
                k in nullable_fields
                and (self.__pydantic_fields_set__.intersection({n}))  # pylint: disable=no-member
            )

            if val != UNSET_SENTINEL:
                if (
                    val is not None
                    or k not in optional_fields
                    or is_nullable_and_explicitly_set
                ):
                    m[k] = val

        return m


class GetValuesByRangeResponseTypedDict(TypedDict):
    result: RangeValuesListResultTypedDict


class GetValuesByRangeResponse(BaseModel):
    next: Union[
        Callable[[], Optional[GetValuesByRangeResponse]],
        Callable[[], Awaitable[Optional[GetValuesByRangeResponse]]],
    ]

    result: RangeValuesListResult
