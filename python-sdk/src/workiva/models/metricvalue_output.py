"""Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT."""

from __future__ import annotations
from .metricattachment import MetricAttachment, MetricAttachmentTypedDict
from .spreadsheetcellconnection import (
    SpreadsheetCellConnection,
    SpreadsheetCellConnectionTypedDict,
)
from .tablecellconnection import TableCellConnection, TableCellConnectionTypedDict
from .textregionconnection import TextRegionConnection, TextRegionConnectionTypedDict
from enum import Enum
import pydantic
from pydantic import model_serializer
from typing import Dict, List, Optional
from typing_extensions import Annotated, NotRequired, TypedDict
from workiva.types import BaseModel, Nullable, OptionalNullable, UNSET, UNSET_SENTINEL


class ConnectionType(str, Enum):
    r"""The type of connection to the value."""

    SPREADSHEET_CELL = "spreadsheetCell"
    TABLE_CELL = "tableCell"
    TEXT_REGION = "textRegion"


class DataSourceTypedDict(TypedDict):
    r"""Represents the source of the value, which can be a Workiva spreadsheet or table cell or a Workiva document text region.
    Only one of the connection types can be specified.

    """

    connection_type: NotRequired[ConnectionType]
    r"""The type of connection to the value."""
    spreadsheet_cell_connection: NotRequired[
        Nullable[SpreadsheetCellConnectionTypedDict]
    ]
    r"""Represents a connection to a value from a Workiva spreadsheet"""
    table_cell_connection: NotRequired[Nullable[TableCellConnectionTypedDict]]
    r"""Represents a connection to a value from a Workiva table cell"""
    text_region_connection: NotRequired[Nullable[TextRegionConnectionTypedDict]]
    r"""Represents a connection to a value from a Workiva document text region"""


class DataSource(BaseModel):
    r"""Represents the source of the value, which can be a Workiva spreadsheet or table cell or a Workiva document text region.
    Only one of the connection types can be specified.

    """

    connection_type: Annotated[
        Optional[ConnectionType], pydantic.Field(alias="connectionType")
    ] = ConnectionType.SPREADSHEET_CELL
    r"""The type of connection to the value."""

    spreadsheet_cell_connection: Annotated[
        OptionalNullable[SpreadsheetCellConnection],
        pydantic.Field(alias="spreadsheetCellConnection"),
    ] = UNSET
    r"""Represents a connection to a value from a Workiva spreadsheet"""

    table_cell_connection: Annotated[
        OptionalNullable[TableCellConnection],
        pydantic.Field(alias="tableCellConnection"),
    ] = UNSET
    r"""Represents a connection to a value from a Workiva table cell"""

    text_region_connection: Annotated[
        OptionalNullable[TextRegionConnection],
        pydantic.Field(alias="textRegionConnection"),
    ] = UNSET
    r"""Represents a connection to a value from a Workiva document text region"""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            [
                "connectionType",
                "spreadsheetCellConnection",
                "tableCellConnection",
                "textRegionConnection",
            ]
        )
        nullable_fields = set(
            ["spreadsheetCellConnection", "tableCellConnection", "textRegionConnection"]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            is_nullable_and_explicitly_set = (
                k in nullable_fields
                and (self.__pydantic_fields_set__.intersection({n}))  # pylint: disable=no-member
            )

            if val != UNSET_SENTINEL:
                if (
                    val is not None
                    or k not in optional_fields
                    or is_nullable_and_explicitly_set
                ):
                    m[k] = val

        return m


class ReportingPeriodTypedDict(TypedDict):
    r"""Defines the reporting period for a value."""

    end: int
    r"""The end month of the collection period, represented as an integer (e.g., Q1 = 3, Q2 = 6, Q3 = 9, Q4 = 12).
    Must be greater than or equal to `start`.

    """
    start: int
    r"""The start month of the collection period, represented as an integer (e.g., Q1 = 1, Q2 = 4, Q3 = 7, Q4 = 10).

    """
    year: int
    r"""The 4-digit year representing the report period for a value."""


class ReportingPeriod(BaseModel):
    r"""Defines the reporting period for a value."""

    end: int
    r"""The end month of the collection period, represented as an integer (e.g., Q1 = 3, Q2 = 6, Q3 = 9, Q4 = 12).
    Must be greater than or equal to `start`.

    """

    start: int
    r"""The start month of the collection period, represented as an integer (e.g., Q1 = 1, Q2 = 4, Q3 = 7, Q4 = 10).

    """

    year: int
    r"""The 4-digit year representing the report period for a value."""


class MetricValueStatus(str, Enum):
    r"""Represents the current status of a metric value.
    The status can only be set to `complete` if it's currently `notStarted`,
    and it can be reset to `notStarted` if it's `complete`.

    """

    NOT_STARTED = "notStarted"
    NOT_SENT = "notSent"
    IN_PROGRESS = "inProgress"
    SENT_FOR_APPROVAL = "sentForApproval"
    RETURNED = "returned"
    COMPLETE = "complete"
    ERROR = "error"


class MetricValueOutputTypedDict(TypedDict):
    r"""Represents a metric value, which is a data record belonging to a specific metric."""

    coordinates: NotRequired[Dict[str, str]]
    r"""A mapping of dimension ids to dimension value ids for the value.
    The maximum number of key-value dimension pairs is limited to 3.

    """
    data_source: NotRequired[DataSourceTypedDict]
    r"""Represents the source of the value, which can be a Workiva spreadsheet or table cell or a Workiva document text region.
    Only one of the connection types can be specified.

    """
    id: NotRequired[str]
    r"""The unique UUID identifier of the metric value."""
    notes: NotRequired[Nullable[str]]
    r"""Optional notes for the value, with a maximum length of 32,767 characters."""
    reporting_period: NotRequired[ReportingPeriodTypedDict]
    r"""Defines the reporting period for a value."""
    status: NotRequired[MetricValueStatus]
    r"""Represents the current status of a metric value.
    The status can only be set to `complete` if it's currently `notStarted`,
    and it can be reset to `notStarted` if it's `complete`.

    """
    supporting_attachments: NotRequired[Nullable[List[MetricAttachmentTypedDict]]]
    r"""A list of attachments associated with the metric value.

    """
    task: NotRequired[str]
    r"""The id of the task that corresponds to the metric value, which can be used to fetch the task/modify details via the tasking api"""
    value: NotRequired[str]
    r"""The string representation of the metric value. The value can be up to 32,767 characters."""


class MetricValueOutput(BaseModel):
    r"""Represents a metric value, which is a data record belonging to a specific metric."""

    coordinates: Optional[Dict[str, str]] = None
    r"""A mapping of dimension ids to dimension value ids for the value.
    The maximum number of key-value dimension pairs is limited to 3.

    """

    data_source: Annotated[Optional[DataSource], pydantic.Field(alias="dataSource")] = (
        None
    )
    r"""Represents the source of the value, which can be a Workiva spreadsheet or table cell or a Workiva document text region.
    Only one of the connection types can be specified.

    """

    id: Optional[str] = None
    r"""The unique UUID identifier of the metric value."""

    notes: OptionalNullable[str] = UNSET
    r"""Optional notes for the value, with a maximum length of 32,767 characters."""

    reporting_period: Annotated[
        Optional[ReportingPeriod], pydantic.Field(alias="reportingPeriod")
    ] = None
    r"""Defines the reporting period for a value."""

    status: Optional[MetricValueStatus] = MetricValueStatus.NOT_STARTED
    r"""Represents the current status of a metric value.
    The status can only be set to `complete` if it's currently `notStarted`,
    and it can be reset to `notStarted` if it's `complete`.

    """

    supporting_attachments: Annotated[
        OptionalNullable[List[MetricAttachment]],
        pydantic.Field(alias="supportingAttachments"),
    ] = UNSET
    r"""A list of attachments associated with the metric value.

    """

    task: Optional[str] = None
    r"""The id of the task that corresponds to the metric value, which can be used to fetch the task/modify details via the tasking api"""

    value: Optional[str] = None
    r"""The string representation of the metric value. The value can be up to 32,767 characters."""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            [
                "coordinates",
                "dataSource",
                "id",
                "notes",
                "reportingPeriod",
                "status",
                "supportingAttachments",
                "task",
                "value",
            ]
        )
        nullable_fields = set(["notes", "supportingAttachments"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            is_nullable_and_explicitly_set = (
                k in nullable_fields
                and (self.__pydantic_fields_set__.intersection({n}))  # pylint: disable=no-member
            )

            if val != UNSET_SENTINEL:
                if (
                    val is not None
                    or k not in optional_fields
                    or is_nullable_and_explicitly_set
                ):
                    m[k] = val

        return m


class MetricValueDataSourceTypedDict(TypedDict):
    r"""Represents the source of the value, which can be a Workiva spreadsheet or table cell or a Workiva document text region.
    Only one of the connection types can be specified.

    """

    connection_type: NotRequired[ConnectionType]
    r"""The type of connection to the value."""
    spreadsheet_cell_connection: NotRequired[
        Nullable[SpreadsheetCellConnectionTypedDict]
    ]
    r"""Represents a connection to a value from a Workiva spreadsheet"""
    table_cell_connection: NotRequired[Nullable[TableCellConnectionTypedDict]]
    r"""Represents a connection to a value from a Workiva table cell"""


class MetricValueDataSource(BaseModel):
    r"""Represents the source of the value, which can be a Workiva spreadsheet or table cell or a Workiva document text region.
    Only one of the connection types can be specified.

    """

    connection_type: Annotated[
        Optional[ConnectionType], pydantic.Field(alias="connectionType")
    ] = ConnectionType.SPREADSHEET_CELL
    r"""The type of connection to the value."""

    spreadsheet_cell_connection: Annotated[
        OptionalNullable[SpreadsheetCellConnection],
        pydantic.Field(alias="spreadsheetCellConnection"),
    ] = UNSET
    r"""Represents a connection to a value from a Workiva spreadsheet"""

    table_cell_connection: Annotated[
        OptionalNullable[TableCellConnection],
        pydantic.Field(alias="tableCellConnection"),
    ] = UNSET
    r"""Represents a connection to a value from a Workiva table cell"""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            ["connectionType", "spreadsheetCellConnection", "tableCellConnection"]
        )
        nullable_fields = set(["spreadsheetCellConnection", "tableCellConnection"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            is_nullable_and_explicitly_set = (
                k in nullable_fields
                and (self.__pydantic_fields_set__.intersection({n}))  # pylint: disable=no-member
            )

            if val != UNSET_SENTINEL:
                if (
                    val is not None
                    or k not in optional_fields
                    or is_nullable_and_explicitly_set
                ):
                    m[k] = val

        return m


class MetricValueTypedDict(TypedDict):
    r"""Represents a metric value, which is a data record belonging to a specific metric."""

    coordinates: NotRequired[Dict[str, str]]
    r"""A mapping of dimension ids to dimension value ids for the value.
    The maximum number of key-value dimension pairs is limited to 3.

    """
    data_source: NotRequired[MetricValueDataSourceTypedDict]
    r"""Represents the source of the value, which can be a Workiva spreadsheet or table cell or a Workiva document text region.
    Only one of the connection types can be specified.

    """
    fields_to_clear: NotRequired[List[str]]
    r"""List of fields to clear."""
    id: NotRequired[str]
    r"""The unique UUID identifier of the metric value."""
    notes: NotRequired[Nullable[str]]
    r"""Optional notes for the value, with a maximum length of 32,767 characters."""
    reporting_period: NotRequired[ReportingPeriodTypedDict]
    r"""Defines the reporting period for a value."""
    status: NotRequired[MetricValueStatus]
    r"""Represents the current status of a metric value.
    The status can only be set to `complete` if it's currently `notStarted`,
    and it can be reset to `notStarted` if it's `complete`.

    """
    task: NotRequired[str]
    r"""The id of the task that corresponds to the metric value, which can be used to fetch the task/modify details via the tasking api"""
    value: NotRequired[str]
    r"""The string representation of the metric value. The value can be up to 32,767 characters."""


class MetricValue(BaseModel):
    r"""Represents a metric value, which is a data record belonging to a specific metric."""

    coordinates: Optional[Dict[str, str]] = None
    r"""A mapping of dimension ids to dimension value ids for the value.
    The maximum number of key-value dimension pairs is limited to 3.

    """

    data_source: Annotated[
        Optional[MetricValueDataSource], pydantic.Field(alias="dataSource")
    ] = None
    r"""Represents the source of the value, which can be a Workiva spreadsheet or table cell or a Workiva document text region.
    Only one of the connection types can be specified.

    """

    fields_to_clear: Annotated[
        Optional[List[str]], pydantic.Field(alias="fieldsToClear")
    ] = None
    r"""List of fields to clear."""

    id: Optional[str] = None
    r"""The unique UUID identifier of the metric value."""

    notes: OptionalNullable[str] = UNSET
    r"""Optional notes for the value, with a maximum length of 32,767 characters."""

    reporting_period: Annotated[
        Optional[ReportingPeriod], pydantic.Field(alias="reportingPeriod")
    ] = None
    r"""Defines the reporting period for a value."""

    status: Optional[MetricValueStatus] = MetricValueStatus.NOT_STARTED
    r"""Represents the current status of a metric value.
    The status can only be set to `complete` if it's currently `notStarted`,
    and it can be reset to `notStarted` if it's `complete`.

    """

    task: Optional[str] = None
    r"""The id of the task that corresponds to the metric value, which can be used to fetch the task/modify details via the tasking api"""

    value: Optional[str] = None
    r"""The string representation of the metric value. The value can be up to 32,767 characters."""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            [
                "coordinates",
                "dataSource",
                "fieldsToClear",
                "id",
                "notes",
                "reportingPeriod",
                "status",
                "task",
                "value",
            ]
        )
        nullable_fields = set(["notes"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            is_nullable_and_explicitly_set = (
                k in nullable_fields
                and (self.__pydantic_fields_set__.intersection({n}))  # pylint: disable=no-member
            )

            if val != UNSET_SENTINEL:
                if (
                    val is not None
                    or k not in optional_fields
                    or is_nullable_and_explicitly_set
                ):
                    m[k] = val

        return m
