"""Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT."""

from .basesdk import BaseSDK
import httpx
from jsonpath import JSONPath
from typing import Any, Awaitable, Dict, List, Mapping, Optional, Union, cast
from workiva import errors, models, utils
from workiva._hooks import HookContext
from workiva.types import BaseModel, OptionalNullable, UNSET
from workiva.utils.unmarshal_json_response import unmarshal_json_response


class Wdata(BaseSDK):
    def cancel_query(
        self,
        *,
        query_result_id: str,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.BaseResponseQueryResultDto:
        r"""Cancel a running query

        Cancels a running query based on the provided result ID, and returns a cancelled
        result unless the query's already in a COMPLETED state.

        :param query_result_id: The unique identifier of the query result
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = models.WDATA_CANCEL_QUERY_OP_SERVERS[0]

        request = models.WdataCancelQueryRequest(
            query_result_id=query_result_id,
        )

        req = self._build_request(
            method="DELETE",
            path="/api/v1/queryresult/{queryResultId}",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            allow_empty_value=None,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="wdata_cancelQuery",
                oauth2_scopes=[],
                security_source=self.sdk_configuration.security,
            ),
            request=req,
            error_status_codes=[
                "400",
                "401",
                "403",
                "404",
                "409",
                "423",
                "429",
                "4XX",
                "500",
                "5XX",
            ],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(models.BaseResponseQueryResultDto, http_res)
        if utils.match_response(http_res, "400", "application/json"):
            response_data = unmarshal_json_response(errors.MultiErrorData, http_res)
            raise errors.MultiError(response_data, http_res)
        if utils.match_response(
            http_res, ["401", "403", "404", "409", "429"], "application/json"
        ):
            response_data = unmarshal_json_response(errors.SingleErrorData, http_res)
            raise errors.SingleError(response_data, http_res)
        if utils.match_response(http_res, "500", "application/json"):
            response_data = unmarshal_json_response(errors.SingleErrorData, http_res)
            raise errors.SingleError(response_data, http_res)
        if utils.match_response(http_res, ["423", "4XX"], "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)

        raise errors.SDKError("Unexpected response received", http_res)

    async def cancel_query_async(
        self,
        *,
        query_result_id: str,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.BaseResponseQueryResultDto:
        r"""Cancel a running query

        Cancels a running query based on the provided result ID, and returns a cancelled
        result unless the query's already in a COMPLETED state.

        :param query_result_id: The unique identifier of the query result
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = models.WDATA_CANCEL_QUERY_OP_SERVERS[0]

        request = models.WdataCancelQueryRequest(
            query_result_id=query_result_id,
        )

        req = self._build_request_async(
            method="DELETE",
            path="/api/v1/queryresult/{queryResultId}",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            allow_empty_value=None,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="wdata_cancelQuery",
                oauth2_scopes=[],
                security_source=self.sdk_configuration.security,
            ),
            request=req,
            error_status_codes=[
                "400",
                "401",
                "403",
                "404",
                "409",
                "423",
                "429",
                "4XX",
                "500",
                "5XX",
            ],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(models.BaseResponseQueryResultDto, http_res)
        if utils.match_response(http_res, "400", "application/json"):
            response_data = unmarshal_json_response(errors.MultiErrorData, http_res)
            raise errors.MultiError(response_data, http_res)
        if utils.match_response(
            http_res, ["401", "403", "404", "409", "429"], "application/json"
        ):
            response_data = unmarshal_json_response(errors.SingleErrorData, http_res)
            raise errors.SingleError(response_data, http_res)
        if utils.match_response(http_res, "500", "application/json"):
            response_data = unmarshal_json_response(errors.SingleErrorData, http_res)
            raise errors.SingleError(response_data, http_res)
        if utils.match_response(http_res, ["423", "4XX"], "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)

        raise errors.SDKError("Unexpected response received", http_res)

    def create_folder(
        self,
        *,
        request: Union[models.FolderDtoInput, models.FolderDtoInputTypedDict],
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.BaseResponseFolderDto:
        r"""Create a new folder

        Creates a folder using the provided information and returns the folder meta.

        :param request: The request object to send.
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = models.WDATA_CREATE_FOLDER_OP_SERVERS[0]

        if not isinstance(request, BaseModel):
            request = utils.unmarshal(request, models.FolderDtoInput)
        request = cast(models.FolderDtoInput, request)

        req = self._build_request(
            method="POST",
            path="/api/v1/folder",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request, False, False, "json", models.FolderDtoInput
            ),
            allow_empty_value=None,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="wdata_createFolder",
                oauth2_scopes=[],
                security_source=self.sdk_configuration.security,
            ),
            request=req,
            error_status_codes=[
                "400",
                "401",
                "403",
                "404",
                "409",
                "423",
                "429",
                "4XX",
                "500",
                "5XX",
            ],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "201", "application/json"):
            return unmarshal_json_response(models.BaseResponseFolderDto, http_res)
        if utils.match_response(http_res, "400", "application/json"):
            response_data = unmarshal_json_response(errors.MultiErrorData, http_res)
            raise errors.MultiError(response_data, http_res)
        if utils.match_response(
            http_res, ["401", "403", "404", "409", "429"], "application/json"
        ):
            response_data = unmarshal_json_response(errors.SingleErrorData, http_res)
            raise errors.SingleError(response_data, http_res)
        if utils.match_response(http_res, "500", "application/json"):
            response_data = unmarshal_json_response(errors.SingleErrorData, http_res)
            raise errors.SingleError(response_data, http_res)
        if utils.match_response(http_res, ["423", "4XX"], "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)

        raise errors.SDKError("Unexpected response received", http_res)

    async def create_folder_async(
        self,
        *,
        request: Union[models.FolderDtoInput, models.FolderDtoInputTypedDict],
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.BaseResponseFolderDto:
        r"""Create a new folder

        Creates a folder using the provided information and returns the folder meta.

        :param request: The request object to send.
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = models.WDATA_CREATE_FOLDER_OP_SERVERS[0]

        if not isinstance(request, BaseModel):
            request = utils.unmarshal(request, models.FolderDtoInput)
        request = cast(models.FolderDtoInput, request)

        req = self._build_request_async(
            method="POST",
            path="/api/v1/folder",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request, False, False, "json", models.FolderDtoInput
            ),
            allow_empty_value=None,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="wdata_createFolder",
                oauth2_scopes=[],
                security_source=self.sdk_configuration.security,
            ),
            request=req,
            error_status_codes=[
                "400",
                "401",
                "403",
                "404",
                "409",
                "423",
                "429",
                "4XX",
                "500",
                "5XX",
            ],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "201", "application/json"):
            return unmarshal_json_response(models.BaseResponseFolderDto, http_res)
        if utils.match_response(http_res, "400", "application/json"):
            response_data = unmarshal_json_response(errors.MultiErrorData, http_res)
            raise errors.MultiError(response_data, http_res)
        if utils.match_response(
            http_res, ["401", "403", "404", "409", "429"], "application/json"
        ):
            response_data = unmarshal_json_response(errors.SingleErrorData, http_res)
            raise errors.SingleError(response_data, http_res)
        if utils.match_response(http_res, "500", "application/json"):
            response_data = unmarshal_json_response(errors.SingleErrorData, http_res)
            raise errors.SingleError(response_data, http_res)
        if utils.match_response(http_res, ["423", "4XX"], "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)

        raise errors.SDKError("Unexpected response received", http_res)

    def create_parameter(
        self,
        *,
        request: Union[
            models.GlobalParameterDtoInput, models.GlobalParameterDtoInputTypedDict
        ],
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.BaseResponseGlobalParameterDto:
        r"""Create parameter

        Creates a parameter.  If there is a parameter with the same ID, a 409 is returned.

        :param request: The request object to send.
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = models.WDATA_CREATE_PARAMETER_OP_SERVERS[0]

        if not isinstance(request, BaseModel):
            request = utils.unmarshal(request, models.GlobalParameterDtoInput)
        request = cast(models.GlobalParameterDtoInput, request)

        req = self._build_request(
            method="POST",
            path="/api/v1/parameter",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request, False, False, "json", models.GlobalParameterDtoInput
            ),
            allow_empty_value=None,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="wdata_createParameter",
                oauth2_scopes=[],
                security_source=self.sdk_configuration.security,
            ),
            request=req,
            error_status_codes=[
                "400",
                "401",
                "403",
                "404",
                "409",
                "423",
                "429",
                "4XX",
                "500",
                "5XX",
            ],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "201", "application/json"):
            return unmarshal_json_response(
                models.BaseResponseGlobalParameterDto, http_res
            )
        if utils.match_response(http_res, "400", "application/json"):
            response_data = unmarshal_json_response(errors.MultiErrorData, http_res)
            raise errors.MultiError(response_data, http_res)
        if utils.match_response(
            http_res, ["401", "403", "404", "409", "429"], "application/json"
        ):
            response_data = unmarshal_json_response(errors.SingleErrorData, http_res)
            raise errors.SingleError(response_data, http_res)
        if utils.match_response(http_res, "500", "application/json"):
            response_data = unmarshal_json_response(errors.SingleErrorData, http_res)
            raise errors.SingleError(response_data, http_res)
        if utils.match_response(http_res, ["423", "4XX"], "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)

        raise errors.SDKError("Unexpected response received", http_res)

    async def create_parameter_async(
        self,
        *,
        request: Union[
            models.GlobalParameterDtoInput, models.GlobalParameterDtoInputTypedDict
        ],
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.BaseResponseGlobalParameterDto:
        r"""Create parameter

        Creates a parameter.  If there is a parameter with the same ID, a 409 is returned.

        :param request: The request object to send.
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = models.WDATA_CREATE_PARAMETER_OP_SERVERS[0]

        if not isinstance(request, BaseModel):
            request = utils.unmarshal(request, models.GlobalParameterDtoInput)
        request = cast(models.GlobalParameterDtoInput, request)

        req = self._build_request_async(
            method="POST",
            path="/api/v1/parameter",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request, False, False, "json", models.GlobalParameterDtoInput
            ),
            allow_empty_value=None,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="wdata_createParameter",
                oauth2_scopes=[],
                security_source=self.sdk_configuration.security,
            ),
            request=req,
            error_status_codes=[
                "400",
                "401",
                "403",
                "404",
                "409",
                "423",
                "429",
                "4XX",
                "500",
                "5XX",
            ],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "201", "application/json"):
            return unmarshal_json_response(
                models.BaseResponseGlobalParameterDto, http_res
            )
        if utils.match_response(http_res, "400", "application/json"):
            response_data = unmarshal_json_response(errors.MultiErrorData, http_res)
            raise errors.MultiError(response_data, http_res)
        if utils.match_response(
            http_res, ["401", "403", "404", "409", "429"], "application/json"
        ):
            response_data = unmarshal_json_response(errors.SingleErrorData, http_res)
            raise errors.SingleError(response_data, http_res)
        if utils.match_response(http_res, "500", "application/json"):
            response_data = unmarshal_json_response(errors.SingleErrorData, http_res)
            raise errors.SingleError(response_data, http_res)
        if utils.match_response(http_res, ["423", "4XX"], "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)

        raise errors.SDKError("Unexpected response received", http_res)

    def create_pivot_view(
        self,
        *,
        request: Union[models.PivotViewDtoInput, models.PivotViewDtoInputTypedDict],
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.BaseResponsePivotViewDto:
        r"""Create a new pivot view

        Creates a view from the provided information. Currently, persists the provided
        `additionalMetadata` field, which can store an arbitrary JSON definition of a pivot
        table view. This pivot table must be associated with a query, and can optionally be
        associated with a query result. When a query is deleted, its associated views are
        also deleted.

        :param request: The request object to send.
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = models.WDATA_CREATE_PIVOT_VIEW_OP_SERVERS[0]

        if not isinstance(request, BaseModel):
            request = utils.unmarshal(request, models.PivotViewDtoInput)
        request = cast(models.PivotViewDtoInput, request)

        req = self._build_request(
            method="POST",
            path="/api/v1/pivotview",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request, False, False, "json", models.PivotViewDtoInput
            ),
            allow_empty_value=None,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="wdata_createPivotView",
                oauth2_scopes=[],
                security_source=self.sdk_configuration.security,
            ),
            request=req,
            error_status_codes=[
                "400",
                "401",
                "403",
                "404",
                "409",
                "423",
                "429",
                "4XX",
                "500",
                "5XX",
            ],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "201", "application/json"):
            return unmarshal_json_response(models.BaseResponsePivotViewDto, http_res)
        if utils.match_response(http_res, "400", "application/json"):
            response_data = unmarshal_json_response(errors.MultiErrorData, http_res)
            raise errors.MultiError(response_data, http_res)
        if utils.match_response(
            http_res, ["401", "403", "404", "409", "429"], "application/json"
        ):
            response_data = unmarshal_json_response(errors.SingleErrorData, http_res)
            raise errors.SingleError(response_data, http_res)
        if utils.match_response(http_res, "500", "application/json"):
            response_data = unmarshal_json_response(errors.SingleErrorData, http_res)
            raise errors.SingleError(response_data, http_res)
        if utils.match_response(http_res, ["423", "4XX"], "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)

        raise errors.SDKError("Unexpected response received", http_res)

    async def create_pivot_view_async(
        self,
        *,
        request: Union[models.PivotViewDtoInput, models.PivotViewDtoInputTypedDict],
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.BaseResponsePivotViewDto:
        r"""Create a new pivot view

        Creates a view from the provided information. Currently, persists the provided
        `additionalMetadata` field, which can store an arbitrary JSON definition of a pivot
        table view. This pivot table must be associated with a query, and can optionally be
        associated with a query result. When a query is deleted, its associated views are
        also deleted.

        :param request: The request object to send.
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = models.WDATA_CREATE_PIVOT_VIEW_OP_SERVERS[0]

        if not isinstance(request, BaseModel):
            request = utils.unmarshal(request, models.PivotViewDtoInput)
        request = cast(models.PivotViewDtoInput, request)

        req = self._build_request_async(
            method="POST",
            path="/api/v1/pivotview",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request, False, False, "json", models.PivotViewDtoInput
            ),
            allow_empty_value=None,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="wdata_createPivotView",
                oauth2_scopes=[],
                security_source=self.sdk_configuration.security,
            ),
            request=req,
            error_status_codes=[
                "400",
                "401",
                "403",
                "404",
                "409",
                "423",
                "429",
                "4XX",
                "500",
                "5XX",
            ],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "201", "application/json"):
            return unmarshal_json_response(models.BaseResponsePivotViewDto, http_res)
        if utils.match_response(http_res, "400", "application/json"):
            response_data = unmarshal_json_response(errors.MultiErrorData, http_res)
            raise errors.MultiError(response_data, http_res)
        if utils.match_response(
            http_res, ["401", "403", "404", "409", "429"], "application/json"
        ):
            response_data = unmarshal_json_response(errors.SingleErrorData, http_res)
            raise errors.SingleError(response_data, http_res)
        if utils.match_response(http_res, "500", "application/json"):
            response_data = unmarshal_json_response(errors.SingleErrorData, http_res)
            raise errors.SingleError(response_data, http_res)
        if utils.match_response(http_res, ["423", "4XX"], "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)

        raise errors.SDKError("Unexpected response received", http_res)

    def create_query(
        self,
        *,
        request: Union[models.QueryDtoInput, models.QueryDtoInputTypedDict],
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.BaseResponseQueryDto:
        r"""Create a new query

        Creates a query object and validates full permissions to ensure the requestor has
        access to all data sources being queried. This endpoint _doesn't_ execute the query;
        to execute, call the POST /queryresult method.

        :param request: The request object to send.
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = models.WDATA_CREATE_QUERY_OP_SERVERS[0]

        if not isinstance(request, BaseModel):
            request = utils.unmarshal(request, models.QueryDtoInput)
        request = cast(models.QueryDtoInput, request)

        req = self._build_request(
            method="POST",
            path="/api/v1/query",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request, False, False, "json", models.QueryDtoInput
            ),
            allow_empty_value=None,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="wdata_createQuery",
                oauth2_scopes=[],
                security_source=self.sdk_configuration.security,
            ),
            request=req,
            error_status_codes=[
                "400",
                "401",
                "403",
                "404",
                "409",
                "423",
                "429",
                "4XX",
                "500",
                "5XX",
            ],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "201", "application/json"):
            return unmarshal_json_response(models.BaseResponseQueryDto, http_res)
        if utils.match_response(http_res, "400", "application/json"):
            response_data = unmarshal_json_response(errors.MultiErrorData, http_res)
            raise errors.MultiError(response_data, http_res)
        if utils.match_response(
            http_res, ["401", "403", "404", "409", "429"], "application/json"
        ):
            response_data = unmarshal_json_response(errors.SingleErrorData, http_res)
            raise errors.SingleError(response_data, http_res)
        if utils.match_response(http_res, "500", "application/json"):
            response_data = unmarshal_json_response(errors.SingleErrorData, http_res)
            raise errors.SingleError(response_data, http_res)
        if utils.match_response(http_res, ["423", "4XX"], "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)

        raise errors.SDKError("Unexpected response received", http_res)

    async def create_query_async(
        self,
        *,
        request: Union[models.QueryDtoInput, models.QueryDtoInputTypedDict],
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.BaseResponseQueryDto:
        r"""Create a new query

        Creates a query object and validates full permissions to ensure the requestor has
        access to all data sources being queried. This endpoint _doesn't_ execute the query;
        to execute, call the POST /queryresult method.

        :param request: The request object to send.
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = models.WDATA_CREATE_QUERY_OP_SERVERS[0]

        if not isinstance(request, BaseModel):
            request = utils.unmarshal(request, models.QueryDtoInput)
        request = cast(models.QueryDtoInput, request)

        req = self._build_request_async(
            method="POST",
            path="/api/v1/query",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request, False, False, "json", models.QueryDtoInput
            ),
            allow_empty_value=None,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="wdata_createQuery",
                oauth2_scopes=[],
                security_source=self.sdk_configuration.security,
            ),
            request=req,
            error_status_codes=[
                "400",
                "401",
                "403",
                "404",
                "409",
                "423",
                "429",
                "4XX",
                "500",
                "5XX",
            ],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "201", "application/json"):
            return unmarshal_json_response(models.BaseResponseQueryDto, http_res)
        if utils.match_response(http_res, "400", "application/json"):
            response_data = unmarshal_json_response(errors.MultiErrorData, http_res)
            raise errors.MultiError(response_data, http_res)
        if utils.match_response(
            http_res, ["401", "403", "404", "409", "429"], "application/json"
        ):
            response_data = unmarshal_json_response(errors.SingleErrorData, http_res)
            raise errors.SingleError(response_data, http_res)
        if utils.match_response(http_res, "500", "application/json"):
            response_data = unmarshal_json_response(errors.SingleErrorData, http_res)
            raise errors.SingleError(response_data, http_res)
        if utils.match_response(http_res, ["423", "4XX"], "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)

        raise errors.SDKError("Unexpected response received", http_res)

    def create_select_list(
        self,
        *,
        request: Union[models.SelectListDtoInput, models.SelectListDtoInputTypedDict],
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.BaseResponseSelectListDto:
        r"""Create a new select list

        Creates a select list using the provided information and returns the select list meta.

        :param request: The request object to send.
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = models.WDATA_CREATE_SELECT_LIST_OP_SERVERS[0]

        if not isinstance(request, BaseModel):
            request = utils.unmarshal(request, models.SelectListDtoInput)
        request = cast(models.SelectListDtoInput, request)

        req = self._build_request(
            method="POST",
            path="/api/v1/selectlist",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request, False, False, "json", models.SelectListDtoInput
            ),
            allow_empty_value=None,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="wdata_createSelectList",
                oauth2_scopes=[],
                security_source=self.sdk_configuration.security,
            ),
            request=req,
            error_status_codes=[
                "400",
                "401",
                "403",
                "404",
                "409",
                "423",
                "429",
                "4XX",
                "500",
                "5XX",
            ],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "201", "application/json"):
            return unmarshal_json_response(models.BaseResponseSelectListDto, http_res)
        if utils.match_response(http_res, "400", "application/json"):
            response_data = unmarshal_json_response(errors.MultiErrorData, http_res)
            raise errors.MultiError(response_data, http_res)
        if utils.match_response(
            http_res, ["401", "403", "404", "409", "429"], "application/json"
        ):
            response_data = unmarshal_json_response(errors.SingleErrorData, http_res)
            raise errors.SingleError(response_data, http_res)
        if utils.match_response(http_res, "500", "application/json"):
            response_data = unmarshal_json_response(errors.SingleErrorData, http_res)
            raise errors.SingleError(response_data, http_res)
        if utils.match_response(http_res, ["423", "4XX"], "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)

        raise errors.SDKError("Unexpected response received", http_res)

    async def create_select_list_async(
        self,
        *,
        request: Union[models.SelectListDtoInput, models.SelectListDtoInputTypedDict],
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.BaseResponseSelectListDto:
        r"""Create a new select list

        Creates a select list using the provided information and returns the select list meta.

        :param request: The request object to send.
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = models.WDATA_CREATE_SELECT_LIST_OP_SERVERS[0]

        if not isinstance(request, BaseModel):
            request = utils.unmarshal(request, models.SelectListDtoInput)
        request = cast(models.SelectListDtoInput, request)

        req = self._build_request_async(
            method="POST",
            path="/api/v1/selectlist",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request, False, False, "json", models.SelectListDtoInput
            ),
            allow_empty_value=None,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="wdata_createSelectList",
                oauth2_scopes=[],
                security_source=self.sdk_configuration.security,
            ),
            request=req,
            error_status_codes=[
                "400",
                "401",
                "403",
                "404",
                "409",
                "423",
                "429",
                "4XX",
                "500",
                "5XX",
            ],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "201", "application/json"):
            return unmarshal_json_response(models.BaseResponseSelectListDto, http_res)
        if utils.match_response(http_res, "400", "application/json"):
            response_data = unmarshal_json_response(errors.MultiErrorData, http_res)
            raise errors.MultiError(response_data, http_res)
        if utils.match_response(
            http_res, ["401", "403", "404", "409", "429"], "application/json"
        ):
            response_data = unmarshal_json_response(errors.SingleErrorData, http_res)
            raise errors.SingleError(response_data, http_res)
        if utils.match_response(http_res, "500", "application/json"):
            response_data = unmarshal_json_response(errors.SingleErrorData, http_res)
            raise errors.SingleError(response_data, http_res)
        if utils.match_response(http_res, ["423", "4XX"], "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)

        raise errors.SDKError("Unexpected response received", http_res)

    def create_shared_table(
        self,
        *,
        request: Union[models.SharedTableDtoInput, models.SharedTableDtoInputTypedDict],
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.BaseResponseSharedTableDto:
        r"""Create a new shared table

        Creates a shared table instance between the workspace of the request and the workspace provided in the body.

        :param request: The request object to send.
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = models.WDATA_CREATE_SHARED_TABLE_OP_SERVERS[0]

        if not isinstance(request, BaseModel):
            request = utils.unmarshal(request, models.SharedTableDtoInput)
        request = cast(models.SharedTableDtoInput, request)

        req = self._build_request(
            method="POST",
            path="/api/v1/sharedtable",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request, False, False, "json", models.SharedTableDtoInput
            ),
            allow_empty_value=None,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="wdata_createSharedTable",
                oauth2_scopes=[],
                security_source=self.sdk_configuration.security,
            ),
            request=req,
            error_status_codes=[
                "400",
                "401",
                "403",
                "404",
                "409",
                "423",
                "429",
                "4XX",
                "500",
                "5XX",
            ],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "201", "application/json"):
            return unmarshal_json_response(models.BaseResponseSharedTableDto, http_res)
        if utils.match_response(http_res, "400", "application/json"):
            response_data = unmarshal_json_response(errors.MultiErrorData, http_res)
            raise errors.MultiError(response_data, http_res)
        if utils.match_response(
            http_res, ["401", "403", "404", "409", "429"], "application/json"
        ):
            response_data = unmarshal_json_response(errors.SingleErrorData, http_res)
            raise errors.SingleError(response_data, http_res)
        if utils.match_response(http_res, "500", "application/json"):
            response_data = unmarshal_json_response(errors.SingleErrorData, http_res)
            raise errors.SingleError(response_data, http_res)
        if utils.match_response(http_res, ["423", "4XX"], "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)

        raise errors.SDKError("Unexpected response received", http_res)

    async def create_shared_table_async(
        self,
        *,
        request: Union[models.SharedTableDtoInput, models.SharedTableDtoInputTypedDict],
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.BaseResponseSharedTableDto:
        r"""Create a new shared table

        Creates a shared table instance between the workspace of the request and the workspace provided in the body.

        :param request: The request object to send.
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = models.WDATA_CREATE_SHARED_TABLE_OP_SERVERS[0]

        if not isinstance(request, BaseModel):
            request = utils.unmarshal(request, models.SharedTableDtoInput)
        request = cast(models.SharedTableDtoInput, request)

        req = self._build_request_async(
            method="POST",
            path="/api/v1/sharedtable",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request, False, False, "json", models.SharedTableDtoInput
            ),
            allow_empty_value=None,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="wdata_createSharedTable",
                oauth2_scopes=[],
                security_source=self.sdk_configuration.security,
            ),
            request=req,
            error_status_codes=[
                "400",
                "401",
                "403",
                "404",
                "409",
                "423",
                "429",
                "4XX",
                "500",
                "5XX",
            ],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "201", "application/json"):
            return unmarshal_json_response(models.BaseResponseSharedTableDto, http_res)
        if utils.match_response(http_res, "400", "application/json"):
            response_data = unmarshal_json_response(errors.MultiErrorData, http_res)
            raise errors.MultiError(response_data, http_res)
        if utils.match_response(
            http_res, ["401", "403", "404", "409", "429"], "application/json"
        ):
            response_data = unmarshal_json_response(errors.SingleErrorData, http_res)
            raise errors.SingleError(response_data, http_res)
        if utils.match_response(http_res, "500", "application/json"):
            response_data = unmarshal_json_response(errors.SingleErrorData, http_res)
            raise errors.SingleError(response_data, http_res)
        if utils.match_response(http_res, ["423", "4XX"], "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)

        raise errors.SDKError("Unexpected response received", http_res)

    def create_table(
        self,
        *,
        request: Union[models.TableDtoInput, models.TableDtoInputTypedDict],
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.BaseResponseTableDto:
        r"""Create a new table

        Creates a table in the database with the specified schema. For type, specify either a dimension or data table. In the interface, data tables appear as fact tables.

        :param request: The request object to send.
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = models.WDATA_CREATE_TABLE_OP_SERVERS[0]

        if not isinstance(request, BaseModel):
            request = utils.unmarshal(request, models.TableDtoInput)
        request = cast(models.TableDtoInput, request)

        req = self._build_request(
            method="POST",
            path="/api/v1/table",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request, False, False, "json", models.TableDtoInput
            ),
            allow_empty_value=None,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="wdata_createTable",
                oauth2_scopes=[],
                security_source=self.sdk_configuration.security,
            ),
            request=req,
            error_status_codes=[
                "400",
                "401",
                "403",
                "404",
                "409",
                "423",
                "429",
                "4XX",
                "500",
                "5XX",
            ],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "201", "application/json"):
            return unmarshal_json_response(models.BaseResponseTableDto, http_res)
        if utils.match_response(http_res, "400", "application/json"):
            response_data = unmarshal_json_response(errors.MultiErrorData, http_res)
            raise errors.MultiError(response_data, http_res)
        if utils.match_response(
            http_res, ["401", "403", "404", "409", "429"], "application/json"
        ):
            response_data = unmarshal_json_response(errors.SingleErrorData, http_res)
            raise errors.SingleError(response_data, http_res)
        if utils.match_response(http_res, "500", "application/json"):
            response_data = unmarshal_json_response(errors.SingleErrorData, http_res)
            raise errors.SingleError(response_data, http_res)
        if utils.match_response(http_res, ["423", "4XX"], "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)

        raise errors.SDKError("Unexpected response received", http_res)

    async def create_table_async(
        self,
        *,
        request: Union[models.TableDtoInput, models.TableDtoInputTypedDict],
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.BaseResponseTableDto:
        r"""Create a new table

        Creates a table in the database with the specified schema. For type, specify either a dimension or data table. In the interface, data tables appear as fact tables.

        :param request: The request object to send.
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = models.WDATA_CREATE_TABLE_OP_SERVERS[0]

        if not isinstance(request, BaseModel):
            request = utils.unmarshal(request, models.TableDtoInput)
        request = cast(models.TableDtoInput, request)

        req = self._build_request_async(
            method="POST",
            path="/api/v1/table",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request, False, False, "json", models.TableDtoInput
            ),
            allow_empty_value=None,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="wdata_createTable",
                oauth2_scopes=[],
                security_source=self.sdk_configuration.security,
            ),
            request=req,
            error_status_codes=[
                "400",
                "401",
                "403",
                "404",
                "409",
                "423",
                "429",
                "4XX",
                "500",
                "5XX",
            ],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "201", "application/json"):
            return unmarshal_json_response(models.BaseResponseTableDto, http_res)
        if utils.match_response(http_res, "400", "application/json"):
            response_data = unmarshal_json_response(errors.MultiErrorData, http_res)
            raise errors.MultiError(response_data, http_res)
        if utils.match_response(
            http_res, ["401", "403", "404", "409", "429"], "application/json"
        ):
            response_data = unmarshal_json_response(errors.SingleErrorData, http_res)
            raise errors.SingleError(response_data, http_res)
        if utils.match_response(http_res, "500", "application/json"):
            response_data = unmarshal_json_response(errors.SingleErrorData, http_res)
            raise errors.SingleError(response_data, http_res)
        if utils.match_response(http_res, ["423", "4XX"], "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)

        raise errors.SDKError("Unexpected response received", http_res)

    def create_tag(
        self,
        *,
        request: Union[models.TagDtoInput, models.TagDtoInputTypedDict],
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.BaseResponseTagDto:
        r"""Create a new tag

        Creates a tag. If another tag already has the same key, returns a 409. There is a limit of 300 values for a tag.

        :param request: The request object to send.
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = models.WDATA_CREATE_TAG_OP_SERVERS[0]

        if not isinstance(request, BaseModel):
            request = utils.unmarshal(request, models.TagDtoInput)
        request = cast(models.TagDtoInput, request)

        req = self._build_request(
            method="POST",
            path="/api/v1/tag",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request, False, False, "json", models.TagDtoInput
            ),
            allow_empty_value=None,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="wdata_createTag",
                oauth2_scopes=[],
                security_source=self.sdk_configuration.security,
            ),
            request=req,
            error_status_codes=[
                "400",
                "401",
                "403",
                "404",
                "409",
                "423",
                "429",
                "4XX",
                "500",
                "5XX",
            ],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "201", "application/json"):
            return unmarshal_json_response(models.BaseResponseTagDto, http_res)
        if utils.match_response(http_res, "400", "application/json"):
            response_data = unmarshal_json_response(errors.MultiErrorData, http_res)
            raise errors.MultiError(response_data, http_res)
        if utils.match_response(
            http_res, ["401", "403", "404", "409", "429"], "application/json"
        ):
            response_data = unmarshal_json_response(errors.SingleErrorData, http_res)
            raise errors.SingleError(response_data, http_res)
        if utils.match_response(http_res, "500", "application/json"):
            response_data = unmarshal_json_response(errors.SingleErrorData, http_res)
            raise errors.SingleError(response_data, http_res)
        if utils.match_response(http_res, ["423", "4XX"], "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)

        raise errors.SDKError("Unexpected response received", http_res)

    async def create_tag_async(
        self,
        *,
        request: Union[models.TagDtoInput, models.TagDtoInputTypedDict],
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.BaseResponseTagDto:
        r"""Create a new tag

        Creates a tag. If another tag already has the same key, returns a 409. There is a limit of 300 values for a tag.

        :param request: The request object to send.
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = models.WDATA_CREATE_TAG_OP_SERVERS[0]

        if not isinstance(request, BaseModel):
            request = utils.unmarshal(request, models.TagDtoInput)
        request = cast(models.TagDtoInput, request)

        req = self._build_request_async(
            method="POST",
            path="/api/v1/tag",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request, False, False, "json", models.TagDtoInput
            ),
            allow_empty_value=None,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="wdata_createTag",
                oauth2_scopes=[],
                security_source=self.sdk_configuration.security,
            ),
            request=req,
            error_status_codes=[
                "400",
                "401",
                "403",
                "404",
                "409",
                "423",
                "429",
                "4XX",
                "500",
                "5XX",
            ],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "201", "application/json"):
            return unmarshal_json_response(models.BaseResponseTagDto, http_res)
        if utils.match_response(http_res, "400", "application/json"):
            response_data = unmarshal_json_response(errors.MultiErrorData, http_res)
            raise errors.MultiError(response_data, http_res)
        if utils.match_response(
            http_res, ["401", "403", "404", "409", "429"], "application/json"
        ):
            response_data = unmarshal_json_response(errors.SingleErrorData, http_res)
            raise errors.SingleError(response_data, http_res)
        if utils.match_response(http_res, "500", "application/json"):
            response_data = unmarshal_json_response(errors.SingleErrorData, http_res)
            raise errors.SingleError(response_data, http_res)
        if utils.match_response(http_res, ["423", "4XX"], "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)

        raise errors.SDKError("Unexpected response received", http_res)

    def create_token(
        self,
        *,
        request: Union[models.TokenDtoInput, models.TokenDtoInputTypedDict],
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.BaseResponseTokenDto:
        r"""Create a new token

        Creates a temporary tokenvalid for only a short period of timeto download a table
        dataset file or query result, given its ID.

        :param request: The request object to send.
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = models.WDATA_CREATE_TOKEN_OP_SERVERS[0]

        if not isinstance(request, BaseModel):
            request = utils.unmarshal(request, models.TokenDtoInput)
        request = cast(models.TokenDtoInput, request)

        req = self._build_request(
            method="POST",
            path="/api/v1/token",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request, False, False, "json", models.TokenDtoInput
            ),
            allow_empty_value=None,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="wdata_createToken",
                oauth2_scopes=[],
                security_source=self.sdk_configuration.security,
            ),
            request=req,
            error_status_codes=[
                "400",
                "401",
                "403",
                "404",
                "409",
                "423",
                "429",
                "4XX",
                "500",
                "5XX",
            ],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "201", "application/json"):
            return unmarshal_json_response(models.BaseResponseTokenDto, http_res)
        if utils.match_response(http_res, "400", "application/json"):
            response_data = unmarshal_json_response(errors.MultiErrorData, http_res)
            raise errors.MultiError(response_data, http_res)
        if utils.match_response(
            http_res, ["401", "403", "404", "409", "429"], "application/json"
        ):
            response_data = unmarshal_json_response(errors.SingleErrorData, http_res)
            raise errors.SingleError(response_data, http_res)
        if utils.match_response(http_res, "500", "application/json"):
            response_data = unmarshal_json_response(errors.SingleErrorData, http_res)
            raise errors.SingleError(response_data, http_res)
        if utils.match_response(http_res, ["423", "4XX"], "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)

        raise errors.SDKError("Unexpected response received", http_res)

    async def create_token_async(
        self,
        *,
        request: Union[models.TokenDtoInput, models.TokenDtoInputTypedDict],
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.BaseResponseTokenDto:
        r"""Create a new token

        Creates a temporary tokenvalid for only a short period of timeto download a table
        dataset file or query result, given its ID.

        :param request: The request object to send.
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = models.WDATA_CREATE_TOKEN_OP_SERVERS[0]

        if not isinstance(request, BaseModel):
            request = utils.unmarshal(request, models.TokenDtoInput)
        request = cast(models.TokenDtoInput, request)

        req = self._build_request_async(
            method="POST",
            path="/api/v1/token",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request, False, False, "json", models.TokenDtoInput
            ),
            allow_empty_value=None,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="wdata_createToken",
                oauth2_scopes=[],
                security_source=self.sdk_configuration.security,
            ),
            request=req,
            error_status_codes=[
                "400",
                "401",
                "403",
                "404",
                "409",
                "423",
                "429",
                "4XX",
                "500",
                "5XX",
            ],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "201", "application/json"):
            return unmarshal_json_response(models.BaseResponseTokenDto, http_res)
        if utils.match_response(http_res, "400", "application/json"):
            response_data = unmarshal_json_response(errors.MultiErrorData, http_res)
            raise errors.MultiError(response_data, http_res)
        if utils.match_response(
            http_res, ["401", "403", "404", "409", "429"], "application/json"
        ):
            response_data = unmarshal_json_response(errors.SingleErrorData, http_res)
            raise errors.SingleError(response_data, http_res)
        if utils.match_response(http_res, "500", "application/json"):
            response_data = unmarshal_json_response(errors.SingleErrorData, http_res)
            raise errors.SingleError(response_data, http_res)
        if utils.match_response(http_res, ["423", "4XX"], "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)

        raise errors.SDKError("Unexpected response received", http_res)

    def delete(
        self,
        *,
        select_list_id: str,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.BaseResponseString:
        r"""Delete a single select list

        Deletes a select list with the provided ID. If no such select list exists, this is
        a no-op.

        :param select_list_id: The unique identifier of the select list
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = models.WDATA_DELETE_OP_SERVERS[0]

        request = models.WdataDeleteRequest(
            select_list_id=select_list_id,
        )

        req = self._build_request(
            method="DELETE",
            path="/api/v1/selectlist/{selectListId}",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            allow_empty_value=None,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="wdata_delete",
                oauth2_scopes=[],
                security_source=self.sdk_configuration.security,
            ),
            request=req,
            error_status_codes=[
                "400",
                "401",
                "403",
                "404",
                "409",
                "423",
                "429",
                "4XX",
                "500",
                "5XX",
            ],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(models.BaseResponseString, http_res)
        if utils.match_response(
            http_res, ["401", "403", "409", "429"], "application/json"
        ):
            response_data = unmarshal_json_response(errors.SingleErrorData, http_res)
            raise errors.SingleError(response_data, http_res)
        if utils.match_response(http_res, "500", "application/json"):
            response_data = unmarshal_json_response(errors.SingleErrorData, http_res)
            raise errors.SingleError(response_data, http_res)
        if utils.match_response(http_res, ["400", "404", "423", "4XX"], "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)

        raise errors.SDKError("Unexpected response received", http_res)

    async def delete_async(
        self,
        *,
        select_list_id: str,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.BaseResponseString:
        r"""Delete a single select list

        Deletes a select list with the provided ID. If no such select list exists, this is
        a no-op.

        :param select_list_id: The unique identifier of the select list
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = models.WDATA_DELETE_OP_SERVERS[0]

        request = models.WdataDeleteRequest(
            select_list_id=select_list_id,
        )

        req = self._build_request_async(
            method="DELETE",
            path="/api/v1/selectlist/{selectListId}",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            allow_empty_value=None,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="wdata_delete",
                oauth2_scopes=[],
                security_source=self.sdk_configuration.security,
            ),
            request=req,
            error_status_codes=[
                "400",
                "401",
                "403",
                "404",
                "409",
                "423",
                "429",
                "4XX",
                "500",
                "5XX",
            ],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(models.BaseResponseString, http_res)
        if utils.match_response(
            http_res, ["401", "403", "409", "429"], "application/json"
        ):
            response_data = unmarshal_json_response(errors.SingleErrorData, http_res)
            raise errors.SingleError(response_data, http_res)
        if utils.match_response(http_res, "500", "application/json"):
            response_data = unmarshal_json_response(errors.SingleErrorData, http_res)
            raise errors.SingleError(response_data, http_res)
        if utils.match_response(http_res, ["400", "404", "423", "4XX"], "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)

        raise errors.SDKError("Unexpected response received", http_res)

    def delete_file(
        self,
        *,
        file_id: str,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.BaseResponseString:
        r"""Delete a single file

        Unstages the file with the provided ID. The file must have a STAGED status; if the
        file isn't STAGED, returns a 409 status. If the file isn't found, this is a no-op.

        :param file_id: The unique identifier of the file
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = models.WDATA_DELETE_FILE_OP_SERVERS[0]

        request = models.WdataDeleteFileRequest(
            file_id=file_id,
        )

        req = self._build_request(
            method="DELETE",
            path="/api/v1/file/{fileId}",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            allow_empty_value=None,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="wdata_deleteFile",
                oauth2_scopes=[],
                security_source=self.sdk_configuration.security,
            ),
            request=req,
            error_status_codes=[
                "400",
                "401",
                "403",
                "404",
                "409",
                "423",
                "429",
                "4XX",
                "500",
                "5XX",
            ],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(models.BaseResponseString, http_res)
        if utils.match_response(
            http_res, ["401", "403", "409", "429"], "application/json"
        ):
            response_data = unmarshal_json_response(errors.SingleErrorData, http_res)
            raise errors.SingleError(response_data, http_res)
        if utils.match_response(http_res, "500", "application/json"):
            response_data = unmarshal_json_response(errors.SingleErrorData, http_res)
            raise errors.SingleError(response_data, http_res)
        if utils.match_response(http_res, ["400", "404", "423", "4XX"], "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)

        raise errors.SDKError("Unexpected response received", http_res)

    async def delete_file_async(
        self,
        *,
        file_id: str,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.BaseResponseString:
        r"""Delete a single file

        Unstages the file with the provided ID. The file must have a STAGED status; if the
        file isn't STAGED, returns a 409 status. If the file isn't found, this is a no-op.

        :param file_id: The unique identifier of the file
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = models.WDATA_DELETE_FILE_OP_SERVERS[0]

        request = models.WdataDeleteFileRequest(
            file_id=file_id,
        )

        req = self._build_request_async(
            method="DELETE",
            path="/api/v1/file/{fileId}",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            allow_empty_value=None,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="wdata_deleteFile",
                oauth2_scopes=[],
                security_source=self.sdk_configuration.security,
            ),
            request=req,
            error_status_codes=[
                "400",
                "401",
                "403",
                "404",
                "409",
                "423",
                "429",
                "4XX",
                "500",
                "5XX",
            ],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(models.BaseResponseString, http_res)
        if utils.match_response(
            http_res, ["401", "403", "409", "429"], "application/json"
        ):
            response_data = unmarshal_json_response(errors.SingleErrorData, http_res)
            raise errors.SingleError(response_data, http_res)
        if utils.match_response(http_res, "500", "application/json"):
            response_data = unmarshal_json_response(errors.SingleErrorData, http_res)
            raise errors.SingleError(response_data, http_res)
        if utils.match_response(http_res, ["400", "404", "423", "4XX"], "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)

        raise errors.SDKError("Unexpected response received", http_res)

    def delete_folder(
        self,
        *,
        folder_id: str,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.BaseResponseString:
        r"""Delete a single folder

        Deletes the folder with the provided ID.  If the folder is not found, this is a
        no-op. <b>All files and sub-folders are also recursively deleted.</b>

        :param folder_id: The unique identifier of the folder
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = models.WDATA_DELETE_FOLDER_OP_SERVERS[0]

        request = models.WdataDeleteFolderRequest(
            folder_id=folder_id,
        )

        req = self._build_request(
            method="DELETE",
            path="/api/v1/folder/{folderId}",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            allow_empty_value=None,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="wdata_deleteFolder",
                oauth2_scopes=[],
                security_source=self.sdk_configuration.security,
            ),
            request=req,
            error_status_codes=[
                "400",
                "401",
                "403",
                "404",
                "409",
                "423",
                "429",
                "4XX",
                "500",
                "5XX",
            ],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(models.BaseResponseString, http_res)
        if utils.match_response(http_res, ["401", "403", "429"], "application/json"):
            response_data = unmarshal_json_response(errors.SingleErrorData, http_res)
            raise errors.SingleError(response_data, http_res)
        if utils.match_response(http_res, "500", "application/json"):
            response_data = unmarshal_json_response(errors.SingleErrorData, http_res)
            raise errors.SingleError(response_data, http_res)
        if utils.match_response(http_res, ["400", "404", "409", "423", "4XX"], "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)

        raise errors.SDKError("Unexpected response received", http_res)

    async def delete_folder_async(
        self,
        *,
        folder_id: str,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.BaseResponseString:
        r"""Delete a single folder

        Deletes the folder with the provided ID.  If the folder is not found, this is a
        no-op. <b>All files and sub-folders are also recursively deleted.</b>

        :param folder_id: The unique identifier of the folder
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = models.WDATA_DELETE_FOLDER_OP_SERVERS[0]

        request = models.WdataDeleteFolderRequest(
            folder_id=folder_id,
        )

        req = self._build_request_async(
            method="DELETE",
            path="/api/v1/folder/{folderId}",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            allow_empty_value=None,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="wdata_deleteFolder",
                oauth2_scopes=[],
                security_source=self.sdk_configuration.security,
            ),
            request=req,
            error_status_codes=[
                "400",
                "401",
                "403",
                "404",
                "409",
                "423",
                "429",
                "4XX",
                "500",
                "5XX",
            ],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(models.BaseResponseString, http_res)
        if utils.match_response(http_res, ["401", "403", "429"], "application/json"):
            response_data = unmarshal_json_response(errors.SingleErrorData, http_res)
            raise errors.SingleError(response_data, http_res)
        if utils.match_response(http_res, "500", "application/json"):
            response_data = unmarshal_json_response(errors.SingleErrorData, http_res)
            raise errors.SingleError(response_data, http_res)
        if utils.match_response(http_res, ["400", "404", "409", "423", "4XX"], "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)

        raise errors.SDKError("Unexpected response received", http_res)

    def delete_parameter(
        self,
        *,
        parameter_id: str,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.BaseResponseString:
        r"""Delete Parameter

        Deletes the parameter with the provided parameter ID.  If the parameter is not found, this is a no-op.

        :param parameter_id: The unique identifier of the parameter
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = models.WDATA_DELETE_PARAMETER_OP_SERVERS[0]

        request = models.WdataDeleteParameterRequest(
            parameter_id=parameter_id,
        )

        req = self._build_request(
            method="DELETE",
            path="/api/v1/parameter/{parameterId}",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            allow_empty_value=None,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="wdata_deleteParameter",
                oauth2_scopes=[],
                security_source=self.sdk_configuration.security,
            ),
            request=req,
            error_status_codes=[
                "400",
                "401",
                "403",
                "404",
                "409",
                "423",
                "429",
                "4XX",
                "500",
                "5XX",
            ],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(models.BaseResponseString, http_res)
        if utils.match_response(http_res, ["401", "403", "429"], "application/json"):
            response_data = unmarshal_json_response(errors.SingleErrorData, http_res)
            raise errors.SingleError(response_data, http_res)
        if utils.match_response(http_res, "500", "application/json"):
            response_data = unmarshal_json_response(errors.SingleErrorData, http_res)
            raise errors.SingleError(response_data, http_res)
        if utils.match_response(http_res, ["400", "404", "409", "423", "4XX"], "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)

        raise errors.SDKError("Unexpected response received", http_res)

    async def delete_parameter_async(
        self,
        *,
        parameter_id: str,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.BaseResponseString:
        r"""Delete Parameter

        Deletes the parameter with the provided parameter ID.  If the parameter is not found, this is a no-op.

        :param parameter_id: The unique identifier of the parameter
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = models.WDATA_DELETE_PARAMETER_OP_SERVERS[0]

        request = models.WdataDeleteParameterRequest(
            parameter_id=parameter_id,
        )

        req = self._build_request_async(
            method="DELETE",
            path="/api/v1/parameter/{parameterId}",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            allow_empty_value=None,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="wdata_deleteParameter",
                oauth2_scopes=[],
                security_source=self.sdk_configuration.security,
            ),
            request=req,
            error_status_codes=[
                "400",
                "401",
                "403",
                "404",
                "409",
                "423",
                "429",
                "4XX",
                "500",
                "5XX",
            ],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(models.BaseResponseString, http_res)
        if utils.match_response(http_res, ["401", "403", "429"], "application/json"):
            response_data = unmarshal_json_response(errors.SingleErrorData, http_res)
            raise errors.SingleError(response_data, http_res)
        if utils.match_response(http_res, "500", "application/json"):
            response_data = unmarshal_json_response(errors.SingleErrorData, http_res)
            raise errors.SingleError(response_data, http_res)
        if utils.match_response(http_res, ["400", "404", "409", "423", "4XX"], "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)

        raise errors.SDKError("Unexpected response received", http_res)

    def delete_pivot_view(
        self,
        *,
        pivot_view_id: str,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.BaseResponseString:
        r"""Delete a single pivot view

        Deletes a view that matches the provided ID.  This is an administrative method and
        should be assumed a hard-delete, given no capability to restore a deleted view is
        available.  A no-op if no such view exists.

        :param pivot_view_id: The unique identifier of the pivot view
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = models.WDATA_DELETE_PIVOT_VIEW_OP_SERVERS[0]

        request = models.WdataDeletePivotViewRequest(
            pivot_view_id=pivot_view_id,
        )

        req = self._build_request(
            method="DELETE",
            path="/api/v1/pivotview/{pivotViewId}",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            allow_empty_value=None,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="wdata_deletePivotView",
                oauth2_scopes=[],
                security_source=self.sdk_configuration.security,
            ),
            request=req,
            error_status_codes=[
                "400",
                "401",
                "403",
                "404",
                "409",
                "423",
                "429",
                "4XX",
                "500",
                "5XX",
            ],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(models.BaseResponseString, http_res)
        if utils.match_response(http_res, ["401", "403", "429"], "application/json"):
            response_data = unmarshal_json_response(errors.SingleErrorData, http_res)
            raise errors.SingleError(response_data, http_res)
        if utils.match_response(http_res, "500", "application/json"):
            response_data = unmarshal_json_response(errors.SingleErrorData, http_res)
            raise errors.SingleError(response_data, http_res)
        if utils.match_response(http_res, ["400", "404", "409", "423", "4XX"], "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)

        raise errors.SDKError("Unexpected response received", http_res)

    async def delete_pivot_view_async(
        self,
        *,
        pivot_view_id: str,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.BaseResponseString:
        r"""Delete a single pivot view

        Deletes a view that matches the provided ID.  This is an administrative method and
        should be assumed a hard-delete, given no capability to restore a deleted view is
        available.  A no-op if no such view exists.

        :param pivot_view_id: The unique identifier of the pivot view
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = models.WDATA_DELETE_PIVOT_VIEW_OP_SERVERS[0]

        request = models.WdataDeletePivotViewRequest(
            pivot_view_id=pivot_view_id,
        )

        req = self._build_request_async(
            method="DELETE",
            path="/api/v1/pivotview/{pivotViewId}",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            allow_empty_value=None,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="wdata_deletePivotView",
                oauth2_scopes=[],
                security_source=self.sdk_configuration.security,
            ),
            request=req,
            error_status_codes=[
                "400",
                "401",
                "403",
                "404",
                "409",
                "423",
                "429",
                "4XX",
                "500",
                "5XX",
            ],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(models.BaseResponseString, http_res)
        if utils.match_response(http_res, ["401", "403", "429"], "application/json"):
            response_data = unmarshal_json_response(errors.SingleErrorData, http_res)
            raise errors.SingleError(response_data, http_res)
        if utils.match_response(http_res, "500", "application/json"):
            response_data = unmarshal_json_response(errors.SingleErrorData, http_res)
            raise errors.SingleError(response_data, http_res)
        if utils.match_response(http_res, ["400", "404", "409", "423", "4XX"], "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)

        raise errors.SDKError("Unexpected response received", http_res)

    def delete_query(
        self,
        *,
        query_id: str,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.BaseResponseString:
        r"""Delete a single query

        Deletes the query that matches the provided ID. If no such query is found, this is
        a no-op.

        :param query_id: The unique identifier of the query
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = models.WDATA_DELETE_QUERY_OP_SERVERS[0]

        request = models.WdataDeleteQueryRequest(
            query_id=query_id,
        )

        req = self._build_request(
            method="DELETE",
            path="/api/v1/query/{queryId}",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            allow_empty_value=None,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="wdata_deleteQuery",
                oauth2_scopes=[],
                security_source=self.sdk_configuration.security,
            ),
            request=req,
            error_status_codes=[
                "400",
                "401",
                "403",
                "404",
                "409",
                "423",
                "429",
                "4XX",
                "500",
                "5XX",
            ],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(models.BaseResponseString, http_res)
        if utils.match_response(http_res, ["401", "403", "429"], "application/json"):
            response_data = unmarshal_json_response(errors.SingleErrorData, http_res)
            raise errors.SingleError(response_data, http_res)
        if utils.match_response(http_res, "500", "application/json"):
            response_data = unmarshal_json_response(errors.SingleErrorData, http_res)
            raise errors.SingleError(response_data, http_res)
        if utils.match_response(http_res, ["400", "404", "409", "423", "4XX"], "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)

        raise errors.SDKError("Unexpected response received", http_res)

    async def delete_query_async(
        self,
        *,
        query_id: str,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.BaseResponseString:
        r"""Delete a single query

        Deletes the query that matches the provided ID. If no such query is found, this is
        a no-op.

        :param query_id: The unique identifier of the query
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = models.WDATA_DELETE_QUERY_OP_SERVERS[0]

        request = models.WdataDeleteQueryRequest(
            query_id=query_id,
        )

        req = self._build_request_async(
            method="DELETE",
            path="/api/v1/query/{queryId}",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            allow_empty_value=None,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="wdata_deleteQuery",
                oauth2_scopes=[],
                security_source=self.sdk_configuration.security,
            ),
            request=req,
            error_status_codes=[
                "400",
                "401",
                "403",
                "404",
                "409",
                "423",
                "429",
                "4XX",
                "500",
                "5XX",
            ],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(models.BaseResponseString, http_res)
        if utils.match_response(http_res, ["401", "403", "429"], "application/json"):
            response_data = unmarshal_json_response(errors.SingleErrorData, http_res)
            raise errors.SingleError(response_data, http_res)
        if utils.match_response(http_res, "500", "application/json"):
            response_data = unmarshal_json_response(errors.SingleErrorData, http_res)
            raise errors.SingleError(response_data, http_res)
        if utils.match_response(http_res, ["400", "404", "409", "423", "4XX"], "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)

        raise errors.SDKError("Unexpected response received", http_res)

    def delete_shared_table(
        self,
        *,
        shared_table_id: str,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.BaseResponseString:
        r"""Delete a single shared table

        Deletes the linkages between the source and destination of a shared table that matches
        the provided ID; the actual table itself is left intact. If no such shared table exists,
        this is a no-op.

        :param shared_table_id: The unique identifier of the shared table
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = models.WDATA_DELETE_SHARED_TABLE_OP_SERVERS[0]

        request = models.WdataDeleteSharedTableRequest(
            shared_table_id=shared_table_id,
        )

        req = self._build_request(
            method="DELETE",
            path="/api/v1/sharedtable/{sharedTableId}",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            allow_empty_value=None,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="wdata_deleteSharedTable",
                oauth2_scopes=[],
                security_source=self.sdk_configuration.security,
            ),
            request=req,
            error_status_codes=[
                "400",
                "401",
                "403",
                "404",
                "409",
                "423",
                "429",
                "4XX",
                "500",
                "5XX",
            ],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(models.BaseResponseString, http_res)
        if utils.match_response(http_res, ["401", "403", "429"], "application/json"):
            response_data = unmarshal_json_response(errors.SingleErrorData, http_res)
            raise errors.SingleError(response_data, http_res)
        if utils.match_response(http_res, "500", "application/json"):
            response_data = unmarshal_json_response(errors.SingleErrorData, http_res)
            raise errors.SingleError(response_data, http_res)
        if utils.match_response(http_res, ["400", "404", "409", "423", "4XX"], "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)

        raise errors.SDKError("Unexpected response received", http_res)

    async def delete_shared_table_async(
        self,
        *,
        shared_table_id: str,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.BaseResponseString:
        r"""Delete a single shared table

        Deletes the linkages between the source and destination of a shared table that matches
        the provided ID; the actual table itself is left intact. If no such shared table exists,
        this is a no-op.

        :param shared_table_id: The unique identifier of the shared table
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = models.WDATA_DELETE_SHARED_TABLE_OP_SERVERS[0]

        request = models.WdataDeleteSharedTableRequest(
            shared_table_id=shared_table_id,
        )

        req = self._build_request_async(
            method="DELETE",
            path="/api/v1/sharedtable/{sharedTableId}",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            allow_empty_value=None,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="wdata_deleteSharedTable",
                oauth2_scopes=[],
                security_source=self.sdk_configuration.security,
            ),
            request=req,
            error_status_codes=[
                "400",
                "401",
                "403",
                "404",
                "409",
                "423",
                "429",
                "4XX",
                "500",
                "5XX",
            ],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(models.BaseResponseString, http_res)
        if utils.match_response(http_res, ["401", "403", "429"], "application/json"):
            response_data = unmarshal_json_response(errors.SingleErrorData, http_res)
            raise errors.SingleError(response_data, http_res)
        if utils.match_response(http_res, "500", "application/json"):
            response_data = unmarshal_json_response(errors.SingleErrorData, http_res)
            raise errors.SingleError(response_data, http_res)
        if utils.match_response(http_res, ["400", "404", "409", "423", "4XX"], "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)

        raise errors.SDKError("Unexpected response received", http_res)

    def delete_table(
        self,
        *,
        table_id: str,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.BaseResponseString:
        r"""Delete a single table

        Soft-deletes the table with the provided ID.

        :param table_id: The unique identifier of the table
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = models.WDATA_DELETE_TABLE_OP_SERVERS[0]

        request = models.WdataDeleteTableRequest(
            table_id=table_id,
        )

        req = self._build_request(
            method="DELETE",
            path="/api/v1/table/{tableId}",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            allow_empty_value=None,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="wdata_deleteTable",
                oauth2_scopes=[],
                security_source=self.sdk_configuration.security,
            ),
            request=req,
            error_status_codes=[
                "400",
                "401",
                "403",
                "404",
                "409",
                "423",
                "429",
                "4XX",
                "500",
                "5XX",
            ],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(models.BaseResponseString, http_res)
        if utils.match_response(http_res, ["401", "403", "429"], "application/json"):
            response_data = unmarshal_json_response(errors.SingleErrorData, http_res)
            raise errors.SingleError(response_data, http_res)
        if utils.match_response(http_res, "500", "application/json"):
            response_data = unmarshal_json_response(errors.SingleErrorData, http_res)
            raise errors.SingleError(response_data, http_res)
        if utils.match_response(http_res, ["400", "404", "409", "423", "4XX"], "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)

        raise errors.SDKError("Unexpected response received", http_res)

    async def delete_table_async(
        self,
        *,
        table_id: str,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.BaseResponseString:
        r"""Delete a single table

        Soft-deletes the table with the provided ID.

        :param table_id: The unique identifier of the table
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = models.WDATA_DELETE_TABLE_OP_SERVERS[0]

        request = models.WdataDeleteTableRequest(
            table_id=table_id,
        )

        req = self._build_request_async(
            method="DELETE",
            path="/api/v1/table/{tableId}",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            allow_empty_value=None,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="wdata_deleteTable",
                oauth2_scopes=[],
                security_source=self.sdk_configuration.security,
            ),
            request=req,
            error_status_codes=[
                "400",
                "401",
                "403",
                "404",
                "409",
                "423",
                "429",
                "4XX",
                "500",
                "5XX",
            ],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(models.BaseResponseString, http_res)
        if utils.match_response(http_res, ["401", "403", "429"], "application/json"):
            response_data = unmarshal_json_response(errors.SingleErrorData, http_res)
            raise errors.SingleError(response_data, http_res)
        if utils.match_response(http_res, "500", "application/json"):
            response_data = unmarshal_json_response(errors.SingleErrorData, http_res)
            raise errors.SingleError(response_data, http_res)
        if utils.match_response(http_res, ["400", "404", "409", "423", "4XX"], "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)

        raise errors.SDKError("Unexpected response received", http_res)

    def delete_tag(
        self,
        *,
        tag_id: str,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.BaseResponseString:
        r"""Delete a single tag

        Deletes the tag with the provided ID. If no such tag is found, this is a no-op.

        :param tag_id: The unique identifier of the tag
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = models.WDATA_DELETE_TAG_OP_SERVERS[0]

        request = models.WdataDeleteTagRequest(
            tag_id=tag_id,
        )

        req = self._build_request(
            method="DELETE",
            path="/api/v1/tag/{tagId}",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            allow_empty_value=None,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="wdata_deleteTag",
                oauth2_scopes=[],
                security_source=self.sdk_configuration.security,
            ),
            request=req,
            error_status_codes=[
                "400",
                "401",
                "403",
                "404",
                "409",
                "423",
                "429",
                "4XX",
                "500",
                "5XX",
            ],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(models.BaseResponseString, http_res)
        if utils.match_response(http_res, ["401", "403", "429"], "application/json"):
            response_data = unmarshal_json_response(errors.SingleErrorData, http_res)
            raise errors.SingleError(response_data, http_res)
        if utils.match_response(http_res, "500", "application/json"):
            response_data = unmarshal_json_response(errors.SingleErrorData, http_res)
            raise errors.SingleError(response_data, http_res)
        if utils.match_response(http_res, ["400", "404", "409", "423", "4XX"], "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)

        raise errors.SDKError("Unexpected response received", http_res)

    async def delete_tag_async(
        self,
        *,
        tag_id: str,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.BaseResponseString:
        r"""Delete a single tag

        Deletes the tag with the provided ID. If no such tag is found, this is a no-op.

        :param tag_id: The unique identifier of the tag
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = models.WDATA_DELETE_TAG_OP_SERVERS[0]

        request = models.WdataDeleteTagRequest(
            tag_id=tag_id,
        )

        req = self._build_request_async(
            method="DELETE",
            path="/api/v1/tag/{tagId}",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            allow_empty_value=None,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="wdata_deleteTag",
                oauth2_scopes=[],
                security_source=self.sdk_configuration.security,
            ),
            request=req,
            error_status_codes=[
                "400",
                "401",
                "403",
                "404",
                "409",
                "423",
                "429",
                "4XX",
                "500",
                "5XX",
            ],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(models.BaseResponseString, http_res)
        if utils.match_response(http_res, ["401", "403", "429"], "application/json"):
            response_data = unmarshal_json_response(errors.SingleErrorData, http_res)
            raise errors.SingleError(response_data, http_res)
        if utils.match_response(http_res, "500", "application/json"):
            response_data = unmarshal_json_response(errors.SingleErrorData, http_res)
            raise errors.SingleError(response_data, http_res)
        if utils.match_response(http_res, ["400", "404", "409", "423", "4XX"], "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)

        raise errors.SDKError("Unexpected response received", http_res)

    def delete_workspace(
        self,
        *,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.BaseResponseString:
        r"""Delete a single workspace

        Deletes all information in the workspace of the request. <b>This is a final operation and can't be undone</b>. Any state left in the workspace due to an error is in an indeterminate state and shouldn't be trusted. Some non-private information may be kept for auditing and metric purposes.

        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = models.WDATA_DELETE_WORKSPACE_OP_SERVERS[0]
        req = self._build_request(
            method="DELETE",
            path="/api/v1/admin/account",
            base_url=base_url,
            url_variables=url_variables,
            request=None,
            request_body_required=False,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            allow_empty_value=None,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="wdata_deleteWorkspace",
                oauth2_scopes=[],
                security_source=self.sdk_configuration.security,
            ),
            request=req,
            error_status_codes=[
                "400",
                "401",
                "403",
                "404",
                "409",
                "423",
                "429",
                "4XX",
                "500",
                "5XX",
            ],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(models.BaseResponseString, http_res)
        if utils.match_response(http_res, ["401", "403", "429"], "application/json"):
            response_data = unmarshal_json_response(errors.SingleErrorData, http_res)
            raise errors.SingleError(response_data, http_res)
        if utils.match_response(http_res, "500", "application/json"):
            response_data = unmarshal_json_response(errors.SingleErrorData, http_res)
            raise errors.SingleError(response_data, http_res)
        if utils.match_response(http_res, ["400", "404", "409", "423", "4XX"], "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)

        raise errors.SDKError("Unexpected response received", http_res)

    async def delete_workspace_async(
        self,
        *,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.BaseResponseString:
        r"""Delete a single workspace

        Deletes all information in the workspace of the request. <b>This is a final operation and can't be undone</b>. Any state left in the workspace due to an error is in an indeterminate state and shouldn't be trusted. Some non-private information may be kept for auditing and metric purposes.

        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = models.WDATA_DELETE_WORKSPACE_OP_SERVERS[0]
        req = self._build_request_async(
            method="DELETE",
            path="/api/v1/admin/account",
            base_url=base_url,
            url_variables=url_variables,
            request=None,
            request_body_required=False,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            allow_empty_value=None,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="wdata_deleteWorkspace",
                oauth2_scopes=[],
                security_source=self.sdk_configuration.security,
            ),
            request=req,
            error_status_codes=[
                "400",
                "401",
                "403",
                "404",
                "409",
                "423",
                "429",
                "4XX",
                "500",
                "5XX",
            ],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(models.BaseResponseString, http_res)
        if utils.match_response(http_res, ["401", "403", "429"], "application/json"):
            response_data = unmarshal_json_response(errors.SingleErrorData, http_res)
            raise errors.SingleError(response_data, http_res)
        if utils.match_response(http_res, "500", "application/json"):
            response_data = unmarshal_json_response(errors.SingleErrorData, http_res)
            raise errors.SingleError(response_data, http_res)
        if utils.match_response(http_res, ["400", "404", "409", "423", "4XX"], "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)

        raise errors.SDKError("Unexpected response received", http_res)

    def describe_query(
        self,
        *,
        query_id: str,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.BaseResponseDescribeQueryResponseDto:
        r"""List the output columns of a query

        List the output columns of a query, including the column name (or alias), catalog, schema,
        table, type, type size in bytes, and a boolean indicating if the column is aliased.

        :param query_id: The unique identifier of the query
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = models.WDATA_DESCRIBE_QUERY_OP_SERVERS[0]

        request = models.WdataDescribeQueryRequest(
            query_id=query_id,
        )

        req = self._build_request(
            method="POST",
            path="/api/v1/query/{queryId}/describe",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            allow_empty_value=None,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="wdata_describeQuery",
                oauth2_scopes=[],
                security_source=self.sdk_configuration.security,
            ),
            request=req,
            error_status_codes=[
                "400",
                "401",
                "403",
                "404",
                "409",
                "423",
                "429",
                "4XX",
                "500",
                "5XX",
            ],
            retry_config=retry_config,
        )

        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(
                models.BaseResponseDescribeQueryResponseDto, http_res
            )
        if utils.match_response(
            http_res, ["400", "401", "403", "404", "409", "423", "429", "4XX"], "*"
        ):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, ["500", "5XX"], "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)

        raise errors.SDKError("Unexpected response received", http_res)

    async def describe_query_async(
        self,
        *,
        query_id: str,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.BaseResponseDescribeQueryResponseDto:
        r"""List the output columns of a query

        List the output columns of a query, including the column name (or alias), catalog, schema,
        table, type, type size in bytes, and a boolean indicating if the column is aliased.

        :param query_id: The unique identifier of the query
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = models.WDATA_DESCRIBE_QUERY_OP_SERVERS[0]

        request = models.WdataDescribeQueryRequest(
            query_id=query_id,
        )

        req = self._build_request_async(
            method="POST",
            path="/api/v1/query/{queryId}/describe",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            allow_empty_value=None,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="wdata_describeQuery",
                oauth2_scopes=[],
                security_source=self.sdk_configuration.security,
            ),
            request=req,
            error_status_codes=[
                "400",
                "401",
                "403",
                "404",
                "409",
                "423",
                "429",
                "4XX",
                "500",
                "5XX",
            ],
            retry_config=retry_config,
        )

        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(
                models.BaseResponseDescribeQueryResponseDto, http_res
            )
        if utils.match_response(
            http_res, ["400", "401", "403", "404", "409", "423", "429", "4XX"], "*"
        ):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, ["500", "5XX"], "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)

        raise errors.SDKError("Unexpected response received", http_res)

    def download_file(
        self,
        *,
        token_id: str,
        filename: Optional[str] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> str:
        r"""Download a single file

        Downloads a table dataset or query result as a file, given its token from the [`Create a new token endpoint`](ref:wdata-createtoken). If no matching entity is found, returns a 404.

        :param token_id: The unique identifier of the token
        :param filename: A filename for the download; if included, the default filename is overridden
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = models.WDATA_DOWNLOAD_FILE_OP_SERVERS[0]

        request = models.WdataDownloadFileRequest(
            filename=filename,
            token_id=token_id,
        )

        req = self._build_request(
            method="GET",
            path="/api/v1/token/{tokenId}",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="*/*",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            allow_empty_value=None,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="wdata_downloadFile",
                oauth2_scopes=[],
                security_source=self.sdk_configuration.security,
            ),
            request=req,
            error_status_codes=[
                "400",
                "401",
                "403",
                "404",
                "409",
                "423",
                "429",
                "4XX",
                "500",
                "5XX",
            ],
            retry_config=retry_config,
        )

        if utils.match_response(http_res, "200", "*/*"):
            return http_res.text
        if utils.match_response(
            http_res, ["400", "401", "403", "404", "409", "423", "429", "4XX"], "*"
        ):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, ["500", "5XX"], "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)

        raise errors.SDKError("Unexpected response received", http_res)

    async def download_file_async(
        self,
        *,
        token_id: str,
        filename: Optional[str] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> str:
        r"""Download a single file

        Downloads a table dataset or query result as a file, given its token from the [`Create a new token endpoint`](ref:wdata-createtoken). If no matching entity is found, returns a 404.

        :param token_id: The unique identifier of the token
        :param filename: A filename for the download; if included, the default filename is overridden
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = models.WDATA_DOWNLOAD_FILE_OP_SERVERS[0]

        request = models.WdataDownloadFileRequest(
            filename=filename,
            token_id=token_id,
        )

        req = self._build_request_async(
            method="GET",
            path="/api/v1/token/{tokenId}",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="*/*",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            allow_empty_value=None,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="wdata_downloadFile",
                oauth2_scopes=[],
                security_source=self.sdk_configuration.security,
            ),
            request=req,
            error_status_codes=[
                "400",
                "401",
                "403",
                "404",
                "409",
                "423",
                "429",
                "4XX",
                "500",
                "5XX",
            ],
            retry_config=retry_config,
        )

        if utils.match_response(http_res, "200", "*/*"):
            return http_res.text
        if utils.match_response(
            http_res, ["400", "401", "403", "404", "409", "423", "429", "4XX"], "*"
        ):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, ["500", "5XX"], "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)

        raise errors.SDKError("Unexpected response received", http_res)

    def download_file_1(
        self,
        *,
        file_id: str,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> httpx.Response:
        r"""Download a single file

        Returns a file with the provided ID, which points to a file meta ID.

        :param file_id: The unique identifier of the file
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = models.WDATA_DOWNLOAD_FILE_1_OP_SERVERS[0]

        request = models.WdataDownloadFile1Request(
            file_id=file_id,
        )

        req = self._build_request(
            method="GET",
            path="/api/v1/file/{fileId}/download",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="*/*",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            allow_empty_value=None,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="wdata_downloadFile_1",
                oauth2_scopes=[],
                security_source=self.sdk_configuration.security,
            ),
            request=req,
            error_status_codes=[
                "400",
                "401",
                "403",
                "404",
                "409",
                "423",
                "429",
                "4XX",
                "500",
                "5XX",
            ],
            stream=True,
            retry_config=retry_config,
        )

        if utils.match_response(http_res, "200", "*/*"):
            return http_res
        if utils.match_response(
            http_res, ["400", "401", "403", "404", "409", "423", "429", "4XX"], "*"
        ):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, ["500", "5XX"], "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)

        http_res_text = utils.stream_to_text(http_res)
        raise errors.SDKError("Unexpected response received", http_res, http_res_text)

    async def download_file_1_async(
        self,
        *,
        file_id: str,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> httpx.Response:
        r"""Download a single file

        Returns a file with the provided ID, which points to a file meta ID.

        :param file_id: The unique identifier of the file
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = models.WDATA_DOWNLOAD_FILE_1_OP_SERVERS[0]

        request = models.WdataDownloadFile1Request(
            file_id=file_id,
        )

        req = self._build_request_async(
            method="GET",
            path="/api/v1/file/{fileId}/download",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="*/*",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            allow_empty_value=None,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="wdata_downloadFile_1",
                oauth2_scopes=[],
                security_source=self.sdk_configuration.security,
            ),
            request=req,
            error_status_codes=[
                "400",
                "401",
                "403",
                "404",
                "409",
                "423",
                "429",
                "4XX",
                "500",
                "5XX",
            ],
            stream=True,
            retry_config=retry_config,
        )

        if utils.match_response(http_res, "200", "*/*"):
            return http_res
        if utils.match_response(
            http_res, ["400", "401", "403", "404", "409", "423", "429", "4XX"], "*"
        ):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, ["500", "5XX"], "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)

        http_res_text = await utils.stream_to_text_async(http_res)
        raise errors.SDKError("Unexpected response received", http_res, http_res_text)

    def download_query_result(
        self,
        *,
        query_result_id: str,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> httpx.Response:
        r"""Download a query result

        Uses the Token Management API to create a token with the query result ID, which it
        then uses to download a CSV file of the query results.

        :param query_result_id: The unique identifier of the query result
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = models.WDATA_DOWNLOAD_QUERY_RESULT_OP_SERVERS[0]

        request = models.WdataDownloadQueryResultRequest(
            query_result_id=query_result_id,
        )

        req = self._build_request(
            method="GET",
            path="/api/v1/queryresult/{queryResultId}/download",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="*/*",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            allow_empty_value=None,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="wdata_downloadQueryResult",
                oauth2_scopes=[],
                security_source=self.sdk_configuration.security,
            ),
            request=req,
            error_status_codes=[
                "400",
                "401",
                "403",
                "404",
                "409",
                "423",
                "429",
                "4XX",
                "500",
                "5XX",
            ],
            stream=True,
            retry_config=retry_config,
        )

        if utils.match_response(http_res, "200", "*/*"):
            return http_res
        if utils.match_response(
            http_res, ["400", "401", "403", "404", "409", "423", "429", "4XX"], "*"
        ):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, ["500", "5XX"], "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)

        http_res_text = utils.stream_to_text(http_res)
        raise errors.SDKError("Unexpected response received", http_res, http_res_text)

    async def download_query_result_async(
        self,
        *,
        query_result_id: str,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> httpx.Response:
        r"""Download a query result

        Uses the Token Management API to create a token with the query result ID, which it
        then uses to download a CSV file of the query results.

        :param query_result_id: The unique identifier of the query result
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = models.WDATA_DOWNLOAD_QUERY_RESULT_OP_SERVERS[0]

        request = models.WdataDownloadQueryResultRequest(
            query_result_id=query_result_id,
        )

        req = self._build_request_async(
            method="GET",
            path="/api/v1/queryresult/{queryResultId}/download",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="*/*",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            allow_empty_value=None,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="wdata_downloadQueryResult",
                oauth2_scopes=[],
                security_source=self.sdk_configuration.security,
            ),
            request=req,
            error_status_codes=[
                "400",
                "401",
                "403",
                "404",
                "409",
                "423",
                "429",
                "4XX",
                "500",
                "5XX",
            ],
            stream=True,
            retry_config=retry_config,
        )

        if utils.match_response(http_res, "200", "*/*"):
            return http_res
        if utils.match_response(
            http_res, ["400", "401", "403", "404", "409", "423", "429", "4XX"], "*"
        ):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, ["500", "5XX"], "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)

        http_res_text = await utils.stream_to_text_async(http_res)
        raise errors.SDKError("Unexpected response received", http_res, http_res_text)

    def export_file_to_spreadsheets(
        self,
        *,
        file_id: str,
        export_file_dto: Union[models.ExportFileDto, models.ExportFileDtoTypedDict],
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.BaseResponseSpreadsheetInfoDto:
        r"""Export a file to spreadsheets

        Exports the file ID identified in the path to the spreadsheet identified by the
        provided URL. If the URL string is empty, creates and returns a new spreadsheet and
        its sheet IDs.

        :param file_id: The unique identifier of the file
        :param export_file_dto: The representation of the file to export
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = models.WDATA_EXPORT_FILE_TO_SPREADSHEETS_OP_SERVERS[0]

        request = models.WdataExportFileToSpreadsheetsRequest(
            file_id=file_id,
            export_file_dto=utils.get_pydantic_model(
                export_file_dto, models.ExportFileDto
            ),
        )

        req = self._build_request(
            method="POST",
            path="/api/v1/file/{fileId}/export",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request.export_file_dto, False, False, "json", models.ExportFileDto
            ),
            allow_empty_value=None,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="wdata_exportFileToSpreadsheets",
                oauth2_scopes=[],
                security_source=self.sdk_configuration.security,
            ),
            request=req,
            error_status_codes=[
                "400",
                "401",
                "403",
                "404",
                "409",
                "423",
                "429",
                "4XX",
                "500",
                "5XX",
            ],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "201", "application/json"):
            return unmarshal_json_response(
                models.BaseResponseSpreadsheetInfoDto, http_res
            )
        if utils.match_response(http_res, "400", "application/json"):
            response_data = unmarshal_json_response(errors.MultiErrorData, http_res)
            raise errors.MultiError(response_data, http_res)
        if utils.match_response(
            http_res, ["401", "403", "404", "409", "429"], "application/json"
        ):
            response_data = unmarshal_json_response(errors.SingleErrorData, http_res)
            raise errors.SingleError(response_data, http_res)
        if utils.match_response(http_res, "500", "application/json"):
            response_data = unmarshal_json_response(errors.SingleErrorData, http_res)
            raise errors.SingleError(response_data, http_res)
        if utils.match_response(http_res, ["423", "4XX"], "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)

        raise errors.SDKError("Unexpected response received", http_res)

    async def export_file_to_spreadsheets_async(
        self,
        *,
        file_id: str,
        export_file_dto: Union[models.ExportFileDto, models.ExportFileDtoTypedDict],
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.BaseResponseSpreadsheetInfoDto:
        r"""Export a file to spreadsheets

        Exports the file ID identified in the path to the spreadsheet identified by the
        provided URL. If the URL string is empty, creates and returns a new spreadsheet and
        its sheet IDs.

        :param file_id: The unique identifier of the file
        :param export_file_dto: The representation of the file to export
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = models.WDATA_EXPORT_FILE_TO_SPREADSHEETS_OP_SERVERS[0]

        request = models.WdataExportFileToSpreadsheetsRequest(
            file_id=file_id,
            export_file_dto=utils.get_pydantic_model(
                export_file_dto, models.ExportFileDto
            ),
        )

        req = self._build_request_async(
            method="POST",
            path="/api/v1/file/{fileId}/export",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request.export_file_dto, False, False, "json", models.ExportFileDto
            ),
            allow_empty_value=None,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="wdata_exportFileToSpreadsheets",
                oauth2_scopes=[],
                security_source=self.sdk_configuration.security,
            ),
            request=req,
            error_status_codes=[
                "400",
                "401",
                "403",
                "404",
                "409",
                "423",
                "429",
                "4XX",
                "500",
                "5XX",
            ],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "201", "application/json"):
            return unmarshal_json_response(
                models.BaseResponseSpreadsheetInfoDto, http_res
            )
        if utils.match_response(http_res, "400", "application/json"):
            response_data = unmarshal_json_response(errors.MultiErrorData, http_res)
            raise errors.MultiError(response_data, http_res)
        if utils.match_response(
            http_res, ["401", "403", "404", "409", "429"], "application/json"
        ):
            response_data = unmarshal_json_response(errors.SingleErrorData, http_res)
            raise errors.SingleError(response_data, http_res)
        if utils.match_response(http_res, "500", "application/json"):
            response_data = unmarshal_json_response(errors.SingleErrorData, http_res)
            raise errors.SingleError(response_data, http_res)
        if utils.match_response(http_res, ["423", "4XX"], "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)

        raise errors.SDKError("Unexpected response received", http_res)

    def export_query_result_to_spreadsheets(
        self,
        *,
        query_result_id: str,
        export_query_result_dto: Union[
            models.ExportQueryResultDto, models.ExportQueryResultDtoTypedDict
        ],
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.BaseResponseString:
        r"""Export query result to spreadsheets

        Exports a query result with the provided ID to Spreadsheets. To determine where to
        export the results, the request body should include a URL copied and pasted from the
        Spreadsheets UI. Returns a 404 if no matching query result is found.

        :param query_result_id: The unique identifier of the query result
        :param export_query_result_dto: The representation of the export query result
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = models.WDATA_EXPORT_QUERY_RESULT_TO_SPREADSHEETS_OP_SERVERS[0]

        request = models.WdataExportQueryResultToSpreadsheetsRequest(
            query_result_id=query_result_id,
            export_query_result_dto=utils.get_pydantic_model(
                export_query_result_dto, models.ExportQueryResultDto
            ),
        )

        req = self._build_request(
            method="POST",
            path="/api/v1/queryresult/{queryResultId}/export",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request.export_query_result_dto,
                False,
                False,
                "json",
                models.ExportQueryResultDto,
            ),
            allow_empty_value=None,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="wdata_exportQueryResultToSpreadsheets",
                oauth2_scopes=[],
                security_source=self.sdk_configuration.security,
            ),
            request=req,
            error_status_codes=[
                "400",
                "401",
                "403",
                "404",
                "409",
                "423",
                "429",
                "4XX",
                "500",
                "5XX",
            ],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "201", "application/json"):
            return unmarshal_json_response(models.BaseResponseString, http_res)
        if utils.match_response(http_res, "400", "application/json"):
            response_data = unmarshal_json_response(errors.MultiErrorData, http_res)
            raise errors.MultiError(response_data, http_res)
        if utils.match_response(
            http_res, ["401", "403", "404", "409", "429"], "application/json"
        ):
            response_data = unmarshal_json_response(errors.SingleErrorData, http_res)
            raise errors.SingleError(response_data, http_res)
        if utils.match_response(http_res, "500", "application/json"):
            response_data = unmarshal_json_response(errors.SingleErrorData, http_res)
            raise errors.SingleError(response_data, http_res)
        if utils.match_response(http_res, ["423", "4XX"], "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)

        raise errors.SDKError("Unexpected response received", http_res)

    async def export_query_result_to_spreadsheets_async(
        self,
        *,
        query_result_id: str,
        export_query_result_dto: Union[
            models.ExportQueryResultDto, models.ExportQueryResultDtoTypedDict
        ],
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.BaseResponseString:
        r"""Export query result to spreadsheets

        Exports a query result with the provided ID to Spreadsheets. To determine where to
        export the results, the request body should include a URL copied and pasted from the
        Spreadsheets UI. Returns a 404 if no matching query result is found.

        :param query_result_id: The unique identifier of the query result
        :param export_query_result_dto: The representation of the export query result
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = models.WDATA_EXPORT_QUERY_RESULT_TO_SPREADSHEETS_OP_SERVERS[0]

        request = models.WdataExportQueryResultToSpreadsheetsRequest(
            query_result_id=query_result_id,
            export_query_result_dto=utils.get_pydantic_model(
                export_query_result_dto, models.ExportQueryResultDto
            ),
        )

        req = self._build_request_async(
            method="POST",
            path="/api/v1/queryresult/{queryResultId}/export",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request.export_query_result_dto,
                False,
                False,
                "json",
                models.ExportQueryResultDto,
            ),
            allow_empty_value=None,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="wdata_exportQueryResultToSpreadsheets",
                oauth2_scopes=[],
                security_source=self.sdk_configuration.security,
            ),
            request=req,
            error_status_codes=[
                "400",
                "401",
                "403",
                "404",
                "409",
                "423",
                "429",
                "4XX",
                "500",
                "5XX",
            ],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "201", "application/json"):
            return unmarshal_json_response(models.BaseResponseString, http_res)
        if utils.match_response(http_res, "400", "application/json"):
            response_data = unmarshal_json_response(errors.MultiErrorData, http_res)
            raise errors.MultiError(response_data, http_res)
        if utils.match_response(
            http_res, ["401", "403", "404", "409", "429"], "application/json"
        ):
            response_data = unmarshal_json_response(errors.SingleErrorData, http_res)
            raise errors.SingleError(response_data, http_res)
        if utils.match_response(http_res, "500", "application/json"):
            response_data = unmarshal_json_response(errors.SingleErrorData, http_res)
            raise errors.SingleError(response_data, http_res)
        if utils.match_response(http_res, ["423", "4XX"], "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)

        raise errors.SDKError("Unexpected response received", http_res)

    def export_workspace(
        self,
        *,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.BaseResponseTokenDto:
        r"""Export a single workspace

        Creates a file representing the entirety of the requested workspace and returns a
        token. Use the [`Download a single file endpoint`](ref:wdata-downloadfile) to
        exchange the token for the file.

        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = models.WDATA_EXPORT_WORKSPACE_OP_SERVERS[0]
        req = self._build_request(
            method="GET",
            path="/api/v1/admin/export",
            base_url=base_url,
            url_variables=url_variables,
            request=None,
            request_body_required=False,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            allow_empty_value=None,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="wdata_exportWorkspace",
                oauth2_scopes=[],
                security_source=self.sdk_configuration.security,
            ),
            request=req,
            error_status_codes=[
                "400",
                "401",
                "403",
                "404",
                "409",
                "423",
                "429",
                "4XX",
                "500",
                "5XX",
            ],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(models.BaseResponseTokenDto, http_res)
        if utils.match_response(http_res, ["403", "404", "429"], "application/json"):
            response_data = unmarshal_json_response(errors.SingleErrorData, http_res)
            raise errors.SingleError(response_data, http_res)
        if utils.match_response(http_res, "500", "application/json"):
            response_data = unmarshal_json_response(errors.SingleErrorData, http_res)
            raise errors.SingleError(response_data, http_res)
        if utils.match_response(http_res, ["400", "401", "409", "423", "4XX"], "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)

        raise errors.SDKError("Unexpected response received", http_res)

    async def export_workspace_async(
        self,
        *,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.BaseResponseTokenDto:
        r"""Export a single workspace

        Creates a file representing the entirety of the requested workspace and returns a
        token. Use the [`Download a single file endpoint`](ref:wdata-downloadfile) to
        exchange the token for the file.

        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = models.WDATA_EXPORT_WORKSPACE_OP_SERVERS[0]
        req = self._build_request_async(
            method="GET",
            path="/api/v1/admin/export",
            base_url=base_url,
            url_variables=url_variables,
            request=None,
            request_body_required=False,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            allow_empty_value=None,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="wdata_exportWorkspace",
                oauth2_scopes=[],
                security_source=self.sdk_configuration.security,
            ),
            request=req,
            error_status_codes=[
                "400",
                "401",
                "403",
                "404",
                "409",
                "423",
                "429",
                "4XX",
                "500",
                "5XX",
            ],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(models.BaseResponseTokenDto, http_res)
        if utils.match_response(http_res, ["403", "404", "429"], "application/json"):
            response_data = unmarshal_json_response(errors.SingleErrorData, http_res)
            raise errors.SingleError(response_data, http_res)
        if utils.match_response(http_res, "500", "application/json"):
            response_data = unmarshal_json_response(errors.SingleErrorData, http_res)
            raise errors.SingleError(response_data, http_res)
        if utils.match_response(http_res, ["400", "401", "409", "423", "4XX"], "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)

        raise errors.SDKError("Unexpected response received", http_res)

    def find_workspace_files_by_size(
        self,
        *,
        cursor: Optional[str] = None,
        limit: Optional[int] = None,
        offset: Optional[int] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> Optional[models.WdataFindWorkspaceFilesBySizeResponse]:
        r"""Retrieve workspace files by size

        Returns a paged collection of the file meta associated with the workspace of the request,
        ordered by size.

        :param cursor: A paging cursor; if included, `limit` is ignored
        :param limit: The number of file meta objects to return, from 1 to 1000; by default, 1000
        :param offset: The item to start with on the page, greater than or equal to 0; by default, 0
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = models.WDATA_FIND_WORKSPACE_FILES_BY_SIZE_OP_SERVERS[0]

        request = models.WdataFindWorkspaceFilesBySizeRequest(
            cursor=cursor,
            limit=limit,
            offset=offset,
        )

        req = self._build_request(
            method="GET",
            path="/api/v1/admin/usage/filesBySize",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            allow_empty_value=None,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="wdata_findWorkspaceFilesBySize",
                oauth2_scopes=[],
                security_source=self.sdk_configuration.security,
            ),
            request=req,
            error_status_codes=[
                "400",
                "401",
                "403",
                "404",
                "409",
                "423",
                "429",
                "4XX",
                "500",
                "5XX",
            ],
            retry_config=retry_config,
        )

        def next_func() -> Optional[models.WdataFindWorkspaceFilesBySizeResponse]:
            body = utils.unmarshal_json(http_res.text, Union[Dict[Any, Any], List[Any]])

            next_cursor = JSONPath("$.cursor").parse(body)

            if len(next_cursor) == 0:
                return None

            next_cursor = next_cursor[0]
            if next_cursor is None or str(next_cursor).strip() == "":
                return None

            return self.find_workspace_files_by_size(
                cursor=next_cursor,
                limit=limit,
                offset=offset,
                retries=retries,
                server_url=server_url,
            )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return models.WdataFindWorkspaceFilesBySizeResponse(
                result=unmarshal_json_response(
                    models.PagedResponseFileMetaDto, http_res
                ),
                next=next_func,
            )
        if utils.match_response(http_res, ["403", "404", "429"], "application/json"):
            response_data = unmarshal_json_response(errors.SingleErrorData, http_res)
            raise errors.SingleError(response_data, http_res)
        if utils.match_response(http_res, "500", "application/json"):
            response_data = unmarshal_json_response(errors.SingleErrorData, http_res)
            raise errors.SingleError(response_data, http_res)
        if utils.match_response(http_res, ["400", "401", "409", "423", "4XX"], "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)

        raise errors.SDKError("Unexpected response received", http_res)

    async def find_workspace_files_by_size_async(
        self,
        *,
        cursor: Optional[str] = None,
        limit: Optional[int] = None,
        offset: Optional[int] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> Optional[models.WdataFindWorkspaceFilesBySizeResponse]:
        r"""Retrieve workspace files by size

        Returns a paged collection of the file meta associated with the workspace of the request,
        ordered by size.

        :param cursor: A paging cursor; if included, `limit` is ignored
        :param limit: The number of file meta objects to return, from 1 to 1000; by default, 1000
        :param offset: The item to start with on the page, greater than or equal to 0; by default, 0
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = models.WDATA_FIND_WORKSPACE_FILES_BY_SIZE_OP_SERVERS[0]

        request = models.WdataFindWorkspaceFilesBySizeRequest(
            cursor=cursor,
            limit=limit,
            offset=offset,
        )

        req = self._build_request_async(
            method="GET",
            path="/api/v1/admin/usage/filesBySize",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            allow_empty_value=None,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="wdata_findWorkspaceFilesBySize",
                oauth2_scopes=[],
                security_source=self.sdk_configuration.security,
            ),
            request=req,
            error_status_codes=[
                "400",
                "401",
                "403",
                "404",
                "409",
                "423",
                "429",
                "4XX",
                "500",
                "5XX",
            ],
            retry_config=retry_config,
        )

        def next_func() -> (
            Awaitable[Optional[models.WdataFindWorkspaceFilesBySizeResponse]]
        ):
            body = utils.unmarshal_json(http_res.text, Union[Dict[Any, Any], List[Any]])

            async def empty_result():
                return None

            next_cursor = JSONPath("$.cursor").parse(body)

            if len(next_cursor) == 0:
                return empty_result()

            next_cursor = next_cursor[0]
            if next_cursor is None or str(next_cursor).strip() == "":
                return empty_result()

            return self.find_workspace_files_by_size_async(
                cursor=next_cursor,
                limit=limit,
                offset=offset,
                retries=retries,
                server_url=server_url,
            )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return models.WdataFindWorkspaceFilesBySizeResponse(
                result=unmarshal_json_response(
                    models.PagedResponseFileMetaDto, http_res
                ),
                next=next_func,
            )
        if utils.match_response(http_res, ["403", "404", "429"], "application/json"):
            response_data = unmarshal_json_response(errors.SingleErrorData, http_res)
            raise errors.SingleError(response_data, http_res)
        if utils.match_response(http_res, "500", "application/json"):
            response_data = unmarshal_json_response(errors.SingleErrorData, http_res)
            raise errors.SingleError(response_data, http_res)
        if utils.match_response(http_res, ["400", "401", "409", "423", "4XX"], "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)

        raise errors.SDKError("Unexpected response received", http_res)

    def get_connection(
        self,
        *,
        connection_id: str,
        workspace_id: Optional[str] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.BaseResponseConnectionDto:
        r"""Get connection details

        Returns details about a specific connection, based on its ID

        :param connection_id: The ID of the connection to return details about
        :param workspace_id:
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = models.WDATA_GET_CONNECTION_OP_SERVERS[0]

        request = models.WdataGetConnectionRequest(
            connection_id=connection_id,
            workspace_id=workspace_id,
        )

        req = self._build_request(
            method="GET",
            path="/api/v1/connections/{connectionId}",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            allow_empty_value=None,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="wdata_getConnection",
                oauth2_scopes=[],
                security_source=self.sdk_configuration.security,
            ),
            request=req,
            error_status_codes=[
                "400",
                "401",
                "403",
                "404",
                "409",
                "423",
                "429",
                "4XX",
                "500",
                "5XX",
            ],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(models.BaseResponseConnectionDto, http_res)
        if utils.match_response(http_res, ["403", "404", "429"], "application/json"):
            response_data = unmarshal_json_response(errors.SingleErrorData, http_res)
            raise errors.SingleError(response_data, http_res)
        if utils.match_response(http_res, "500", "application/json"):
            response_data = unmarshal_json_response(errors.SingleErrorData, http_res)
            raise errors.SingleError(response_data, http_res)
        if utils.match_response(http_res, ["400", "401", "409", "423", "4XX"], "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)

        raise errors.SDKError("Unexpected response received", http_res)

    async def get_connection_async(
        self,
        *,
        connection_id: str,
        workspace_id: Optional[str] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.BaseResponseConnectionDto:
        r"""Get connection details

        Returns details about a specific connection, based on its ID

        :param connection_id: The ID of the connection to return details about
        :param workspace_id:
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = models.WDATA_GET_CONNECTION_OP_SERVERS[0]

        request = models.WdataGetConnectionRequest(
            connection_id=connection_id,
            workspace_id=workspace_id,
        )

        req = self._build_request_async(
            method="GET",
            path="/api/v1/connections/{connectionId}",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            allow_empty_value=None,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="wdata_getConnection",
                oauth2_scopes=[],
                security_source=self.sdk_configuration.security,
            ),
            request=req,
            error_status_codes=[
                "400",
                "401",
                "403",
                "404",
                "409",
                "423",
                "429",
                "4XX",
                "500",
                "5XX",
            ],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(models.BaseResponseConnectionDto, http_res)
        if utils.match_response(http_res, ["403", "404", "429"], "application/json"):
            response_data = unmarshal_json_response(errors.SingleErrorData, http_res)
            raise errors.SingleError(response_data, http_res)
        if utils.match_response(http_res, "500", "application/json"):
            response_data = unmarshal_json_response(errors.SingleErrorData, http_res)
            raise errors.SingleError(response_data, http_res)
        if utils.match_response(http_res, ["400", "401", "409", "423", "4XX"], "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)

        raise errors.SDKError("Unexpected response received", http_res)

    def get_dependencies(
        self,
        *,
        query_id: str,
        cursor: Optional[str] = None,
        limit: Optional[int] = 1000,
        offset: Optional[int] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> Optional[models.WdataGetDependenciesResponse]:
        r"""Retrieve dependencies

        Returns an unordered collection of all tables the matching query uses as datasources, including any shared tables outside of this OAuth token's workspace. The endpoint verifies the user has read permissions on the query, but _not_ on the tables returned.

        :param query_id: The unique identifier of the query
        :param cursor: A paging cursor; if included, `limit` is ignored
        :param limit: The number of dependencies to return, from 1 to 1000; by default, 1000
        :param offset: The item to start with on the page, greater than or equal to 0; by default, 0
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = models.WDATA_GET_DEPENDENCIES_OP_SERVERS[0]

        request = models.WdataGetDependenciesRequest(
            cursor=cursor,
            limit=limit,
            offset=offset,
            query_id=query_id,
        )

        req = self._build_request(
            method="GET",
            path="/api/v1/query/{queryId}/dependencies",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            allow_empty_value=None,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="wdata_getDependencies",
                oauth2_scopes=[],
                security_source=self.sdk_configuration.security,
            ),
            request=req,
            error_status_codes=[
                "400",
                "401",
                "403",
                "404",
                "409",
                "423",
                "429",
                "4XX",
                "500",
                "5XX",
            ],
            retry_config=retry_config,
        )

        def next_func() -> Optional[models.WdataGetDependenciesResponse]:
            body = utils.unmarshal_json(http_res.text, Union[Dict[Any, Any], List[Any]])

            next_cursor = JSONPath("$.cursor").parse(body)

            if len(next_cursor) == 0:
                return None

            next_cursor = next_cursor[0]
            if next_cursor is None or str(next_cursor).strip() == "":
                return None

            return self.get_dependencies(
                query_id=query_id,
                cursor=next_cursor,
                limit=limit,
                offset=offset,
                retries=retries,
                server_url=server_url,
            )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return models.WdataGetDependenciesResponse(
                result=unmarshal_json_response(models.PagedResponseTableDto, http_res),
                next=next_func,
            )
        if utils.match_response(http_res, ["403", "404", "429"], "application/json"):
            response_data = unmarshal_json_response(errors.SingleErrorData, http_res)
            raise errors.SingleError(response_data, http_res)
        if utils.match_response(http_res, "500", "application/json"):
            response_data = unmarshal_json_response(errors.SingleErrorData, http_res)
            raise errors.SingleError(response_data, http_res)
        if utils.match_response(http_res, ["400", "401", "409", "423", "4XX"], "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)

        raise errors.SDKError("Unexpected response received", http_res)

    async def get_dependencies_async(
        self,
        *,
        query_id: str,
        cursor: Optional[str] = None,
        limit: Optional[int] = 1000,
        offset: Optional[int] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> Optional[models.WdataGetDependenciesResponse]:
        r"""Retrieve dependencies

        Returns an unordered collection of all tables the matching query uses as datasources, including any shared tables outside of this OAuth token's workspace. The endpoint verifies the user has read permissions on the query, but _not_ on the tables returned.

        :param query_id: The unique identifier of the query
        :param cursor: A paging cursor; if included, `limit` is ignored
        :param limit: The number of dependencies to return, from 1 to 1000; by default, 1000
        :param offset: The item to start with on the page, greater than or equal to 0; by default, 0
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = models.WDATA_GET_DEPENDENCIES_OP_SERVERS[0]

        request = models.WdataGetDependenciesRequest(
            cursor=cursor,
            limit=limit,
            offset=offset,
            query_id=query_id,
        )

        req = self._build_request_async(
            method="GET",
            path="/api/v1/query/{queryId}/dependencies",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            allow_empty_value=None,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="wdata_getDependencies",
                oauth2_scopes=[],
                security_source=self.sdk_configuration.security,
            ),
            request=req,
            error_status_codes=[
                "400",
                "401",
                "403",
                "404",
                "409",
                "423",
                "429",
                "4XX",
                "500",
                "5XX",
            ],
            retry_config=retry_config,
        )

        def next_func() -> Awaitable[Optional[models.WdataGetDependenciesResponse]]:
            body = utils.unmarshal_json(http_res.text, Union[Dict[Any, Any], List[Any]])

            async def empty_result():
                return None

            next_cursor = JSONPath("$.cursor").parse(body)

            if len(next_cursor) == 0:
                return empty_result()

            next_cursor = next_cursor[0]
            if next_cursor is None or str(next_cursor).strip() == "":
                return empty_result()

            return self.get_dependencies_async(
                query_id=query_id,
                cursor=next_cursor,
                limit=limit,
                offset=offset,
                retries=retries,
                server_url=server_url,
            )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return models.WdataGetDependenciesResponse(
                result=unmarshal_json_response(models.PagedResponseTableDto, http_res),
                next=next_func,
            )
        if utils.match_response(http_res, ["403", "404", "429"], "application/json"):
            response_data = unmarshal_json_response(errors.SingleErrorData, http_res)
            raise errors.SingleError(response_data, http_res)
        if utils.match_response(http_res, "500", "application/json"):
            response_data = unmarshal_json_response(errors.SingleErrorData, http_res)
            raise errors.SingleError(response_data, http_res)
        if utils.match_response(http_res, ["400", "401", "409", "423", "4XX"], "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)

        raise errors.SDKError("Unexpected response received", http_res)

    def get_dependents(
        self,
        *,
        table_id: str,
        cursor: Optional[str] = None,
        limit: Optional[int] = 1000,
        offset: Optional[int] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> Optional[models.WdataGetDependentsResponse]:
        r"""Retrieve a list of dependents

        Returns a list of all queries that use the table with provided ID as a datasource.
        If a shared table, this may include queries outside of the current OAuth context.
        Permission is checked only for the table ID provided, _not_ on the returned list of
        queries.

        :param table_id: The unique identifier of the table
        :param cursor: A paging cursor; if included, `limit` is ignored
        :param limit: The number of folders to return, from 1 to 1000; by default, 1000
        :param offset: The item to start with on the page, greater than or equal to 0; by default, 0
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = models.WDATA_GET_DEPENDENTS_OP_SERVERS[0]

        request = models.WdataGetDependentsRequest(
            cursor=cursor,
            limit=limit,
            offset=offset,
            table_id=table_id,
        )

        req = self._build_request(
            method="GET",
            path="/api/v1/table/{tableId}/dependents",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            allow_empty_value=None,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="wdata_getDependents",
                oauth2_scopes=[],
                security_source=self.sdk_configuration.security,
            ),
            request=req,
            error_status_codes=[
                "400",
                "401",
                "403",
                "404",
                "409",
                "423",
                "429",
                "4XX",
                "500",
                "5XX",
            ],
            retry_config=retry_config,
        )

        def next_func() -> Optional[models.WdataGetDependentsResponse]:
            body = utils.unmarshal_json(http_res.text, Union[Dict[Any, Any], List[Any]])

            next_cursor = JSONPath("$.cursor").parse(body)

            if len(next_cursor) == 0:
                return None

            next_cursor = next_cursor[0]
            if next_cursor is None or str(next_cursor).strip() == "":
                return None

            return self.get_dependents(
                table_id=table_id,
                cursor=next_cursor,
                limit=limit,
                offset=offset,
                retries=retries,
                server_url=server_url,
            )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return models.WdataGetDependentsResponse(
                result=unmarshal_json_response(models.PagedResponseQueryDto, http_res),
                next=next_func,
            )
        if utils.match_response(http_res, ["403", "404", "429"], "application/json"):
            response_data = unmarshal_json_response(errors.SingleErrorData, http_res)
            raise errors.SingleError(response_data, http_res)
        if utils.match_response(http_res, "500", "application/json"):
            response_data = unmarshal_json_response(errors.SingleErrorData, http_res)
            raise errors.SingleError(response_data, http_res)
        if utils.match_response(http_res, ["400", "401", "409", "423", "4XX"], "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)

        raise errors.SDKError("Unexpected response received", http_res)

    async def get_dependents_async(
        self,
        *,
        table_id: str,
        cursor: Optional[str] = None,
        limit: Optional[int] = 1000,
        offset: Optional[int] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> Optional[models.WdataGetDependentsResponse]:
        r"""Retrieve a list of dependents

        Returns a list of all queries that use the table with provided ID as a datasource.
        If a shared table, this may include queries outside of the current OAuth context.
        Permission is checked only for the table ID provided, _not_ on the returned list of
        queries.

        :param table_id: The unique identifier of the table
        :param cursor: A paging cursor; if included, `limit` is ignored
        :param limit: The number of folders to return, from 1 to 1000; by default, 1000
        :param offset: The item to start with on the page, greater than or equal to 0; by default, 0
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = models.WDATA_GET_DEPENDENTS_OP_SERVERS[0]

        request = models.WdataGetDependentsRequest(
            cursor=cursor,
            limit=limit,
            offset=offset,
            table_id=table_id,
        )

        req = self._build_request_async(
            method="GET",
            path="/api/v1/table/{tableId}/dependents",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            allow_empty_value=None,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="wdata_getDependents",
                oauth2_scopes=[],
                security_source=self.sdk_configuration.security,
            ),
            request=req,
            error_status_codes=[
                "400",
                "401",
                "403",
                "404",
                "409",
                "423",
                "429",
                "4XX",
                "500",
                "5XX",
            ],
            retry_config=retry_config,
        )

        def next_func() -> Awaitable[Optional[models.WdataGetDependentsResponse]]:
            body = utils.unmarshal_json(http_res.text, Union[Dict[Any, Any], List[Any]])

            async def empty_result():
                return None

            next_cursor = JSONPath("$.cursor").parse(body)

            if len(next_cursor) == 0:
                return empty_result()

            next_cursor = next_cursor[0]
            if next_cursor is None or str(next_cursor).strip() == "":
                return empty_result()

            return self.get_dependents_async(
                table_id=table_id,
                cursor=next_cursor,
                limit=limit,
                offset=offset,
                retries=retries,
                server_url=server_url,
            )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return models.WdataGetDependentsResponse(
                result=unmarshal_json_response(models.PagedResponseQueryDto, http_res),
                next=next_func,
            )
        if utils.match_response(http_res, ["403", "404", "429"], "application/json"):
            response_data = unmarshal_json_response(errors.SingleErrorData, http_res)
            raise errors.SingleError(response_data, http_res)
        if utils.match_response(http_res, "500", "application/json"):
            response_data = unmarshal_json_response(errors.SingleErrorData, http_res)
            raise errors.SingleError(response_data, http_res)
        if utils.match_response(http_res, ["400", "401", "409", "423", "4XX"], "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)

        raise errors.SDKError("Unexpected response received", http_res)

    def get_errors(
        self,
        *,
        file_id: str,
        cursor: Optional[str] = None,
        limit: Optional[int] = 50,
        offset: Optional[int] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> Optional[models.WdataGetErrorsResponse]:
        r"""Retrieve errors

        Returns a paged list of operation errors during the upload, import, or tagging
        processes for the provided file ID, if they exist. This list is immutable and may be
        empty if no errors have occurred. If errors exist we recommend fixing them and
        reimporting your file

        :param file_id: The unique identifier of the file
        :param cursor: A paging cursor; if included, `limit` is ignored
        :param limit: The number of errors to return, from 1 to 50; by default, 50
        :param offset: The item to start with on the page, greater than or equal to 0; by default, 0
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = models.WDATA_GET_ERRORS_OP_SERVERS[0]

        request = models.WdataGetErrorsRequest(
            cursor=cursor,
            file_id=file_id,
            limit=limit,
            offset=offset,
        )

        req = self._build_request(
            method="GET",
            path="/api/v1/file/{fileId}/error",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            allow_empty_value=None,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="wdata_getErrors",
                oauth2_scopes=[],
                security_source=self.sdk_configuration.security,
            ),
            request=req,
            error_status_codes=[
                "400",
                "401",
                "403",
                "404",
                "409",
                "423",
                "429",
                "4XX",
                "500",
                "5XX",
            ],
            retry_config=retry_config,
        )

        def next_func() -> Optional[models.WdataGetErrorsResponse]:
            body = utils.unmarshal_json(http_res.text, Union[Dict[Any, Any], List[Any]])

            next_cursor = JSONPath("$.cursor").parse(body)

            if len(next_cursor) == 0:
                return None

            next_cursor = next_cursor[0]
            if next_cursor is None or str(next_cursor).strip() == "":
                return None

            return self.get_errors(
                file_id=file_id,
                cursor=next_cursor,
                limit=limit,
                offset=offset,
                retries=retries,
                server_url=server_url,
            )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return models.WdataGetErrorsResponse(
                result=unmarshal_json_response(
                    models.PagedResponseImportErrorDto, http_res
                ),
                next=next_func,
            )
        if utils.match_response(http_res, ["403", "404", "429"], "application/json"):
            response_data = unmarshal_json_response(errors.SingleErrorData, http_res)
            raise errors.SingleError(response_data, http_res)
        if utils.match_response(http_res, "500", "application/json"):
            response_data = unmarshal_json_response(errors.SingleErrorData, http_res)
            raise errors.SingleError(response_data, http_res)
        if utils.match_response(http_res, ["400", "401", "409", "423", "4XX"], "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)

        raise errors.SDKError("Unexpected response received", http_res)

    async def get_errors_async(
        self,
        *,
        file_id: str,
        cursor: Optional[str] = None,
        limit: Optional[int] = 50,
        offset: Optional[int] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> Optional[models.WdataGetErrorsResponse]:
        r"""Retrieve errors

        Returns a paged list of operation errors during the upload, import, or tagging
        processes for the provided file ID, if they exist. This list is immutable and may be
        empty if no errors have occurred. If errors exist we recommend fixing them and
        reimporting your file

        :param file_id: The unique identifier of the file
        :param cursor: A paging cursor; if included, `limit` is ignored
        :param limit: The number of errors to return, from 1 to 50; by default, 50
        :param offset: The item to start with on the page, greater than or equal to 0; by default, 0
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = models.WDATA_GET_ERRORS_OP_SERVERS[0]

        request = models.WdataGetErrorsRequest(
            cursor=cursor,
            file_id=file_id,
            limit=limit,
            offset=offset,
        )

        req = self._build_request_async(
            method="GET",
            path="/api/v1/file/{fileId}/error",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            allow_empty_value=None,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="wdata_getErrors",
                oauth2_scopes=[],
                security_source=self.sdk_configuration.security,
            ),
            request=req,
            error_status_codes=[
                "400",
                "401",
                "403",
                "404",
                "409",
                "423",
                "429",
                "4XX",
                "500",
                "5XX",
            ],
            retry_config=retry_config,
        )

        def next_func() -> Awaitable[Optional[models.WdataGetErrorsResponse]]:
            body = utils.unmarshal_json(http_res.text, Union[Dict[Any, Any], List[Any]])

            async def empty_result():
                return None

            next_cursor = JSONPath("$.cursor").parse(body)

            if len(next_cursor) == 0:
                return empty_result()

            next_cursor = next_cursor[0]
            if next_cursor is None or str(next_cursor).strip() == "":
                return empty_result()

            return self.get_errors_async(
                file_id=file_id,
                cursor=next_cursor,
                limit=limit,
                offset=offset,
                retries=retries,
                server_url=server_url,
            )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return models.WdataGetErrorsResponse(
                result=unmarshal_json_response(
                    models.PagedResponseImportErrorDto, http_res
                ),
                next=next_func,
            )
        if utils.match_response(http_res, ["403", "404", "429"], "application/json"):
            response_data = unmarshal_json_response(errors.SingleErrorData, http_res)
            raise errors.SingleError(response_data, http_res)
        if utils.match_response(http_res, "500", "application/json"):
            response_data = unmarshal_json_response(errors.SingleErrorData, http_res)
            raise errors.SingleError(response_data, http_res)
        if utils.match_response(http_res, ["400", "401", "409", "423", "4XX"], "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)

        raise errors.SDKError("Unexpected response received", http_res)

    def get_file(
        self,
        *,
        file_id: str,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.BaseResponseFileMetaDto:
        r"""Retrieve a single file

        Returns the file meta that matches the provided ID, or a 404 if an associated file
        can't be found.

        :param file_id: The unique identifier of the file
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = models.WDATA_GET_FILE_OP_SERVERS[0]

        request = models.WdataGetFileRequest(
            file_id=file_id,
        )

        req = self._build_request(
            method="GET",
            path="/api/v1/file/{fileId}",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            allow_empty_value=None,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="wdata_getFile",
                oauth2_scopes=[],
                security_source=self.sdk_configuration.security,
            ),
            request=req,
            error_status_codes=[
                "400",
                "401",
                "403",
                "404",
                "409",
                "423",
                "429",
                "4XX",
                "500",
                "5XX",
            ],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(models.BaseResponseFileMetaDto, http_res)
        if utils.match_response(http_res, ["403", "404", "429"], "application/json"):
            response_data = unmarshal_json_response(errors.SingleErrorData, http_res)
            raise errors.SingleError(response_data, http_res)
        if utils.match_response(http_res, "500", "application/json"):
            response_data = unmarshal_json_response(errors.SingleErrorData, http_res)
            raise errors.SingleError(response_data, http_res)
        if utils.match_response(http_res, ["400", "401", "409", "423", "4XX"], "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)

        raise errors.SDKError("Unexpected response received", http_res)

    async def get_file_async(
        self,
        *,
        file_id: str,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.BaseResponseFileMetaDto:
        r"""Retrieve a single file

        Returns the file meta that matches the provided ID, or a 404 if an associated file
        can't be found.

        :param file_id: The unique identifier of the file
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = models.WDATA_GET_FILE_OP_SERVERS[0]

        request = models.WdataGetFileRequest(
            file_id=file_id,
        )

        req = self._build_request_async(
            method="GET",
            path="/api/v1/file/{fileId}",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            allow_empty_value=None,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="wdata_getFile",
                oauth2_scopes=[],
                security_source=self.sdk_configuration.security,
            ),
            request=req,
            error_status_codes=[
                "400",
                "401",
                "403",
                "404",
                "409",
                "423",
                "429",
                "4XX",
                "500",
                "5XX",
            ],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(models.BaseResponseFileMetaDto, http_res)
        if utils.match_response(http_res, ["403", "404", "429"], "application/json"):
            response_data = unmarshal_json_response(errors.SingleErrorData, http_res)
            raise errors.SingleError(response_data, http_res)
        if utils.match_response(http_res, "500", "application/json"):
            response_data = unmarshal_json_response(errors.SingleErrorData, http_res)
            raise errors.SingleError(response_data, http_res)
        if utils.match_response(http_res, ["400", "401", "409", "423", "4XX"], "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)

        raise errors.SDKError("Unexpected response received", http_res)

    def get_files(
        self,
        *,
        request: Union[
            models.WdataGetFilesRequest, models.WdataGetFilesRequestTypedDict
        ],
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> Optional[models.WdataGetFilesResponse]:
        r"""Retrieve a list of files

        Returns a paged list of all files associated with the provided table ID, as well
        as metadata associated with each file.

        :param request: The request object to send.
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = models.WDATA_GET_FILES_OP_SERVERS[0]

        if not isinstance(request, BaseModel):
            request = utils.unmarshal(request, models.WdataGetFilesRequest)
        request = cast(models.WdataGetFilesRequest, request)

        req = self._build_request(
            method="GET",
            path="/api/v1/file",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            allow_empty_value=None,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="wdata_getFiles",
                oauth2_scopes=[],
                security_source=self.sdk_configuration.security,
            ),
            request=req,
            error_status_codes=[
                "400",
                "401",
                "403",
                "404",
                "409",
                "423",
                "429",
                "4XX",
                "500",
                "5XX",
            ],
            retry_config=retry_config,
        )

        def next_func() -> Optional[models.WdataGetFilesResponse]:
            body = utils.unmarshal_json(http_res.text, Union[Dict[Any, Any], List[Any]])

            next_cursor = JSONPath("$.cursor").parse(body)

            if len(next_cursor) == 0:
                return None

            next_cursor = next_cursor[0]
            if next_cursor is None or str(next_cursor).strip() == "":
                return None

            return self.get_files(
                request=models.WdataGetFilesRequest(
                    table_id=request.table_id,
                    cursor=next_cursor,
                    limit=request.limit,
                    offset=request.offset,
                    search_text=request.search_text,
                    sort_by=request.sort_by,
                    sort_order=request.sort_order,
                ),
                retries=retries,
                server_url=server_url,
            )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return models.WdataGetFilesResponse(
                result=unmarshal_json_response(
                    models.PagedResponseFileMetaDto, http_res
                ),
                next=next_func,
            )
        if utils.match_response(http_res, ["403", "404", "429"], "application/json"):
            response_data = unmarshal_json_response(errors.SingleErrorData, http_res)
            raise errors.SingleError(response_data, http_res)
        if utils.match_response(http_res, "500", "application/json"):
            response_data = unmarshal_json_response(errors.SingleErrorData, http_res)
            raise errors.SingleError(response_data, http_res)
        if utils.match_response(http_res, ["400", "401", "409", "423", "4XX"], "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)

        raise errors.SDKError("Unexpected response received", http_res)

    async def get_files_async(
        self,
        *,
        request: Union[
            models.WdataGetFilesRequest, models.WdataGetFilesRequestTypedDict
        ],
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> Optional[models.WdataGetFilesResponse]:
        r"""Retrieve a list of files

        Returns a paged list of all files associated with the provided table ID, as well
        as metadata associated with each file.

        :param request: The request object to send.
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = models.WDATA_GET_FILES_OP_SERVERS[0]

        if not isinstance(request, BaseModel):
            request = utils.unmarshal(request, models.WdataGetFilesRequest)
        request = cast(models.WdataGetFilesRequest, request)

        req = self._build_request_async(
            method="GET",
            path="/api/v1/file",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            allow_empty_value=None,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="wdata_getFiles",
                oauth2_scopes=[],
                security_source=self.sdk_configuration.security,
            ),
            request=req,
            error_status_codes=[
                "400",
                "401",
                "403",
                "404",
                "409",
                "423",
                "429",
                "4XX",
                "500",
                "5XX",
            ],
            retry_config=retry_config,
        )

        def next_func() -> Awaitable[Optional[models.WdataGetFilesResponse]]:
            body = utils.unmarshal_json(http_res.text, Union[Dict[Any, Any], List[Any]])

            async def empty_result():
                return None

            next_cursor = JSONPath("$.cursor").parse(body)

            if len(next_cursor) == 0:
                return empty_result()

            next_cursor = next_cursor[0]
            if next_cursor is None or str(next_cursor).strip() == "":
                return empty_result()

            return self.get_files_async(
                request=models.WdataGetFilesRequest(
                    table_id=request.table_id,
                    cursor=next_cursor,
                    limit=request.limit,
                    offset=request.offset,
                    search_text=request.search_text,
                    sort_by=request.sort_by,
                    sort_order=request.sort_order,
                ),
                retries=retries,
                server_url=server_url,
            )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return models.WdataGetFilesResponse(
                result=unmarshal_json_response(
                    models.PagedResponseFileMetaDto, http_res
                ),
                next=next_func,
            )
        if utils.match_response(http_res, ["403", "404", "429"], "application/json"):
            response_data = unmarshal_json_response(errors.SingleErrorData, http_res)
            raise errors.SingleError(response_data, http_res)
        if utils.match_response(http_res, "500", "application/json"):
            response_data = unmarshal_json_response(errors.SingleErrorData, http_res)
            raise errors.SingleError(response_data, http_res)
        if utils.match_response(http_res, ["400", "401", "409", "423", "4XX"], "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)

        raise errors.SDKError("Unexpected response received", http_res)

    def get_folder(
        self,
        *,
        folder_id: str,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.BaseResponseFolderDto:
        r"""Retrieve a single folder

        Returns a folder with the provided ID, or a 404 if no matching folder is found.

        :param folder_id: The unique identifier of the folder
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = models.WDATA_GET_FOLDER_OP_SERVERS[0]

        request = models.WdataGetFolderRequest(
            folder_id=folder_id,
        )

        req = self._build_request(
            method="GET",
            path="/api/v1/folder/{folderId}",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            allow_empty_value=None,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="wdata_getFolder",
                oauth2_scopes=[],
                security_source=self.sdk_configuration.security,
            ),
            request=req,
            error_status_codes=[
                "400",
                "401",
                "403",
                "404",
                "409",
                "423",
                "429",
                "4XX",
                "500",
                "5XX",
            ],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(models.BaseResponseFolderDto, http_res)
        if utils.match_response(http_res, ["403", "404", "429"], "application/json"):
            response_data = unmarshal_json_response(errors.SingleErrorData, http_res)
            raise errors.SingleError(response_data, http_res)
        if utils.match_response(http_res, "500", "application/json"):
            response_data = unmarshal_json_response(errors.SingleErrorData, http_res)
            raise errors.SingleError(response_data, http_res)
        if utils.match_response(http_res, ["400", "401", "409", "423", "4XX"], "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)

        raise errors.SDKError("Unexpected response received", http_res)

    async def get_folder_async(
        self,
        *,
        folder_id: str,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.BaseResponseFolderDto:
        r"""Retrieve a single folder

        Returns a folder with the provided ID, or a 404 if no matching folder is found.

        :param folder_id: The unique identifier of the folder
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = models.WDATA_GET_FOLDER_OP_SERVERS[0]

        request = models.WdataGetFolderRequest(
            folder_id=folder_id,
        )

        req = self._build_request_async(
            method="GET",
            path="/api/v1/folder/{folderId}",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            allow_empty_value=None,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="wdata_getFolder",
                oauth2_scopes=[],
                security_source=self.sdk_configuration.security,
            ),
            request=req,
            error_status_codes=[
                "400",
                "401",
                "403",
                "404",
                "409",
                "423",
                "429",
                "4XX",
                "500",
                "5XX",
            ],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(models.BaseResponseFolderDto, http_res)
        if utils.match_response(http_res, ["403", "404", "429"], "application/json"):
            response_data = unmarshal_json_response(errors.SingleErrorData, http_res)
            raise errors.SingleError(response_data, http_res)
        if utils.match_response(http_res, "500", "application/json"):
            response_data = unmarshal_json_response(errors.SingleErrorData, http_res)
            raise errors.SingleError(response_data, http_res)
        if utils.match_response(http_res, ["400", "401", "409", "423", "4XX"], "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)

        raise errors.SDKError("Unexpected response received", http_res)

    def get_import_info(
        self,
        *,
        table_id: str,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.BaseResponseImportInfoDto:
        r"""Retrieve import information

        Returns information around imported files for a table.

        :param table_id: The unique identifier of the table
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = models.WDATA_GET_IMPORT_INFO_OP_SERVERS[0]

        request = models.WdataGetImportInfoRequest(
            table_id=table_id,
        )

        req = self._build_request(
            method="GET",
            path="/api/v1/table/{tableId}/importInfo",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            allow_empty_value=None,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="wdata_getImportInfo",
                oauth2_scopes=[],
                security_source=self.sdk_configuration.security,
            ),
            request=req,
            error_status_codes=[
                "400",
                "401",
                "403",
                "404",
                "409",
                "423",
                "429",
                "4XX",
                "500",
                "5XX",
            ],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(models.BaseResponseImportInfoDto, http_res)
        if utils.match_response(http_res, ["403", "404", "429"], "application/json"):
            response_data = unmarshal_json_response(errors.SingleErrorData, http_res)
            raise errors.SingleError(response_data, http_res)
        if utils.match_response(http_res, "500", "application/json"):
            response_data = unmarshal_json_response(errors.SingleErrorData, http_res)
            raise errors.SingleError(response_data, http_res)
        if utils.match_response(http_res, ["400", "401", "409", "423", "4XX"], "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)

        raise errors.SDKError("Unexpected response received", http_res)

    async def get_import_info_async(
        self,
        *,
        table_id: str,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.BaseResponseImportInfoDto:
        r"""Retrieve import information

        Returns information around imported files for a table.

        :param table_id: The unique identifier of the table
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = models.WDATA_GET_IMPORT_INFO_OP_SERVERS[0]

        request = models.WdataGetImportInfoRequest(
            table_id=table_id,
        )

        req = self._build_request_async(
            method="GET",
            path="/api/v1/table/{tableId}/importInfo",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            allow_empty_value=None,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="wdata_getImportInfo",
                oauth2_scopes=[],
                security_source=self.sdk_configuration.security,
            ),
            request=req,
            error_status_codes=[
                "400",
                "401",
                "403",
                "404",
                "409",
                "423",
                "429",
                "4XX",
                "500",
                "5XX",
            ],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(models.BaseResponseImportInfoDto, http_res)
        if utils.match_response(http_res, ["403", "404", "429"], "application/json"):
            response_data = unmarshal_json_response(errors.SingleErrorData, http_res)
            raise errors.SingleError(response_data, http_res)
        if utils.match_response(http_res, "500", "application/json"):
            response_data = unmarshal_json_response(errors.SingleErrorData, http_res)
            raise errors.SingleError(response_data, http_res)
        if utils.match_response(http_res, ["400", "401", "409", "423", "4XX"], "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)

        raise errors.SDKError("Unexpected response received", http_res)

    def get_parameter(
        self,
        *,
        parameter_id: str,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.BaseResponseGlobalParameterDto:
        r"""Get Parameter

        Returns a parameter matching the provided parameter ID.  If no matching entity can be found, a 404 status is returned.

        :param parameter_id: The unique identifier of the parameter
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = models.WDATA_GET_PARAMETER_OP_SERVERS[0]

        request = models.WdataGetParameterRequest(
            parameter_id=parameter_id,
        )

        req = self._build_request(
            method="GET",
            path="/api/v1/parameter/{parameterId}",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            allow_empty_value=None,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="wdata_getParameter",
                oauth2_scopes=[],
                security_source=self.sdk_configuration.security,
            ),
            request=req,
            error_status_codes=[
                "400",
                "401",
                "403",
                "404",
                "409",
                "423",
                "429",
                "4XX",
                "500",
                "5XX",
            ],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(
                models.BaseResponseGlobalParameterDto, http_res
            )
        if utils.match_response(http_res, ["403", "404", "429"], "application/json"):
            response_data = unmarshal_json_response(errors.SingleErrorData, http_res)
            raise errors.SingleError(response_data, http_res)
        if utils.match_response(http_res, "500", "application/json"):
            response_data = unmarshal_json_response(errors.SingleErrorData, http_res)
            raise errors.SingleError(response_data, http_res)
        if utils.match_response(http_res, ["400", "401", "409", "423", "4XX"], "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)

        raise errors.SDKError("Unexpected response received", http_res)

    async def get_parameter_async(
        self,
        *,
        parameter_id: str,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.BaseResponseGlobalParameterDto:
        r"""Get Parameter

        Returns a parameter matching the provided parameter ID.  If no matching entity can be found, a 404 status is returned.

        :param parameter_id: The unique identifier of the parameter
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = models.WDATA_GET_PARAMETER_OP_SERVERS[0]

        request = models.WdataGetParameterRequest(
            parameter_id=parameter_id,
        )

        req = self._build_request_async(
            method="GET",
            path="/api/v1/parameter/{parameterId}",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            allow_empty_value=None,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="wdata_getParameter",
                oauth2_scopes=[],
                security_source=self.sdk_configuration.security,
            ),
            request=req,
            error_status_codes=[
                "400",
                "401",
                "403",
                "404",
                "409",
                "423",
                "429",
                "4XX",
                "500",
                "5XX",
            ],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(
                models.BaseResponseGlobalParameterDto, http_res
            )
        if utils.match_response(http_res, ["403", "404", "429"], "application/json"):
            response_data = unmarshal_json_response(errors.SingleErrorData, http_res)
            raise errors.SingleError(response_data, http_res)
        if utils.match_response(http_res, "500", "application/json"):
            response_data = unmarshal_json_response(errors.SingleErrorData, http_res)
            raise errors.SingleError(response_data, http_res)
        if utils.match_response(http_res, ["400", "401", "409", "423", "4XX"], "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)

        raise errors.SDKError("Unexpected response received", http_res)

    def get_pivot_view(
        self,
        *,
        pivot_view_id: str,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.BaseResponsePivotViewDto:
        r"""Retrieve a single pivot view

        Returns a view with the provided ID, or a 404 if no view matches the ID.

        :param pivot_view_id: The unique identifier of the pivot view
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = models.WDATA_GET_PIVOT_VIEW_OP_SERVERS[0]

        request = models.WdataGetPivotViewRequest(
            pivot_view_id=pivot_view_id,
        )

        req = self._build_request(
            method="GET",
            path="/api/v1/pivotview/{pivotViewId}",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            allow_empty_value=None,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="wdata_getPivotView",
                oauth2_scopes=[],
                security_source=self.sdk_configuration.security,
            ),
            request=req,
            error_status_codes=[
                "400",
                "401",
                "403",
                "404",
                "409",
                "423",
                "429",
                "4XX",
                "500",
                "5XX",
            ],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(models.BaseResponsePivotViewDto, http_res)
        if utils.match_response(http_res, ["403", "404", "429"], "application/json"):
            response_data = unmarshal_json_response(errors.SingleErrorData, http_res)
            raise errors.SingleError(response_data, http_res)
        if utils.match_response(http_res, "500", "application/json"):
            response_data = unmarshal_json_response(errors.SingleErrorData, http_res)
            raise errors.SingleError(response_data, http_res)
        if utils.match_response(http_res, ["400", "401", "409", "423", "4XX"], "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)

        raise errors.SDKError("Unexpected response received", http_res)

    async def get_pivot_view_async(
        self,
        *,
        pivot_view_id: str,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.BaseResponsePivotViewDto:
        r"""Retrieve a single pivot view

        Returns a view with the provided ID, or a 404 if no view matches the ID.

        :param pivot_view_id: The unique identifier of the pivot view
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = models.WDATA_GET_PIVOT_VIEW_OP_SERVERS[0]

        request = models.WdataGetPivotViewRequest(
            pivot_view_id=pivot_view_id,
        )

        req = self._build_request_async(
            method="GET",
            path="/api/v1/pivotview/{pivotViewId}",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            allow_empty_value=None,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="wdata_getPivotView",
                oauth2_scopes=[],
                security_source=self.sdk_configuration.security,
            ),
            request=req,
            error_status_codes=[
                "400",
                "401",
                "403",
                "404",
                "409",
                "423",
                "429",
                "4XX",
                "500",
                "5XX",
            ],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(models.BaseResponsePivotViewDto, http_res)
        if utils.match_response(http_res, ["403", "404", "429"], "application/json"):
            response_data = unmarshal_json_response(errors.SingleErrorData, http_res)
            raise errors.SingleError(response_data, http_res)
        if utils.match_response(http_res, "500", "application/json"):
            response_data = unmarshal_json_response(errors.SingleErrorData, http_res)
            raise errors.SingleError(response_data, http_res)
        if utils.match_response(http_res, ["400", "401", "409", "423", "4XX"], "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)

        raise errors.SDKError("Unexpected response received", http_res)

    def get_query(
        self,
        *,
        query_id: str,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.BaseResponseQueryDto:
        r"""Retrieve a single query

        Returns a query that matches the provided ID, or a 404 if no matching query is found.

        :param query_id: The unique identifier of the query
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = models.WDATA_GET_QUERY_OP_SERVERS[0]

        request = models.WdataGetQueryRequest(
            query_id=query_id,
        )

        req = self._build_request(
            method="GET",
            path="/api/v1/query/{queryId}",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            allow_empty_value=None,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="wdata_getQuery",
                oauth2_scopes=[],
                security_source=self.sdk_configuration.security,
            ),
            request=req,
            error_status_codes=[
                "400",
                "401",
                "403",
                "404",
                "409",
                "423",
                "429",
                "4XX",
                "500",
                "5XX",
            ],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(models.BaseResponseQueryDto, http_res)
        if utils.match_response(http_res, ["403", "404", "429"], "application/json"):
            response_data = unmarshal_json_response(errors.SingleErrorData, http_res)
            raise errors.SingleError(response_data, http_res)
        if utils.match_response(http_res, "500", "application/json"):
            response_data = unmarshal_json_response(errors.SingleErrorData, http_res)
            raise errors.SingleError(response_data, http_res)
        if utils.match_response(http_res, ["400", "401", "409", "423", "4XX"], "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)

        raise errors.SDKError("Unexpected response received", http_res)

    async def get_query_async(
        self,
        *,
        query_id: str,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.BaseResponseQueryDto:
        r"""Retrieve a single query

        Returns a query that matches the provided ID, or a 404 if no matching query is found.

        :param query_id: The unique identifier of the query
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = models.WDATA_GET_QUERY_OP_SERVERS[0]

        request = models.WdataGetQueryRequest(
            query_id=query_id,
        )

        req = self._build_request_async(
            method="GET",
            path="/api/v1/query/{queryId}",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            allow_empty_value=None,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="wdata_getQuery",
                oauth2_scopes=[],
                security_source=self.sdk_configuration.security,
            ),
            request=req,
            error_status_codes=[
                "400",
                "401",
                "403",
                "404",
                "409",
                "423",
                "429",
                "4XX",
                "500",
                "5XX",
            ],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(models.BaseResponseQueryDto, http_res)
        if utils.match_response(http_res, ["403", "404", "429"], "application/json"):
            response_data = unmarshal_json_response(errors.SingleErrorData, http_res)
            raise errors.SingleError(response_data, http_res)
        if utils.match_response(http_res, "500", "application/json"):
            response_data = unmarshal_json_response(errors.SingleErrorData, http_res)
            raise errors.SingleError(response_data, http_res)
        if utils.match_response(http_res, ["400", "401", "409", "423", "4XX"], "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)

        raise errors.SDKError("Unexpected response received", http_res)

    def get_query_column_data(
        self,
        *,
        request: Union[models.QueryTextDto, models.QueryTextDtoTypedDict],
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.BaseResponseQueryColumnDataDto:
        r"""Retrieve query column data

        Returns a QueryColumnDataDto representing the column data for the given query text.
        If the query isn't valid, returns a 400.

        :param request: The request object to send.
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = models.WDATA_GET_QUERY_COLUMN_DATA_OP_SERVERS[0]

        if not isinstance(request, BaseModel):
            request = utils.unmarshal(request, models.QueryTextDto)
        request = cast(models.QueryTextDto, request)

        req = self._build_request(
            method="POST",
            path="/api/v1/query/data",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request, False, False, "json", models.QueryTextDto
            ),
            allow_empty_value=None,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="wdata_getQueryColumnData",
                oauth2_scopes=[],
                security_source=self.sdk_configuration.security,
            ),
            request=req,
            error_status_codes=[
                "400",
                "401",
                "403",
                "404",
                "409",
                "423",
                "429",
                "4XX",
                "500",
                "5XX",
            ],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(
                models.BaseResponseQueryColumnDataDto, http_res
            )
        if utils.match_response(http_res, "400", "application/json"):
            response_data = unmarshal_json_response(errors.MultiErrorData, http_res)
            raise errors.MultiError(response_data, http_res)
        if utils.match_response(
            http_res, ["401", "403", "404", "409", "429"], "application/json"
        ):
            response_data = unmarshal_json_response(errors.SingleErrorData, http_res)
            raise errors.SingleError(response_data, http_res)
        if utils.match_response(http_res, "500", "application/json"):
            response_data = unmarshal_json_response(errors.SingleErrorData, http_res)
            raise errors.SingleError(response_data, http_res)
        if utils.match_response(http_res, ["423", "4XX"], "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)

        raise errors.SDKError("Unexpected response received", http_res)

    async def get_query_column_data_async(
        self,
        *,
        request: Union[models.QueryTextDto, models.QueryTextDtoTypedDict],
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.BaseResponseQueryColumnDataDto:
        r"""Retrieve query column data

        Returns a QueryColumnDataDto representing the column data for the given query text.
        If the query isn't valid, returns a 400.

        :param request: The request object to send.
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = models.WDATA_GET_QUERY_COLUMN_DATA_OP_SERVERS[0]

        if not isinstance(request, BaseModel):
            request = utils.unmarshal(request, models.QueryTextDto)
        request = cast(models.QueryTextDto, request)

        req = self._build_request_async(
            method="POST",
            path="/api/v1/query/data",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request, False, False, "json", models.QueryTextDto
            ),
            allow_empty_value=None,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="wdata_getQueryColumnData",
                oauth2_scopes=[],
                security_source=self.sdk_configuration.security,
            ),
            request=req,
            error_status_codes=[
                "400",
                "401",
                "403",
                "404",
                "409",
                "423",
                "429",
                "4XX",
                "500",
                "5XX",
            ],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(
                models.BaseResponseQueryColumnDataDto, http_res
            )
        if utils.match_response(http_res, "400", "application/json"):
            response_data = unmarshal_json_response(errors.MultiErrorData, http_res)
            raise errors.MultiError(response_data, http_res)
        if utils.match_response(
            http_res, ["401", "403", "404", "409", "429"], "application/json"
        ):
            response_data = unmarshal_json_response(errors.SingleErrorData, http_res)
            raise errors.SingleError(response_data, http_res)
        if utils.match_response(http_res, "500", "application/json"):
            response_data = unmarshal_json_response(errors.SingleErrorData, http_res)
            raise errors.SingleError(response_data, http_res)
        if utils.match_response(http_res, ["423", "4XX"], "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)

        raise errors.SDKError("Unexpected response received", http_res)

    def get_query_result(
        self,
        *,
        query_result_id: str,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.BaseResponseQueryResultDto:
        r"""Retrieve a single query result

        Returns a single query result that matches the provided ID, or a 404 if no such
        query result is found.

        :param query_result_id: The unique identifier of the query result
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = models.WDATA_GET_QUERY_RESULT_OP_SERVERS[0]

        request = models.WdataGetQueryResultRequest(
            query_result_id=query_result_id,
        )

        req = self._build_request(
            method="GET",
            path="/api/v1/queryresult/{queryResultId}",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            allow_empty_value=None,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="wdata_getQueryResult",
                oauth2_scopes=[],
                security_source=self.sdk_configuration.security,
            ),
            request=req,
            error_status_codes=[
                "400",
                "401",
                "403",
                "404",
                "409",
                "423",
                "429",
                "4XX",
                "500",
                "5XX",
            ],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(models.BaseResponseQueryResultDto, http_res)
        if utils.match_response(http_res, ["403", "404", "429"], "application/json"):
            response_data = unmarshal_json_response(errors.SingleErrorData, http_res)
            raise errors.SingleError(response_data, http_res)
        if utils.match_response(http_res, "500", "application/json"):
            response_data = unmarshal_json_response(errors.SingleErrorData, http_res)
            raise errors.SingleError(response_data, http_res)
        if utils.match_response(http_res, ["400", "401", "409", "423", "4XX"], "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)

        raise errors.SDKError("Unexpected response received", http_res)

    async def get_query_result_async(
        self,
        *,
        query_result_id: str,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.BaseResponseQueryResultDto:
        r"""Retrieve a single query result

        Returns a single query result that matches the provided ID, or a 404 if no such
        query result is found.

        :param query_result_id: The unique identifier of the query result
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = models.WDATA_GET_QUERY_RESULT_OP_SERVERS[0]

        request = models.WdataGetQueryResultRequest(
            query_result_id=query_result_id,
        )

        req = self._build_request_async(
            method="GET",
            path="/api/v1/queryresult/{queryResultId}",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            allow_empty_value=None,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="wdata_getQueryResult",
                oauth2_scopes=[],
                security_source=self.sdk_configuration.security,
            ),
            request=req,
            error_status_codes=[
                "400",
                "401",
                "403",
                "404",
                "409",
                "423",
                "429",
                "4XX",
                "500",
                "5XX",
            ],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(models.BaseResponseQueryResultDto, http_res)
        if utils.match_response(http_res, ["403", "404", "429"], "application/json"):
            response_data = unmarshal_json_response(errors.SingleErrorData, http_res)
            raise errors.SingleError(response_data, http_res)
        if utils.match_response(http_res, "500", "application/json"):
            response_data = unmarshal_json_response(errors.SingleErrorData, http_res)
            raise errors.SingleError(response_data, http_res)
        if utils.match_response(http_res, ["400", "401", "409", "423", "4XX"], "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)

        raise errors.SDKError("Unexpected response received", http_res)

    def get_refresh_batch_status(
        self,
        *,
        batch_id: str,
        workspace_id: Optional[str] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.BaseResponseRefreshBatchDto:
        r"""Gets the status of a batch refresh

        Returns details about a specific batch refresh, based on its ID.

        :param batch_id: The ID of the batch to return details about
        :param workspace_id:
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = models.WDATA_GET_REFRESH_BATCH_STATUS_OP_SERVERS[0]

        request = models.WdataGetRefreshBatchStatusRequest(
            batch_id=batch_id,
            workspace_id=workspace_id,
        )

        req = self._build_request(
            method="GET",
            path="/api/v1/connections/batch/refresh/{batchId}",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            allow_empty_value=None,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="wdata_getRefreshBatchStatus",
                oauth2_scopes=[],
                security_source=self.sdk_configuration.security,
            ),
            request=req,
            error_status_codes=[
                "400",
                "401",
                "403",
                "404",
                "409",
                "423",
                "429",
                "4XX",
                "500",
                "5XX",
            ],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(models.BaseResponseRefreshBatchDto, http_res)
        if utils.match_response(http_res, "400", "application/json"):
            response_data = unmarshal_json_response(errors.MultiErrorData, http_res)
            raise errors.MultiError(response_data, http_res)
        if utils.match_response(
            http_res, ["401", "403", "404", "409", "429"], "application/json"
        ):
            response_data = unmarshal_json_response(errors.SingleErrorData, http_res)
            raise errors.SingleError(response_data, http_res)
        if utils.match_response(http_res, "500", "application/json"):
            response_data = unmarshal_json_response(errors.SingleErrorData, http_res)
            raise errors.SingleError(response_data, http_res)
        if utils.match_response(http_res, ["423", "4XX"], "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)

        raise errors.SDKError("Unexpected response received", http_res)

    async def get_refresh_batch_status_async(
        self,
        *,
        batch_id: str,
        workspace_id: Optional[str] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.BaseResponseRefreshBatchDto:
        r"""Gets the status of a batch refresh

        Returns details about a specific batch refresh, based on its ID.

        :param batch_id: The ID of the batch to return details about
        :param workspace_id:
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = models.WDATA_GET_REFRESH_BATCH_STATUS_OP_SERVERS[0]

        request = models.WdataGetRefreshBatchStatusRequest(
            batch_id=batch_id,
            workspace_id=workspace_id,
        )

        req = self._build_request_async(
            method="GET",
            path="/api/v1/connections/batch/refresh/{batchId}",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            allow_empty_value=None,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="wdata_getRefreshBatchStatus",
                oauth2_scopes=[],
                security_source=self.sdk_configuration.security,
            ),
            request=req,
            error_status_codes=[
                "400",
                "401",
                "403",
                "404",
                "409",
                "423",
                "429",
                "4XX",
                "500",
                "5XX",
            ],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(models.BaseResponseRefreshBatchDto, http_res)
        if utils.match_response(http_res, "400", "application/json"):
            response_data = unmarshal_json_response(errors.MultiErrorData, http_res)
            raise errors.MultiError(response_data, http_res)
        if utils.match_response(
            http_res, ["401", "403", "404", "409", "429"], "application/json"
        ):
            response_data = unmarshal_json_response(errors.SingleErrorData, http_res)
            raise errors.SingleError(response_data, http_res)
        if utils.match_response(http_res, "500", "application/json"):
            response_data = unmarshal_json_response(errors.SingleErrorData, http_res)
            raise errors.SingleError(response_data, http_res)
        if utils.match_response(http_res, ["423", "4XX"], "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)

        raise errors.SDKError("Unexpected response received", http_res)

    def get_refresh_status(
        self,
        *,
        connection_id: str,
        job_id: Optional[str] = None,
        workspace_id: Optional[str] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.BaseResponseConnectionRunDto:
        r"""Get connection refresh status

        Returns details about a specific connection refresh status, based on its ID. To retrieve details about a specific refresh, provide its 'jobId'.

        :param connection_id: The ID of the connection to return details about
        :param job_id: The ID of the job running for a connection
        :param workspace_id:
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = models.WDATA_GET_REFRESH_STATUS_OP_SERVERS[0]

        request = models.WdataGetRefreshStatusRequest(
            connection_id=connection_id,
            job_id=job_id,
            workspace_id=workspace_id,
        )

        req = self._build_request(
            method="GET",
            path="/api/v1/connections/{connectionId}/status",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            allow_empty_value=None,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="wdata_getRefreshStatus",
                oauth2_scopes=[],
                security_source=self.sdk_configuration.security,
            ),
            request=req,
            error_status_codes=[
                "400",
                "401",
                "403",
                "404",
                "409",
                "423",
                "429",
                "4XX",
                "500",
                "5XX",
            ],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(
                models.BaseResponseConnectionRunDto, http_res
            )
        if utils.match_response(http_res, ["403", "404", "429"], "application/json"):
            response_data = unmarshal_json_response(errors.SingleErrorData, http_res)
            raise errors.SingleError(response_data, http_res)
        if utils.match_response(http_res, "500", "application/json"):
            response_data = unmarshal_json_response(errors.SingleErrorData, http_res)
            raise errors.SingleError(response_data, http_res)
        if utils.match_response(http_res, ["400", "401", "409", "423", "4XX"], "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)

        raise errors.SDKError("Unexpected response received", http_res)

    async def get_refresh_status_async(
        self,
        *,
        connection_id: str,
        job_id: Optional[str] = None,
        workspace_id: Optional[str] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.BaseResponseConnectionRunDto:
        r"""Get connection refresh status

        Returns details about a specific connection refresh status, based on its ID. To retrieve details about a specific refresh, provide its 'jobId'.

        :param connection_id: The ID of the connection to return details about
        :param job_id: The ID of the job running for a connection
        :param workspace_id:
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = models.WDATA_GET_REFRESH_STATUS_OP_SERVERS[0]

        request = models.WdataGetRefreshStatusRequest(
            connection_id=connection_id,
            job_id=job_id,
            workspace_id=workspace_id,
        )

        req = self._build_request_async(
            method="GET",
            path="/api/v1/connections/{connectionId}/status",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            allow_empty_value=None,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="wdata_getRefreshStatus",
                oauth2_scopes=[],
                security_source=self.sdk_configuration.security,
            ),
            request=req,
            error_status_codes=[
                "400",
                "401",
                "403",
                "404",
                "409",
                "423",
                "429",
                "4XX",
                "500",
                "5XX",
            ],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(
                models.BaseResponseConnectionRunDto, http_res
            )
        if utils.match_response(http_res, ["403", "404", "429"], "application/json"):
            response_data = unmarshal_json_response(errors.SingleErrorData, http_res)
            raise errors.SingleError(response_data, http_res)
        if utils.match_response(http_res, "500", "application/json"):
            response_data = unmarshal_json_response(errors.SingleErrorData, http_res)
            raise errors.SingleError(response_data, http_res)
        if utils.match_response(http_res, ["400", "401", "409", "423", "4XX"], "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)

        raise errors.SDKError("Unexpected response received", http_res)

    def get_select_list(
        self,
        *,
        select_list_id: str,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.BaseResponseSelectListDto:
        r"""Retrieve a single select list

        Returns a select list that matches the provided ID, or a 404 if no matching select
        list is found.

        :param select_list_id: The unique identifier of the select list
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = models.WDATA_GET_SELECT_LIST_OP_SERVERS[0]

        request = models.WdataGetSelectListRequest(
            select_list_id=select_list_id,
        )

        req = self._build_request(
            method="GET",
            path="/api/v1/selectlist/{selectListId}",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            allow_empty_value=None,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="wdata_getSelectList",
                oauth2_scopes=[],
                security_source=self.sdk_configuration.security,
            ),
            request=req,
            error_status_codes=[
                "400",
                "401",
                "403",
                "404",
                "409",
                "423",
                "429",
                "4XX",
                "500",
                "5XX",
            ],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(models.BaseResponseSelectListDto, http_res)
        if utils.match_response(http_res, ["403", "404", "429"], "application/json"):
            response_data = unmarshal_json_response(errors.SingleErrorData, http_res)
            raise errors.SingleError(response_data, http_res)
        if utils.match_response(http_res, "500", "application/json"):
            response_data = unmarshal_json_response(errors.SingleErrorData, http_res)
            raise errors.SingleError(response_data, http_res)
        if utils.match_response(http_res, ["400", "401", "409", "423", "4XX"], "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)

        raise errors.SDKError("Unexpected response received", http_res)

    async def get_select_list_async(
        self,
        *,
        select_list_id: str,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.BaseResponseSelectListDto:
        r"""Retrieve a single select list

        Returns a select list that matches the provided ID, or a 404 if no matching select
        list is found.

        :param select_list_id: The unique identifier of the select list
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = models.WDATA_GET_SELECT_LIST_OP_SERVERS[0]

        request = models.WdataGetSelectListRequest(
            select_list_id=select_list_id,
        )

        req = self._build_request_async(
            method="GET",
            path="/api/v1/selectlist/{selectListId}",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            allow_empty_value=None,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="wdata_getSelectList",
                oauth2_scopes=[],
                security_source=self.sdk_configuration.security,
            ),
            request=req,
            error_status_codes=[
                "400",
                "401",
                "403",
                "404",
                "409",
                "423",
                "429",
                "4XX",
                "500",
                "5XX",
            ],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(models.BaseResponseSelectListDto, http_res)
        if utils.match_response(http_res, ["403", "404", "429"], "application/json"):
            response_data = unmarshal_json_response(errors.SingleErrorData, http_res)
            raise errors.SingleError(response_data, http_res)
        if utils.match_response(http_res, "500", "application/json"):
            response_data = unmarshal_json_response(errors.SingleErrorData, http_res)
            raise errors.SingleError(response_data, http_res)
        if utils.match_response(http_res, ["400", "401", "409", "423", "4XX"], "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)

        raise errors.SDKError("Unexpected response received", http_res)

    def get_shared_table(
        self,
        *,
        shared_table_id: str,
        shared_with_me: Optional[bool] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.BaseResponseSharedTableDto:
        r"""Retrieve a single shared table

        Returns a shared table that matches the provided ID, or a 404 if no matching shared table is found.

        :param shared_table_id: The unique identifier of the shared table
        :param shared_with_me: If true, returns a shared table with the provided ID that has been shared _to_rather than fromthe workspace of the request.
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = models.WDATA_GET_SHARED_TABLE_OP_SERVERS[0]

        request = models.WdataGetSharedTableRequest(
            shared_table_id=shared_table_id,
            shared_with_me=shared_with_me,
        )

        req = self._build_request(
            method="GET",
            path="/api/v1/sharedtable/{sharedTableId}",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            allow_empty_value=None,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="wdata_getSharedTable",
                oauth2_scopes=[],
                security_source=self.sdk_configuration.security,
            ),
            request=req,
            error_status_codes=[
                "400",
                "401",
                "403",
                "404",
                "409",
                "423",
                "429",
                "4XX",
                "500",
                "5XX",
            ],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(models.BaseResponseSharedTableDto, http_res)
        if utils.match_response(http_res, ["403", "404", "429"], "application/json"):
            response_data = unmarshal_json_response(errors.SingleErrorData, http_res)
            raise errors.SingleError(response_data, http_res)
        if utils.match_response(http_res, "500", "application/json"):
            response_data = unmarshal_json_response(errors.SingleErrorData, http_res)
            raise errors.SingleError(response_data, http_res)
        if utils.match_response(http_res, ["400", "401", "409", "423", "4XX"], "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)

        raise errors.SDKError("Unexpected response received", http_res)

    async def get_shared_table_async(
        self,
        *,
        shared_table_id: str,
        shared_with_me: Optional[bool] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.BaseResponseSharedTableDto:
        r"""Retrieve a single shared table

        Returns a shared table that matches the provided ID, or a 404 if no matching shared table is found.

        :param shared_table_id: The unique identifier of the shared table
        :param shared_with_me: If true, returns a shared table with the provided ID that has been shared _to_rather than fromthe workspace of the request.
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = models.WDATA_GET_SHARED_TABLE_OP_SERVERS[0]

        request = models.WdataGetSharedTableRequest(
            shared_table_id=shared_table_id,
            shared_with_me=shared_with_me,
        )

        req = self._build_request_async(
            method="GET",
            path="/api/v1/sharedtable/{sharedTableId}",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            allow_empty_value=None,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="wdata_getSharedTable",
                oauth2_scopes=[],
                security_source=self.sdk_configuration.security,
            ),
            request=req,
            error_status_codes=[
                "400",
                "401",
                "403",
                "404",
                "409",
                "423",
                "429",
                "4XX",
                "500",
                "5XX",
            ],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(models.BaseResponseSharedTableDto, http_res)
        if utils.match_response(http_res, ["403", "404", "429"], "application/json"):
            response_data = unmarshal_json_response(errors.SingleErrorData, http_res)
            raise errors.SingleError(response_data, http_res)
        if utils.match_response(http_res, "500", "application/json"):
            response_data = unmarshal_json_response(errors.SingleErrorData, http_res)
            raise errors.SingleError(response_data, http_res)
        if utils.match_response(http_res, ["400", "401", "409", "423", "4XX"], "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)

        raise errors.SDKError("Unexpected response received", http_res)

    def get_table(
        self,
        *,
        table_id: str,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.BaseResponseTableDto:
        r"""Retrieve a single table

        Returns a table with the provided ID, or a 404 if no such table is found.

        :param table_id: The unique identifier of the table
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = models.WDATA_GET_TABLE_OP_SERVERS[0]

        request = models.WdataGetTableRequest(
            table_id=table_id,
        )

        req = self._build_request(
            method="GET",
            path="/api/v1/table/{tableId}",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            allow_empty_value=None,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="wdata_getTable",
                oauth2_scopes=[],
                security_source=self.sdk_configuration.security,
            ),
            request=req,
            error_status_codes=[
                "400",
                "401",
                "403",
                "404",
                "409",
                "423",
                "429",
                "4XX",
                "500",
                "5XX",
            ],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(models.BaseResponseTableDto, http_res)
        if utils.match_response(http_res, ["403", "404", "429"], "application/json"):
            response_data = unmarshal_json_response(errors.SingleErrorData, http_res)
            raise errors.SingleError(response_data, http_res)
        if utils.match_response(http_res, "500", "application/json"):
            response_data = unmarshal_json_response(errors.SingleErrorData, http_res)
            raise errors.SingleError(response_data, http_res)
        if utils.match_response(http_res, ["400", "401", "409", "423", "4XX"], "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)

        raise errors.SDKError("Unexpected response received", http_res)

    async def get_table_async(
        self,
        *,
        table_id: str,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.BaseResponseTableDto:
        r"""Retrieve a single table

        Returns a table with the provided ID, or a 404 if no such table is found.

        :param table_id: The unique identifier of the table
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = models.WDATA_GET_TABLE_OP_SERVERS[0]

        request = models.WdataGetTableRequest(
            table_id=table_id,
        )

        req = self._build_request_async(
            method="GET",
            path="/api/v1/table/{tableId}",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            allow_empty_value=None,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="wdata_getTable",
                oauth2_scopes=[],
                security_source=self.sdk_configuration.security,
            ),
            request=req,
            error_status_codes=[
                "400",
                "401",
                "403",
                "404",
                "409",
                "423",
                "429",
                "4XX",
                "500",
                "5XX",
            ],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(models.BaseResponseTableDto, http_res)
        if utils.match_response(http_res, ["403", "404", "429"], "application/json"):
            response_data = unmarshal_json_response(errors.SingleErrorData, http_res)
            raise errors.SingleError(response_data, http_res)
        if utils.match_response(http_res, "500", "application/json"):
            response_data = unmarshal_json_response(errors.SingleErrorData, http_res)
            raise errors.SingleError(response_data, http_res)
        if utils.match_response(http_res, ["400", "401", "409", "423", "4XX"], "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)

        raise errors.SDKError("Unexpected response received", http_res)

    def get_tables(
        self,
        *,
        cursor: Optional[str] = None,
        include_shared: Optional[bool] = False,
        limit: Optional[int] = 1000,
        offset: Optional[int] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> Optional[models.WdataGetTablesResponse]:
        r"""Retrieve a list of tables

        Returns all tables available in the workspace.

        :param cursor: a paging cursor; if included the limit is ignored
        :param include_shared: If true, returns all tables shared with the workspace associated with the request. If false, returns only tables the workspace owns.
        :param limit: the number of folders to return, from 1 to 1000; by default, 1000
        :param offset: The item to start with on the page, must be greater than or equal to 0, will default to 0
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = models.WDATA_GET_TABLES_OP_SERVERS[0]

        request = models.WdataGetTablesRequest(
            cursor=cursor,
            include_shared=include_shared,
            limit=limit,
            offset=offset,
        )

        req = self._build_request(
            method="GET",
            path="/api/v1/table",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            allow_empty_value=None,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="wdata_getTables",
                oauth2_scopes=[],
                security_source=self.sdk_configuration.security,
            ),
            request=req,
            error_status_codes=[
                "400",
                "401",
                "403",
                "404",
                "409",
                "423",
                "429",
                "4XX",
                "500",
                "5XX",
            ],
            retry_config=retry_config,
        )

        def next_func() -> Optional[models.WdataGetTablesResponse]:
            body = utils.unmarshal_json(http_res.text, Union[Dict[Any, Any], List[Any]])

            next_cursor = JSONPath("$.cursor").parse(body)

            if len(next_cursor) == 0:
                return None

            next_cursor = next_cursor[0]
            if next_cursor is None or str(next_cursor).strip() == "":
                return None

            return self.get_tables(
                cursor=next_cursor,
                include_shared=include_shared,
                limit=limit,
                offset=offset,
                retries=retries,
                server_url=server_url,
            )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return models.WdataGetTablesResponse(
                result=unmarshal_json_response(models.PagedResponseTableDto, http_res),
                next=next_func,
            )
        if utils.match_response(http_res, ["403", "404", "429"], "application/json"):
            response_data = unmarshal_json_response(errors.SingleErrorData, http_res)
            raise errors.SingleError(response_data, http_res)
        if utils.match_response(http_res, "500", "application/json"):
            response_data = unmarshal_json_response(errors.SingleErrorData, http_res)
            raise errors.SingleError(response_data, http_res)
        if utils.match_response(http_res, ["400", "401", "409", "423", "4XX"], "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)

        raise errors.SDKError("Unexpected response received", http_res)

    async def get_tables_async(
        self,
        *,
        cursor: Optional[str] = None,
        include_shared: Optional[bool] = False,
        limit: Optional[int] = 1000,
        offset: Optional[int] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> Optional[models.WdataGetTablesResponse]:
        r"""Retrieve a list of tables

        Returns all tables available in the workspace.

        :param cursor: a paging cursor; if included the limit is ignored
        :param include_shared: If true, returns all tables shared with the workspace associated with the request. If false, returns only tables the workspace owns.
        :param limit: the number of folders to return, from 1 to 1000; by default, 1000
        :param offset: The item to start with on the page, must be greater than or equal to 0, will default to 0
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = models.WDATA_GET_TABLES_OP_SERVERS[0]

        request = models.WdataGetTablesRequest(
            cursor=cursor,
            include_shared=include_shared,
            limit=limit,
            offset=offset,
        )

        req = self._build_request_async(
            method="GET",
            path="/api/v1/table",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            allow_empty_value=None,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="wdata_getTables",
                oauth2_scopes=[],
                security_source=self.sdk_configuration.security,
            ),
            request=req,
            error_status_codes=[
                "400",
                "401",
                "403",
                "404",
                "409",
                "423",
                "429",
                "4XX",
                "500",
                "5XX",
            ],
            retry_config=retry_config,
        )

        def next_func() -> Awaitable[Optional[models.WdataGetTablesResponse]]:
            body = utils.unmarshal_json(http_res.text, Union[Dict[Any, Any], List[Any]])

            async def empty_result():
                return None

            next_cursor = JSONPath("$.cursor").parse(body)

            if len(next_cursor) == 0:
                return empty_result()

            next_cursor = next_cursor[0]
            if next_cursor is None or str(next_cursor).strip() == "":
                return empty_result()

            return self.get_tables_async(
                cursor=next_cursor,
                include_shared=include_shared,
                limit=limit,
                offset=offset,
                retries=retries,
                server_url=server_url,
            )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return models.WdataGetTablesResponse(
                result=unmarshal_json_response(models.PagedResponseTableDto, http_res),
                next=next_func,
            )
        if utils.match_response(http_res, ["403", "404", "429"], "application/json"):
            response_data = unmarshal_json_response(errors.SingleErrorData, http_res)
            raise errors.SingleError(response_data, http_res)
        if utils.match_response(http_res, "500", "application/json"):
            response_data = unmarshal_json_response(errors.SingleErrorData, http_res)
            raise errors.SingleError(response_data, http_res)
        if utils.match_response(http_res, ["400", "401", "409", "423", "4XX"], "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)

        raise errors.SDKError("Unexpected response received", http_res)

    def get_tables_dependent_on_query(
        self,
        *,
        query_id: str,
        cursor: Optional[str] = None,
        limit: Optional[int] = 1000,
        offset: Optional[int] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> Optional[models.WdataGetTablesDependentOnQueryResponse]:
        r"""Retrieve a list of dependents

        Returns a list of all tables that use the query with provided ID as a datasource.

        :param query_id: The unique identifier of the query
        :param cursor: A paging cursor; if included, `limit` is ignored
        :param limit: The number of folders to return, from 1 to 1000; by default, 1000
        :param offset: The item to start with on the page, greater than or equal to 0; by default, 0
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = models.WDATA_GET_TABLES_DEPENDENT_ON_QUERY_OP_SERVERS[0]

        request = models.WdataGetTablesDependentOnQueryRequest(
            cursor=cursor,
            limit=limit,
            offset=offset,
            query_id=query_id,
        )

        req = self._build_request(
            method="GET",
            path="/api/v1/query/{queryId}/dependents",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            allow_empty_value=None,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="wdata_getTablesDependentOnQuery",
                oauth2_scopes=[],
                security_source=self.sdk_configuration.security,
            ),
            request=req,
            error_status_codes=[
                "400",
                "401",
                "403",
                "404",
                "409",
                "423",
                "429",
                "4XX",
                "500",
                "5XX",
            ],
            retry_config=retry_config,
        )

        def next_func() -> Optional[models.WdataGetTablesDependentOnQueryResponse]:
            body = utils.unmarshal_json(http_res.text, Union[Dict[Any, Any], List[Any]])

            next_cursor = JSONPath("$.cursor").parse(body)

            if len(next_cursor) == 0:
                return None

            next_cursor = next_cursor[0]
            if next_cursor is None or str(next_cursor).strip() == "":
                return None

            return self.get_tables_dependent_on_query(
                query_id=query_id,
                cursor=next_cursor,
                limit=limit,
                offset=offset,
                retries=retries,
                server_url=server_url,
            )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return models.WdataGetTablesDependentOnQueryResponse(
                result=unmarshal_json_response(models.PagedResponseTableDto, http_res),
                next=next_func,
            )
        if utils.match_response(http_res, ["403", "404", "429"], "application/json"):
            response_data = unmarshal_json_response(errors.SingleErrorData, http_res)
            raise errors.SingleError(response_data, http_res)
        if utils.match_response(http_res, "500", "application/json"):
            response_data = unmarshal_json_response(errors.SingleErrorData, http_res)
            raise errors.SingleError(response_data, http_res)
        if utils.match_response(http_res, ["400", "401", "409", "423", "4XX"], "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)

        raise errors.SDKError("Unexpected response received", http_res)

    async def get_tables_dependent_on_query_async(
        self,
        *,
        query_id: str,
        cursor: Optional[str] = None,
        limit: Optional[int] = 1000,
        offset: Optional[int] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> Optional[models.WdataGetTablesDependentOnQueryResponse]:
        r"""Retrieve a list of dependents

        Returns a list of all tables that use the query with provided ID as a datasource.

        :param query_id: The unique identifier of the query
        :param cursor: A paging cursor; if included, `limit` is ignored
        :param limit: The number of folders to return, from 1 to 1000; by default, 1000
        :param offset: The item to start with on the page, greater than or equal to 0; by default, 0
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = models.WDATA_GET_TABLES_DEPENDENT_ON_QUERY_OP_SERVERS[0]

        request = models.WdataGetTablesDependentOnQueryRequest(
            cursor=cursor,
            limit=limit,
            offset=offset,
            query_id=query_id,
        )

        req = self._build_request_async(
            method="GET",
            path="/api/v1/query/{queryId}/dependents",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            allow_empty_value=None,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="wdata_getTablesDependentOnQuery",
                oauth2_scopes=[],
                security_source=self.sdk_configuration.security,
            ),
            request=req,
            error_status_codes=[
                "400",
                "401",
                "403",
                "404",
                "409",
                "423",
                "429",
                "4XX",
                "500",
                "5XX",
            ],
            retry_config=retry_config,
        )

        def next_func() -> (
            Awaitable[Optional[models.WdataGetTablesDependentOnQueryResponse]]
        ):
            body = utils.unmarshal_json(http_res.text, Union[Dict[Any, Any], List[Any]])

            async def empty_result():
                return None

            next_cursor = JSONPath("$.cursor").parse(body)

            if len(next_cursor) == 0:
                return empty_result()

            next_cursor = next_cursor[0]
            if next_cursor is None or str(next_cursor).strip() == "":
                return empty_result()

            return self.get_tables_dependent_on_query_async(
                query_id=query_id,
                cursor=next_cursor,
                limit=limit,
                offset=offset,
                retries=retries,
                server_url=server_url,
            )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return models.WdataGetTablesDependentOnQueryResponse(
                result=unmarshal_json_response(models.PagedResponseTableDto, http_res),
                next=next_func,
            )
        if utils.match_response(http_res, ["403", "404", "429"], "application/json"):
            response_data = unmarshal_json_response(errors.SingleErrorData, http_res)
            raise errors.SingleError(response_data, http_res)
        if utils.match_response(http_res, "500", "application/json"):
            response_data = unmarshal_json_response(errors.SingleErrorData, http_res)
            raise errors.SingleError(response_data, http_res)
        if utils.match_response(http_res, ["400", "401", "409", "423", "4XX"], "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)

        raise errors.SDKError("Unexpected response received", http_res)

    def get_workspace_query_usage(
        self,
        *,
        start_date: Optional[str] = "1970-01-01",
        stop_date: Optional[str] = "9999-01-01",
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.BaseResponseLong:
        r"""Retrieve workspace query usage

        Returns a Long that represents the number of bytes queried by the workspace of the
        request since the start time provided.

        :param start_date: The earliest date of usage to consider
        :param stop_date: The end date of usage to consider
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = models.WDATA_GET_WORKSPACE_QUERY_USAGE_OP_SERVERS[0]

        request = models.WdataGetWorkspaceQueryUsageRequest(
            start_date=start_date,
            stop_date=stop_date,
        )

        req = self._build_request(
            method="GET",
            path="/api/v1/admin/usage/query",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            allow_empty_value=None,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="wdata_getWorkspaceQueryUsage",
                oauth2_scopes=[],
                security_source=self.sdk_configuration.security,
            ),
            request=req,
            error_status_codes=[
                "400",
                "401",
                "403",
                "404",
                "409",
                "423",
                "429",
                "4XX",
                "500",
                "5XX",
            ],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(models.BaseResponseLong, http_res)
        if utils.match_response(http_res, ["403", "404", "429"], "application/json"):
            response_data = unmarshal_json_response(errors.SingleErrorData, http_res)
            raise errors.SingleError(response_data, http_res)
        if utils.match_response(http_res, "500", "application/json"):
            response_data = unmarshal_json_response(errors.SingleErrorData, http_res)
            raise errors.SingleError(response_data, http_res)
        if utils.match_response(http_res, ["400", "401", "409", "423", "4XX"], "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)

        raise errors.SDKError("Unexpected response received", http_res)

    async def get_workspace_query_usage_async(
        self,
        *,
        start_date: Optional[str] = "1970-01-01",
        stop_date: Optional[str] = "9999-01-01",
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.BaseResponseLong:
        r"""Retrieve workspace query usage

        Returns a Long that represents the number of bytes queried by the workspace of the
        request since the start time provided.

        :param start_date: The earliest date of usage to consider
        :param stop_date: The end date of usage to consider
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = models.WDATA_GET_WORKSPACE_QUERY_USAGE_OP_SERVERS[0]

        request = models.WdataGetWorkspaceQueryUsageRequest(
            start_date=start_date,
            stop_date=stop_date,
        )

        req = self._build_request_async(
            method="GET",
            path="/api/v1/admin/usage/query",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            allow_empty_value=None,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="wdata_getWorkspaceQueryUsage",
                oauth2_scopes=[],
                security_source=self.sdk_configuration.security,
            ),
            request=req,
            error_status_codes=[
                "400",
                "401",
                "403",
                "404",
                "409",
                "423",
                "429",
                "4XX",
                "500",
                "5XX",
            ],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(models.BaseResponseLong, http_res)
        if utils.match_response(http_res, ["403", "404", "429"], "application/json"):
            response_data = unmarshal_json_response(errors.SingleErrorData, http_res)
            raise errors.SingleError(response_data, http_res)
        if utils.match_response(http_res, "500", "application/json"):
            response_data = unmarshal_json_response(errors.SingleErrorData, http_res)
            raise errors.SingleError(response_data, http_res)
        if utils.match_response(http_res, ["400", "401", "409", "423", "4XX"], "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)

        raise errors.SDKError("Unexpected response received", http_res)

    def get_workspace_upload_usage(
        self,
        *,
        start_date: Optional[str] = "1970-01-01",
        stop_date: Optional[str] = "9999-01-01",
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.BaseResponseLong:
        r"""Retrieve workspace upload usage

        Returns a Long that represents the number of bytes uploaded by the workspace associated with this request from the start time provided to now.

        :param start_date: The starting point to begin considering usage
        :param stop_date: The ending point when considering usage
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = models.WDATA_GET_WORKSPACE_UPLOAD_USAGE_OP_SERVERS[0]

        request = models.WdataGetWorkspaceUploadUsageRequest(
            start_date=start_date,
            stop_date=stop_date,
        )

        req = self._build_request(
            method="GET",
            path="/api/v1/admin/usage/upload",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            allow_empty_value=None,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="wdata_getWorkspaceUploadUsage",
                oauth2_scopes=[],
                security_source=self.sdk_configuration.security,
            ),
            request=req,
            error_status_codes=[
                "400",
                "401",
                "403",
                "404",
                "409",
                "423",
                "429",
                "4XX",
                "500",
                "5XX",
            ],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(models.BaseResponseLong, http_res)
        if utils.match_response(http_res, ["403", "404", "429"], "application/json"):
            response_data = unmarshal_json_response(errors.SingleErrorData, http_res)
            raise errors.SingleError(response_data, http_res)
        if utils.match_response(http_res, "500", "application/json"):
            response_data = unmarshal_json_response(errors.SingleErrorData, http_res)
            raise errors.SingleError(response_data, http_res)
        if utils.match_response(http_res, ["400", "401", "409", "423", "4XX"], "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)

        raise errors.SDKError("Unexpected response received", http_res)

    async def get_workspace_upload_usage_async(
        self,
        *,
        start_date: Optional[str] = "1970-01-01",
        stop_date: Optional[str] = "9999-01-01",
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.BaseResponseLong:
        r"""Retrieve workspace upload usage

        Returns a Long that represents the number of bytes uploaded by the workspace associated with this request from the start time provided to now.

        :param start_date: The starting point to begin considering usage
        :param stop_date: The ending point when considering usage
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = models.WDATA_GET_WORKSPACE_UPLOAD_USAGE_OP_SERVERS[0]

        request = models.WdataGetWorkspaceUploadUsageRequest(
            start_date=start_date,
            stop_date=stop_date,
        )

        req = self._build_request_async(
            method="GET",
            path="/api/v1/admin/usage/upload",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            allow_empty_value=None,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="wdata_getWorkspaceUploadUsage",
                oauth2_scopes=[],
                security_source=self.sdk_configuration.security,
            ),
            request=req,
            error_status_codes=[
                "400",
                "401",
                "403",
                "404",
                "409",
                "423",
                "429",
                "4XX",
                "500",
                "5XX",
            ],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(models.BaseResponseLong, http_res)
        if utils.match_response(http_res, ["403", "404", "429"], "application/json"):
            response_data = unmarshal_json_response(errors.SingleErrorData, http_res)
            raise errors.SingleError(response_data, http_res)
        if utils.match_response(http_res, "500", "application/json"):
            response_data = unmarshal_json_response(errors.SingleErrorData, http_res)
            raise errors.SingleError(response_data, http_res)
        if utils.match_response(http_res, ["400", "401", "409", "423", "4XX"], "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)

        raise errors.SDKError("Unexpected response received", http_res)

    def health_check(
        self,
        *,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.BaseResponseMapStringString:
        r"""Health check

        Returns the status of the API WSGI servers

        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = models.WDATA_HEALTH_CHECK_OP_SERVERS[0]
        req = self._build_request(
            method="GET",
            path="/health",
            base_url=base_url,
            url_variables=url_variables,
            request=None,
            request_body_required=False,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            allow_empty_value=None,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="wdata_healthCheck",
                oauth2_scopes=[],
                security_source=self.sdk_configuration.security,
            ),
            request=req,
            error_status_codes=[
                "400",
                "401",
                "403",
                "404",
                "409",
                "423",
                "429",
                "4XX",
                "500",
                "5XX",
            ],
            retry_config=retry_config,
        )

        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(models.BaseResponseMapStringString, http_res)
        if utils.match_response(
            http_res, ["400", "401", "403", "404", "409", "423", "429", "4XX"], "*"
        ):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, ["500", "5XX"], "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)

        raise errors.SDKError("Unexpected response received", http_res)

    async def health_check_async(
        self,
        *,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.BaseResponseMapStringString:
        r"""Health check

        Returns the status of the API WSGI servers

        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = models.WDATA_HEALTH_CHECK_OP_SERVERS[0]
        req = self._build_request_async(
            method="GET",
            path="/health",
            base_url=base_url,
            url_variables=url_variables,
            request=None,
            request_body_required=False,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            allow_empty_value=None,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="wdata_healthCheck",
                oauth2_scopes=[],
                security_source=self.sdk_configuration.security,
            ),
            request=req,
            error_status_codes=[
                "400",
                "401",
                "403",
                "404",
                "409",
                "423",
                "429",
                "4XX",
                "500",
                "5XX",
            ],
            retry_config=retry_config,
        )

        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(models.BaseResponseMapStringString, http_res)
        if utils.match_response(
            http_res, ["400", "401", "403", "404", "409", "423", "429", "4XX"], "*"
        ):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, ["500", "5XX"], "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)

        raise errors.SDKError("Unexpected response received", http_res)

    def import_data(
        self,
        *,
        wipe: Optional[bool] = True,
        request_body: Optional[
            Union[
                models.WdataImportDataRequestBody,
                models.WdataImportDataRequestBodyTypedDict,
            ]
        ] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.BaseResponseString:
        r"""Import data

        By default, deletes all information in the workspace of the request. <b>This is a final
        operation and can't be undone.</b>  Any state left in the workspace due to an error is
        in an indeterminate state and shouldn't be trusted. Some non-private information may be
        kept for auditing and metric purposes. After the delete, it then imports the tables, tags,
        and queries in the provided cb file into the workspace. <br><br>
        This is an asynchronous operation. Returns a 201 when the file is correctly decoded and
        its tables, queries, and tags are saved. Files continue to import after this call
        completes.

        :param wipe:
        :param request_body:
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = models.WDATA_IMPORT_DATA_OP_SERVERS[0]

        request = models.WdataImportDataRequest(
            wipe=wipe,
            request_body=utils.get_pydantic_model(
                request_body, Optional[models.WdataImportDataRequestBody]
            ),
        )

        req = self._build_request(
            method="POST",
            path="/api/v1/admin/import",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request.request_body,
                False,
                True,
                "multipart",
                Optional[models.WdataImportDataRequestBody],
            ),
            allow_empty_value=None,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="wdata_importData",
                oauth2_scopes=[],
                security_source=self.sdk_configuration.security,
            ),
            request=req,
            error_status_codes=[
                "400",
                "401",
                "403",
                "404",
                "409",
                "423",
                "429",
                "4XX",
                "500",
                "5XX",
            ],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "201", "application/json"):
            return unmarshal_json_response(models.BaseResponseString, http_res)
        if utils.match_response(http_res, "400", "application/json"):
            response_data = unmarshal_json_response(errors.MultiErrorData, http_res)
            raise errors.MultiError(response_data, http_res)
        if utils.match_response(
            http_res, ["401", "403", "404", "409", "429"], "application/json"
        ):
            response_data = unmarshal_json_response(errors.SingleErrorData, http_res)
            raise errors.SingleError(response_data, http_res)
        if utils.match_response(http_res, "500", "application/json"):
            response_data = unmarshal_json_response(errors.SingleErrorData, http_res)
            raise errors.SingleError(response_data, http_res)
        if utils.match_response(http_res, ["423", "4XX"], "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)

        raise errors.SDKError("Unexpected response received", http_res)

    async def import_data_async(
        self,
        *,
        wipe: Optional[bool] = True,
        request_body: Optional[
            Union[
                models.WdataImportDataRequestBody,
                models.WdataImportDataRequestBodyTypedDict,
            ]
        ] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.BaseResponseString:
        r"""Import data

        By default, deletes all information in the workspace of the request. <b>This is a final
        operation and can't be undone.</b>  Any state left in the workspace due to an error is
        in an indeterminate state and shouldn't be trusted. Some non-private information may be
        kept for auditing and metric purposes. After the delete, it then imports the tables, tags,
        and queries in the provided cb file into the workspace. <br><br>
        This is an asynchronous operation. Returns a 201 when the file is correctly decoded and
        its tables, queries, and tags are saved. Files continue to import after this call
        completes.

        :param wipe:
        :param request_body:
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = models.WDATA_IMPORT_DATA_OP_SERVERS[0]

        request = models.WdataImportDataRequest(
            wipe=wipe,
            request_body=utils.get_pydantic_model(
                request_body, Optional[models.WdataImportDataRequestBody]
            ),
        )

        req = self._build_request_async(
            method="POST",
            path="/api/v1/admin/import",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request.request_body,
                False,
                True,
                "multipart",
                Optional[models.WdataImportDataRequestBody],
            ),
            allow_empty_value=None,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="wdata_importData",
                oauth2_scopes=[],
                security_source=self.sdk_configuration.security,
            ),
            request=req,
            error_status_codes=[
                "400",
                "401",
                "403",
                "404",
                "409",
                "423",
                "429",
                "4XX",
                "500",
                "5XX",
            ],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "201", "application/json"):
            return unmarshal_json_response(models.BaseResponseString, http_res)
        if utils.match_response(http_res, "400", "application/json"):
            response_data = unmarshal_json_response(errors.MultiErrorData, http_res)
            raise errors.MultiError(response_data, http_res)
        if utils.match_response(
            http_res, ["401", "403", "404", "409", "429"], "application/json"
        ):
            response_data = unmarshal_json_response(errors.SingleErrorData, http_res)
            raise errors.SingleError(response_data, http_res)
        if utils.match_response(http_res, "500", "application/json"):
            response_data = unmarshal_json_response(errors.SingleErrorData, http_res)
            raise errors.SingleError(response_data, http_res)
        if utils.match_response(http_res, ["423", "4XX"], "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)

        raise errors.SDKError("Unexpected response received", http_res)

    def import_file(
        self,
        *,
        table_id: str,
        import_dto: Union[models.ImportDto, models.ImportDtoTypedDict],
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.BaseResponseFileMetaDto:
        r"""Import a single file

        Imports the provided file into the associated table, and immediately returns a
        file meta object with an ID that can be used to poll the file controller for status.

        :param table_id: The unique identifier of the table
        :param import_dto: The representation of the table to import
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = models.WDATA_IMPORT_FILE_OP_SERVERS[0]

        request = models.WdataImportFileRequest(
            table_id=table_id,
            import_dto=utils.get_pydantic_model(import_dto, models.ImportDto),
        )

        req = self._build_request(
            method="POST",
            path="/api/v1/table/{tableId}/import",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request.import_dto, False, False, "json", models.ImportDto
            ),
            allow_empty_value=None,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="wdata_importFile",
                oauth2_scopes=[],
                security_source=self.sdk_configuration.security,
            ),
            request=req,
            error_status_codes=[
                "400",
                "401",
                "403",
                "404",
                "409",
                "423",
                "429",
                "4XX",
                "500",
                "5XX",
            ],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(models.BaseResponseFileMetaDto, http_res)
        if utils.match_response(http_res, "400", "application/json"):
            response_data = unmarshal_json_response(errors.MultiErrorData, http_res)
            raise errors.MultiError(response_data, http_res)
        if utils.match_response(
            http_res, ["401", "403", "404", "409", "429"], "application/json"
        ):
            response_data = unmarshal_json_response(errors.SingleErrorData, http_res)
            raise errors.SingleError(response_data, http_res)
        if utils.match_response(http_res, "500", "application/json"):
            response_data = unmarshal_json_response(errors.SingleErrorData, http_res)
            raise errors.SingleError(response_data, http_res)
        if utils.match_response(http_res, ["423", "4XX"], "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)

        raise errors.SDKError("Unexpected response received", http_res)

    async def import_file_async(
        self,
        *,
        table_id: str,
        import_dto: Union[models.ImportDto, models.ImportDtoTypedDict],
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.BaseResponseFileMetaDto:
        r"""Import a single file

        Imports the provided file into the associated table, and immediately returns a
        file meta object with an ID that can be used to poll the file controller for status.

        :param table_id: The unique identifier of the table
        :param import_dto: The representation of the table to import
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = models.WDATA_IMPORT_FILE_OP_SERVERS[0]

        request = models.WdataImportFileRequest(
            table_id=table_id,
            import_dto=utils.get_pydantic_model(import_dto, models.ImportDto),
        )

        req = self._build_request_async(
            method="POST",
            path="/api/v1/table/{tableId}/import",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request.import_dto, False, False, "json", models.ImportDto
            ),
            allow_empty_value=None,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="wdata_importFile",
                oauth2_scopes=[],
                security_source=self.sdk_configuration.security,
            ),
            request=req,
            error_status_codes=[
                "400",
                "401",
                "403",
                "404",
                "409",
                "423",
                "429",
                "4XX",
                "500",
                "5XX",
            ],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(models.BaseResponseFileMetaDto, http_res)
        if utils.match_response(http_res, "400", "application/json"):
            response_data = unmarshal_json_response(errors.MultiErrorData, http_res)
            raise errors.MultiError(response_data, http_res)
        if utils.match_response(
            http_res, ["401", "403", "404", "409", "429"], "application/json"
        ):
            response_data = unmarshal_json_response(errors.SingleErrorData, http_res)
            raise errors.SingleError(response_data, http_res)
        if utils.match_response(http_res, "500", "application/json"):
            response_data = unmarshal_json_response(errors.SingleErrorData, http_res)
            raise errors.SingleError(response_data, http_res)
        if utils.match_response(http_res, ["423", "4XX"], "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)

        raise errors.SDKError("Unexpected response received", http_res)

    def import_from_spreadsheets(
        self,
        *,
        table_id: str,
        import_from_spreadsheet_dto: Union[
            models.ImportFromSpreadsheetDto, models.ImportFromSpreadsheetDtoTypedDict
        ],
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.BaseResponseFileMetaDto:
        r"""Import from spreadsheets

        Imports spreadsheet data and immediately returns a file meta result. This DTO has
        an ID, which can be used to poll on status via the file controller.

        :param table_id: The unique identifier of the table
        :param import_from_spreadsheet_dto: The representation of the table to update
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = models.WDATA_IMPORT_FROM_SPREADSHEETS_OP_SERVERS[0]

        request = models.WdataImportFromSpreadsheetsRequest(
            table_id=table_id,
            import_from_spreadsheet_dto=utils.get_pydantic_model(
                import_from_spreadsheet_dto, models.ImportFromSpreadsheetDto
            ),
        )

        req = self._build_request(
            method="POST",
            path="/api/v1/table/{tableId}/spreadsheet/import",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request.import_from_spreadsheet_dto,
                False,
                False,
                "json",
                models.ImportFromSpreadsheetDto,
            ),
            allow_empty_value=None,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="wdata_importFromSpreadsheets",
                oauth2_scopes=[],
                security_source=self.sdk_configuration.security,
            ),
            request=req,
            error_status_codes=[
                "400",
                "401",
                "403",
                "404",
                "409",
                "423",
                "429",
                "4XX",
                "500",
                "5XX",
            ],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(models.BaseResponseFileMetaDto, http_res)
        if utils.match_response(http_res, "400", "application/json"):
            response_data = unmarshal_json_response(errors.MultiErrorData, http_res)
            raise errors.MultiError(response_data, http_res)
        if utils.match_response(
            http_res, ["401", "403", "404", "409", "429"], "application/json"
        ):
            response_data = unmarshal_json_response(errors.SingleErrorData, http_res)
            raise errors.SingleError(response_data, http_res)
        if utils.match_response(http_res, "500", "application/json"):
            response_data = unmarshal_json_response(errors.SingleErrorData, http_res)
            raise errors.SingleError(response_data, http_res)
        if utils.match_response(http_res, ["423", "4XX"], "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)

        raise errors.SDKError("Unexpected response received", http_res)

    async def import_from_spreadsheets_async(
        self,
        *,
        table_id: str,
        import_from_spreadsheet_dto: Union[
            models.ImportFromSpreadsheetDto, models.ImportFromSpreadsheetDtoTypedDict
        ],
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.BaseResponseFileMetaDto:
        r"""Import from spreadsheets

        Imports spreadsheet data and immediately returns a file meta result. This DTO has
        an ID, which can be used to poll on status via the file controller.

        :param table_id: The unique identifier of the table
        :param import_from_spreadsheet_dto: The representation of the table to update
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = models.WDATA_IMPORT_FROM_SPREADSHEETS_OP_SERVERS[0]

        request = models.WdataImportFromSpreadsheetsRequest(
            table_id=table_id,
            import_from_spreadsheet_dto=utils.get_pydantic_model(
                import_from_spreadsheet_dto, models.ImportFromSpreadsheetDto
            ),
        )

        req = self._build_request_async(
            method="POST",
            path="/api/v1/table/{tableId}/spreadsheet/import",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request.import_from_spreadsheet_dto,
                False,
                False,
                "json",
                models.ImportFromSpreadsheetDto,
            ),
            allow_empty_value=None,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="wdata_importFromSpreadsheets",
                oauth2_scopes=[],
                security_source=self.sdk_configuration.security,
            ),
            request=req,
            error_status_codes=[
                "400",
                "401",
                "403",
                "404",
                "409",
                "423",
                "429",
                "4XX",
                "500",
                "5XX",
            ],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(models.BaseResponseFileMetaDto, http_res)
        if utils.match_response(http_res, "400", "application/json"):
            response_data = unmarshal_json_response(errors.MultiErrorData, http_res)
            raise errors.MultiError(response_data, http_res)
        if utils.match_response(
            http_res, ["401", "403", "404", "409", "429"], "application/json"
        ):
            response_data = unmarshal_json_response(errors.SingleErrorData, http_res)
            raise errors.SingleError(response_data, http_res)
        if utils.match_response(http_res, "500", "application/json"):
            response_data = unmarshal_json_response(errors.SingleErrorData, http_res)
            raise errors.SingleError(response_data, http_res)
        if utils.match_response(http_res, ["423", "4XX"], "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)

        raise errors.SDKError("Unexpected response received", http_res)

    def is_query_valid(
        self,
        *,
        request: Union[models.QueryDtoInput, models.QueryDtoInputTypedDict],
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.BaseResponseQueryDto:
        r"""Parses the query to determine if it is valid

        Returns the provided QueryDto

        :param request: The request object to send.
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = models.WDATA_IS_QUERY_VALID_OP_SERVERS[0]

        if not isinstance(request, BaseModel):
            request = utils.unmarshal(request, models.QueryDtoInput)
        request = cast(models.QueryDtoInput, request)

        req = self._build_request(
            method="POST",
            path="/api/v1/query/validation",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request, False, False, "json", models.QueryDtoInput
            ),
            allow_empty_value=None,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="wdata_isQueryValid",
                oauth2_scopes=[],
                security_source=self.sdk_configuration.security,
            ),
            request=req,
            error_status_codes=[
                "400",
                "401",
                "403",
                "404",
                "409",
                "423",
                "429",
                "4XX",
                "500",
                "5XX",
            ],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(models.BaseResponseQueryDto, http_res)
        if utils.match_response(http_res, "400", "application/json"):
            response_data = unmarshal_json_response(errors.MultiErrorData, http_res)
            raise errors.MultiError(response_data, http_res)
        if utils.match_response(
            http_res, ["401", "403", "404", "409", "429"], "application/json"
        ):
            response_data = unmarshal_json_response(errors.SingleErrorData, http_res)
            raise errors.SingleError(response_data, http_res)
        if utils.match_response(http_res, "500", "application/json"):
            response_data = unmarshal_json_response(errors.SingleErrorData, http_res)
            raise errors.SingleError(response_data, http_res)
        if utils.match_response(http_res, ["423", "4XX"], "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)

        raise errors.SDKError("Unexpected response received", http_res)

    async def is_query_valid_async(
        self,
        *,
        request: Union[models.QueryDtoInput, models.QueryDtoInputTypedDict],
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.BaseResponseQueryDto:
        r"""Parses the query to determine if it is valid

        Returns the provided QueryDto

        :param request: The request object to send.
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = models.WDATA_IS_QUERY_VALID_OP_SERVERS[0]

        if not isinstance(request, BaseModel):
            request = utils.unmarshal(request, models.QueryDtoInput)
        request = cast(models.QueryDtoInput, request)

        req = self._build_request_async(
            method="POST",
            path="/api/v1/query/validation",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request, False, False, "json", models.QueryDtoInput
            ),
            allow_empty_value=None,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="wdata_isQueryValid",
                oauth2_scopes=[],
                security_source=self.sdk_configuration.security,
            ),
            request=req,
            error_status_codes=[
                "400",
                "401",
                "403",
                "404",
                "409",
                "423",
                "429",
                "4XX",
                "500",
                "5XX",
            ],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(models.BaseResponseQueryDto, http_res)
        if utils.match_response(http_res, "400", "application/json"):
            response_data = unmarshal_json_response(errors.MultiErrorData, http_res)
            raise errors.MultiError(response_data, http_res)
        if utils.match_response(
            http_res, ["401", "403", "404", "409", "429"], "application/json"
        ):
            response_data = unmarshal_json_response(errors.SingleErrorData, http_res)
            raise errors.SingleError(response_data, http_res)
        if utils.match_response(http_res, "500", "application/json"):
            response_data = unmarshal_json_response(errors.SingleErrorData, http_res)
            raise errors.SingleError(response_data, http_res)
        if utils.match_response(http_res, ["423", "4XX"], "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)

        raise errors.SDKError("Unexpected response received", http_res)

    def list_children(
        self,
        *,
        folder_id: str,
        cursor: Optional[str] = None,
        limit: Optional[int] = 1000,
        offset: Optional[int] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> Optional[models.WdataListChildrenResponse]:
        r"""Retrieve list of folder contents

        Returns a paged list of all children whose parent ID matches the provided folder
        ID.  If the folder ID in the path is the literal 'null' value, returns a list of
        all entities with no parent.

        :param folder_id: The unique identifier of the folder
        :param cursor: A paging cursor; if included, `limit` is ignored
        :param limit: The number of folders to return, from 1 to 1000; by default, 1000
        :param offset: The item to start with on the page, greater than or equal to 0; by default, 0
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = models.WDATA_LIST_CHILDREN_OP_SERVERS[0]

        request = models.WdataListChildrenRequest(
            cursor=cursor,
            folder_id=folder_id,
            limit=limit,
            offset=offset,
        )

        req = self._build_request(
            method="GET",
            path="/api/v1/folder/{folderId}/children",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            allow_empty_value=None,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="wdata_listChildren",
                oauth2_scopes=[],
                security_source=self.sdk_configuration.security,
            ),
            request=req,
            error_status_codes=[
                "400",
                "401",
                "403",
                "404",
                "409",
                "423",
                "429",
                "4XX",
                "500",
                "5XX",
            ],
            retry_config=retry_config,
        )

        def next_func() -> Optional[models.WdataListChildrenResponse]:
            body = utils.unmarshal_json(http_res.text, Union[Dict[Any, Any], List[Any]])

            next_cursor = JSONPath("$.cursor").parse(body)

            if len(next_cursor) == 0:
                return None

            next_cursor = next_cursor[0]
            if next_cursor is None or str(next_cursor).strip() == "":
                return None

            return self.list_children(
                folder_id=folder_id,
                cursor=next_cursor,
                limit=limit,
                offset=offset,
                retries=retries,
                server_url=server_url,
            )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return models.WdataListChildrenResponse(
                result=unmarshal_json_response(
                    models.PagedResponseFolderableDto, http_res
                ),
                next=next_func,
            )
        if utils.match_response(http_res, ["403", "404", "429"], "application/json"):
            response_data = unmarshal_json_response(errors.SingleErrorData, http_res)
            raise errors.SingleError(response_data, http_res)
        if utils.match_response(http_res, "500", "application/json"):
            response_data = unmarshal_json_response(errors.SingleErrorData, http_res)
            raise errors.SingleError(response_data, http_res)
        if utils.match_response(http_res, ["400", "401", "409", "423", "4XX"], "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)

        raise errors.SDKError("Unexpected response received", http_res)

    async def list_children_async(
        self,
        *,
        folder_id: str,
        cursor: Optional[str] = None,
        limit: Optional[int] = 1000,
        offset: Optional[int] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> Optional[models.WdataListChildrenResponse]:
        r"""Retrieve list of folder contents

        Returns a paged list of all children whose parent ID matches the provided folder
        ID.  If the folder ID in the path is the literal 'null' value, returns a list of
        all entities with no parent.

        :param folder_id: The unique identifier of the folder
        :param cursor: A paging cursor; if included, `limit` is ignored
        :param limit: The number of folders to return, from 1 to 1000; by default, 1000
        :param offset: The item to start with on the page, greater than or equal to 0; by default, 0
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = models.WDATA_LIST_CHILDREN_OP_SERVERS[0]

        request = models.WdataListChildrenRequest(
            cursor=cursor,
            folder_id=folder_id,
            limit=limit,
            offset=offset,
        )

        req = self._build_request_async(
            method="GET",
            path="/api/v1/folder/{folderId}/children",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            allow_empty_value=None,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="wdata_listChildren",
                oauth2_scopes=[],
                security_source=self.sdk_configuration.security,
            ),
            request=req,
            error_status_codes=[
                "400",
                "401",
                "403",
                "404",
                "409",
                "423",
                "429",
                "4XX",
                "500",
                "5XX",
            ],
            retry_config=retry_config,
        )

        def next_func() -> Awaitable[Optional[models.WdataListChildrenResponse]]:
            body = utils.unmarshal_json(http_res.text, Union[Dict[Any, Any], List[Any]])

            async def empty_result():
                return None

            next_cursor = JSONPath("$.cursor").parse(body)

            if len(next_cursor) == 0:
                return empty_result()

            next_cursor = next_cursor[0]
            if next_cursor is None or str(next_cursor).strip() == "":
                return empty_result()

            return self.list_children_async(
                folder_id=folder_id,
                cursor=next_cursor,
                limit=limit,
                offset=offset,
                retries=retries,
                server_url=server_url,
            )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return models.WdataListChildrenResponse(
                result=unmarshal_json_response(
                    models.PagedResponseFolderableDto, http_res
                ),
                next=next_func,
            )
        if utils.match_response(http_res, ["403", "404", "429"], "application/json"):
            response_data = unmarshal_json_response(errors.SingleErrorData, http_res)
            raise errors.SingleError(response_data, http_res)
        if utils.match_response(http_res, "500", "application/json"):
            response_data = unmarshal_json_response(errors.SingleErrorData, http_res)
            raise errors.SingleError(response_data, http_res)
        if utils.match_response(http_res, ["400", "401", "409", "423", "4XX"], "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)

        raise errors.SDKError("Unexpected response received", http_res)

    def list_connections(
        self,
        *,
        request: Union[
            models.WdataListConnectionsRequest,
            models.WdataListConnectionsRequestTypedDict,
        ] = models.WdataListConnectionsRequest(),
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> Optional[models.WdataListConnectionsResponse]:
        r"""List connections

        A pageable endpoint to list data connections between features of the Workiva platform. When filtering by source or destination, the corresponding ID is required.

        :param request: The request object to send.
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = models.WDATA_LIST_CONNECTIONS_OP_SERVERS[0]

        if not isinstance(request, BaseModel):
            request = utils.unmarshal(request, models.WdataListConnectionsRequest)
        request = cast(models.WdataListConnectionsRequest, request)

        req = self._build_request(
            method="GET",
            path="/api/v1/connections",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            allow_empty_value=None,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="wdata_listConnections",
                oauth2_scopes=[],
                security_source=self.sdk_configuration.security,
            ),
            request=req,
            error_status_codes=[
                "400",
                "401",
                "403",
                "404",
                "409",
                "423",
                "429",
                "4XX",
                "500",
                "5XX",
            ],
            retry_config=retry_config,
        )

        def next_func() -> Optional[models.WdataListConnectionsResponse]:
            body = utils.unmarshal_json(http_res.text, Union[Dict[Any, Any], List[Any]])

            next_cursor = JSONPath("$.cursor").parse(body)

            if len(next_cursor) == 0:
                return None

            next_cursor = next_cursor[0]
            if next_cursor is None or str(next_cursor).strip() == "":
                return None

            return self.list_connections(
                request=models.WdataListConnectionsRequest(
                    cursor=next_cursor,
                    destination_id=request.destination_id,
                    destination_type=request.destination_type,
                    limit=request.limit,
                    offset=request.offset,
                    source_id=request.source_id,
                    source_type=request.source_type,
                ),
                retries=retries,
                server_url=server_url,
            )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return models.WdataListConnectionsResponse(
                result=unmarshal_json_response(
                    models.PagedResponseConnectionDto, http_res
                ),
                next=next_func,
            )
        if utils.match_response(http_res, ["403", "404", "429"], "application/json"):
            response_data = unmarshal_json_response(errors.SingleErrorData, http_res)
            raise errors.SingleError(response_data, http_res)
        if utils.match_response(http_res, "500", "application/json"):
            response_data = unmarshal_json_response(errors.SingleErrorData, http_res)
            raise errors.SingleError(response_data, http_res)
        if utils.match_response(http_res, ["400", "401", "409", "423", "4XX"], "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)

        raise errors.SDKError("Unexpected response received", http_res)

    async def list_connections_async(
        self,
        *,
        request: Union[
            models.WdataListConnectionsRequest,
            models.WdataListConnectionsRequestTypedDict,
        ] = models.WdataListConnectionsRequest(),
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> Optional[models.WdataListConnectionsResponse]:
        r"""List connections

        A pageable endpoint to list data connections between features of the Workiva platform. When filtering by source or destination, the corresponding ID is required.

        :param request: The request object to send.
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = models.WDATA_LIST_CONNECTIONS_OP_SERVERS[0]

        if not isinstance(request, BaseModel):
            request = utils.unmarshal(request, models.WdataListConnectionsRequest)
        request = cast(models.WdataListConnectionsRequest, request)

        req = self._build_request_async(
            method="GET",
            path="/api/v1/connections",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            allow_empty_value=None,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="wdata_listConnections",
                oauth2_scopes=[],
                security_source=self.sdk_configuration.security,
            ),
            request=req,
            error_status_codes=[
                "400",
                "401",
                "403",
                "404",
                "409",
                "423",
                "429",
                "4XX",
                "500",
                "5XX",
            ],
            retry_config=retry_config,
        )

        def next_func() -> Awaitable[Optional[models.WdataListConnectionsResponse]]:
            body = utils.unmarshal_json(http_res.text, Union[Dict[Any, Any], List[Any]])

            async def empty_result():
                return None

            next_cursor = JSONPath("$.cursor").parse(body)

            if len(next_cursor) == 0:
                return empty_result()

            next_cursor = next_cursor[0]
            if next_cursor is None or str(next_cursor).strip() == "":
                return empty_result()

            return self.list_connections_async(
                request=models.WdataListConnectionsRequest(
                    cursor=next_cursor,
                    destination_id=request.destination_id,
                    destination_type=request.destination_type,
                    limit=request.limit,
                    offset=request.offset,
                    source_id=request.source_id,
                    source_type=request.source_type,
                ),
                retries=retries,
                server_url=server_url,
            )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return models.WdataListConnectionsResponse(
                result=unmarshal_json_response(
                    models.PagedResponseConnectionDto, http_res
                ),
                next=next_func,
            )
        if utils.match_response(http_res, ["403", "404", "429"], "application/json"):
            response_data = unmarshal_json_response(errors.SingleErrorData, http_res)
            raise errors.SingleError(response_data, http_res)
        if utils.match_response(http_res, "500", "application/json"):
            response_data = unmarshal_json_response(errors.SingleErrorData, http_res)
            raise errors.SingleError(response_data, http_res)
        if utils.match_response(http_res, ["400", "401", "409", "423", "4XX"], "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)

        raise errors.SDKError("Unexpected response received", http_res)

    def list_folders(
        self,
        *,
        cursor: Optional[str] = None,
        limit: Optional[int] = 1000,
        offset: Optional[int] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> Optional[models.WdataListFoldersResponse]:
        r"""Retrieve a list of folders

        Returns a paged list of all folders associated with the workspace.

        :param cursor: A paging cursor; if included, `limit` is ignored
        :param limit: The number of folders to return, from 1 to 1000; by default, 1000
        :param offset: The item to start with on the page, greater than or equal to 0; by default, 0
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = models.WDATA_LIST_FOLDERS_OP_SERVERS[0]

        request = models.WdataListFoldersRequest(
            cursor=cursor,
            limit=limit,
            offset=offset,
        )

        req = self._build_request(
            method="GET",
            path="/api/v1/folder",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            allow_empty_value=None,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="wdata_listFolders",
                oauth2_scopes=[],
                security_source=self.sdk_configuration.security,
            ),
            request=req,
            error_status_codes=[
                "400",
                "401",
                "403",
                "404",
                "409",
                "423",
                "429",
                "4XX",
                "500",
                "5XX",
            ],
            retry_config=retry_config,
        )

        def next_func() -> Optional[models.WdataListFoldersResponse]:
            body = utils.unmarshal_json(http_res.text, Union[Dict[Any, Any], List[Any]])

            next_cursor = JSONPath("$.cursor").parse(body)

            if len(next_cursor) == 0:
                return None

            next_cursor = next_cursor[0]
            if next_cursor is None or str(next_cursor).strip() == "":
                return None

            return self.list_folders(
                cursor=next_cursor,
                limit=limit,
                offset=offset,
                retries=retries,
                server_url=server_url,
            )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return models.WdataListFoldersResponse(
                result=unmarshal_json_response(models.PagedResponseFolderDto, http_res),
                next=next_func,
            )
        if utils.match_response(http_res, ["403", "404", "429"], "application/json"):
            response_data = unmarshal_json_response(errors.SingleErrorData, http_res)
            raise errors.SingleError(response_data, http_res)
        if utils.match_response(http_res, "500", "application/json"):
            response_data = unmarshal_json_response(errors.SingleErrorData, http_res)
            raise errors.SingleError(response_data, http_res)
        if utils.match_response(http_res, ["400", "401", "409", "423", "4XX"], "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)

        raise errors.SDKError("Unexpected response received", http_res)

    async def list_folders_async(
        self,
        *,
        cursor: Optional[str] = None,
        limit: Optional[int] = 1000,
        offset: Optional[int] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> Optional[models.WdataListFoldersResponse]:
        r"""Retrieve a list of folders

        Returns a paged list of all folders associated with the workspace.

        :param cursor: A paging cursor; if included, `limit` is ignored
        :param limit: The number of folders to return, from 1 to 1000; by default, 1000
        :param offset: The item to start with on the page, greater than or equal to 0; by default, 0
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = models.WDATA_LIST_FOLDERS_OP_SERVERS[0]

        request = models.WdataListFoldersRequest(
            cursor=cursor,
            limit=limit,
            offset=offset,
        )

        req = self._build_request_async(
            method="GET",
            path="/api/v1/folder",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            allow_empty_value=None,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="wdata_listFolders",
                oauth2_scopes=[],
                security_source=self.sdk_configuration.security,
            ),
            request=req,
            error_status_codes=[
                "400",
                "401",
                "403",
                "404",
                "409",
                "423",
                "429",
                "4XX",
                "500",
                "5XX",
            ],
            retry_config=retry_config,
        )

        def next_func() -> Awaitable[Optional[models.WdataListFoldersResponse]]:
            body = utils.unmarshal_json(http_res.text, Union[Dict[Any, Any], List[Any]])

            async def empty_result():
                return None

            next_cursor = JSONPath("$.cursor").parse(body)

            if len(next_cursor) == 0:
                return empty_result()

            next_cursor = next_cursor[0]
            if next_cursor is None or str(next_cursor).strip() == "":
                return empty_result()

            return self.list_folders_async(
                cursor=next_cursor,
                limit=limit,
                offset=offset,
                retries=retries,
                server_url=server_url,
            )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return models.WdataListFoldersResponse(
                result=unmarshal_json_response(models.PagedResponseFolderDto, http_res),
                next=next_func,
            )
        if utils.match_response(http_res, ["403", "404", "429"], "application/json"):
            response_data = unmarshal_json_response(errors.SingleErrorData, http_res)
            raise errors.SingleError(response_data, http_res)
        if utils.match_response(http_res, "500", "application/json"):
            response_data = unmarshal_json_response(errors.SingleErrorData, http_res)
            raise errors.SingleError(response_data, http_res)
        if utils.match_response(http_res, ["400", "401", "409", "423", "4XX"], "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)

        raise errors.SDKError("Unexpected response received", http_res)

    def list_parameters(
        self,
        *,
        cursor: Optional[str] = None,
        limit: Optional[int] = 1000,
        offset: Optional[int] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> Optional[models.WdataListParametersResponse]:
        r"""Get Parameters

        Returns a list of all parameters associated with the workspace.  By default, these
        parameters are ordered by their names in ascending order.

        :param cursor: A paging cursor; if included the limit is ignored
        :param limit: The number of parameters to return, must be between 1 and 1000, will default
            to 1000
        :param offset: The item to start with on the page, must be greater than or equal to 0, will default to 0
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = models.WDATA_LIST_PARAMETERS_OP_SERVERS[0]

        request = models.WdataListParametersRequest(
            cursor=cursor,
            limit=limit,
            offset=offset,
        )

        req = self._build_request(
            method="GET",
            path="/api/v1/parameter",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            allow_empty_value=None,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="wdata_listParameters",
                oauth2_scopes=[],
                security_source=self.sdk_configuration.security,
            ),
            request=req,
            error_status_codes=[
                "400",
                "401",
                "403",
                "404",
                "409",
                "423",
                "429",
                "4XX",
                "500",
                "5XX",
            ],
            retry_config=retry_config,
        )

        def next_func() -> Optional[models.WdataListParametersResponse]:
            body = utils.unmarshal_json(http_res.text, Union[Dict[Any, Any], List[Any]])

            next_cursor = JSONPath("$.cursor").parse(body)

            if len(next_cursor) == 0:
                return None

            next_cursor = next_cursor[0]
            if next_cursor is None or str(next_cursor).strip() == "":
                return None

            return self.list_parameters(
                cursor=next_cursor,
                limit=limit,
                offset=offset,
                retries=retries,
                server_url=server_url,
            )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return models.WdataListParametersResponse(
                result=unmarshal_json_response(
                    models.PagedResponseGlobalParameterDto, http_res
                ),
                next=next_func,
            )
        if utils.match_response(http_res, ["403", "404", "429"], "application/json"):
            response_data = unmarshal_json_response(errors.SingleErrorData, http_res)
            raise errors.SingleError(response_data, http_res)
        if utils.match_response(http_res, "500", "application/json"):
            response_data = unmarshal_json_response(errors.SingleErrorData, http_res)
            raise errors.SingleError(response_data, http_res)
        if utils.match_response(http_res, ["400", "401", "409", "423", "4XX"], "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)

        raise errors.SDKError("Unexpected response received", http_res)

    async def list_parameters_async(
        self,
        *,
        cursor: Optional[str] = None,
        limit: Optional[int] = 1000,
        offset: Optional[int] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> Optional[models.WdataListParametersResponse]:
        r"""Get Parameters

        Returns a list of all parameters associated with the workspace.  By default, these
        parameters are ordered by their names in ascending order.

        :param cursor: A paging cursor; if included the limit is ignored
        :param limit: The number of parameters to return, must be between 1 and 1000, will default
            to 1000
        :param offset: The item to start with on the page, must be greater than or equal to 0, will default to 0
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = models.WDATA_LIST_PARAMETERS_OP_SERVERS[0]

        request = models.WdataListParametersRequest(
            cursor=cursor,
            limit=limit,
            offset=offset,
        )

        req = self._build_request_async(
            method="GET",
            path="/api/v1/parameter",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            allow_empty_value=None,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="wdata_listParameters",
                oauth2_scopes=[],
                security_source=self.sdk_configuration.security,
            ),
            request=req,
            error_status_codes=[
                "400",
                "401",
                "403",
                "404",
                "409",
                "423",
                "429",
                "4XX",
                "500",
                "5XX",
            ],
            retry_config=retry_config,
        )

        def next_func() -> Awaitable[Optional[models.WdataListParametersResponse]]:
            body = utils.unmarshal_json(http_res.text, Union[Dict[Any, Any], List[Any]])

            async def empty_result():
                return None

            next_cursor = JSONPath("$.cursor").parse(body)

            if len(next_cursor) == 0:
                return empty_result()

            next_cursor = next_cursor[0]
            if next_cursor is None or str(next_cursor).strip() == "":
                return empty_result()

            return self.list_parameters_async(
                cursor=next_cursor,
                limit=limit,
                offset=offset,
                retries=retries,
                server_url=server_url,
            )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return models.WdataListParametersResponse(
                result=unmarshal_json_response(
                    models.PagedResponseGlobalParameterDto, http_res
                ),
                next=next_func,
            )
        if utils.match_response(http_res, ["403", "404", "429"], "application/json"):
            response_data = unmarshal_json_response(errors.SingleErrorData, http_res)
            raise errors.SingleError(response_data, http_res)
        if utils.match_response(http_res, "500", "application/json"):
            response_data = unmarshal_json_response(errors.SingleErrorData, http_res)
            raise errors.SingleError(response_data, http_res)
        if utils.match_response(http_res, ["400", "401", "409", "423", "4XX"], "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)

        raise errors.SDKError("Unexpected response received", http_res)

    def list_pivot_views(
        self,
        *,
        query_id: str,
        cursor: Optional[str] = None,
        limit: Optional[int] = 1000,
        offset: Optional[int] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> Optional[models.WdataListPivotViewsResponse]:
        r"""Retrieve a list of pivot views

        Returns a paged list of views in the workspace of the request. If queryId is provided, the results are limited to only views associated with the query ID.

        :param query_id: The unique query identifier to filter the views
        :param cursor: A paging cursor; if included, `limit` is ignored
        :param limit: The number of views to return, from 1 to 1000; by default, 1000
        :param offset: The item to start with on the page, greater than or equal to 0; by default, 0
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = models.WDATA_LIST_PIVOT_VIEWS_OP_SERVERS[0]

        request = models.WdataListPivotViewsRequest(
            cursor=cursor,
            limit=limit,
            offset=offset,
            query_id=query_id,
        )

        req = self._build_request(
            method="GET",
            path="/api/v1/pivotview",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            allow_empty_value=None,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="wdata_listPivotViews",
                oauth2_scopes=[],
                security_source=self.sdk_configuration.security,
            ),
            request=req,
            error_status_codes=[
                "400",
                "401",
                "403",
                "404",
                "409",
                "423",
                "429",
                "4XX",
                "500",
                "5XX",
            ],
            retry_config=retry_config,
        )

        def next_func() -> Optional[models.WdataListPivotViewsResponse]:
            body = utils.unmarshal_json(http_res.text, Union[Dict[Any, Any], List[Any]])

            next_cursor = JSONPath("$.cursor").parse(body)

            if len(next_cursor) == 0:
                return None

            next_cursor = next_cursor[0]
            if next_cursor is None or str(next_cursor).strip() == "":
                return None

            return self.list_pivot_views(
                query_id=query_id,
                cursor=next_cursor,
                limit=limit,
                offset=offset,
                retries=retries,
                server_url=server_url,
            )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return models.WdataListPivotViewsResponse(
                result=unmarshal_json_response(
                    models.PagedResponsePivotViewDto, http_res
                ),
                next=next_func,
            )
        if utils.match_response(http_res, ["403", "404", "429"], "application/json"):
            response_data = unmarshal_json_response(errors.SingleErrorData, http_res)
            raise errors.SingleError(response_data, http_res)
        if utils.match_response(http_res, "500", "application/json"):
            response_data = unmarshal_json_response(errors.SingleErrorData, http_res)
            raise errors.SingleError(response_data, http_res)
        if utils.match_response(http_res, ["400", "401", "409", "423", "4XX"], "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)

        raise errors.SDKError("Unexpected response received", http_res)

    async def list_pivot_views_async(
        self,
        *,
        query_id: str,
        cursor: Optional[str] = None,
        limit: Optional[int] = 1000,
        offset: Optional[int] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> Optional[models.WdataListPivotViewsResponse]:
        r"""Retrieve a list of pivot views

        Returns a paged list of views in the workspace of the request. If queryId is provided, the results are limited to only views associated with the query ID.

        :param query_id: The unique query identifier to filter the views
        :param cursor: A paging cursor; if included, `limit` is ignored
        :param limit: The number of views to return, from 1 to 1000; by default, 1000
        :param offset: The item to start with on the page, greater than or equal to 0; by default, 0
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = models.WDATA_LIST_PIVOT_VIEWS_OP_SERVERS[0]

        request = models.WdataListPivotViewsRequest(
            cursor=cursor,
            limit=limit,
            offset=offset,
            query_id=query_id,
        )

        req = self._build_request_async(
            method="GET",
            path="/api/v1/pivotview",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            allow_empty_value=None,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="wdata_listPivotViews",
                oauth2_scopes=[],
                security_source=self.sdk_configuration.security,
            ),
            request=req,
            error_status_codes=[
                "400",
                "401",
                "403",
                "404",
                "409",
                "423",
                "429",
                "4XX",
                "500",
                "5XX",
            ],
            retry_config=retry_config,
        )

        def next_func() -> Awaitable[Optional[models.WdataListPivotViewsResponse]]:
            body = utils.unmarshal_json(http_res.text, Union[Dict[Any, Any], List[Any]])

            async def empty_result():
                return None

            next_cursor = JSONPath("$.cursor").parse(body)

            if len(next_cursor) == 0:
                return empty_result()

            next_cursor = next_cursor[0]
            if next_cursor is None or str(next_cursor).strip() == "":
                return empty_result()

            return self.list_pivot_views_async(
                query_id=query_id,
                cursor=next_cursor,
                limit=limit,
                offset=offset,
                retries=retries,
                server_url=server_url,
            )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return models.WdataListPivotViewsResponse(
                result=unmarshal_json_response(
                    models.PagedResponsePivotViewDto, http_res
                ),
                next=next_func,
            )
        if utils.match_response(http_res, ["403", "404", "429"], "application/json"):
            response_data = unmarshal_json_response(errors.SingleErrorData, http_res)
            raise errors.SingleError(response_data, http_res)
        if utils.match_response(http_res, "500", "application/json"):
            response_data = unmarshal_json_response(errors.SingleErrorData, http_res)
            raise errors.SingleError(response_data, http_res)
        if utils.match_response(http_res, ["400", "401", "409", "423", "4XX"], "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)

        raise errors.SDKError("Unexpected response received", http_res)

    def list_queries(
        self,
        *,
        cursor: Optional[str] = None,
        ids: Optional[List[str]] = None,
        limit: Optional[int] = 1000,
        offset: Optional[int] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> Optional[models.WdataListQueriesResponse]:
        r"""Retrieve list of queries

        Returns a list of all non-temporary queries associated with the workspace. By default, these queries are ordered by their names, in ascending order.

        :param cursor: A paging cursor; if included, `limit` is ignored
        :param ids: A list of ids to filter the returned list by
        :param limit: The number of queries to return, from 1 to 1000; by default, 1000
        :param offset: The item to start with on the page, greater than or equal to 0; by default, 0
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = models.WDATA_LIST_QUERIES_OP_SERVERS[0]

        request = models.WdataListQueriesRequest(
            cursor=cursor,
            ids=ids,
            limit=limit,
            offset=offset,
        )

        req = self._build_request(
            method="GET",
            path="/api/v1/query",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            allow_empty_value=None,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="wdata_listQueries",
                oauth2_scopes=[],
                security_source=self.sdk_configuration.security,
            ),
            request=req,
            error_status_codes=[
                "400",
                "401",
                "403",
                "404",
                "409",
                "423",
                "429",
                "4XX",
                "500",
                "5XX",
            ],
            retry_config=retry_config,
        )

        def next_func() -> Optional[models.WdataListQueriesResponse]:
            body = utils.unmarshal_json(http_res.text, Union[Dict[Any, Any], List[Any]])

            next_cursor = JSONPath("$.cursor").parse(body)

            if len(next_cursor) == 0:
                return None

            next_cursor = next_cursor[0]
            if next_cursor is None or str(next_cursor).strip() == "":
                return None

            return self.list_queries(
                cursor=next_cursor,
                ids=ids,
                limit=limit,
                offset=offset,
                retries=retries,
                server_url=server_url,
            )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return models.WdataListQueriesResponse(
                result=unmarshal_json_response(models.PagedResponseQueryDto, http_res),
                next=next_func,
            )
        if utils.match_response(http_res, ["403", "404", "429"], "application/json"):
            response_data = unmarshal_json_response(errors.SingleErrorData, http_res)
            raise errors.SingleError(response_data, http_res)
        if utils.match_response(http_res, "500", "application/json"):
            response_data = unmarshal_json_response(errors.SingleErrorData, http_res)
            raise errors.SingleError(response_data, http_res)
        if utils.match_response(http_res, ["400", "401", "409", "423", "4XX"], "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)

        raise errors.SDKError("Unexpected response received", http_res)

    async def list_queries_async(
        self,
        *,
        cursor: Optional[str] = None,
        ids: Optional[List[str]] = None,
        limit: Optional[int] = 1000,
        offset: Optional[int] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> Optional[models.WdataListQueriesResponse]:
        r"""Retrieve list of queries

        Returns a list of all non-temporary queries associated with the workspace. By default, these queries are ordered by their names, in ascending order.

        :param cursor: A paging cursor; if included, `limit` is ignored
        :param ids: A list of ids to filter the returned list by
        :param limit: The number of queries to return, from 1 to 1000; by default, 1000
        :param offset: The item to start with on the page, greater than or equal to 0; by default, 0
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = models.WDATA_LIST_QUERIES_OP_SERVERS[0]

        request = models.WdataListQueriesRequest(
            cursor=cursor,
            ids=ids,
            limit=limit,
            offset=offset,
        )

        req = self._build_request_async(
            method="GET",
            path="/api/v1/query",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            allow_empty_value=None,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="wdata_listQueries",
                oauth2_scopes=[],
                security_source=self.sdk_configuration.security,
            ),
            request=req,
            error_status_codes=[
                "400",
                "401",
                "403",
                "404",
                "409",
                "423",
                "429",
                "4XX",
                "500",
                "5XX",
            ],
            retry_config=retry_config,
        )

        def next_func() -> Awaitable[Optional[models.WdataListQueriesResponse]]:
            body = utils.unmarshal_json(http_res.text, Union[Dict[Any, Any], List[Any]])

            async def empty_result():
                return None

            next_cursor = JSONPath("$.cursor").parse(body)

            if len(next_cursor) == 0:
                return empty_result()

            next_cursor = next_cursor[0]
            if next_cursor is None or str(next_cursor).strip() == "":
                return empty_result()

            return self.list_queries_async(
                cursor=next_cursor,
                ids=ids,
                limit=limit,
                offset=offset,
                retries=retries,
                server_url=server_url,
            )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return models.WdataListQueriesResponse(
                result=unmarshal_json_response(models.PagedResponseQueryDto, http_res),
                next=next_func,
            )
        if utils.match_response(http_res, ["403", "404", "429"], "application/json"):
            response_data = unmarshal_json_response(errors.SingleErrorData, http_res)
            raise errors.SingleError(response_data, http_res)
        if utils.match_response(http_res, "500", "application/json"):
            response_data = unmarshal_json_response(errors.SingleErrorData, http_res)
            raise errors.SingleError(response_data, http_res)
        if utils.match_response(http_res, ["400", "401", "409", "423", "4XX"], "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)

        raise errors.SDKError("Unexpected response received", http_res)

    def list_query_results(
        self,
        *,
        request: Union[
            models.WdataListQueryResultsRequest,
            models.WdataListQueryResultsRequestTypedDict,
        ],
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> Optional[models.WdataListQueryResultsResponse]:
        r"""Retrieve a list of query results

        Returns a paged list of query results that match the provided query ID, or an empty
        list if no matching query is found.

        :param request: The request object to send.
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = models.WDATA_LIST_QUERY_RESULTS_OP_SERVERS[0]

        if not isinstance(request, BaseModel):
            request = utils.unmarshal(request, models.WdataListQueryResultsRequest)
        request = cast(models.WdataListQueryResultsRequest, request)

        req = self._build_request(
            method="GET",
            path="/api/v1/queryresult",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            allow_empty_value=None,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="wdata_listQueryResults",
                oauth2_scopes=[],
                security_source=self.sdk_configuration.security,
            ),
            request=req,
            error_status_codes=[
                "400",
                "401",
                "403",
                "404",
                "409",
                "423",
                "429",
                "4XX",
                "500",
                "5XX",
            ],
            retry_config=retry_config,
        )

        def next_func() -> Optional[models.WdataListQueryResultsResponse]:
            body = utils.unmarshal_json(http_res.text, Union[Dict[Any, Any], List[Any]])

            next_cursor = JSONPath("$.cursor").parse(body)

            if len(next_cursor) == 0:
                return None

            next_cursor = next_cursor[0]
            if next_cursor is None or str(next_cursor).strip() == "":
                return None

            return self.list_query_results(
                request=models.WdataListQueryResultsRequest(
                    query_id=request.query_id,
                    cursor=next_cursor,
                    limit=request.limit,
                    offset=request.offset,
                    user_specific=request.user_specific,
                ),
                retries=retries,
                server_url=server_url,
            )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return models.WdataListQueryResultsResponse(
                result=unmarshal_json_response(
                    models.PagedResponseQueryResultDto, http_res
                ),
                next=next_func,
            )
        if utils.match_response(http_res, ["403", "404", "429"], "application/json"):
            response_data = unmarshal_json_response(errors.SingleErrorData, http_res)
            raise errors.SingleError(response_data, http_res)
        if utils.match_response(http_res, "500", "application/json"):
            response_data = unmarshal_json_response(errors.SingleErrorData, http_res)
            raise errors.SingleError(response_data, http_res)
        if utils.match_response(http_res, ["400", "401", "409", "423", "4XX"], "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)

        raise errors.SDKError("Unexpected response received", http_res)

    async def list_query_results_async(
        self,
        *,
        request: Union[
            models.WdataListQueryResultsRequest,
            models.WdataListQueryResultsRequestTypedDict,
        ],
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> Optional[models.WdataListQueryResultsResponse]:
        r"""Retrieve a list of query results

        Returns a paged list of query results that match the provided query ID, or an empty
        list if no matching query is found.

        :param request: The request object to send.
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = models.WDATA_LIST_QUERY_RESULTS_OP_SERVERS[0]

        if not isinstance(request, BaseModel):
            request = utils.unmarshal(request, models.WdataListQueryResultsRequest)
        request = cast(models.WdataListQueryResultsRequest, request)

        req = self._build_request_async(
            method="GET",
            path="/api/v1/queryresult",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            allow_empty_value=None,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="wdata_listQueryResults",
                oauth2_scopes=[],
                security_source=self.sdk_configuration.security,
            ),
            request=req,
            error_status_codes=[
                "400",
                "401",
                "403",
                "404",
                "409",
                "423",
                "429",
                "4XX",
                "500",
                "5XX",
            ],
            retry_config=retry_config,
        )

        def next_func() -> Awaitable[Optional[models.WdataListQueryResultsResponse]]:
            body = utils.unmarshal_json(http_res.text, Union[Dict[Any, Any], List[Any]])

            async def empty_result():
                return None

            next_cursor = JSONPath("$.cursor").parse(body)

            if len(next_cursor) == 0:
                return empty_result()

            next_cursor = next_cursor[0]
            if next_cursor is None or str(next_cursor).strip() == "":
                return empty_result()

            return self.list_query_results_async(
                request=models.WdataListQueryResultsRequest(
                    query_id=request.query_id,
                    cursor=next_cursor,
                    limit=request.limit,
                    offset=request.offset,
                    user_specific=request.user_specific,
                ),
                retries=retries,
                server_url=server_url,
            )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return models.WdataListQueryResultsResponse(
                result=unmarshal_json_response(
                    models.PagedResponseQueryResultDto, http_res
                ),
                next=next_func,
            )
        if utils.match_response(http_res, ["403", "404", "429"], "application/json"):
            response_data = unmarshal_json_response(errors.SingleErrorData, http_res)
            raise errors.SingleError(response_data, http_res)
        if utils.match_response(http_res, "500", "application/json"):
            response_data = unmarshal_json_response(errors.SingleErrorData, http_res)
            raise errors.SingleError(response_data, http_res)
        if utils.match_response(http_res, ["400", "401", "409", "423", "4XX"], "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)

        raise errors.SDKError("Unexpected response received", http_res)

    def list_select_lists(
        self,
        *,
        cursor: Optional[str] = None,
        limit: Optional[int] = None,
        offset: Optional[int] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> Optional[models.WdataListSelectListsResponse]:
        r"""Retrieve a list of select lists

        Returns a list of select lists associated with the workspace.

        :param cursor: A paging cursor; if included, `limit` is ignored
        :param limit: The number of select lists to return, from 1 to 1000; by default, 1000
        :param offset: The item to start with on the page, greater than or equal to 0; by default, 0
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = models.WDATA_LIST_SELECT_LISTS_OP_SERVERS[0]

        request = models.WdataListSelectListsRequest(
            cursor=cursor,
            limit=limit,
            offset=offset,
        )

        req = self._build_request(
            method="GET",
            path="/api/v1/selectlist",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            allow_empty_value=None,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="wdata_listSelectLists",
                oauth2_scopes=[],
                security_source=self.sdk_configuration.security,
            ),
            request=req,
            error_status_codes=[
                "400",
                "401",
                "403",
                "404",
                "409",
                "423",
                "429",
                "4XX",
                "500",
                "5XX",
            ],
            retry_config=retry_config,
        )

        def next_func() -> Optional[models.WdataListSelectListsResponse]:
            body = utils.unmarshal_json(http_res.text, Union[Dict[Any, Any], List[Any]])

            next_cursor = JSONPath("$.cursor").parse(body)

            if len(next_cursor) == 0:
                return None

            next_cursor = next_cursor[0]
            if next_cursor is None or str(next_cursor).strip() == "":
                return None

            return self.list_select_lists(
                cursor=next_cursor,
                limit=limit,
                offset=offset,
                retries=retries,
                server_url=server_url,
            )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return models.WdataListSelectListsResponse(
                result=unmarshal_json_response(
                    models.PagedResponseSelectListDto, http_res
                ),
                next=next_func,
            )
        if utils.match_response(http_res, ["403", "404", "429"], "application/json"):
            response_data = unmarshal_json_response(errors.SingleErrorData, http_res)
            raise errors.SingleError(response_data, http_res)
        if utils.match_response(http_res, "500", "application/json"):
            response_data = unmarshal_json_response(errors.SingleErrorData, http_res)
            raise errors.SingleError(response_data, http_res)
        if utils.match_response(http_res, ["400", "401", "409", "423", "4XX"], "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)

        raise errors.SDKError("Unexpected response received", http_res)

    async def list_select_lists_async(
        self,
        *,
        cursor: Optional[str] = None,
        limit: Optional[int] = None,
        offset: Optional[int] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> Optional[models.WdataListSelectListsResponse]:
        r"""Retrieve a list of select lists

        Returns a list of select lists associated with the workspace.

        :param cursor: A paging cursor; if included, `limit` is ignored
        :param limit: The number of select lists to return, from 1 to 1000; by default, 1000
        :param offset: The item to start with on the page, greater than or equal to 0; by default, 0
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = models.WDATA_LIST_SELECT_LISTS_OP_SERVERS[0]

        request = models.WdataListSelectListsRequest(
            cursor=cursor,
            limit=limit,
            offset=offset,
        )

        req = self._build_request_async(
            method="GET",
            path="/api/v1/selectlist",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            allow_empty_value=None,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="wdata_listSelectLists",
                oauth2_scopes=[],
                security_source=self.sdk_configuration.security,
            ),
            request=req,
            error_status_codes=[
                "400",
                "401",
                "403",
                "404",
                "409",
                "423",
                "429",
                "4XX",
                "500",
                "5XX",
            ],
            retry_config=retry_config,
        )

        def next_func() -> Awaitable[Optional[models.WdataListSelectListsResponse]]:
            body = utils.unmarshal_json(http_res.text, Union[Dict[Any, Any], List[Any]])

            async def empty_result():
                return None

            next_cursor = JSONPath("$.cursor").parse(body)

            if len(next_cursor) == 0:
                return empty_result()

            next_cursor = next_cursor[0]
            if next_cursor is None or str(next_cursor).strip() == "":
                return empty_result()

            return self.list_select_lists_async(
                cursor=next_cursor,
                limit=limit,
                offset=offset,
                retries=retries,
                server_url=server_url,
            )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return models.WdataListSelectListsResponse(
                result=unmarshal_json_response(
                    models.PagedResponseSelectListDto, http_res
                ),
                next=next_func,
            )
        if utils.match_response(http_res, ["403", "404", "429"], "application/json"):
            response_data = unmarshal_json_response(errors.SingleErrorData, http_res)
            raise errors.SingleError(response_data, http_res)
        if utils.match_response(http_res, "500", "application/json"):
            response_data = unmarshal_json_response(errors.SingleErrorData, http_res)
            raise errors.SingleError(response_data, http_res)
        if utils.match_response(http_res, ["400", "401", "409", "423", "4XX"], "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)

        raise errors.SDKError("Unexpected response received", http_res)

    def list_shared_tables(
        self,
        *,
        request: Union[
            models.WdataListSharedTablesRequest,
            models.WdataListSharedTablesRequestTypedDict,
        ] = models.WdataListSharedTablesRequest(),
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> Optional[models.WdataListSharedTablesResponse]:
        r"""Retrieve a list of shared tables

        Returns a list of shared tables associated with the workspace of the request.

        :param request: The request object to send.
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = models.WDATA_LIST_SHARED_TABLES_OP_SERVERS[0]

        if not isinstance(request, BaseModel):
            request = utils.unmarshal(request, models.WdataListSharedTablesRequest)
        request = cast(models.WdataListSharedTablesRequest, request)

        req = self._build_request(
            method="GET",
            path="/api/v1/sharedtable",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            allow_empty_value=None,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="wdata_listSharedTables",
                oauth2_scopes=[],
                security_source=self.sdk_configuration.security,
            ),
            request=req,
            error_status_codes=[
                "400",
                "401",
                "403",
                "404",
                "409",
                "423",
                "429",
                "4XX",
                "500",
                "5XX",
            ],
            retry_config=retry_config,
        )

        def next_func() -> Optional[models.WdataListSharedTablesResponse]:
            body = utils.unmarshal_json(http_res.text, Union[Dict[Any, Any], List[Any]])

            next_cursor = JSONPath("$.cursor").parse(body)

            if len(next_cursor) == 0:
                return None

            next_cursor = next_cursor[0]
            if next_cursor is None or str(next_cursor).strip() == "":
                return None

            return self.list_shared_tables(
                request=models.WdataListSharedTablesRequest(
                    cursor=next_cursor,
                    limit=request.limit,
                    offset=request.offset,
                    shared_with_me=request.shared_with_me,
                    table_id=request.table_id,
                ),
                retries=retries,
                server_url=server_url,
            )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return models.WdataListSharedTablesResponse(
                result=unmarshal_json_response(
                    models.PagedResponseSharedTableDto, http_res
                ),
                next=next_func,
            )
        if utils.match_response(http_res, ["403", "404", "429"], "application/json"):
            response_data = unmarshal_json_response(errors.SingleErrorData, http_res)
            raise errors.SingleError(response_data, http_res)
        if utils.match_response(http_res, "500", "application/json"):
            response_data = unmarshal_json_response(errors.SingleErrorData, http_res)
            raise errors.SingleError(response_data, http_res)
        if utils.match_response(http_res, ["400", "401", "409", "423", "4XX"], "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)

        raise errors.SDKError("Unexpected response received", http_res)

    async def list_shared_tables_async(
        self,
        *,
        request: Union[
            models.WdataListSharedTablesRequest,
            models.WdataListSharedTablesRequestTypedDict,
        ] = models.WdataListSharedTablesRequest(),
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> Optional[models.WdataListSharedTablesResponse]:
        r"""Retrieve a list of shared tables

        Returns a list of shared tables associated with the workspace of the request.

        :param request: The request object to send.
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = models.WDATA_LIST_SHARED_TABLES_OP_SERVERS[0]

        if not isinstance(request, BaseModel):
            request = utils.unmarshal(request, models.WdataListSharedTablesRequest)
        request = cast(models.WdataListSharedTablesRequest, request)

        req = self._build_request_async(
            method="GET",
            path="/api/v1/sharedtable",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            allow_empty_value=None,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="wdata_listSharedTables",
                oauth2_scopes=[],
                security_source=self.sdk_configuration.security,
            ),
            request=req,
            error_status_codes=[
                "400",
                "401",
                "403",
                "404",
                "409",
                "423",
                "429",
                "4XX",
                "500",
                "5XX",
            ],
            retry_config=retry_config,
        )

        def next_func() -> Awaitable[Optional[models.WdataListSharedTablesResponse]]:
            body = utils.unmarshal_json(http_res.text, Union[Dict[Any, Any], List[Any]])

            async def empty_result():
                return None

            next_cursor = JSONPath("$.cursor").parse(body)

            if len(next_cursor) == 0:
                return empty_result()

            next_cursor = next_cursor[0]
            if next_cursor is None or str(next_cursor).strip() == "":
                return empty_result()

            return self.list_shared_tables_async(
                request=models.WdataListSharedTablesRequest(
                    cursor=next_cursor,
                    limit=request.limit,
                    offset=request.offset,
                    shared_with_me=request.shared_with_me,
                    table_id=request.table_id,
                ),
                retries=retries,
                server_url=server_url,
            )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return models.WdataListSharedTablesResponse(
                result=unmarshal_json_response(
                    models.PagedResponseSharedTableDto, http_res
                ),
                next=next_func,
            )
        if utils.match_response(http_res, ["403", "404", "429"], "application/json"):
            response_data = unmarshal_json_response(errors.SingleErrorData, http_res)
            raise errors.SingleError(response_data, http_res)
        if utils.match_response(http_res, "500", "application/json"):
            response_data = unmarshal_json_response(errors.SingleErrorData, http_res)
            raise errors.SingleError(response_data, http_res)
        if utils.match_response(http_res, ["400", "401", "409", "423", "4XX"], "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)

        raise errors.SDKError("Unexpected response received", http_res)

    def list_tags(
        self,
        *,
        cursor: Optional[str] = None,
        limit: Optional[int] = 1000,
        offset: Optional[int] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> Optional[models.WdataListTagsResponse]:
        r"""Retrieve a list of tags

        Returns a paged list of all tags associated with the workspace of the request.

        :param cursor: A paging cursor; if included, `limit` is ignored
        :param limit: The number of tags to return, from 1 to 1000; by default, 1000
        :param offset: The item to start with on the page, greater than or equal to 0; by default, 0
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = models.WDATA_LIST_TAGS_OP_SERVERS[0]

        request = models.WdataListTagsRequest(
            cursor=cursor,
            limit=limit,
            offset=offset,
        )

        req = self._build_request(
            method="GET",
            path="/api/v1/tag",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            allow_empty_value=None,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="wdata_listTags",
                oauth2_scopes=[],
                security_source=self.sdk_configuration.security,
            ),
            request=req,
            error_status_codes=[
                "400",
                "401",
                "403",
                "404",
                "409",
                "423",
                "429",
                "4XX",
                "500",
                "5XX",
            ],
            retry_config=retry_config,
        )

        def next_func() -> Optional[models.WdataListTagsResponse]:
            body = utils.unmarshal_json(http_res.text, Union[Dict[Any, Any], List[Any]])

            next_cursor = JSONPath("$.cursor").parse(body)

            if len(next_cursor) == 0:
                return None

            next_cursor = next_cursor[0]
            if next_cursor is None or str(next_cursor).strip() == "":
                return None

            return self.list_tags(
                cursor=next_cursor,
                limit=limit,
                offset=offset,
                retries=retries,
                server_url=server_url,
            )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return models.WdataListTagsResponse(
                result=unmarshal_json_response(models.PagedResponseTagDto, http_res),
                next=next_func,
            )
        if utils.match_response(http_res, ["403", "404", "429"], "application/json"):
            response_data = unmarshal_json_response(errors.SingleErrorData, http_res)
            raise errors.SingleError(response_data, http_res)
        if utils.match_response(http_res, "500", "application/json"):
            response_data = unmarshal_json_response(errors.SingleErrorData, http_res)
            raise errors.SingleError(response_data, http_res)
        if utils.match_response(http_res, ["400", "401", "409", "423", "4XX"], "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)

        raise errors.SDKError("Unexpected response received", http_res)

    async def list_tags_async(
        self,
        *,
        cursor: Optional[str] = None,
        limit: Optional[int] = 1000,
        offset: Optional[int] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> Optional[models.WdataListTagsResponse]:
        r"""Retrieve a list of tags

        Returns a paged list of all tags associated with the workspace of the request.

        :param cursor: A paging cursor; if included, `limit` is ignored
        :param limit: The number of tags to return, from 1 to 1000; by default, 1000
        :param offset: The item to start with on the page, greater than or equal to 0; by default, 0
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = models.WDATA_LIST_TAGS_OP_SERVERS[0]

        request = models.WdataListTagsRequest(
            cursor=cursor,
            limit=limit,
            offset=offset,
        )

        req = self._build_request_async(
            method="GET",
            path="/api/v1/tag",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            allow_empty_value=None,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="wdata_listTags",
                oauth2_scopes=[],
                security_source=self.sdk_configuration.security,
            ),
            request=req,
            error_status_codes=[
                "400",
                "401",
                "403",
                "404",
                "409",
                "423",
                "429",
                "4XX",
                "500",
                "5XX",
            ],
            retry_config=retry_config,
        )

        def next_func() -> Awaitable[Optional[models.WdataListTagsResponse]]:
            body = utils.unmarshal_json(http_res.text, Union[Dict[Any, Any], List[Any]])

            async def empty_result():
                return None

            next_cursor = JSONPath("$.cursor").parse(body)

            if len(next_cursor) == 0:
                return empty_result()

            next_cursor = next_cursor[0]
            if next_cursor is None or str(next_cursor).strip() == "":
                return empty_result()

            return self.list_tags_async(
                cursor=next_cursor,
                limit=limit,
                offset=offset,
                retries=retries,
                server_url=server_url,
            )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return models.WdataListTagsResponse(
                result=unmarshal_json_response(models.PagedResponseTagDto, http_res),
                next=next_func,
            )
        if utils.match_response(http_res, ["403", "404", "429"], "application/json"):
            response_data = unmarshal_json_response(errors.SingleErrorData, http_res)
            raise errors.SingleError(response_data, http_res)
        if utils.match_response(http_res, "500", "application/json"):
            response_data = unmarshal_json_response(errors.SingleErrorData, http_res)
            raise errors.SingleError(response_data, http_res)
        if utils.match_response(http_res, ["400", "401", "409", "423", "4XX"], "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)

        raise errors.SDKError("Unexpected response received", http_res)

    def parse_date(
        self,
        *,
        request: Union[models.DatetimeDto, models.DatetimeDtoTypedDict],
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.BaseResponseString:
        r"""Parse a date

        Provides a simple endpoint to check whether a given date candidate parses with
        the provided format string.  Both the date candidate and format strings are required.
        Returns a 200 if the date parses, or a 400 with a message if not. If the date parses,
        the provided format can be provided as column metadata, and the imported values parse
        correctly. The format string is java DateTimeFormatter style e.g. dateFormat =
        \"MM/dd/yyyy\" and candidate = \"07/28/1987\"

        :param request: The request object to send.
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = models.WDATA_PARSE_DATE_OP_SERVERS[0]

        if not isinstance(request, BaseModel):
            request = utils.unmarshal(request, models.DatetimeDto)
        request = cast(models.DatetimeDto, request)

        req = self._build_request(
            method="POST",
            path="/api/v1/util/datetime",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request, False, False, "json", models.DatetimeDto
            ),
            allow_empty_value=None,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="wdata_parseDate",
                oauth2_scopes=[],
                security_source=self.sdk_configuration.security,
            ),
            request=req,
            error_status_codes=[
                "400",
                "401",
                "403",
                "404",
                "409",
                "423",
                "429",
                "4XX",
                "500",
                "5XX",
            ],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(models.BaseResponseString, http_res)
        if utils.match_response(http_res, "400", "application/json"):
            response_data = unmarshal_json_response(errors.MultiErrorData, http_res)
            raise errors.MultiError(response_data, http_res)
        if utils.match_response(
            http_res, ["401", "403", "404", "409", "429"], "application/json"
        ):
            response_data = unmarshal_json_response(errors.SingleErrorData, http_res)
            raise errors.SingleError(response_data, http_res)
        if utils.match_response(http_res, "500", "application/json"):
            response_data = unmarshal_json_response(errors.SingleErrorData, http_res)
            raise errors.SingleError(response_data, http_res)
        if utils.match_response(http_res, ["423", "4XX"], "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)

        raise errors.SDKError("Unexpected response received", http_res)

    async def parse_date_async(
        self,
        *,
        request: Union[models.DatetimeDto, models.DatetimeDtoTypedDict],
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.BaseResponseString:
        r"""Parse a date

        Provides a simple endpoint to check whether a given date candidate parses with
        the provided format string.  Both the date candidate and format strings are required.
        Returns a 200 if the date parses, or a 400 with a message if not. If the date parses,
        the provided format can be provided as column metadata, and the imported values parse
        correctly. The format string is java DateTimeFormatter style e.g. dateFormat =
        \"MM/dd/yyyy\" and candidate = \"07/28/1987\"

        :param request: The request object to send.
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = models.WDATA_PARSE_DATE_OP_SERVERS[0]

        if not isinstance(request, BaseModel):
            request = utils.unmarshal(request, models.DatetimeDto)
        request = cast(models.DatetimeDto, request)

        req = self._build_request_async(
            method="POST",
            path="/api/v1/util/datetime",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request, False, False, "json", models.DatetimeDto
            ),
            allow_empty_value=None,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="wdata_parseDate",
                oauth2_scopes=[],
                security_source=self.sdk_configuration.security,
            ),
            request=req,
            error_status_codes=[
                "400",
                "401",
                "403",
                "404",
                "409",
                "423",
                "429",
                "4XX",
                "500",
                "5XX",
            ],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(models.BaseResponseString, http_res)
        if utils.match_response(http_res, "400", "application/json"):
            response_data = unmarshal_json_response(errors.MultiErrorData, http_res)
            raise errors.MultiError(response_data, http_res)
        if utils.match_response(
            http_res, ["401", "403", "404", "409", "429"], "application/json"
        ):
            response_data = unmarshal_json_response(errors.SingleErrorData, http_res)
            raise errors.SingleError(response_data, http_res)
        if utils.match_response(http_res, "500", "application/json"):
            response_data = unmarshal_json_response(errors.SingleErrorData, http_res)
            raise errors.SingleError(response_data, http_res)
        if utils.match_response(http_res, ["423", "4XX"], "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)

        raise errors.SDKError("Unexpected response received", http_res)

    def refresh_batch(
        self,
        *,
        request_body: Union[
            List[models.RefreshConnectionDto],
            List[models.RefreshConnectionDtoTypedDict],
        ],
        cancel_unwritables: Optional[bool] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.BaseResponseRefreshBatchDto:
        r"""Refresh batch of connections

        Refreshes multiple incoming connections within the same spreadsheet, based on ID. When connecting to multiple spreadsheets, tables or other destinations, use the [`singular refresh connection`](ref:wdata-refreshconnection) instead.
        `usePreviousDestinationParameters` and  `usePreviousSourceParameters` will use the exact parameters of your previous run; any new parameters youve provided will be ignored. This endpoint only works for outgoing connections if they are all connected to the same workbook. This endpoint has a limit of 100 refreshes per request.

        :param request_body:
        :param cancel_unwritables: Allow individual connections in the batch to be canceled if they have a destination that is unwritable. This will NOT cancel the entire batch.
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = models.WDATA_REFRESH_BATCH_OP_SERVERS[0]

        request = models.WdataRefreshBatchRequest(
            cancel_unwritables=cancel_unwritables,
            request_body=utils.get_pydantic_model(
                request_body, List[models.RefreshConnectionDto]
            ),
        )

        req = self._build_request(
            method="POST",
            path="/api/v1/connections/batch/refresh",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request.request_body,
                False,
                False,
                "json",
                List[models.RefreshConnectionDto],
            ),
            allow_empty_value=None,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="wdata_refreshBatch",
                oauth2_scopes=[],
                security_source=self.sdk_configuration.security,
            ),
            request=req,
            error_status_codes=[
                "400",
                "401",
                "403",
                "404",
                "409",
                "423",
                "429",
                "4XX",
                "500",
                "5XX",
            ],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(models.BaseResponseRefreshBatchDto, http_res)
        if utils.match_response(http_res, "400", "application/json"):
            response_data = unmarshal_json_response(errors.MultiErrorData, http_res)
            raise errors.MultiError(response_data, http_res)
        if utils.match_response(
            http_res, ["401", "403", "404", "409", "429"], "application/json"
        ):
            response_data = unmarshal_json_response(errors.SingleErrorData, http_res)
            raise errors.SingleError(response_data, http_res)
        if utils.match_response(http_res, "500", "application/json"):
            response_data = unmarshal_json_response(errors.SingleErrorData, http_res)
            raise errors.SingleError(response_data, http_res)
        if utils.match_response(http_res, ["423", "4XX"], "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)

        raise errors.SDKError("Unexpected response received", http_res)

    async def refresh_batch_async(
        self,
        *,
        request_body: Union[
            List[models.RefreshConnectionDto],
            List[models.RefreshConnectionDtoTypedDict],
        ],
        cancel_unwritables: Optional[bool] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.BaseResponseRefreshBatchDto:
        r"""Refresh batch of connections

        Refreshes multiple incoming connections within the same spreadsheet, based on ID. When connecting to multiple spreadsheets, tables or other destinations, use the [`singular refresh connection`](ref:wdata-refreshconnection) instead.
        `usePreviousDestinationParameters` and  `usePreviousSourceParameters` will use the exact parameters of your previous run; any new parameters youve provided will be ignored. This endpoint only works for outgoing connections if they are all connected to the same workbook. This endpoint has a limit of 100 refreshes per request.

        :param request_body:
        :param cancel_unwritables: Allow individual connections in the batch to be canceled if they have a destination that is unwritable. This will NOT cancel the entire batch.
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = models.WDATA_REFRESH_BATCH_OP_SERVERS[0]

        request = models.WdataRefreshBatchRequest(
            cancel_unwritables=cancel_unwritables,
            request_body=utils.get_pydantic_model(
                request_body, List[models.RefreshConnectionDto]
            ),
        )

        req = self._build_request_async(
            method="POST",
            path="/api/v1/connections/batch/refresh",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request.request_body,
                False,
                False,
                "json",
                List[models.RefreshConnectionDto],
            ),
            allow_empty_value=None,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="wdata_refreshBatch",
                oauth2_scopes=[],
                security_source=self.sdk_configuration.security,
            ),
            request=req,
            error_status_codes=[
                "400",
                "401",
                "403",
                "404",
                "409",
                "423",
                "429",
                "4XX",
                "500",
                "5XX",
            ],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(models.BaseResponseRefreshBatchDto, http_res)
        if utils.match_response(http_res, "400", "application/json"):
            response_data = unmarshal_json_response(errors.MultiErrorData, http_res)
            raise errors.MultiError(response_data, http_res)
        if utils.match_response(
            http_res, ["401", "403", "404", "409", "429"], "application/json"
        ):
            response_data = unmarshal_json_response(errors.SingleErrorData, http_res)
            raise errors.SingleError(response_data, http_res)
        if utils.match_response(http_res, "500", "application/json"):
            response_data = unmarshal_json_response(errors.SingleErrorData, http_res)
            raise errors.SingleError(response_data, http_res)
        if utils.match_response(http_res, ["423", "4XX"], "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)

        raise errors.SDKError("Unexpected response received", http_res)

    def refresh_connection(
        self,
        *,
        connection_id: str,
        refresh_connection_dto: Union[
            models.RefreshConnectionDto, models.RefreshConnectionDtoTypedDict
        ],
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.BaseResponseConnectionRunDto:
        r"""Refresh connection

        Refreshes a specific connection, based on its ID

        :param connection_id:
        :param refresh_connection_dto:
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = models.WDATA_REFRESH_CONNECTION_OP_SERVERS[0]

        request = models.WdataRefreshConnectionRequest(
            connection_id=connection_id,
            refresh_connection_dto=utils.get_pydantic_model(
                refresh_connection_dto, models.RefreshConnectionDto
            ),
        )

        req = self._build_request(
            method="POST",
            path="/api/v1/connections/{connectionId}/refresh",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request.refresh_connection_dto,
                False,
                False,
                "json",
                models.RefreshConnectionDto,
            ),
            allow_empty_value=None,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="wdata_refreshConnection",
                oauth2_scopes=[],
                security_source=self.sdk_configuration.security,
            ),
            request=req,
            error_status_codes=[
                "400",
                "401",
                "403",
                "404",
                "409",
                "423",
                "429",
                "4XX",
                "500",
                "5XX",
            ],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(
                models.BaseResponseConnectionRunDto, http_res
            )
        if utils.match_response(http_res, "400", "application/json"):
            response_data = unmarshal_json_response(errors.MultiErrorData, http_res)
            raise errors.MultiError(response_data, http_res)
        if utils.match_response(
            http_res, ["401", "403", "404", "409", "429"], "application/json"
        ):
            response_data = unmarshal_json_response(errors.SingleErrorData, http_res)
            raise errors.SingleError(response_data, http_res)
        if utils.match_response(http_res, "500", "application/json"):
            response_data = unmarshal_json_response(errors.SingleErrorData, http_res)
            raise errors.SingleError(response_data, http_res)
        if utils.match_response(http_res, ["423", "4XX"], "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)

        raise errors.SDKError("Unexpected response received", http_res)

    async def refresh_connection_async(
        self,
        *,
        connection_id: str,
        refresh_connection_dto: Union[
            models.RefreshConnectionDto, models.RefreshConnectionDtoTypedDict
        ],
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.BaseResponseConnectionRunDto:
        r"""Refresh connection

        Refreshes a specific connection, based on its ID

        :param connection_id:
        :param refresh_connection_dto:
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = models.WDATA_REFRESH_CONNECTION_OP_SERVERS[0]

        request = models.WdataRefreshConnectionRequest(
            connection_id=connection_id,
            refresh_connection_dto=utils.get_pydantic_model(
                refresh_connection_dto, models.RefreshConnectionDto
            ),
        )

        req = self._build_request_async(
            method="POST",
            path="/api/v1/connections/{connectionId}/refresh",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request.refresh_connection_dto,
                False,
                False,
                "json",
                models.RefreshConnectionDto,
            ),
            allow_empty_value=None,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="wdata_refreshConnection",
                oauth2_scopes=[],
                security_source=self.sdk_configuration.security,
            ),
            request=req,
            error_status_codes=[
                "400",
                "401",
                "403",
                "404",
                "409",
                "423",
                "429",
                "4XX",
                "500",
                "5XX",
            ],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(
                models.BaseResponseConnectionRunDto, http_res
            )
        if utils.match_response(http_res, "400", "application/json"):
            response_data = unmarshal_json_response(errors.MultiErrorData, http_res)
            raise errors.MultiError(response_data, http_res)
        if utils.match_response(
            http_res, ["401", "403", "404", "409", "429"], "application/json"
        ):
            response_data = unmarshal_json_response(errors.SingleErrorData, http_res)
            raise errors.SingleError(response_data, http_res)
        if utils.match_response(http_res, "500", "application/json"):
            response_data = unmarshal_json_response(errors.SingleErrorData, http_res)
            raise errors.SingleError(response_data, http_res)
        if utils.match_response(http_res, ["423", "4XX"], "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)

        raise errors.SDKError("Unexpected response received", http_res)

    def run_query(
        self,
        *,
        request: Union[models.QueryResultDtoInput, models.QueryResultDtoInputTypedDict],
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.BaseResponseQueryResultDto:
        r"""Execute a query

        Runs a query and immediately returns a query result entity, which has an ID that
        can be used to poll the status from the GET /queryresult method. A status of
        COMPLETED or ERROR indicates the query has completed.

        :param request: The request object to send.
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = models.WDATA_RUN_QUERY_OP_SERVERS[0]

        if not isinstance(request, BaseModel):
            request = utils.unmarshal(request, models.QueryResultDtoInput)
        request = cast(models.QueryResultDtoInput, request)

        req = self._build_request(
            method="POST",
            path="/api/v1/queryresult",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request, False, False, "json", models.QueryResultDtoInput
            ),
            allow_empty_value=None,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="wdata_runQuery",
                oauth2_scopes=[],
                security_source=self.sdk_configuration.security,
            ),
            request=req,
            error_status_codes=[
                "400",
                "401",
                "403",
                "404",
                "409",
                "423",
                "429",
                "4XX",
                "500",
                "5XX",
            ],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "201", "application/json"):
            return unmarshal_json_response(models.BaseResponseQueryResultDto, http_res)
        if utils.match_response(http_res, "400", "application/json"):
            response_data = unmarshal_json_response(errors.MultiErrorData, http_res)
            raise errors.MultiError(response_data, http_res)
        if utils.match_response(
            http_res, ["401", "403", "404", "409", "429"], "application/json"
        ):
            response_data = unmarshal_json_response(errors.SingleErrorData, http_res)
            raise errors.SingleError(response_data, http_res)
        if utils.match_response(http_res, "500", "application/json"):
            response_data = unmarshal_json_response(errors.SingleErrorData, http_res)
            raise errors.SingleError(response_data, http_res)
        if utils.match_response(http_res, ["423", "4XX"], "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)

        raise errors.SDKError("Unexpected response received", http_res)

    async def run_query_async(
        self,
        *,
        request: Union[models.QueryResultDtoInput, models.QueryResultDtoInputTypedDict],
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.BaseResponseQueryResultDto:
        r"""Execute a query

        Runs a query and immediately returns a query result entity, which has an ID that
        can be used to poll the status from the GET /queryresult method. A status of
        COMPLETED or ERROR indicates the query has completed.

        :param request: The request object to send.
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = models.WDATA_RUN_QUERY_OP_SERVERS[0]

        if not isinstance(request, BaseModel):
            request = utils.unmarshal(request, models.QueryResultDtoInput)
        request = cast(models.QueryResultDtoInput, request)

        req = self._build_request_async(
            method="POST",
            path="/api/v1/queryresult",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request, False, False, "json", models.QueryResultDtoInput
            ),
            allow_empty_value=None,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="wdata_runQuery",
                oauth2_scopes=[],
                security_source=self.sdk_configuration.security,
            ),
            request=req,
            error_status_codes=[
                "400",
                "401",
                "403",
                "404",
                "409",
                "423",
                "429",
                "4XX",
                "500",
                "5XX",
            ],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "201", "application/json"):
            return unmarshal_json_response(models.BaseResponseQueryResultDto, http_res)
        if utils.match_response(http_res, "400", "application/json"):
            response_data = unmarshal_json_response(errors.MultiErrorData, http_res)
            raise errors.MultiError(response_data, http_res)
        if utils.match_response(
            http_res, ["401", "403", "404", "409", "429"], "application/json"
        ):
            response_data = unmarshal_json_response(errors.SingleErrorData, http_res)
            raise errors.SingleError(response_data, http_res)
        if utils.match_response(http_res, "500", "application/json"):
            response_data = unmarshal_json_response(errors.SingleErrorData, http_res)
            raise errors.SingleError(response_data, http_res)
        if utils.match_response(http_res, ["423", "4XX"], "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)

        raise errors.SDKError("Unexpected response received", http_res)

    def search(
        self,
        *,
        request: Union[
            models.WdataSearchRequest, models.WdataSearchRequestTypedDict
        ] = models.WdataSearchRequest(),
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> Optional[models.WdataSearchResponse]:
        r"""Search

        Returns a list of all entities that match the provided criteria. Both name and
        description are fuzzy matches; they match _any_ entity that contains the provided
        string. The type is used to filter results based on the provided type of entity.
        The consumer must have READ access on all returned entities.

        :param request: The request object to send.
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = models.WDATA_SEARCH_OP_SERVERS[0]

        if not isinstance(request, BaseModel):
            request = utils.unmarshal(request, models.WdataSearchRequest)
        request = cast(models.WdataSearchRequest, request)

        req = self._build_request(
            method="GET",
            path="/api/v1/entity",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            allow_empty_value=None,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="wdata_search",
                oauth2_scopes=[],
                security_source=self.sdk_configuration.security,
            ),
            request=req,
            error_status_codes=[
                "400",
                "401",
                "403",
                "404",
                "409",
                "423",
                "429",
                "4XX",
                "500",
                "5XX",
            ],
            retry_config=retry_config,
        )

        def next_func() -> Optional[models.WdataSearchResponse]:
            body = utils.unmarshal_json(http_res.text, Union[Dict[Any, Any], List[Any]])

            next_cursor = JSONPath("$.cursor").parse(body)

            if len(next_cursor) == 0:
                return None

            next_cursor = next_cursor[0]
            if next_cursor is None or str(next_cursor).strip() == "":
                return None

            return self.search(
                request=models.WdataSearchRequest(
                    cursor=next_cursor,
                    description=request.description,
                    limit=request.limit,
                    name=request.name,
                    offset=request.offset,
                    type=request.type,
                ),
                retries=retries,
                server_url=server_url,
            )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return models.WdataSearchResponse(
                result=unmarshal_json_response(
                    models.PagedResponseFolderableDto, http_res
                ),
                next=next_func,
            )
        if utils.match_response(http_res, ["403", "404", "429"], "application/json"):
            response_data = unmarshal_json_response(errors.SingleErrorData, http_res)
            raise errors.SingleError(response_data, http_res)
        if utils.match_response(http_res, "500", "application/json"):
            response_data = unmarshal_json_response(errors.SingleErrorData, http_res)
            raise errors.SingleError(response_data, http_res)
        if utils.match_response(http_res, ["400", "401", "409", "423", "4XX"], "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)

        raise errors.SDKError("Unexpected response received", http_res)

    async def search_async(
        self,
        *,
        request: Union[
            models.WdataSearchRequest, models.WdataSearchRequestTypedDict
        ] = models.WdataSearchRequest(),
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> Optional[models.WdataSearchResponse]:
        r"""Search

        Returns a list of all entities that match the provided criteria. Both name and
        description are fuzzy matches; they match _any_ entity that contains the provided
        string. The type is used to filter results based on the provided type of entity.
        The consumer must have READ access on all returned entities.

        :param request: The request object to send.
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = models.WDATA_SEARCH_OP_SERVERS[0]

        if not isinstance(request, BaseModel):
            request = utils.unmarshal(request, models.WdataSearchRequest)
        request = cast(models.WdataSearchRequest, request)

        req = self._build_request_async(
            method="GET",
            path="/api/v1/entity",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            allow_empty_value=None,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="wdata_search",
                oauth2_scopes=[],
                security_source=self.sdk_configuration.security,
            ),
            request=req,
            error_status_codes=[
                "400",
                "401",
                "403",
                "404",
                "409",
                "423",
                "429",
                "4XX",
                "500",
                "5XX",
            ],
            retry_config=retry_config,
        )

        def next_func() -> Awaitable[Optional[models.WdataSearchResponse]]:
            body = utils.unmarshal_json(http_res.text, Union[Dict[Any, Any], List[Any]])

            async def empty_result():
                return None

            next_cursor = JSONPath("$.cursor").parse(body)

            if len(next_cursor) == 0:
                return empty_result()

            next_cursor = next_cursor[0]
            if next_cursor is None or str(next_cursor).strip() == "":
                return empty_result()

            return self.search_async(
                request=models.WdataSearchRequest(
                    cursor=next_cursor,
                    description=request.description,
                    limit=request.limit,
                    name=request.name,
                    offset=request.offset,
                    type=request.type,
                ),
                retries=retries,
                server_url=server_url,
            )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return models.WdataSearchResponse(
                result=unmarshal_json_response(
                    models.PagedResponseFolderableDto, http_res
                ),
                next=next_func,
            )
        if utils.match_response(http_res, ["403", "404", "429"], "application/json"):
            response_data = unmarshal_json_response(errors.SingleErrorData, http_res)
            raise errors.SingleError(response_data, http_res)
        if utils.match_response(http_res, "500", "application/json"):
            response_data = unmarshal_json_response(errors.SingleErrorData, http_res)
            raise errors.SingleError(response_data, http_res)
        if utils.match_response(http_res, ["400", "401", "409", "423", "4XX"], "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)

        raise errors.SDKError("Unexpected response received", http_res)

    def set_children(
        self,
        *,
        folder_id: str,
        request_body: Union[
            List[models.FolderableDtoInput], List[models.FolderableDtoInputTypedDict]
        ],
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.BaseResponseCollectionFolderableDto:
        r"""Move content into a folder

        Sets the children of a folder using the entities' types and IDs provided in the
        body. If the entities previously resided under a folder, including the root,
        they move to the folder with the provided ID. If the provided ID is 'null',
        the entities move to the root folder.

        :param folder_id: The unique identifier of the folder
        :param request_body: The representation of the entities to drop into the folder
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = models.WDATA_SET_CHILDREN_OP_SERVERS[0]

        request = models.WdataSetChildrenRequest(
            folder_id=folder_id,
            request_body=utils.get_pydantic_model(
                request_body, List[models.FolderableDtoInput]
            ),
        )

        req = self._build_request(
            method="POST",
            path="/api/v1/folder/{folderId}/children",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request.request_body,
                False,
                False,
                "json",
                List[models.FolderableDtoInput],
            ),
            allow_empty_value=None,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="wdata_setChildren",
                oauth2_scopes=[],
                security_source=self.sdk_configuration.security,
            ),
            request=req,
            error_status_codes=[
                "400",
                "401",
                "403",
                "404",
                "409",
                "423",
                "429",
                "4XX",
                "500",
                "5XX",
            ],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(
                models.BaseResponseCollectionFolderableDto, http_res
            )
        if utils.match_response(http_res, "400", "application/json"):
            response_data = unmarshal_json_response(errors.MultiErrorData, http_res)
            raise errors.MultiError(response_data, http_res)
        if utils.match_response(
            http_res, ["401", "403", "404", "409", "429"], "application/json"
        ):
            response_data = unmarshal_json_response(errors.SingleErrorData, http_res)
            raise errors.SingleError(response_data, http_res)
        if utils.match_response(http_res, "500", "application/json"):
            response_data = unmarshal_json_response(errors.SingleErrorData, http_res)
            raise errors.SingleError(response_data, http_res)
        if utils.match_response(http_res, ["423", "4XX"], "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)

        raise errors.SDKError("Unexpected response received", http_res)

    async def set_children_async(
        self,
        *,
        folder_id: str,
        request_body: Union[
            List[models.FolderableDtoInput], List[models.FolderableDtoInputTypedDict]
        ],
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.BaseResponseCollectionFolderableDto:
        r"""Move content into a folder

        Sets the children of a folder using the entities' types and IDs provided in the
        body. If the entities previously resided under a folder, including the root,
        they move to the folder with the provided ID. If the provided ID is 'null',
        the entities move to the root folder.

        :param folder_id: The unique identifier of the folder
        :param request_body: The representation of the entities to drop into the folder
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = models.WDATA_SET_CHILDREN_OP_SERVERS[0]

        request = models.WdataSetChildrenRequest(
            folder_id=folder_id,
            request_body=utils.get_pydantic_model(
                request_body, List[models.FolderableDtoInput]
            ),
        )

        req = self._build_request_async(
            method="POST",
            path="/api/v1/folder/{folderId}/children",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request.request_body,
                False,
                False,
                "json",
                List[models.FolderableDtoInput],
            ),
            allow_empty_value=None,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="wdata_setChildren",
                oauth2_scopes=[],
                security_source=self.sdk_configuration.security,
            ),
            request=req,
            error_status_codes=[
                "400",
                "401",
                "403",
                "404",
                "409",
                "423",
                "429",
                "4XX",
                "500",
                "5XX",
            ],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(
                models.BaseResponseCollectionFolderableDto, http_res
            )
        if utils.match_response(http_res, "400", "application/json"):
            response_data = unmarshal_json_response(errors.MultiErrorData, http_res)
            raise errors.MultiError(response_data, http_res)
        if utils.match_response(
            http_res, ["401", "403", "404", "409", "429"], "application/json"
        ):
            response_data = unmarshal_json_response(errors.SingleErrorData, http_res)
            raise errors.SingleError(response_data, http_res)
        if utils.match_response(http_res, "500", "application/json"):
            response_data = unmarshal_json_response(errors.SingleErrorData, http_res)
            raise errors.SingleError(response_data, http_res)
        if utils.match_response(http_res, ["423", "4XX"], "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)

        raise errors.SDKError("Unexpected response received", http_res)

    def unimport_file(
        self,
        *,
        file_id: str,
        table_id: str,
        force: Optional[str] = "false",
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.BaseResponseFileMetaDto:
        r"""Unimport a single file

        Unimports the provided file from the provided table. Returns a 409 if the file is
        not in an imported state, or a 404 if the file can't be found.

        :param file_id: The unique identifier of the file
        :param table_id: The unique identifier of the table
        :param force: If true, unimports and deletes file from the table
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = models.WDATA_UNIMPORT_FILE_OP_SERVERS[0]

        request = models.WdataUnimportFileRequest(
            file_id=file_id,
            force=force,
            table_id=table_id,
        )

        req = self._build_request(
            method="DELETE",
            path="/api/v1/table/{tableId}/import/{fileId}",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            allow_empty_value=None,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="wdata_unimportFile",
                oauth2_scopes=[],
                security_source=self.sdk_configuration.security,
            ),
            request=req,
            error_status_codes=[
                "400",
                "401",
                "403",
                "404",
                "409",
                "423",
                "429",
                "4XX",
                "500",
                "5XX",
            ],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(models.BaseResponseFileMetaDto, http_res)
        if utils.match_response(http_res, "400", "application/json"):
            response_data = unmarshal_json_response(errors.MultiErrorData, http_res)
            raise errors.MultiError(response_data, http_res)
        if utils.match_response(
            http_res, ["401", "403", "404", "409", "429"], "application/json"
        ):
            response_data = unmarshal_json_response(errors.SingleErrorData, http_res)
            raise errors.SingleError(response_data, http_res)
        if utils.match_response(http_res, "500", "application/json"):
            response_data = unmarshal_json_response(errors.SingleErrorData, http_res)
            raise errors.SingleError(response_data, http_res)
        if utils.match_response(http_res, ["423", "4XX"], "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)

        raise errors.SDKError("Unexpected response received", http_res)

    async def unimport_file_async(
        self,
        *,
        file_id: str,
        table_id: str,
        force: Optional[str] = "false",
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.BaseResponseFileMetaDto:
        r"""Unimport a single file

        Unimports the provided file from the provided table. Returns a 409 if the file is
        not in an imported state, or a 404 if the file can't be found.

        :param file_id: The unique identifier of the file
        :param table_id: The unique identifier of the table
        :param force: If true, unimports and deletes file from the table
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = models.WDATA_UNIMPORT_FILE_OP_SERVERS[0]

        request = models.WdataUnimportFileRequest(
            file_id=file_id,
            force=force,
            table_id=table_id,
        )

        req = self._build_request_async(
            method="DELETE",
            path="/api/v1/table/{tableId}/import/{fileId}",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            allow_empty_value=None,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="wdata_unimportFile",
                oauth2_scopes=[],
                security_source=self.sdk_configuration.security,
            ),
            request=req,
            error_status_codes=[
                "400",
                "401",
                "403",
                "404",
                "409",
                "423",
                "429",
                "4XX",
                "500",
                "5XX",
            ],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(models.BaseResponseFileMetaDto, http_res)
        if utils.match_response(http_res, "400", "application/json"):
            response_data = unmarshal_json_response(errors.MultiErrorData, http_res)
            raise errors.MultiError(response_data, http_res)
        if utils.match_response(
            http_res, ["401", "403", "404", "409", "429"], "application/json"
        ):
            response_data = unmarshal_json_response(errors.SingleErrorData, http_res)
            raise errors.SingleError(response_data, http_res)
        if utils.match_response(http_res, "500", "application/json"):
            response_data = unmarshal_json_response(errors.SingleErrorData, http_res)
            raise errors.SingleError(response_data, http_res)
        if utils.match_response(http_res, ["423", "4XX"], "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)

        raise errors.SDKError("Unexpected response received", http_res)

    def update_folder(
        self,
        *,
        folder_id: str,
        folder_dto: Union[models.FolderDtoInput, models.FolderDtoInputTypedDict],
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.BaseResponseFolderDto:
        r"""Update a single folder

        Updates the folder that matches the provided ID with the details provided in the
        body.

        :param folder_id: The unique identifier of the folder
        :param folder_dto: The representation of the folder to update
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = models.WDATA_UPDATE_FOLDER_OP_SERVERS[0]

        request = models.WdataUpdateFolderRequest(
            folder_id=folder_id,
            folder_dto=utils.get_pydantic_model(folder_dto, models.FolderDtoInput),
        )

        req = self._build_request(
            method="PUT",
            path="/api/v1/folder/{folderId}",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request.folder_dto, False, False, "json", models.FolderDtoInput
            ),
            allow_empty_value=None,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="wdata_updateFolder",
                oauth2_scopes=[],
                security_source=self.sdk_configuration.security,
            ),
            request=req,
            error_status_codes=[
                "400",
                "401",
                "403",
                "404",
                "409",
                "423",
                "429",
                "4XX",
                "500",
                "5XX",
            ],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(models.BaseResponseFolderDto, http_res)
        if utils.match_response(http_res, "400", "application/json"):
            response_data = unmarshal_json_response(errors.MultiErrorData, http_res)
            raise errors.MultiError(response_data, http_res)
        if utils.match_response(
            http_res, ["401", "403", "404", "409", "429"], "application/json"
        ):
            response_data = unmarshal_json_response(errors.SingleErrorData, http_res)
            raise errors.SingleError(response_data, http_res)
        if utils.match_response(http_res, "500", "application/json"):
            response_data = unmarshal_json_response(errors.SingleErrorData, http_res)
            raise errors.SingleError(response_data, http_res)
        if utils.match_response(http_res, ["423", "4XX"], "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)

        raise errors.SDKError("Unexpected response received", http_res)

    async def update_folder_async(
        self,
        *,
        folder_id: str,
        folder_dto: Union[models.FolderDtoInput, models.FolderDtoInputTypedDict],
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.BaseResponseFolderDto:
        r"""Update a single folder

        Updates the folder that matches the provided ID with the details provided in the
        body.

        :param folder_id: The unique identifier of the folder
        :param folder_dto: The representation of the folder to update
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = models.WDATA_UPDATE_FOLDER_OP_SERVERS[0]

        request = models.WdataUpdateFolderRequest(
            folder_id=folder_id,
            folder_dto=utils.get_pydantic_model(folder_dto, models.FolderDtoInput),
        )

        req = self._build_request_async(
            method="PUT",
            path="/api/v1/folder/{folderId}",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request.folder_dto, False, False, "json", models.FolderDtoInput
            ),
            allow_empty_value=None,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="wdata_updateFolder",
                oauth2_scopes=[],
                security_source=self.sdk_configuration.security,
            ),
            request=req,
            error_status_codes=[
                "400",
                "401",
                "403",
                "404",
                "409",
                "423",
                "429",
                "4XX",
                "500",
                "5XX",
            ],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(models.BaseResponseFolderDto, http_res)
        if utils.match_response(http_res, "400", "application/json"):
            response_data = unmarshal_json_response(errors.MultiErrorData, http_res)
            raise errors.MultiError(response_data, http_res)
        if utils.match_response(
            http_res, ["401", "403", "404", "409", "429"], "application/json"
        ):
            response_data = unmarshal_json_response(errors.SingleErrorData, http_res)
            raise errors.SingleError(response_data, http_res)
        if utils.match_response(http_res, "500", "application/json"):
            response_data = unmarshal_json_response(errors.SingleErrorData, http_res)
            raise errors.SingleError(response_data, http_res)
        if utils.match_response(http_res, ["423", "4XX"], "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)

        raise errors.SDKError("Unexpected response received", http_res)

    def update_parameter(
        self,
        *,
        parameter_id: str,
        global_parameter_dto: Union[
            models.GlobalParameterDtoInput, models.GlobalParameterDtoInputTypedDict
        ],
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.BaseResponseGlobalParameterDto:
        r"""Update Parameter

        Updates the parameter matching the provided ID in the provided payload.

        :param parameter_id: The unique identifier of the parameter
        :param global_parameter_dto: The representation of the parameter to update
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = models.WDATA_UPDATE_PARAMETER_OP_SERVERS[0]

        request = models.WdataUpdateParameterRequest(
            parameter_id=parameter_id,
            global_parameter_dto=utils.get_pydantic_model(
                global_parameter_dto, models.GlobalParameterDtoInput
            ),
        )

        req = self._build_request(
            method="PUT",
            path="/api/v1/parameter/{parameterId}",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request.global_parameter_dto,
                False,
                False,
                "json",
                models.GlobalParameterDtoInput,
            ),
            allow_empty_value=None,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="wdata_updateParameter",
                oauth2_scopes=[],
                security_source=self.sdk_configuration.security,
            ),
            request=req,
            error_status_codes=[
                "400",
                "401",
                "403",
                "404",
                "409",
                "423",
                "429",
                "4XX",
                "500",
                "5XX",
            ],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(
                models.BaseResponseGlobalParameterDto, http_res
            )
        if utils.match_response(http_res, "400", "application/json"):
            response_data = unmarshal_json_response(errors.MultiErrorData, http_res)
            raise errors.MultiError(response_data, http_res)
        if utils.match_response(
            http_res, ["401", "403", "404", "409", "429"], "application/json"
        ):
            response_data = unmarshal_json_response(errors.SingleErrorData, http_res)
            raise errors.SingleError(response_data, http_res)
        if utils.match_response(http_res, "500", "application/json"):
            response_data = unmarshal_json_response(errors.SingleErrorData, http_res)
            raise errors.SingleError(response_data, http_res)
        if utils.match_response(http_res, ["423", "4XX"], "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)

        raise errors.SDKError("Unexpected response received", http_res)

    async def update_parameter_async(
        self,
        *,
        parameter_id: str,
        global_parameter_dto: Union[
            models.GlobalParameterDtoInput, models.GlobalParameterDtoInputTypedDict
        ],
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.BaseResponseGlobalParameterDto:
        r"""Update Parameter

        Updates the parameter matching the provided ID in the provided payload.

        :param parameter_id: The unique identifier of the parameter
        :param global_parameter_dto: The representation of the parameter to update
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = models.WDATA_UPDATE_PARAMETER_OP_SERVERS[0]

        request = models.WdataUpdateParameterRequest(
            parameter_id=parameter_id,
            global_parameter_dto=utils.get_pydantic_model(
                global_parameter_dto, models.GlobalParameterDtoInput
            ),
        )

        req = self._build_request_async(
            method="PUT",
            path="/api/v1/parameter/{parameterId}",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request.global_parameter_dto,
                False,
                False,
                "json",
                models.GlobalParameterDtoInput,
            ),
            allow_empty_value=None,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="wdata_updateParameter",
                oauth2_scopes=[],
                security_source=self.sdk_configuration.security,
            ),
            request=req,
            error_status_codes=[
                "400",
                "401",
                "403",
                "404",
                "409",
                "423",
                "429",
                "4XX",
                "500",
                "5XX",
            ],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(
                models.BaseResponseGlobalParameterDto, http_res
            )
        if utils.match_response(http_res, "400", "application/json"):
            response_data = unmarshal_json_response(errors.MultiErrorData, http_res)
            raise errors.MultiError(response_data, http_res)
        if utils.match_response(
            http_res, ["401", "403", "404", "409", "429"], "application/json"
        ):
            response_data = unmarshal_json_response(errors.SingleErrorData, http_res)
            raise errors.SingleError(response_data, http_res)
        if utils.match_response(http_res, "500", "application/json"):
            response_data = unmarshal_json_response(errors.SingleErrorData, http_res)
            raise errors.SingleError(response_data, http_res)
        if utils.match_response(http_res, ["423", "4XX"], "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)

        raise errors.SDKError("Unexpected response received", http_res)

    def update_pivot_view(
        self,
        *,
        pivot_view_id: str,
        pivot_view_dto: Union[
            models.PivotViewDtoInput, models.PivotViewDtoInputTypedDict
        ],
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.BaseResponsePivotViewDto:
        r"""Update a single pivot view

        Updates the view that matches the provided ID with the details provided in the
        body. The associated query can't be updated, so providing the query ID has no effect.

        :param pivot_view_id: The unique identifier of the pivot view
        :param pivot_view_dto: The representation of the pivot view to create
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = models.WDATA_UPDATE_PIVOT_VIEW_OP_SERVERS[0]

        request = models.WdataUpdatePivotViewRequest(
            pivot_view_id=pivot_view_id,
            pivot_view_dto=utils.get_pydantic_model(
                pivot_view_dto, models.PivotViewDtoInput
            ),
        )

        req = self._build_request(
            method="PUT",
            path="/api/v1/pivotview/{pivotViewId}",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request.pivot_view_dto, False, False, "json", models.PivotViewDtoInput
            ),
            allow_empty_value=None,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="wdata_updatePivotView",
                oauth2_scopes=[],
                security_source=self.sdk_configuration.security,
            ),
            request=req,
            error_status_codes=[
                "400",
                "401",
                "403",
                "404",
                "409",
                "423",
                "429",
                "4XX",
                "500",
                "5XX",
            ],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(models.BaseResponsePivotViewDto, http_res)
        if utils.match_response(http_res, "400", "application/json"):
            response_data = unmarshal_json_response(errors.MultiErrorData, http_res)
            raise errors.MultiError(response_data, http_res)
        if utils.match_response(
            http_res, ["401", "403", "404", "409", "429"], "application/json"
        ):
            response_data = unmarshal_json_response(errors.SingleErrorData, http_res)
            raise errors.SingleError(response_data, http_res)
        if utils.match_response(http_res, "500", "application/json"):
            response_data = unmarshal_json_response(errors.SingleErrorData, http_res)
            raise errors.SingleError(response_data, http_res)
        if utils.match_response(http_res, ["423", "4XX"], "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)

        raise errors.SDKError("Unexpected response received", http_res)

    async def update_pivot_view_async(
        self,
        *,
        pivot_view_id: str,
        pivot_view_dto: Union[
            models.PivotViewDtoInput, models.PivotViewDtoInputTypedDict
        ],
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.BaseResponsePivotViewDto:
        r"""Update a single pivot view

        Updates the view that matches the provided ID with the details provided in the
        body. The associated query can't be updated, so providing the query ID has no effect.

        :param pivot_view_id: The unique identifier of the pivot view
        :param pivot_view_dto: The representation of the pivot view to create
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = models.WDATA_UPDATE_PIVOT_VIEW_OP_SERVERS[0]

        request = models.WdataUpdatePivotViewRequest(
            pivot_view_id=pivot_view_id,
            pivot_view_dto=utils.get_pydantic_model(
                pivot_view_dto, models.PivotViewDtoInput
            ),
        )

        req = self._build_request_async(
            method="PUT",
            path="/api/v1/pivotview/{pivotViewId}",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request.pivot_view_dto, False, False, "json", models.PivotViewDtoInput
            ),
            allow_empty_value=None,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="wdata_updatePivotView",
                oauth2_scopes=[],
                security_source=self.sdk_configuration.security,
            ),
            request=req,
            error_status_codes=[
                "400",
                "401",
                "403",
                "404",
                "409",
                "423",
                "429",
                "4XX",
                "500",
                "5XX",
            ],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(models.BaseResponsePivotViewDto, http_res)
        if utils.match_response(http_res, "400", "application/json"):
            response_data = unmarshal_json_response(errors.MultiErrorData, http_res)
            raise errors.MultiError(response_data, http_res)
        if utils.match_response(
            http_res, ["401", "403", "404", "409", "429"], "application/json"
        ):
            response_data = unmarshal_json_response(errors.SingleErrorData, http_res)
            raise errors.SingleError(response_data, http_res)
        if utils.match_response(http_res, "500", "application/json"):
            response_data = unmarshal_json_response(errors.SingleErrorData, http_res)
            raise errors.SingleError(response_data, http_res)
        if utils.match_response(http_res, ["423", "4XX"], "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)

        raise errors.SDKError("Unexpected response received", http_res)

    def update_query(
        self,
        *,
        query_id: str,
        query_dto: Union[models.QueryDtoInput, models.QueryDtoInputTypedDict],
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.BaseResponseQueryDto:
        r"""Update a single query

        Updates the query that matches the provided ID with the details provided in the
        body.

        :param query_id: The unique identifier of the query
        :param query_dto: The representation of the query to update
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = models.WDATA_UPDATE_QUERY_OP_SERVERS[0]

        request = models.WdataUpdateQueryRequest(
            query_id=query_id,
            query_dto=utils.get_pydantic_model(query_dto, models.QueryDtoInput),
        )

        req = self._build_request(
            method="PUT",
            path="/api/v1/query/{queryId}",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request.query_dto, False, False, "json", models.QueryDtoInput
            ),
            allow_empty_value=None,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="wdata_updateQuery",
                oauth2_scopes=[],
                security_source=self.sdk_configuration.security,
            ),
            request=req,
            error_status_codes=[
                "400",
                "401",
                "403",
                "404",
                "409",
                "423",
                "429",
                "4XX",
                "500",
                "5XX",
            ],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(models.BaseResponseQueryDto, http_res)
        if utils.match_response(http_res, "400", "application/json"):
            response_data = unmarshal_json_response(errors.MultiErrorData, http_res)
            raise errors.MultiError(response_data, http_res)
        if utils.match_response(
            http_res, ["401", "403", "404", "409", "429"], "application/json"
        ):
            response_data = unmarshal_json_response(errors.SingleErrorData, http_res)
            raise errors.SingleError(response_data, http_res)
        if utils.match_response(http_res, "500", "application/json"):
            response_data = unmarshal_json_response(errors.SingleErrorData, http_res)
            raise errors.SingleError(response_data, http_res)
        if utils.match_response(http_res, ["423", "4XX"], "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)

        raise errors.SDKError("Unexpected response received", http_res)

    async def update_query_async(
        self,
        *,
        query_id: str,
        query_dto: Union[models.QueryDtoInput, models.QueryDtoInputTypedDict],
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.BaseResponseQueryDto:
        r"""Update a single query

        Updates the query that matches the provided ID with the details provided in the
        body.

        :param query_id: The unique identifier of the query
        :param query_dto: The representation of the query to update
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = models.WDATA_UPDATE_QUERY_OP_SERVERS[0]

        request = models.WdataUpdateQueryRequest(
            query_id=query_id,
            query_dto=utils.get_pydantic_model(query_dto, models.QueryDtoInput),
        )

        req = self._build_request_async(
            method="PUT",
            path="/api/v1/query/{queryId}",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request.query_dto, False, False, "json", models.QueryDtoInput
            ),
            allow_empty_value=None,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="wdata_updateQuery",
                oauth2_scopes=[],
                security_source=self.sdk_configuration.security,
            ),
            request=req,
            error_status_codes=[
                "400",
                "401",
                "403",
                "404",
                "409",
                "423",
                "429",
                "4XX",
                "500",
                "5XX",
            ],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(models.BaseResponseQueryDto, http_res)
        if utils.match_response(http_res, "400", "application/json"):
            response_data = unmarshal_json_response(errors.MultiErrorData, http_res)
            raise errors.MultiError(response_data, http_res)
        if utils.match_response(
            http_res, ["401", "403", "404", "409", "429"], "application/json"
        ):
            response_data = unmarshal_json_response(errors.SingleErrorData, http_res)
            raise errors.SingleError(response_data, http_res)
        if utils.match_response(http_res, "500", "application/json"):
            response_data = unmarshal_json_response(errors.SingleErrorData, http_res)
            raise errors.SingleError(response_data, http_res)
        if utils.match_response(http_res, ["423", "4XX"], "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)

        raise errors.SDKError("Unexpected response received", http_res)

    def update_select_list(
        self,
        *,
        select_list_id: str,
        select_list_dto: Union[
            models.SelectListDtoInput, models.SelectListDtoInputTypedDict
        ],
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.BaseResponseSelectListDto:
        r"""Update a single select list

        Updates the select list with the provided ID with the details provided  in the
        body.

        :param select_list_id: The unique identifier of the select list
        :param select_list_dto: The representation of the select list to update
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = models.WDATA_UPDATE_SELECT_LIST_OP_SERVERS[0]

        request = models.WdataUpdateSelectListRequest(
            select_list_id=select_list_id,
            select_list_dto=utils.get_pydantic_model(
                select_list_dto, models.SelectListDtoInput
            ),
        )

        req = self._build_request(
            method="PUT",
            path="/api/v1/selectlist/{selectListId}",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request.select_list_dto, False, False, "json", models.SelectListDtoInput
            ),
            allow_empty_value=None,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="wdata_updateSelectList",
                oauth2_scopes=[],
                security_source=self.sdk_configuration.security,
            ),
            request=req,
            error_status_codes=[
                "400",
                "401",
                "403",
                "404",
                "409",
                "423",
                "429",
                "4XX",
                "500",
                "5XX",
            ],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(models.BaseResponseSelectListDto, http_res)
        if utils.match_response(http_res, "400", "application/json"):
            response_data = unmarshal_json_response(errors.MultiErrorData, http_res)
            raise errors.MultiError(response_data, http_res)
        if utils.match_response(
            http_res, ["401", "403", "404", "409", "429"], "application/json"
        ):
            response_data = unmarshal_json_response(errors.SingleErrorData, http_res)
            raise errors.SingleError(response_data, http_res)
        if utils.match_response(http_res, "500", "application/json"):
            response_data = unmarshal_json_response(errors.SingleErrorData, http_res)
            raise errors.SingleError(response_data, http_res)
        if utils.match_response(http_res, ["423", "4XX"], "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)

        raise errors.SDKError("Unexpected response received", http_res)

    async def update_select_list_async(
        self,
        *,
        select_list_id: str,
        select_list_dto: Union[
            models.SelectListDtoInput, models.SelectListDtoInputTypedDict
        ],
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.BaseResponseSelectListDto:
        r"""Update a single select list

        Updates the select list with the provided ID with the details provided  in the
        body.

        :param select_list_id: The unique identifier of the select list
        :param select_list_dto: The representation of the select list to update
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = models.WDATA_UPDATE_SELECT_LIST_OP_SERVERS[0]

        request = models.WdataUpdateSelectListRequest(
            select_list_id=select_list_id,
            select_list_dto=utils.get_pydantic_model(
                select_list_dto, models.SelectListDtoInput
            ),
        )

        req = self._build_request_async(
            method="PUT",
            path="/api/v1/selectlist/{selectListId}",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request.select_list_dto, False, False, "json", models.SelectListDtoInput
            ),
            allow_empty_value=None,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="wdata_updateSelectList",
                oauth2_scopes=[],
                security_source=self.sdk_configuration.security,
            ),
            request=req,
            error_status_codes=[
                "400",
                "401",
                "403",
                "404",
                "409",
                "423",
                "429",
                "4XX",
                "500",
                "5XX",
            ],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(models.BaseResponseSelectListDto, http_res)
        if utils.match_response(http_res, "400", "application/json"):
            response_data = unmarshal_json_response(errors.MultiErrorData, http_res)
            raise errors.MultiError(response_data, http_res)
        if utils.match_response(
            http_res, ["401", "403", "404", "409", "429"], "application/json"
        ):
            response_data = unmarshal_json_response(errors.SingleErrorData, http_res)
            raise errors.SingleError(response_data, http_res)
        if utils.match_response(http_res, "500", "application/json"):
            response_data = unmarshal_json_response(errors.SingleErrorData, http_res)
            raise errors.SingleError(response_data, http_res)
        if utils.match_response(http_res, ["423", "4XX"], "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)

        raise errors.SDKError("Unexpected response received", http_res)

    def update_table(
        self,
        *,
        table_id: str,
        table_dto: Union[models.TableDtoInput, models.TableDtoInputTypedDict],
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.BaseResponseTableDto:
        r"""Update a single table

        Updates an existing table with the provided information. Include all user-defined
        table columns with the request. For type, specify either a dimension or data table.
        In the interface, data tables appear as fact tables.
        * If the table has no imported
        data, user-defined columns not included with the request are deleted, and columns are
        sorted according to their order in the request.
        * If the table has imported data,
        any columns with names not already in the table are considered new. This equality
        check is case-insensitive. Any new columns appear after other user-defined columns,
        but before any meta columns, which start with `_`.

        :param table_id: The unique identifier of the table
        :param table_dto: The representation of the table to update
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = models.WDATA_UPDATE_TABLE_OP_SERVERS[0]

        request = models.WdataUpdateTableRequest(
            table_id=table_id,
            table_dto=utils.get_pydantic_model(table_dto, models.TableDtoInput),
        )

        req = self._build_request(
            method="PUT",
            path="/api/v1/table/{tableId}",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request.table_dto, False, False, "json", models.TableDtoInput
            ),
            allow_empty_value=None,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="wdata_updateTable",
                oauth2_scopes=[],
                security_source=self.sdk_configuration.security,
            ),
            request=req,
            error_status_codes=[
                "400",
                "401",
                "403",
                "404",
                "409",
                "423",
                "429",
                "4XX",
                "500",
                "5XX",
            ],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(models.BaseResponseTableDto, http_res)
        if utils.match_response(http_res, "400", "application/json"):
            response_data = unmarshal_json_response(errors.MultiErrorData, http_res)
            raise errors.MultiError(response_data, http_res)
        if utils.match_response(
            http_res, ["401", "403", "404", "409", "429"], "application/json"
        ):
            response_data = unmarshal_json_response(errors.SingleErrorData, http_res)
            raise errors.SingleError(response_data, http_res)
        if utils.match_response(http_res, "500", "application/json"):
            response_data = unmarshal_json_response(errors.SingleErrorData, http_res)
            raise errors.SingleError(response_data, http_res)
        if utils.match_response(http_res, ["423", "4XX"], "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)

        raise errors.SDKError("Unexpected response received", http_res)

    async def update_table_async(
        self,
        *,
        table_id: str,
        table_dto: Union[models.TableDtoInput, models.TableDtoInputTypedDict],
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.BaseResponseTableDto:
        r"""Update a single table

        Updates an existing table with the provided information. Include all user-defined
        table columns with the request. For type, specify either a dimension or data table.
        In the interface, data tables appear as fact tables.
        * If the table has no imported
        data, user-defined columns not included with the request are deleted, and columns are
        sorted according to their order in the request.
        * If the table has imported data,
        any columns with names not already in the table are considered new. This equality
        check is case-insensitive. Any new columns appear after other user-defined columns,
        but before any meta columns, which start with `_`.

        :param table_id: The unique identifier of the table
        :param table_dto: The representation of the table to update
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = models.WDATA_UPDATE_TABLE_OP_SERVERS[0]

        request = models.WdataUpdateTableRequest(
            table_id=table_id,
            table_dto=utils.get_pydantic_model(table_dto, models.TableDtoInput),
        )

        req = self._build_request_async(
            method="PUT",
            path="/api/v1/table/{tableId}",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request.table_dto, False, False, "json", models.TableDtoInput
            ),
            allow_empty_value=None,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="wdata_updateTable",
                oauth2_scopes=[],
                security_source=self.sdk_configuration.security,
            ),
            request=req,
            error_status_codes=[
                "400",
                "401",
                "403",
                "404",
                "409",
                "423",
                "429",
                "4XX",
                "500",
                "5XX",
            ],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(models.BaseResponseTableDto, http_res)
        if utils.match_response(http_res, "400", "application/json"):
            response_data = unmarshal_json_response(errors.MultiErrorData, http_res)
            raise errors.MultiError(response_data, http_res)
        if utils.match_response(
            http_res, ["401", "403", "404", "409", "429"], "application/json"
        ):
            response_data = unmarshal_json_response(errors.SingleErrorData, http_res)
            raise errors.SingleError(response_data, http_res)
        if utils.match_response(http_res, "500", "application/json"):
            response_data = unmarshal_json_response(errors.SingleErrorData, http_res)
            raise errors.SingleError(response_data, http_res)
        if utils.match_response(http_res, ["423", "4XX"], "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)

        raise errors.SDKError("Unexpected response received", http_res)

    def update_tag(
        self,
        *,
        tag_id: str,
        tag_dto: Union[models.TagDtoInput, models.TagDtoInputTypedDict],
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.BaseResponseTagDto:
        r"""Update a single tag

        Updates the tag that matches the provided ID with the details provided in the body.
        Ignores the provided key, as keys are immutable once set.
        There is a limit of 300 values for a tag.

        :param tag_id: The unique identifier of the tag
        :param tag_dto: The representation of the tag to update
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = models.WDATA_UPDATE_TAG_OP_SERVERS[0]

        request = models.WdataUpdateTagRequest(
            tag_id=tag_id,
            tag_dto=utils.get_pydantic_model(tag_dto, models.TagDtoInput),
        )

        req = self._build_request(
            method="PUT",
            path="/api/v1/tag/{tagId}",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request.tag_dto, False, False, "json", models.TagDtoInput
            ),
            allow_empty_value=None,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="wdata_updateTag",
                oauth2_scopes=[],
                security_source=self.sdk_configuration.security,
            ),
            request=req,
            error_status_codes=[
                "400",
                "401",
                "403",
                "404",
                "409",
                "423",
                "429",
                "4XX",
                "500",
                "5XX",
            ],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(models.BaseResponseTagDto, http_res)
        if utils.match_response(http_res, "400", "application/json"):
            response_data = unmarshal_json_response(errors.MultiErrorData, http_res)
            raise errors.MultiError(response_data, http_res)
        if utils.match_response(
            http_res, ["401", "403", "404", "409", "429"], "application/json"
        ):
            response_data = unmarshal_json_response(errors.SingleErrorData, http_res)
            raise errors.SingleError(response_data, http_res)
        if utils.match_response(http_res, "500", "application/json"):
            response_data = unmarshal_json_response(errors.SingleErrorData, http_res)
            raise errors.SingleError(response_data, http_res)
        if utils.match_response(http_res, ["423", "4XX"], "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)

        raise errors.SDKError("Unexpected response received", http_res)

    async def update_tag_async(
        self,
        *,
        tag_id: str,
        tag_dto: Union[models.TagDtoInput, models.TagDtoInputTypedDict],
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.BaseResponseTagDto:
        r"""Update a single tag

        Updates the tag that matches the provided ID with the details provided in the body.
        Ignores the provided key, as keys are immutable once set.
        There is a limit of 300 values for a tag.

        :param tag_id: The unique identifier of the tag
        :param tag_dto: The representation of the tag to update
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = models.WDATA_UPDATE_TAG_OP_SERVERS[0]

        request = models.WdataUpdateTagRequest(
            tag_id=tag_id,
            tag_dto=utils.get_pydantic_model(tag_dto, models.TagDtoInput),
        )

        req = self._build_request_async(
            method="PUT",
            path="/api/v1/tag/{tagId}",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request.tag_dto, False, False, "json", models.TagDtoInput
            ),
            allow_empty_value=None,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="wdata_updateTag",
                oauth2_scopes=[],
                security_source=self.sdk_configuration.security,
            ),
            request=req,
            error_status_codes=[
                "400",
                "401",
                "403",
                "404",
                "409",
                "423",
                "429",
                "4XX",
                "500",
                "5XX",
            ],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(models.BaseResponseTagDto, http_res)
        if utils.match_response(http_res, "400", "application/json"):
            response_data = unmarshal_json_response(errors.MultiErrorData, http_res)
            raise errors.MultiError(response_data, http_res)
        if utils.match_response(
            http_res, ["401", "403", "404", "409", "429"], "application/json"
        ):
            response_data = unmarshal_json_response(errors.SingleErrorData, http_res)
            raise errors.SingleError(response_data, http_res)
        if utils.match_response(http_res, "500", "application/json"):
            response_data = unmarshal_json_response(errors.SingleErrorData, http_res)
            raise errors.SingleError(response_data, http_res)
        if utils.match_response(http_res, ["423", "4XX"], "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)

        raise errors.SDKError("Unexpected response received", http_res)

    def upload_file(
        self,
        *,
        request: Union[
            models.WdataUploadFileRequest, models.WdataUploadFileRequestTypedDict
        ],
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.BaseResponseFileMetaDto:
        r"""Upload a single file

        Accepts CSV, TSV, or JSON files, or a ZIP file that contains a single CSV, TSV, or
        JSON file. If a ZIP, it must contain a CSV, TSV, or JSON file, and the name of the
        CSV, TSV, or JSON file is also used with the imported file. Downloading this file
        again downloads the source. Note that all files uploaded must have a .csv, .tsv, or .json
        extension. JSON files are expected to have a single JSON record per line; a JSON file is
        a series of JSON objects delimited by a newline character.

        :param request: The request object to send.
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = models.WDATA_UPLOAD_FILE_OP_SERVERS[0]

        if not isinstance(request, BaseModel):
            request = utils.unmarshal(request, models.WdataUploadFileRequest)
        request = cast(models.WdataUploadFileRequest, request)

        req = self._build_request(
            method="POST",
            path="/api/v1/file",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request.request_body,
                False,
                True,
                "multipart",
                Optional[models.WdataUploadFileRequestBody],
            ),
            allow_empty_value=None,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="wdata_uploadFile",
                oauth2_scopes=[],
                security_source=self.sdk_configuration.security,
            ),
            request=req,
            error_status_codes=[
                "400",
                "401",
                "403",
                "404",
                "409",
                "423",
                "429",
                "4XX",
                "500",
                "5XX",
            ],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "201", "application/json"):
            return unmarshal_json_response(models.BaseResponseFileMetaDto, http_res)
        if utils.match_response(http_res, "400", "application/json"):
            response_data = unmarshal_json_response(errors.MultiErrorData, http_res)
            raise errors.MultiError(response_data, http_res)
        if utils.match_response(
            http_res, ["401", "403", "404", "409", "429"], "application/json"
        ):
            response_data = unmarshal_json_response(errors.SingleErrorData, http_res)
            raise errors.SingleError(response_data, http_res)
        if utils.match_response(http_res, "500", "application/json"):
            response_data = unmarshal_json_response(errors.SingleErrorData, http_res)
            raise errors.SingleError(response_data, http_res)
        if utils.match_response(http_res, ["423", "4XX"], "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)

        raise errors.SDKError("Unexpected response received", http_res)

    async def upload_file_async(
        self,
        *,
        request: Union[
            models.WdataUploadFileRequest, models.WdataUploadFileRequestTypedDict
        ],
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.BaseResponseFileMetaDto:
        r"""Upload a single file

        Accepts CSV, TSV, or JSON files, or a ZIP file that contains a single CSV, TSV, or
        JSON file. If a ZIP, it must contain a CSV, TSV, or JSON file, and the name of the
        CSV, TSV, or JSON file is also used with the imported file. Downloading this file
        again downloads the source. Note that all files uploaded must have a .csv, .tsv, or .json
        extension. JSON files are expected to have a single JSON record per line; a JSON file is
        a series of JSON objects delimited by a newline character.

        :param request: The request object to send.
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = models.WDATA_UPLOAD_FILE_OP_SERVERS[0]

        if not isinstance(request, BaseModel):
            request = utils.unmarshal(request, models.WdataUploadFileRequest)
        request = cast(models.WdataUploadFileRequest, request)

        req = self._build_request_async(
            method="POST",
            path="/api/v1/file",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request.request_body,
                False,
                True,
                "multipart",
                Optional[models.WdataUploadFileRequestBody],
            ),
            allow_empty_value=None,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="wdata_uploadFile",
                oauth2_scopes=[],
                security_source=self.sdk_configuration.security,
            ),
            request=req,
            error_status_codes=[
                "400",
                "401",
                "403",
                "404",
                "409",
                "423",
                "429",
                "4XX",
                "500",
                "5XX",
            ],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "201", "application/json"):
            return unmarshal_json_response(models.BaseResponseFileMetaDto, http_res)
        if utils.match_response(http_res, "400", "application/json"):
            response_data = unmarshal_json_response(errors.MultiErrorData, http_res)
            raise errors.MultiError(response_data, http_res)
        if utils.match_response(
            http_res, ["401", "403", "404", "409", "429"], "application/json"
        ):
            response_data = unmarshal_json_response(errors.SingleErrorData, http_res)
            raise errors.SingleError(response_data, http_res)
        if utils.match_response(http_res, "500", "application/json"):
            response_data = unmarshal_json_response(errors.SingleErrorData, http_res)
            raise errors.SingleError(response_data, http_res)
        if utils.match_response(http_res, ["423", "4XX"], "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)

        raise errors.SDKError("Unexpected response received", http_res)

    def validate_filename(
        self,
        *,
        filename: str,
        table_id: str,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.BaseResponseString:
        r"""Validate whether a file with the filename can be uploaded to the table

        If the filename is valid, this returns 200. If the table already has a file with the same name, this returns 409. If the user isn't allowed to read the table, or if the table isn't found, this returns 404.

        :param filename: The name of the file to upload
        :param table_id: The ID of the table to upload the file to
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = models.WDATA_VALIDATE_FILENAME_OP_SERVERS[0]

        request = models.WdataValidateFilenameRequest(
            filename=filename,
            table_id=table_id,
        )

        req = self._build_request(
            method="GET",
            path="/api/v1/file/validateName",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            allow_empty_value=None,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="wdata_validateFilename",
                oauth2_scopes=[],
                security_source=self.sdk_configuration.security,
            ),
            request=req,
            error_status_codes=[
                "400",
                "401",
                "403",
                "404",
                "409",
                "423",
                "429",
                "4XX",
                "500",
                "5XX",
            ],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(models.BaseResponseString, http_res)
        if utils.match_response(
            http_res, ["403", "404", "409", "429"], "application/json"
        ):
            response_data = unmarshal_json_response(errors.SingleErrorData, http_res)
            raise errors.SingleError(response_data, http_res)
        if utils.match_response(http_res, "500", "application/json"):
            response_data = unmarshal_json_response(errors.SingleErrorData, http_res)
            raise errors.SingleError(response_data, http_res)
        if utils.match_response(http_res, ["400", "401", "423", "4XX"], "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)

        raise errors.SDKError("Unexpected response received", http_res)

    async def validate_filename_async(
        self,
        *,
        filename: str,
        table_id: str,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.BaseResponseString:
        r"""Validate whether a file with the filename can be uploaded to the table

        If the filename is valid, this returns 200. If the table already has a file with the same name, this returns 409. If the user isn't allowed to read the table, or if the table isn't found, this returns 404.

        :param filename: The name of the file to upload
        :param table_id: The ID of the table to upload the file to
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = models.WDATA_VALIDATE_FILENAME_OP_SERVERS[0]

        request = models.WdataValidateFilenameRequest(
            filename=filename,
            table_id=table_id,
        )

        req = self._build_request_async(
            method="GET",
            path="/api/v1/file/validateName",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            allow_empty_value=None,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="wdata_validateFilename",
                oauth2_scopes=[],
                security_source=self.sdk_configuration.security,
            ),
            request=req,
            error_status_codes=[
                "400",
                "401",
                "403",
                "404",
                "409",
                "423",
                "429",
                "4XX",
                "500",
                "5XX",
            ],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(models.BaseResponseString, http_res)
        if utils.match_response(
            http_res, ["403", "404", "409", "429"], "application/json"
        ):
            response_data = unmarshal_json_response(errors.SingleErrorData, http_res)
            raise errors.SingleError(response_data, http_res)
        if utils.match_response(http_res, "500", "application/json"):
            response_data = unmarshal_json_response(errors.SingleErrorData, http_res)
            raise errors.SingleError(response_data, http_res)
        if utils.match_response(http_res, ["400", "401", "423", "4XX"], "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)

        raise errors.SDKError("Unexpected response received", http_res)

    def validate_files(
        self,
        *,
        request: Union[
            models.StartValidateFilesDto, models.StartValidateFilesDtoTypedDict
        ],
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.BaseResponseValidateFilesDto:
        r"""Validate files

        Validates files associated with the provided table ID. Validation repairs any files in
        an inconsistent state, and deletes those without enough state to recover. All files
        deleted or repaired are returned.

        :param request: The request object to send.
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = models.WDATA_VALIDATE_FILES_OP_SERVERS[0]

        if not isinstance(request, BaseModel):
            request = utils.unmarshal(request, models.StartValidateFilesDto)
        request = cast(models.StartValidateFilesDto, request)

        req = self._build_request(
            method="POST",
            path="/api/v1/admin/validation/files",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request, False, False, "json", models.StartValidateFilesDto
            ),
            allow_empty_value=None,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="wdata_validateFiles",
                oauth2_scopes=[],
                security_source=self.sdk_configuration.security,
            ),
            request=req,
            error_status_codes=[
                "400",
                "401",
                "403",
                "404",
                "409",
                "423",
                "429",
                "4XX",
                "500",
                "5XX",
            ],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "201", "application/json"):
            return unmarshal_json_response(
                models.BaseResponseValidateFilesDto, http_res
            )
        if utils.match_response(http_res, "400", "application/json"):
            response_data = unmarshal_json_response(errors.MultiErrorData, http_res)
            raise errors.MultiError(response_data, http_res)
        if utils.match_response(
            http_res, ["401", "403", "404", "409", "429"], "application/json"
        ):
            response_data = unmarshal_json_response(errors.SingleErrorData, http_res)
            raise errors.SingleError(response_data, http_res)
        if utils.match_response(http_res, "500", "application/json"):
            response_data = unmarshal_json_response(errors.SingleErrorData, http_res)
            raise errors.SingleError(response_data, http_res)
        if utils.match_response(http_res, ["423", "4XX"], "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)

        raise errors.SDKError("Unexpected response received", http_res)

    async def validate_files_async(
        self,
        *,
        request: Union[
            models.StartValidateFilesDto, models.StartValidateFilesDtoTypedDict
        ],
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.BaseResponseValidateFilesDto:
        r"""Validate files

        Validates files associated with the provided table ID. Validation repairs any files in
        an inconsistent state, and deletes those without enough state to recover. All files
        deleted or repaired are returned.

        :param request: The request object to send.
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = models.WDATA_VALIDATE_FILES_OP_SERVERS[0]

        if not isinstance(request, BaseModel):
            request = utils.unmarshal(request, models.StartValidateFilesDto)
        request = cast(models.StartValidateFilesDto, request)

        req = self._build_request_async(
            method="POST",
            path="/api/v1/admin/validation/files",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request, False, False, "json", models.StartValidateFilesDto
            ),
            allow_empty_value=None,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="wdata_validateFiles",
                oauth2_scopes=[],
                security_source=self.sdk_configuration.security,
            ),
            request=req,
            error_status_codes=[
                "400",
                "401",
                "403",
                "404",
                "409",
                "423",
                "429",
                "4XX",
                "500",
                "5XX",
            ],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "201", "application/json"):
            return unmarshal_json_response(
                models.BaseResponseValidateFilesDto, http_res
            )
        if utils.match_response(http_res, "400", "application/json"):
            response_data = unmarshal_json_response(errors.MultiErrorData, http_res)
            raise errors.MultiError(response_data, http_res)
        if utils.match_response(
            http_res, ["401", "403", "404", "409", "429"], "application/json"
        ):
            response_data = unmarshal_json_response(errors.SingleErrorData, http_res)
            raise errors.SingleError(response_data, http_res)
        if utils.match_response(http_res, "500", "application/json"):
            response_data = unmarshal_json_response(errors.SingleErrorData, http_res)
            raise errors.SingleError(response_data, http_res)
        if utils.match_response(http_res, ["423", "4XX"], "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)

        raise errors.SDKError("Unexpected response received", http_res)

    def validate_tables(
        self,
        *,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.BaseResponseValidateTablesDto:
        r"""Validate tables

        Validates the tables in the workspace associated with the request. Validation returns an entity that indicates the tables deleted due to bad state, and those with enough state and repaired.

        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = models.WDATA_VALIDATE_TABLES_OP_SERVERS[0]
        req = self._build_request(
            method="POST",
            path="/api/v1/admin/validation/tables",
            base_url=base_url,
            url_variables=url_variables,
            request=None,
            request_body_required=False,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            allow_empty_value=None,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="wdata_validateTables",
                oauth2_scopes=[],
                security_source=self.sdk_configuration.security,
            ),
            request=req,
            error_status_codes=[
                "400",
                "401",
                "403",
                "404",
                "409",
                "423",
                "429",
                "4XX",
                "500",
                "5XX",
            ],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "201", "application/json"):
            return unmarshal_json_response(
                models.BaseResponseValidateTablesDto, http_res
            )
        if utils.match_response(http_res, "400", "application/json"):
            response_data = unmarshal_json_response(errors.MultiErrorData, http_res)
            raise errors.MultiError(response_data, http_res)
        if utils.match_response(
            http_res, ["401", "403", "404", "409", "429"], "application/json"
        ):
            response_data = unmarshal_json_response(errors.SingleErrorData, http_res)
            raise errors.SingleError(response_data, http_res)
        if utils.match_response(http_res, "500", "application/json"):
            response_data = unmarshal_json_response(errors.SingleErrorData, http_res)
            raise errors.SingleError(response_data, http_res)
        if utils.match_response(http_res, ["423", "4XX"], "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)

        raise errors.SDKError("Unexpected response received", http_res)

    async def validate_tables_async(
        self,
        *,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.BaseResponseValidateTablesDto:
        r"""Validate tables

        Validates the tables in the workspace associated with the request. Validation returns an entity that indicates the tables deleted due to bad state, and those with enough state and repaired.

        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = models.WDATA_VALIDATE_TABLES_OP_SERVERS[0]
        req = self._build_request_async(
            method="POST",
            path="/api/v1/admin/validation/tables",
            base_url=base_url,
            url_variables=url_variables,
            request=None,
            request_body_required=False,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            allow_empty_value=None,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="wdata_validateTables",
                oauth2_scopes=[],
                security_source=self.sdk_configuration.security,
            ),
            request=req,
            error_status_codes=[
                "400",
                "401",
                "403",
                "404",
                "409",
                "423",
                "429",
                "4XX",
                "500",
                "5XX",
            ],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "201", "application/json"):
            return unmarshal_json_response(
                models.BaseResponseValidateTablesDto, http_res
            )
        if utils.match_response(http_res, "400", "application/json"):
            response_data = unmarshal_json_response(errors.MultiErrorData, http_res)
            raise errors.MultiError(response_data, http_res)
        if utils.match_response(
            http_res, ["401", "403", "404", "409", "429"], "application/json"
        ):
            response_data = unmarshal_json_response(errors.SingleErrorData, http_res)
            raise errors.SingleError(response_data, http_res)
        if utils.match_response(http_res, "500", "application/json"):
            response_data = unmarshal_json_response(errors.SingleErrorData, http_res)
            raise errors.SingleError(response_data, http_res)
        if utils.match_response(http_res, ["423", "4XX"], "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)

        raise errors.SDKError("Unexpected response received", http_res)
