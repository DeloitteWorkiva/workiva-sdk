"""Platform API — documents namespace.

Auto-generated by codegen. Do not edit manually.
"""

from __future__ import annotations

from typing import Any, Optional

import httpx

from workiva._constants import _API
from workiva._operations._base import BaseNamespace
from workiva.models.platform import (
    DocumentExport,
    DocumentFiltersReapplication,
    LinksPublicationOptions,
    ResourcePermissionsModification,
    Section,
    SectionCopy,
    SectionsEdits,
)


class Documents(BaseNamespace):
    """Documents operations."""

    _api: _API = _API.PLATFORM

    def get_documents(
        self,
        *,
        filter_: Optional[str] = None,
        order_by: Optional[str] = None,
        maxpagesize: Optional[int] = 1000,
        next_: Optional[str] = None,
        timeout: Optional[float] = None,
    ) -> httpx.Response:
        """Retrieve a list of documents

        Returns a paginated list of [documents](ref:documents#document).
        """
        return self._client.request(
            "GET",
            self._api,
            "/documents",
            query_params={
                "$filter": filter_,
                "$orderBy": order_by,
                "$maxpagesize": maxpagesize,
                "$next": next_,
            },
            timeout=timeout,
        )

    async def get_documents_async(
        self,
        *,
        filter_: Optional[str] = None,
        order_by: Optional[str] = None,
        maxpagesize: Optional[int] = 1000,
        next_: Optional[str] = None,
        timeout: Optional[float] = None,
    ) -> httpx.Response:
        """Retrieve a list of documents (async)

        Returns a paginated list of [documents](ref:documents#document).
        """
        return await self._client.request_async(
            "GET",
            self._api,
            "/documents",
            query_params={
                "$filter": filter_,
                "$orderBy": order_by,
                "$maxpagesize": maxpagesize,
                "$next": next_,
            },
            timeout=timeout,
        )

    def get_document_by_id(
        self,
        *,
        document_id: str,
        expand: Optional[str] = None,
        timeout: Optional[float] = None,
    ) -> httpx.Response:
        """Retrieve a single document

        Retrieves a [document](ref:documents#document) given its ID.
        """
        return self._client.request(
            "GET",
            self._api,
            "/documents/{documentId}",
            path_params={
                "documentId": document_id,
            },
            query_params={
                "$expand": expand,
            },
            timeout=timeout,
        )

    async def get_document_by_id_async(
        self,
        *,
        document_id: str,
        expand: Optional[str] = None,
        timeout: Optional[float] = None,
    ) -> httpx.Response:
        """Retrieve a single document (async)

        Retrieves a [document](ref:documents#document) given its ID.
        """
        return await self._client.request_async(
            "GET",
            self._api,
            "/documents/{documentId}",
            path_params={
                "documentId": document_id,
            },
            query_params={
                "$expand": expand,
            },
            timeout=timeout,
        )

    def partially_update_document_by_id(
        self,
        *,
        document_id: str,
        body: list[Any],
        timeout: Optional[float] = None,
    ) -> httpx.Response:
        """Partially update a single document

        Updates the properties of a [document](ref:documents#document).

        This is a long running operation. Responses include a `Location` header,
        which indicates where to poll for results. For more details on long-
        running job polling,
        see [Operations endpoint](ref:getoperationbyid).

        ### Options

        |Path                             |PATCH Operations Supported        |
        |---------------------------------|----------------------------------|
        |`/customFields/<custom field id>`|`add`, `remove`, `replace`, `test`|
        |`/customFieldGroups`             |`add`, `remove`, `replace`, `test`|
        |`/sectionCustomFieldGroups`      |`add`, `remove`, `replace`, `test`|
        |`/lock`                          |`replace`                         |

        ### Examples

        #### Add a custom field value

        ```json
        [
          {
            "op": "add",
            "path": "/customFields/com.workiva.gsr.legal_entity",
            "value": "Workiva"
          }
        ]
        ```

        #### Remove a custom field value

        ```json
        [
          {
            "op": "remove",
            "path": "/customFields/com.workiva.gsr.legal_entity"
          }
        ]
        ```

        #### Replace a custom field value

        ```json
        [
          {
            "op": "replace",
            "path": "/customFields/com.workiva.gsr.legal_entity",
            "value": "Workiva, Inc."
          }
        ]
        ```

        #### Verifying customFieldGroup is empty before replacing the list

        ```json
        [
          {
            "op": "test",
            "path": "/customFieldGroups",
            "value": []
          },
          {
            "op": "replace",
            "path": "/customFieldGroups",
            "value": ["gsr.reporting"]
          }
        ]
        ```

        #### Adding a customFieldGroup to the end of a list

        ```json
        [
          {
            "op": "add",
            "path": "/customFieldGroups/-",
            "value": "gsr.reporting"
          }
        ]
        ```
        """
        return self._client.request(
            "PATCH",
            self._api,
            "/documents/{documentId}",
            path_params={
                "documentId": document_id,
            },
            json_body=body,
            timeout=timeout,
        )

    async def partially_update_document_by_id_async(
        self,
        *,
        document_id: str,
        body: list[Any],
        timeout: Optional[float] = None,
    ) -> httpx.Response:
        """Partially update a single document (async)

        Updates the properties of a [document](ref:documents#document).

        This is a long running operation. Responses include a `Location` header,
        which indicates where to poll for results. For more details on long-
        running job polling,
        see [Operations endpoint](ref:getoperationbyid).

        ### Options

        |Path                             |PATCH Operations Supported        |
        |---------------------------------|----------------------------------|
        |`/customFields/<custom field id>`|`add`, `remove`, `replace`, `test`|
        |`/customFieldGroups`             |`add`, `remove`, `replace`, `test`|
        |`/sectionCustomFieldGroups`      |`add`, `remove`, `replace`, `test`|
        |`/lock`                          |`replace`                         |

        ### Examples

        #### Add a custom field value

        ```json
        [
          {
            "op": "add",
            "path": "/customFields/com.workiva.gsr.legal_entity",
            "value": "Workiva"
          }
        ]
        ```

        #### Remove a custom field value

        ```json
        [
          {
            "op": "remove",
            "path": "/customFields/com.workiva.gsr.legal_entity"
          }
        ]
        ```

        #### Replace a custom field value

        ```json
        [
          {
            "op": "replace",
            "path": "/customFields/com.workiva.gsr.legal_entity",
            "value": "Workiva, Inc."
          }
        ]
        ```

        #### Verifying customFieldGroup is empty before replacing the list

        ```json
        [
          {
            "op": "test",
            "path": "/customFieldGroups",
            "value": []
          },
          {
            "op": "replace",
            "path": "/customFieldGroups",
            "value": ["gsr.reporting"]
          }
        ]
        ```

        #### Adding a customFieldGroup to the end of a list

        ```json
        [
          {
            "op": "add",
            "path": "/customFieldGroups/-",
            "value": "gsr.reporting"
          }
        ]
        ```
        """
        return await self._client.request_async(
            "PATCH",
            self._api,
            "/documents/{documentId}",
            path_params={
                "documentId": document_id,
            },
            json_body=body,
            timeout=timeout,
        )

    def document_export(
        self,
        *,
        document_id: str,
        body: DocumentExport,
        timeout: Optional[float] = None,
    ) -> httpx.Response:
        """Initiate a document export

        Asynchronously exports a [document](ref:documents#document) as .PDF or
        .DOCX., or .XHTML. Options are specified using a
        [DocumentExport](ref:documents#documentexport) object.
        When exporting XHTML that you plan to edit or modify, use the
        `editableXhtml` option. Otherwise, the export retains fidelity so it
        visually matches the document as it appears in the browser.
        Responses include a `Location` header, which indicates where to poll for
        export results. For more details on long-running job polling, see
        [Operations endpoint](ref:getoperationbyid). When the export completes,
        its status will be `completed`, and the response body includes a
        `resourceURL`. To download the exported file, perform a GET on the
        `resourceURL` with the same authentication credentials and flow as the
        export request. For more details, see [Authentication
        documentation](ref:authentication).
        """
        return self._client.request(
            "POST",
            self._api,
            "/documents/{documentId}/export",
            path_params={
                "documentId": document_id,
            },
            json_body=body,
            timeout=timeout,
        )

    async def document_export_async(
        self,
        *,
        document_id: str,
        body: DocumentExport,
        timeout: Optional[float] = None,
    ) -> httpx.Response:
        """Initiate a document export (async)

        Asynchronously exports a [document](ref:documents#document) as .PDF or
        .DOCX., or .XHTML. Options are specified using a
        [DocumentExport](ref:documents#documentexport) object.
        When exporting XHTML that you plan to edit or modify, use the
        `editableXhtml` option. Otherwise, the export retains fidelity so it
        visually matches the document as it appears in the browser.
        Responses include a `Location` header, which indicates where to poll for
        export results. For more details on long-running job polling, see
        [Operations endpoint](ref:getoperationbyid). When the export completes,
        its status will be `completed`, and the response body includes a
        `resourceURL`. To download the exported file, perform a GET on the
        `resourceURL` with the same authentication credentials and flow as the
        export request. For more details, see [Authentication
        documentation](ref:authentication).
        """
        return await self._client.request_async(
            "POST",
            self._api,
            "/documents/{documentId}/export",
            path_params={
                "documentId": document_id,
            },
            json_body=body,
            timeout=timeout,
        )

    def document_filters_reapplication(
        self,
        *,
        document_id: str,
        body: DocumentFiltersReapplication,
        timeout: Optional[float] = None,
    ) -> httpx.Response:
        """Reapply filters to the document

        Performs a [`DocumentFiltersReapplication`](ref:content#documentfiltersr
        eapplication) on the specified document.
        This endpoint is used to refresh the document's filters based on the
        latest state or configuration changes.
        The filters are reapplied in the context of the document's current data
        state.

        This is a long-running operation. Responses include a `Location` header,
        which indicates where to poll for results.
        For more details on long-running job polling, see [Operations
        endpoint](ref:getoperationbyid).
        """
        return self._client.request(
            "POST",
            self._api,
            "/documents/{documentId}/filters/reapplication",
            path_params={
                "documentId": document_id,
            },
            json_body=body,
            timeout=timeout,
        )

    async def document_filters_reapplication_async(
        self,
        *,
        document_id: str,
        body: DocumentFiltersReapplication,
        timeout: Optional[float] = None,
    ) -> httpx.Response:
        """Reapply filters to the document (async)

        Performs a [`DocumentFiltersReapplication`](ref:content#documentfiltersr
        eapplication) on the specified document.
        This endpoint is used to refresh the document's filters based on the
        latest state or configuration changes.
        The filters are reapplied in the context of the document's current data
        state.

        This is a long-running operation. Responses include a `Location` header,
        which indicates where to poll for results.
        For more details on long-running job polling, see [Operations
        endpoint](ref:getoperationbyid).
        """
        return await self._client.request_async(
            "POST",
            self._api,
            "/documents/{documentId}/filters/reapplication",
            path_params={
                "documentId": document_id,
            },
            json_body=body,
            timeout=timeout,
        )

    def document_links_publication(
        self,
        *,
        document_id: str,
        body: LinksPublicationOptions,
        timeout: Optional[float] = None,
    ) -> httpx.Response:
        """Initiate publication of links in a document

        Publishes the links in a document - either all (as document owner) or
        only one's own. Content at the latest document revision will be used for
        publish.
        The response also includes a `Location` header, which indicates where to
        poll for operation results. For more details on long-running job
        polling, see [Operations endpoint](ref:getoperationbyid).
        """
        return self._client.request(
            "POST",
            self._api,
            "/documents/{documentId}/links/publication",
            path_params={
                "documentId": document_id,
            },
            json_body=body,
            timeout=timeout,
        )

    async def document_links_publication_async(
        self,
        *,
        document_id: str,
        body: LinksPublicationOptions,
        timeout: Optional[float] = None,
    ) -> httpx.Response:
        """Initiate publication of links in a document (async)

        Publishes the links in a document - either all (as document owner) or
        only one's own. Content at the latest document revision will be used for
        publish.
        The response also includes a `Location` header, which indicates where to
        poll for operation results. For more details on long-running job
        polling, see [Operations endpoint](ref:getoperationbyid).
        """
        return await self._client.request_async(
            "POST",
            self._api,
            "/documents/{documentId}/links/publication",
            path_params={
                "documentId": document_id,
            },
            json_body=body,
            timeout=timeout,
        )

    def get_document_milestones(
        self,
        *,
        document_id: str,
        next_: Optional[str] = None,
        timeout: Optional[float] = None,
    ) -> httpx.Response:
        """Retrieve a list of milestones for a document

        Returns [MilestoneListResult](ref:milestones#milestonelistresult).
        """
        return self._client.request(
            "GET",
            self._api,
            "/documents/{documentId}/milestones",
            path_params={
                "documentId": document_id,
            },
            query_params={
                "$next": next_,
            },
            timeout=timeout,
        )

    async def get_document_milestones_async(
        self,
        *,
        document_id: str,
        next_: Optional[str] = None,
        timeout: Optional[float] = None,
    ) -> httpx.Response:
        """Retrieve a list of milestones for a document (async)

        Returns [MilestoneListResult](ref:milestones#milestonelistresult).
        """
        return await self._client.request_async(
            "GET",
            self._api,
            "/documents/{documentId}/milestones",
            path_params={
                "documentId": document_id,
            },
            query_params={
                "$next": next_,
            },
            timeout=timeout,
        )

    def get_document_permissions(
        self,
        *,
        document_id: str,
        filter_: Optional[str] = None,
        maxpagesize: Optional[int] = 1000,
        next_: Optional[str] = None,
        timeout: Optional[float] = None,
    ) -> httpx.Response:
        """Retrieve permissions for a document

        Retrieves a paginated list of permissions for a given document
        """
        return self._client.request(
            "GET",
            self._api,
            "/documents/{documentId}/permissions",
            path_params={
                "documentId": document_id,
            },
            query_params={
                "$filter": filter_,
                "$maxpagesize": maxpagesize,
                "$next": next_,
            },
            timeout=timeout,
        )

    async def get_document_permissions_async(
        self,
        *,
        document_id: str,
        filter_: Optional[str] = None,
        maxpagesize: Optional[int] = 1000,
        next_: Optional[str] = None,
        timeout: Optional[float] = None,
    ) -> httpx.Response:
        """Retrieve permissions for a document (async)

        Retrieves a paginated list of permissions for a given document
        """
        return await self._client.request_async(
            "GET",
            self._api,
            "/documents/{documentId}/permissions",
            path_params={
                "documentId": document_id,
            },
            query_params={
                "$filter": filter_,
                "$maxpagesize": maxpagesize,
                "$next": next_,
            },
            timeout=timeout,
        )

    def document_permissions_modification(
        self,
        *,
        document_id: str,
        body: ResourcePermissionsModification,
        timeout: Optional[float] = None,
    ) -> httpx.Response:
        """Modify permissions on a document

        Assign and/or revoke permissions on a document. If any modification in a
        request fails, all modifications on that request fail. <br /><br /> _To
        modify an existing permission, the existing permission must first be
        explicitly revoked. Then, the new permission needs to be assigned. This
        can be done in a single request by sending `toAssign` and `toRevoke` in
        the request body._
        """
        return self._client.request(
            "POST",
            self._api,
            "/documents/{documentId}/permissions/modification",
            path_params={
                "documentId": document_id,
            },
            json_body=body,
            timeout=timeout,
        )

    async def document_permissions_modification_async(
        self,
        *,
        document_id: str,
        body: ResourcePermissionsModification,
        timeout: Optional[float] = None,
    ) -> httpx.Response:
        """Modify permissions on a document (async)

        Assign and/or revoke permissions on a document. If any modification in a
        request fails, all modifications on that request fail. <br /><br /> _To
        modify an existing permission, the existing permission must first be
        explicitly revoked. Then, the new permission needs to be assigned. This
        can be done in a single request by sending `toAssign` and `toRevoke` in
        the request body._
        """
        return await self._client.request_async(
            "POST",
            self._api,
            "/documents/{documentId}/permissions/modification",
            path_params={
                "documentId": document_id,
            },
            json_body=body,
            timeout=timeout,
        )

    def get_sections(
        self,
        *,
        document_id: str,
        revision: Optional[str] = None,
        maxpagesize: Optional[int] = 1000,
        next_: Optional[str] = None,
        timeout: Optional[float] = None,
    ) -> httpx.Response:
        """Retrieve a list of sections

        Returns a list of [sections](ref:documents#section).
        """
        return self._client.request(
            "GET",
            self._api,
            "/documents/{documentId}/sections",
            path_params={
                "documentId": document_id,
            },
            query_params={
                "$revision": revision,
                "$maxpagesize": maxpagesize,
                "$next": next_,
            },
            timeout=timeout,
        )

    async def get_sections_async(
        self,
        *,
        document_id: str,
        revision: Optional[str] = None,
        maxpagesize: Optional[int] = 1000,
        next_: Optional[str] = None,
        timeout: Optional[float] = None,
    ) -> httpx.Response:
        """Retrieve a list of sections (async)

        Returns a list of [sections](ref:documents#section).
        """
        return await self._client.request_async(
            "GET",
            self._api,
            "/documents/{documentId}/sections",
            path_params={
                "documentId": document_id,
            },
            query_params={
                "$revision": revision,
                "$maxpagesize": maxpagesize,
                "$next": next_,
            },
            timeout=timeout,
        )

    def create_section(
        self,
        *,
        document_id: str,
        body: Section,
        timeout: Optional[float] = None,
    ) -> httpx.Response:
        """Create a new section in a document

        Creates a new [section](ref:documents#section) in a
        [document](ref:documents#document), given its properties. By default,
        the new section appears at the top-most position.
        """
        return self._client.request(
            "POST",
            self._api,
            "/documents/{documentId}/sections",
            path_params={
                "documentId": document_id,
            },
            json_body=body,
            timeout=timeout,
        )

    async def create_section_async(
        self,
        *,
        document_id: str,
        body: Section,
        timeout: Optional[float] = None,
    ) -> httpx.Response:
        """Create a new section in a document (async)

        Creates a new [section](ref:documents#section) in a
        [document](ref:documents#document), given its properties. By default,
        the new section appears at the top-most position.
        """
        return await self._client.request_async(
            "POST",
            self._api,
            "/documents/{documentId}/sections",
            path_params={
                "documentId": document_id,
            },
            json_body=body,
            timeout=timeout,
        )

    def get_section_by_id(
        self,
        *,
        document_id: str,
        section_id: str,
        expand: Optional[str] = None,
        revision: Optional[str] = None,
        timeout: Optional[float] = None,
    ) -> httpx.Response:
        """Retrieve a single section

        Retrieves a [section](ref:documents#section) given its ID.
        """
        return self._client.request(
            "GET",
            self._api,
            "/documents/{documentId}/sections/{sectionId}",
            path_params={
                "documentId": document_id,
                "sectionId": section_id,
            },
            query_params={
                "$expand": expand,
                "$revision": revision,
            },
            timeout=timeout,
        )

    async def get_section_by_id_async(
        self,
        *,
        document_id: str,
        section_id: str,
        expand: Optional[str] = None,
        revision: Optional[str] = None,
        timeout: Optional[float] = None,
    ) -> httpx.Response:
        """Retrieve a single section (async)

        Retrieves a [section](ref:documents#section) given its ID.
        """
        return await self._client.request_async(
            "GET",
            self._api,
            "/documents/{documentId}/sections/{sectionId}",
            path_params={
                "documentId": document_id,
                "sectionId": section_id,
            },
            query_params={
                "$expand": expand,
                "$revision": revision,
            },
            timeout=timeout,
        )

    def delete_section_by_id(
        self,
        *,
        document_id: str,
        section_id: str,
        timeout: Optional[float] = None,
    ) -> httpx.Response:
        """Delete a single section

        Deletes a [section](ref:documents#section) given its ID.
        """
        return self._client.request(
            "DELETE",
            self._api,
            "/documents/{documentId}/sections/{sectionId}",
            path_params={
                "documentId": document_id,
                "sectionId": section_id,
            },
            timeout=timeout,
        )

    async def delete_section_by_id_async(
        self,
        *,
        document_id: str,
        section_id: str,
        timeout: Optional[float] = None,
    ) -> httpx.Response:
        """Delete a single section (async)

        Deletes a [section](ref:documents#section) given its ID.
        """
        return await self._client.request_async(
            "DELETE",
            self._api,
            "/documents/{documentId}/sections/{sectionId}",
            path_params={
                "documentId": document_id,
                "sectionId": section_id,
            },
            timeout=timeout,
        )

    def partially_update_section_by_id(
        self,
        *,
        document_id: str,
        section_id: str,
        body: list[Any],
        timeout: Optional[float] = None,
    ) -> httpx.Response:
        """Partially update a single section

        Updates the properties of a [section](ref:documents#section).

        This is a long running operation. Responses include a `Location` header,
        which indicates where to poll for results. For more details on long-
        running job polling,
        see [Operations endpoint](ref:getoperationbyid).

        ### Options

        | Path                                     | PATCH Operations Supported
        |
        |------------------------------------------|----------------------------
        --------|
        | `/name`                                  | `replace`
        |
        | `/parent`                                | `replace`
        |
        | `/parent/id`                             | `replace`
        |
        | `/index`                                 | `replace`
        |
        | `/nonPrinting`                           | `replace`
        |
        | `/customFields`                          | `add`, `remove`, `replace`,
        `test` |
        | `/customFields/<customFieldId>`          | `add`, `remove`, `replace`,
        `test` |
        | `/lock`                                  | `replace`
        |
        | `/properties/margins/top`                | `replace`
        |
        | `/properties/margins/bottom`             | `replace`
        |
        | `/properties/margins/right`              | `replace`
        |
        | `/properties/margins/left`               | `replace`
        |
        | `/properties/pageBreakBefore`            | `replace`
        |
        | `/properties/exhibit`                    | `replace`
        |
        | `/properties/edgarKeepTogether`          | `replace`
        |
        | `/properties/pageNumber/reset`           | `replace`
        |
        | `/properties/pageNumber/startAt`         | `replace`
        |
        | `/properties/background/color`           | `replace`
        |
        | `/properties/background/image`           | `replace`
        |
        | `/properties/restartFootnoteNumbering`   | `replace`
        |
        | `/properties/header/alternatingPage`     | `replace`
        |
        | `/properties/header/differentFirstPage`  | `replace`
        |
        | `/properties/header/differentLastPage`   | `replace`
        |
        | `/properties/header/margin/right`        | `replace`
        |
        | `/properties/header/margin/left`         | `replace`
        |
        | `/properties/header/matchSectionMargins` | `replace`
        |
        | `/properties/header/positionFromTop`     | `replace`
        |
        | `/properties/header/sameAsPrevious`      | `replace`
        |
        | `/properties/footer/alternatingPage`     | `replace`
        |
        | `/properties/footer/differentFirstPage`  | `replace`
        |
        | `/properties/footer/differentLastPage`   | `replace`
        |
        | `/properties/footer/margin/right`        | `replace`
        |
        | `/properties/footer/margin/left`         | `replace`
        |
        | `/properties/footer/matchSectionMargins` | `replace`
        |
        | `/properties/footer/positionFromBottom`  | `replace`
        |
        | `/properties/footer/sameAsPrevious`      | `replace`
        |

        ### Examples

        #### Update the name of a section

        ```json
        [
          {
            "op": "replace",
            "path": "/name",
            "value": "Introduction"
          }
        ]
        ```

        #### Update the parent of a section (preserving its index)

        ```json
        [
          {
            "op": "replace",
            "path": "/parent",
            "value": {
              "id": "b9b3ddb587744a27aafda3c9865f1f0a_1"
            }
          }
        ]
        ```

        #### Update the parent of a section (making it the first child)

        ```json
        [
          {
            "op": "replace",
            "path": "/parent",
            "value": {
              "id": "b9b3ddb587744a27aafda3c9865f1f0a_1"
            }
          },
          {
            "op": "replace",
            "path": "/index",
            "value": 0
          }
        ]
        ```

        #### Add a custom field value
        ```json

        [
          {
            "op": "add",
            "path": "/customFields/com.workiva.gsr.legal_entity",
            "value": "Workiva"
          }
        ]
        ```

        #### Remove a custom field value

        ```json
        [
          {
            "op": "remove",
            "path": "/customFields/com.workiva.gsr.legal_entity"
          }
        ]
        ```

        #### Replace a custom field value
        ```json

        [
          {
            "op": "replace",
            "path": "/customFields/com.workiva.gsr.legal_entity",
            "value": "Workiva, Inc."
          }
        ]
        ```
        """
        return self._client.request(
            "PATCH",
            self._api,
            "/documents/{documentId}/sections/{sectionId}",
            path_params={
                "documentId": document_id,
                "sectionId": section_id,
            },
            json_body=body,
            timeout=timeout,
        )

    async def partially_update_section_by_id_async(
        self,
        *,
        document_id: str,
        section_id: str,
        body: list[Any],
        timeout: Optional[float] = None,
    ) -> httpx.Response:
        """Partially update a single section (async)

        Updates the properties of a [section](ref:documents#section).

        This is a long running operation. Responses include a `Location` header,
        which indicates where to poll for results. For more details on long-
        running job polling,
        see [Operations endpoint](ref:getoperationbyid).

        ### Options

        | Path                                     | PATCH Operations Supported
        |
        |------------------------------------------|----------------------------
        --------|
        | `/name`                                  | `replace`
        |
        | `/parent`                                | `replace`
        |
        | `/parent/id`                             | `replace`
        |
        | `/index`                                 | `replace`
        |
        | `/nonPrinting`                           | `replace`
        |
        | `/customFields`                          | `add`, `remove`, `replace`,
        `test` |
        | `/customFields/<customFieldId>`          | `add`, `remove`, `replace`,
        `test` |
        | `/lock`                                  | `replace`
        |
        | `/properties/margins/top`                | `replace`
        |
        | `/properties/margins/bottom`             | `replace`
        |
        | `/properties/margins/right`              | `replace`
        |
        | `/properties/margins/left`               | `replace`
        |
        | `/properties/pageBreakBefore`            | `replace`
        |
        | `/properties/exhibit`                    | `replace`
        |
        | `/properties/edgarKeepTogether`          | `replace`
        |
        | `/properties/pageNumber/reset`           | `replace`
        |
        | `/properties/pageNumber/startAt`         | `replace`
        |
        | `/properties/background/color`           | `replace`
        |
        | `/properties/background/image`           | `replace`
        |
        | `/properties/restartFootnoteNumbering`   | `replace`
        |
        | `/properties/header/alternatingPage`     | `replace`
        |
        | `/properties/header/differentFirstPage`  | `replace`
        |
        | `/properties/header/differentLastPage`   | `replace`
        |
        | `/properties/header/margin/right`        | `replace`
        |
        | `/properties/header/margin/left`         | `replace`
        |
        | `/properties/header/matchSectionMargins` | `replace`
        |
        | `/properties/header/positionFromTop`     | `replace`
        |
        | `/properties/header/sameAsPrevious`      | `replace`
        |
        | `/properties/footer/alternatingPage`     | `replace`
        |
        | `/properties/footer/differentFirstPage`  | `replace`
        |
        | `/properties/footer/differentLastPage`   | `replace`
        |
        | `/properties/footer/margin/right`        | `replace`
        |
        | `/properties/footer/margin/left`         | `replace`
        |
        | `/properties/footer/matchSectionMargins` | `replace`
        |
        | `/properties/footer/positionFromBottom`  | `replace`
        |
        | `/properties/footer/sameAsPrevious`      | `replace`
        |

        ### Examples

        #### Update the name of a section

        ```json
        [
          {
            "op": "replace",
            "path": "/name",
            "value": "Introduction"
          }
        ]
        ```

        #### Update the parent of a section (preserving its index)

        ```json
        [
          {
            "op": "replace",
            "path": "/parent",
            "value": {
              "id": "b9b3ddb587744a27aafda3c9865f1f0a_1"
            }
          }
        ]
        ```

        #### Update the parent of a section (making it the first child)

        ```json
        [
          {
            "op": "replace",
            "path": "/parent",
            "value": {
              "id": "b9b3ddb587744a27aafda3c9865f1f0a_1"
            }
          },
          {
            "op": "replace",
            "path": "/index",
            "value": 0
          }
        ]
        ```

        #### Add a custom field value
        ```json

        [
          {
            "op": "add",
            "path": "/customFields/com.workiva.gsr.legal_entity",
            "value": "Workiva"
          }
        ]
        ```

        #### Remove a custom field value

        ```json
        [
          {
            "op": "remove",
            "path": "/customFields/com.workiva.gsr.legal_entity"
          }
        ]
        ```

        #### Replace a custom field value
        ```json

        [
          {
            "op": "replace",
            "path": "/customFields/com.workiva.gsr.legal_entity",
            "value": "Workiva, Inc."
          }
        ]
        ```
        """
        return await self._client.request_async(
            "PATCH",
            self._api,
            "/documents/{documentId}/sections/{sectionId}",
            path_params={
                "documentId": document_id,
                "sectionId": section_id,
            },
            json_body=body,
            timeout=timeout,
        )

    def copy_section(
        self,
        *,
        document_id: str,
        section_id: str,
        body: SectionCopy,
        timeout: Optional[float] = None,
    ) -> httpx.Response:
        """Copy section

        Asynchronously copies a [section](ref:documents#section) given details
        about the copy's destination within the same or another document.
        Options are specified using a [SectionCopy](ref:documents#sectioncopy)
        object.

        Copies only the section's content — not any labels, comments, tasks, or
        formatting from a style guide. Unless otherwise specified, the copy
        appears at the top level of its destination document, with an index of
        0, and with the same name as the original section.
        """
        return self._client.request(
            "POST",
            self._api,
            "/documents/{documentId}/sections/{sectionId}/copy",
            path_params={
                "documentId": document_id,
                "sectionId": section_id,
            },
            json_body=body,
            timeout=timeout,
        )

    async def copy_section_async(
        self,
        *,
        document_id: str,
        section_id: str,
        body: SectionCopy,
        timeout: Optional[float] = None,
    ) -> httpx.Response:
        """Copy section (async)

        Asynchronously copies a [section](ref:documents#section) given details
        about the copy's destination within the same or another document.
        Options are specified using a [SectionCopy](ref:documents#sectioncopy)
        object.

        Copies only the section's content — not any labels, comments, tasks, or
        formatting from a style guide. Unless otherwise specified, the copy
        appears at the top level of its destination document, with an index of
        0, and with the same name as the original section.
        """
        return await self._client.request_async(
            "POST",
            self._api,
            "/documents/{documentId}/sections/{sectionId}/copy",
            path_params={
                "documentId": document_id,
                "sectionId": section_id,
            },
            json_body=body,
            timeout=timeout,
        )

    def edit_sections(
        self,
        *,
        document_id: str,
        body: SectionsEdits,
        timeout: Optional[float] = None,
    ) -> httpx.Response:
        """Initiate sections edits

        Updates the properties of a collection of
        [sections](ref:documents#section) in a document using
        [SectionsEdits](ref:documents#sectionsedit) request. This is a long
        running operation.
        Responses include a `Location` header, which indicates where to poll for
        results. For more details on long-running job polling, see [Operations
        endpoint](ref:getoperationbyid). When the update completes, its status
        will be `completed`.
        """
        return self._client.request(
            "POST",
            self._api,
            "/documents/{documentId}/sections/edit",
            path_params={
                "documentId": document_id,
            },
            json_body=body,
            timeout=timeout,
        )

    async def edit_sections_async(
        self,
        *,
        document_id: str,
        body: SectionsEdits,
        timeout: Optional[float] = None,
    ) -> httpx.Response:
        """Initiate sections edits (async)

        Updates the properties of a collection of
        [sections](ref:documents#section) in a document using
        [SectionsEdits](ref:documents#sectionsedit) request. This is a long
        running operation.
        Responses include a `Location` header, which indicates where to poll for
        results. For more details on long-running job polling, see [Operations
        endpoint](ref:getoperationbyid). When the update completes, its status
        will be `completed`.
        """
        return await self._client.request_async(
            "POST",
            self._api,
            "/documents/{documentId}/sections/edit",
            path_params={
                "documentId": document_id,
            },
            json_body=body,
            timeout=timeout,
        )

    def get_section_permissions(
        self,
        *,
        document_id: str,
        section_id: str,
        filter_: Optional[str] = None,
        maxpagesize: Optional[int] = 1000,
        next_: Optional[str] = None,
        timeout: Optional[float] = None,
    ) -> httpx.Response:
        """Retrieve permissions for a section in a document

        Retrieves a paginated list of permissions for the given section in a
        document
        """
        return self._client.request(
            "GET",
            self._api,
            "/documents/{documentId}/sections/{sectionId}/permissions",
            path_params={
                "documentId": document_id,
                "sectionId": section_id,
            },
            query_params={
                "$filter": filter_,
                "$maxpagesize": maxpagesize,
                "$next": next_,
            },
            timeout=timeout,
        )

    async def get_section_permissions_async(
        self,
        *,
        document_id: str,
        section_id: str,
        filter_: Optional[str] = None,
        maxpagesize: Optional[int] = 1000,
        next_: Optional[str] = None,
        timeout: Optional[float] = None,
    ) -> httpx.Response:
        """Retrieve permissions for a section in a document (async)

        Retrieves a paginated list of permissions for the given section in a
        document
        """
        return await self._client.request_async(
            "GET",
            self._api,
            "/documents/{documentId}/sections/{sectionId}/permissions",
            path_params={
                "documentId": document_id,
                "sectionId": section_id,
            },
            query_params={
                "$filter": filter_,
                "$maxpagesize": maxpagesize,
                "$next": next_,
            },
            timeout=timeout,
        )

    def section_permissions_modification(
        self,
        *,
        document_id: str,
        section_id: str,
        body: ResourcePermissionsModification,
        timeout: Optional[float] = None,
    ) -> httpx.Response:
        """Modify permissions on a given section of a document

        Assign and/or revoke permissions on a section. If any modification in a
        request fails, all modifications on that request fail. <br /><br /> _To
        modify an existing permission, the existing permission must first be
        explicitly revoked. Then, the new permission needs to be assigned. This
        can be done in a single request by sending `toAssign` and `toRevoke` in
        the request body._
        """
        return self._client.request(
            "POST",
            self._api,
            "/documents/{documentId}/sections/{sectionId}/permissions/modification",
            path_params={
                "documentId": document_id,
                "sectionId": section_id,
            },
            json_body=body,
            timeout=timeout,
        )

    async def section_permissions_modification_async(
        self,
        *,
        document_id: str,
        section_id: str,
        body: ResourcePermissionsModification,
        timeout: Optional[float] = None,
    ) -> httpx.Response:
        """Modify permissions on a given section of a document (async)

        Assign and/or revoke permissions on a section. If any modification in a
        request fails, all modifications on that request fail. <br /><br /> _To
        modify an existing permission, the existing permission must first be
        explicitly revoked. Then, the new permission needs to be assigned. This
        can be done in a single request by sending `toAssign` and `toRevoke` in
        the request body._
        """
        return await self._client.request_async(
            "POST",
            self._api,
            "/documents/{documentId}/sections/{sectionId}/permissions/modification",
            path_params={
                "documentId": document_id,
                "sectionId": section_id,
            },
            json_body=body,
            timeout=timeout,
        )
