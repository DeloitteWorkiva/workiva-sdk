"""Wdata API â€” file_management namespace.

Auto-generated by codegen. Do not edit manually.
"""

from __future__ import annotations

from typing import Any, Optional

import httpx

from workiva._constants import _API
from workiva._operations._base import BaseNamespace


class FileManagement(BaseNamespace):
    """FileManagement operations."""

    _api: _API = _API.WDATA

    def upload_file(
        self,
        *,
        table_id: str,
        name: Optional[str] = None,
        url: Optional[str] = None,
        source: Optional[str] = None,
        delimiter: Optional[str] = None,
        import_dto: Optional[str] = None,
        body: Optional[dict[str, Any]] = None,
        timeout: Optional[float] = None,
    ) -> httpx.Response:
        """Upload a single file

        Accepts CSV, TSV, or JSON files, or a ZIP file that contains a single
        CSV, TSV, or
        JSON file. If a ZIP, it must contain a CSV, TSV, or JSON file, and the
        name of the
        CSV, TSV, or JSON file is also used with the imported file. Downloading
        this file
        again downloads the source. Note that all files uploaded must have a
        .csv, .tsv, or .json
        extension. JSON files are expected to have a single JSON record per
        line; a JSON file is
        a series of JSON objects delimited by a newline character.
        """
        return self._client.request(
            "POST",
            self._api,
            "/api/v1/file",
            query_params={
                "tableId": table_id,
                "name": name,
                "url": url,
                "source": source,
                "delimiter": delimiter,
                "importDto": import_dto,
            },
            files=body,
            timeout=timeout,
        )

    async def upload_file_async(
        self,
        *,
        table_id: str,
        name: Optional[str] = None,
        url: Optional[str] = None,
        source: Optional[str] = None,
        delimiter: Optional[str] = None,
        import_dto: Optional[str] = None,
        body: Optional[dict[str, Any]] = None,
        timeout: Optional[float] = None,
    ) -> httpx.Response:
        """Upload a single file (async)

        Accepts CSV, TSV, or JSON files, or a ZIP file that contains a single
        CSV, TSV, or
        JSON file. If a ZIP, it must contain a CSV, TSV, or JSON file, and the
        name of the
        CSV, TSV, or JSON file is also used with the imported file. Downloading
        this file
        again downloads the source. Note that all files uploaded must have a
        .csv, .tsv, or .json
        extension. JSON files are expected to have a single JSON record per
        line; a JSON file is
        a series of JSON objects delimited by a newline character.
        """
        return await self._client.request_async(
            "POST",
            self._api,
            "/api/v1/file",
            query_params={
                "tableId": table_id,
                "name": name,
                "url": url,
                "source": source,
                "delimiter": delimiter,
                "importDto": import_dto,
            },
            files=body,
            timeout=timeout,
        )

    def get_files(
        self,
        *,
        table_id: str,
        cursor: Optional[str] = None,
        limit: Optional[int] = None,
        offset: Optional[int] = None,
        sort_order: Optional[str] = None,
        sort_by: Optional[str] = None,
        search_text: Optional[str] = None,
        timeout: Optional[float] = None,
    ) -> httpx.Response:
        """Retrieve a list of files

        Returns a paged list of all files associated with the provided table ID,
        as well
        as metadata associated with each file.
        """
        return self._client.request(
            "GET",
            self._api,
            "/api/v1/file",
            query_params={
                "tableId": table_id,
                "cursor": cursor,
                "limit": limit,
                "offset": offset,
                "sortOrder": sort_order,
                "sortBy": sort_by,
                "searchText": search_text,
            },
            timeout=timeout,
        )

    async def get_files_async(
        self,
        *,
        table_id: str,
        cursor: Optional[str] = None,
        limit: Optional[int] = None,
        offset: Optional[int] = None,
        sort_order: Optional[str] = None,
        sort_by: Optional[str] = None,
        search_text: Optional[str] = None,
        timeout: Optional[float] = None,
    ) -> httpx.Response:
        """Retrieve a list of files (async)

        Returns a paged list of all files associated with the provided table ID,
        as well
        as metadata associated with each file.
        """
        return await self._client.request_async(
            "GET",
            self._api,
            "/api/v1/file",
            query_params={
                "tableId": table_id,
                "cursor": cursor,
                "limit": limit,
                "offset": offset,
                "sortOrder": sort_order,
                "sortBy": sort_by,
                "searchText": search_text,
            },
            timeout=timeout,
        )

    def validate_filename(
        self,
        *,
        table_id: str,
        filename: str,
        timeout: Optional[float] = None,
    ) -> httpx.Response:
        """Validate whether a file with the filename can be uploaded to the table

        If the filename is valid, this returns 200. If the table already has a
        file with the same name, this returns 409. If the user isn't allowed to
        read the table, or if the table isn't found, this returns 404.
        """
        return self._client.request(
            "GET",
            self._api,
            "/api/v1/file/validateName",
            query_params={
                "tableId": table_id,
                "filename": filename,
            },
            timeout=timeout,
        )

    async def validate_filename_async(
        self,
        *,
        table_id: str,
        filename: str,
        timeout: Optional[float] = None,
    ) -> httpx.Response:
        """Validate whether a file with the filename can be uploaded to the table (async)

        If the filename is valid, this returns 200. If the table already has a
        file with the same name, this returns 409. If the user isn't allowed to
        read the table, or if the table isn't found, this returns 404.
        """
        return await self._client.request_async(
            "GET",
            self._api,
            "/api/v1/file/validateName",
            query_params={
                "tableId": table_id,
                "filename": filename,
            },
            timeout=timeout,
        )

    def delete_file(
        self,
        *,
        file_id: str,
        timeout: Optional[float] = None,
    ) -> httpx.Response:
        """Delete a single file

        Unstages the file with the provided ID. The file must have a STAGED
        status; if the
        file isn't STAGED, returns a 409 status. If the file isn't found, this
        is a no-op.
        """
        return self._client.request(
            "DELETE",
            self._api,
            "/api/v1/file/{fileId}",
            path_params={
                "fileId": file_id,
            },
            timeout=timeout,
        )

    async def delete_file_async(
        self,
        *,
        file_id: str,
        timeout: Optional[float] = None,
    ) -> httpx.Response:
        """Delete a single file (async)

        Unstages the file with the provided ID. The file must have a STAGED
        status; if the
        file isn't STAGED, returns a 409 status. If the file isn't found, this
        is a no-op.
        """
        return await self._client.request_async(
            "DELETE",
            self._api,
            "/api/v1/file/{fileId}",
            path_params={
                "fileId": file_id,
            },
            timeout=timeout,
        )

    def get_file(
        self,
        *,
        file_id: str,
        timeout: Optional[float] = None,
    ) -> httpx.Response:
        """Retrieve a single file

        Returns the file meta that matches the provided ID, or a 404 if an
        associated file
        can't be found.
        """
        return self._client.request(
            "GET",
            self._api,
            "/api/v1/file/{fileId}",
            path_params={
                "fileId": file_id,
            },
            timeout=timeout,
        )

    async def get_file_async(
        self,
        *,
        file_id: str,
        timeout: Optional[float] = None,
    ) -> httpx.Response:
        """Retrieve a single file (async)

        Returns the file meta that matches the provided ID, or a 404 if an
        associated file
        can't be found.
        """
        return await self._client.request_async(
            "GET",
            self._api,
            "/api/v1/file/{fileId}",
            path_params={
                "fileId": file_id,
            },
            timeout=timeout,
        )

    def download_file_1(
        self,
        *,
        file_id: str,
        timeout: Optional[float] = None,
    ) -> httpx.Response:
        """Download a single file

        Returns a file with the provided ID, which points to a file meta ID.
        """
        return self._client.request(
            "GET",
            self._api,
            "/api/v1/file/{fileId}/download",
            path_params={
                "fileId": file_id,
            },
            timeout=timeout,
        )

    async def download_file_1_async(
        self,
        *,
        file_id: str,
        timeout: Optional[float] = None,
    ) -> httpx.Response:
        """Download a single file (async)

        Returns a file with the provided ID, which points to a file meta ID.
        """
        return await self._client.request_async(
            "GET",
            self._api,
            "/api/v1/file/{fileId}/download",
            path_params={
                "fileId": file_id,
            },
            timeout=timeout,
        )

    def get_errors(
        self,
        *,
        file_id: str,
        cursor: Optional[str] = None,
        limit: Optional[int] = 50,
        offset: Optional[int] = None,
        timeout: Optional[float] = None,
    ) -> httpx.Response:
        """Retrieve errors

        Returns a paged list of operation errors during the upload, import, or
        tagging
        processes for the provided file ID, if they exist. This list is
        immutable and may be
        empty if no errors have occurred. If errors exist we recommend fixing
        them and
        reimporting your file
        """
        return self._client.request(
            "GET",
            self._api,
            "/api/v1/file/{fileId}/error",
            path_params={
                "fileId": file_id,
            },
            query_params={
                "cursor": cursor,
                "limit": limit,
                "offset": offset,
            },
            timeout=timeout,
        )

    async def get_errors_async(
        self,
        *,
        file_id: str,
        cursor: Optional[str] = None,
        limit: Optional[int] = 50,
        offset: Optional[int] = None,
        timeout: Optional[float] = None,
    ) -> httpx.Response:
        """Retrieve errors (async)

        Returns a paged list of operation errors during the upload, import, or
        tagging
        processes for the provided file ID, if they exist. This list is
        immutable and may be
        empty if no errors have occurred. If errors exist we recommend fixing
        them and
        reimporting your file
        """
        return await self._client.request_async(
            "GET",
            self._api,
            "/api/v1/file/{fileId}/error",
            path_params={
                "fileId": file_id,
            },
            query_params={
                "cursor": cursor,
                "limit": limit,
                "offset": offset,
            },
            timeout=timeout,
        )

    def export_file_to_spreadsheets(
        self,
        *,
        file_id: str,
        body: ExportFileDto,
        timeout: Optional[float] = None,
    ) -> httpx.Response:
        """Export a file to spreadsheets

        Exports the file ID identified in the path to the spreadsheet identified
        by the
        provided URL. If the URL string is empty, creates and returns a new
        spreadsheet and
        its sheet IDs.
        """
        return self._client.request(
            "POST",
            self._api,
            "/api/v1/file/{fileId}/export",
            path_params={
                "fileId": file_id,
            },
            json_body=body,
            timeout=timeout,
        )

    async def export_file_to_spreadsheets_async(
        self,
        *,
        file_id: str,
        body: ExportFileDto,
        timeout: Optional[float] = None,
    ) -> httpx.Response:
        """Export a file to spreadsheets (async)

        Exports the file ID identified in the path to the spreadsheet identified
        by the
        provided URL. If the URL string is empty, creates and returns a new
        spreadsheet and
        its sheet IDs.
        """
        return await self._client.request_async(
            "POST",
            self._api,
            "/api/v1/file/{fileId}/export",
            path_params={
                "fileId": file_id,
            },
            json_body=body,
            timeout=timeout,
        )
