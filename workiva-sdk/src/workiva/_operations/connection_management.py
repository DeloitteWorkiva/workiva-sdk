"""Wdata API — connection_management namespace.

Auto-generated by codegen. Do not edit manually.
"""

from __future__ import annotations

from typing import Any, Optional

import httpx

from workiva._constants import _API
from workiva._operations._base import BaseNamespace


class ConnectionManagement(BaseNamespace):
    """ConnectionManagement operations."""

    _api: _API = _API.WDATA

    def list_connections(
        self,
        *,
        source_type: Optional[str] = None,
        destination_type: Optional[str] = None,
        source_id: Optional[str] = None,
        destination_id: Optional[str] = None,
        cursor: Optional[str] = None,
        limit: Optional[int] = None,
        offset: Optional[int] = None,
        timeout: Optional[float] = None,
    ) -> httpx.Response:
        """List connections

        A pageable endpoint to list data connections between features of the
        Workiva platform. When filtering by source or destination, the
        corresponding ID is required.
        """
        return self._client.request(
            "GET",
            self._api,
            "/api/v1/connections",
            query_params={
                "sourceType": source_type,
                "destinationType": destination_type,
                "sourceId": source_id,
                "destinationId": destination_id,
                "cursor": cursor,
                "limit": limit,
                "offset": offset,
            },
            timeout=timeout,
        )

    async def list_connections_async(
        self,
        *,
        source_type: Optional[str] = None,
        destination_type: Optional[str] = None,
        source_id: Optional[str] = None,
        destination_id: Optional[str] = None,
        cursor: Optional[str] = None,
        limit: Optional[int] = None,
        offset: Optional[int] = None,
        timeout: Optional[float] = None,
    ) -> httpx.Response:
        """List connections (async)

        A pageable endpoint to list data connections between features of the
        Workiva platform. When filtering by source or destination, the
        corresponding ID is required.
        """
        return await self._client.request_async(
            "GET",
            self._api,
            "/api/v1/connections",
            query_params={
                "sourceType": source_type,
                "destinationType": destination_type,
                "sourceId": source_id,
                "destinationId": destination_id,
                "cursor": cursor,
                "limit": limit,
                "offset": offset,
            },
            timeout=timeout,
        )

    def refresh_batch(
        self,
        *,
        body: list[RefreshConnectionDto],
        cancel_unwritables: Optional[bool] = None,
        timeout: Optional[float] = None,
    ) -> httpx.Response:
        """Refresh batch of connections

        Refreshes multiple incoming connections within the same spreadsheet,
        based on ID. When connecting to multiple spreadsheets, tables or other
        destinations, use the [`singular refresh connection`](ref:wdata-
        refreshconnection) instead.
         `usePreviousDestinationParameters` and  `usePreviousSourceParameters`
        will use the exact parameters of your previous run; any new parameters
        you’ve provided will be ignored. This endpoint only works for outgoing
        connections if they are all connected to the same workbook. This
        endpoint has a limit of 100 refreshes per request.
        """
        return self._client.request(
            "POST",
            self._api,
            "/api/v1/connections/batch/refresh",
            query_params={
                "cancelUnwritables": cancel_unwritables,
            },
            json_body=body,
            timeout=timeout,
        )

    async def refresh_batch_async(
        self,
        *,
        body: list[RefreshConnectionDto],
        cancel_unwritables: Optional[bool] = None,
        timeout: Optional[float] = None,
    ) -> httpx.Response:
        """Refresh batch of connections (async)

        Refreshes multiple incoming connections within the same spreadsheet,
        based on ID. When connecting to multiple spreadsheets, tables or other
        destinations, use the [`singular refresh connection`](ref:wdata-
        refreshconnection) instead.
         `usePreviousDestinationParameters` and  `usePreviousSourceParameters`
        will use the exact parameters of your previous run; any new parameters
        you’ve provided will be ignored. This endpoint only works for outgoing
        connections if they are all connected to the same workbook. This
        endpoint has a limit of 100 refreshes per request.
        """
        return await self._client.request_async(
            "POST",
            self._api,
            "/api/v1/connections/batch/refresh",
            query_params={
                "cancelUnwritables": cancel_unwritables,
            },
            json_body=body,
            timeout=timeout,
        )

    def get_refresh_batch_status(
        self,
        *,
        batch_id: str,
        workspace_id: Optional[str] = None,
        timeout: Optional[float] = None,
    ) -> httpx.Response:
        """Gets the status of a batch refresh

        Returns details about a specific batch refresh, based on its ID.
        """
        return self._client.request(
            "GET",
            self._api,
            "/api/v1/connections/batch/refresh/{batchId}",
            path_params={
                "batchId": batch_id,
            },
            query_params={
                "workspaceId": workspace_id,
            },
            timeout=timeout,
        )

    async def get_refresh_batch_status_async(
        self,
        *,
        batch_id: str,
        workspace_id: Optional[str] = None,
        timeout: Optional[float] = None,
    ) -> httpx.Response:
        """Gets the status of a batch refresh (async)

        Returns details about a specific batch refresh, based on its ID.
        """
        return await self._client.request_async(
            "GET",
            self._api,
            "/api/v1/connections/batch/refresh/{batchId}",
            path_params={
                "batchId": batch_id,
            },
            query_params={
                "workspaceId": workspace_id,
            },
            timeout=timeout,
        )

    def get_connection(
        self,
        *,
        connection_id: str,
        workspace_id: Optional[str] = None,
        timeout: Optional[float] = None,
    ) -> httpx.Response:
        """Get connection details

        Returns details about a specific connection, based on its ID
        """
        return self._client.request(
            "GET",
            self._api,
            "/api/v1/connections/{connectionId}",
            path_params={
                "connectionId": connection_id,
            },
            query_params={
                "workspaceId": workspace_id,
            },
            timeout=timeout,
        )

    async def get_connection_async(
        self,
        *,
        connection_id: str,
        workspace_id: Optional[str] = None,
        timeout: Optional[float] = None,
    ) -> httpx.Response:
        """Get connection details (async)

        Returns details about a specific connection, based on its ID
        """
        return await self._client.request_async(
            "GET",
            self._api,
            "/api/v1/connections/{connectionId}",
            path_params={
                "connectionId": connection_id,
            },
            query_params={
                "workspaceId": workspace_id,
            },
            timeout=timeout,
        )

    def refresh_connection(
        self,
        *,
        connection_id: str,
        body: RefreshConnectionDto,
        timeout: Optional[float] = None,
    ) -> httpx.Response:
        """Refresh connection

        Refreshes a specific connection, based on its ID
        """
        return self._client.request(
            "POST",
            self._api,
            "/api/v1/connections/{connectionId}/refresh",
            path_params={
                "connectionId": connection_id,
            },
            json_body=body,
            timeout=timeout,
        )

    async def refresh_connection_async(
        self,
        *,
        connection_id: str,
        body: RefreshConnectionDto,
        timeout: Optional[float] = None,
    ) -> httpx.Response:
        """Refresh connection (async)

        Refreshes a specific connection, based on its ID
        """
        return await self._client.request_async(
            "POST",
            self._api,
            "/api/v1/connections/{connectionId}/refresh",
            path_params={
                "connectionId": connection_id,
            },
            json_body=body,
            timeout=timeout,
        )

    def get_refresh_status(
        self,
        *,
        connection_id: str,
        job_id: Optional[str] = None,
        workspace_id: Optional[str] = None,
        timeout: Optional[float] = None,
    ) -> httpx.Response:
        """Get connection refresh status

        Returns details about a specific connection refresh status, based on its
        ID. To retrieve details about a specific refresh, provide its 'jobId'.
        """
        return self._client.request(
            "GET",
            self._api,
            "/api/v1/connections/{connectionId}/status",
            path_params={
                "connectionId": connection_id,
            },
            query_params={
                "jobId": job_id,
                "workspaceId": workspace_id,
            },
            timeout=timeout,
        )

    async def get_refresh_status_async(
        self,
        *,
        connection_id: str,
        job_id: Optional[str] = None,
        workspace_id: Optional[str] = None,
        timeout: Optional[float] = None,
    ) -> httpx.Response:
        """Get connection refresh status (async)

        Returns details about a specific connection refresh status, based on its
        ID. To retrieve details about a specific refresh, provide its 'jobId'.
        """
        return await self._client.request_async(
            "GET",
            self._api,
            "/api/v1/connections/{connectionId}/status",
            path_params={
                "connectionId": connection_id,
            },
            query_params={
                "jobId": job_id,
                "workspaceId": workspace_id,
            },
            timeout=timeout,
        )
