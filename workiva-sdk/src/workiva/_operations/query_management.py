"""Wdata API â€” query_management namespace.

Auto-generated by codegen. Do not edit manually.
"""

from __future__ import annotations

from typing import Any, Optional

import httpx

from workiva._constants import _API
from workiva._operations._base import BaseNamespace


class QueryManagement(BaseNamespace):
    """QueryManagement operations."""

    _api: _API = _API.WDATA

    def create_query(
        self,
        *,
        body: QueryDto,
        timeout: Optional[float] = None,
    ) -> httpx.Response:
        """Create a new query

        Creates a query object and validates full permissions to ensure the
        requestor has
        access to all data sources being queried. This endpoint _doesn't_
        execute the query;
        to execute, call the POST /queryresult method.
        """
        return self._client.request(
            "POST",
            self._api,
            "/api/v1/query",
            json_body=body,
            timeout=timeout,
        )

    async def create_query_async(
        self,
        *,
        body: QueryDto,
        timeout: Optional[float] = None,
    ) -> httpx.Response:
        """Create a new query (async)

        Creates a query object and validates full permissions to ensure the
        requestor has
        access to all data sources being queried. This endpoint _doesn't_
        execute the query;
        to execute, call the POST /queryresult method.
        """
        return await self._client.request_async(
            "POST",
            self._api,
            "/api/v1/query",
            json_body=body,
            timeout=timeout,
        )

    def list_queries(
        self,
        *,
        cursor: Optional[str] = None,
        limit: Optional[int] = 1000,
        offset: Optional[int] = None,
        ids: Optional[list[str]] = None,
        timeout: Optional[float] = None,
    ) -> httpx.Response:
        """Retrieve list of queries

        Returns a list of all non-temporary queries associated with the
        workspace. By default, these queries are ordered by their names, in
        ascending order.
        """
        return self._client.request(
            "GET",
            self._api,
            "/api/v1/query",
            query_params={
                "cursor": cursor,
                "limit": limit,
                "offset": offset,
                "ids": ids,
            },
            timeout=timeout,
        )

    async def list_queries_async(
        self,
        *,
        cursor: Optional[str] = None,
        limit: Optional[int] = 1000,
        offset: Optional[int] = None,
        ids: Optional[list[str]] = None,
        timeout: Optional[float] = None,
    ) -> httpx.Response:
        """Retrieve list of queries (async)

        Returns a list of all non-temporary queries associated with the
        workspace. By default, these queries are ordered by their names, in
        ascending order.
        """
        return await self._client.request_async(
            "GET",
            self._api,
            "/api/v1/query",
            query_params={
                "cursor": cursor,
                "limit": limit,
                "offset": offset,
                "ids": ids,
            },
            timeout=timeout,
        )

    def get_query_column_data(
        self,
        *,
        body: QueryTextDto,
        timeout: Optional[float] = None,
    ) -> httpx.Response:
        """Retrieve query column data

        Returns a QueryColumnDataDto representing the column data for the given
        query text.
        If the query isn't valid, returns a 400.
        """
        return self._client.request(
            "POST",
            self._api,
            "/api/v1/query/data",
            json_body=body,
            timeout=timeout,
        )

    async def get_query_column_data_async(
        self,
        *,
        body: QueryTextDto,
        timeout: Optional[float] = None,
    ) -> httpx.Response:
        """Retrieve query column data (async)

        Returns a QueryColumnDataDto representing the column data for the given
        query text.
        If the query isn't valid, returns a 400.
        """
        return await self._client.request_async(
            "POST",
            self._api,
            "/api/v1/query/data",
            json_body=body,
            timeout=timeout,
        )

    def is_query_valid(
        self,
        *,
        body: QueryDto,
        timeout: Optional[float] = None,
    ) -> httpx.Response:
        """Parses the query to determine if it is valid

        Returns the provided QueryDto
        """
        return self._client.request(
            "POST",
            self._api,
            "/api/v1/query/validation",
            json_body=body,
            timeout=timeout,
        )

    async def is_query_valid_async(
        self,
        *,
        body: QueryDto,
        timeout: Optional[float] = None,
    ) -> httpx.Response:
        """Parses the query to determine if it is valid (async)

        Returns the provided QueryDto
        """
        return await self._client.request_async(
            "POST",
            self._api,
            "/api/v1/query/validation",
            json_body=body,
            timeout=timeout,
        )

    def update_query(
        self,
        *,
        query_id: str,
        body: QueryDto,
        timeout: Optional[float] = None,
    ) -> httpx.Response:
        """Update a single query

        Updates the query that matches the provided ID with the details provided
        in the
        body.
        """
        return self._client.request(
            "PUT",
            self._api,
            "/api/v1/query/{queryId}",
            path_params={
                "queryId": query_id,
            },
            json_body=body,
            timeout=timeout,
        )

    async def update_query_async(
        self,
        *,
        query_id: str,
        body: QueryDto,
        timeout: Optional[float] = None,
    ) -> httpx.Response:
        """Update a single query (async)

        Updates the query that matches the provided ID with the details provided
        in the
        body.
        """
        return await self._client.request_async(
            "PUT",
            self._api,
            "/api/v1/query/{queryId}",
            path_params={
                "queryId": query_id,
            },
            json_body=body,
            timeout=timeout,
        )

    def delete_query(
        self,
        *,
        query_id: str,
        timeout: Optional[float] = None,
    ) -> httpx.Response:
        """Delete a single query

        Deletes the query that matches the provided ID. If no such query is
        found, this is
        a no-op.
        """
        return self._client.request(
            "DELETE",
            self._api,
            "/api/v1/query/{queryId}",
            path_params={
                "queryId": query_id,
            },
            timeout=timeout,
        )

    async def delete_query_async(
        self,
        *,
        query_id: str,
        timeout: Optional[float] = None,
    ) -> httpx.Response:
        """Delete a single query (async)

        Deletes the query that matches the provided ID. If no such query is
        found, this is
        a no-op.
        """
        return await self._client.request_async(
            "DELETE",
            self._api,
            "/api/v1/query/{queryId}",
            path_params={
                "queryId": query_id,
            },
            timeout=timeout,
        )

    def get_query(
        self,
        *,
        query_id: str,
        timeout: Optional[float] = None,
    ) -> httpx.Response:
        """Retrieve a single query

        Returns a query that matches the provided ID, or a 404 if no matching
        query is found.
        """
        return self._client.request(
            "GET",
            self._api,
            "/api/v1/query/{queryId}",
            path_params={
                "queryId": query_id,
            },
            timeout=timeout,
        )

    async def get_query_async(
        self,
        *,
        query_id: str,
        timeout: Optional[float] = None,
    ) -> httpx.Response:
        """Retrieve a single query (async)

        Returns a query that matches the provided ID, or a 404 if no matching
        query is found.
        """
        return await self._client.request_async(
            "GET",
            self._api,
            "/api/v1/query/{queryId}",
            path_params={
                "queryId": query_id,
            },
            timeout=timeout,
        )

    def get_dependencies(
        self,
        *,
        query_id: str,
        cursor: Optional[str] = None,
        limit: Optional[int] = 1000,
        offset: Optional[int] = None,
        timeout: Optional[float] = None,
    ) -> httpx.Response:
        """Retrieve dependencies

        Returns an unordered collection of all tables the matching query uses as
        datasources, including any shared tables outside of this OAuth token's
        workspace. The endpoint verifies the user has read permissions on the
        query, but _not_ on the tables returned.
        """
        return self._client.request(
            "GET",
            self._api,
            "/api/v1/query/{queryId}/dependencies",
            path_params={
                "queryId": query_id,
            },
            query_params={
                "cursor": cursor,
                "limit": limit,
                "offset": offset,
            },
            timeout=timeout,
        )

    async def get_dependencies_async(
        self,
        *,
        query_id: str,
        cursor: Optional[str] = None,
        limit: Optional[int] = 1000,
        offset: Optional[int] = None,
        timeout: Optional[float] = None,
    ) -> httpx.Response:
        """Retrieve dependencies (async)

        Returns an unordered collection of all tables the matching query uses as
        datasources, including any shared tables outside of this OAuth token's
        workspace. The endpoint verifies the user has read permissions on the
        query, but _not_ on the tables returned.
        """
        return await self._client.request_async(
            "GET",
            self._api,
            "/api/v1/query/{queryId}/dependencies",
            path_params={
                "queryId": query_id,
            },
            query_params={
                "cursor": cursor,
                "limit": limit,
                "offset": offset,
            },
            timeout=timeout,
        )

    def get_tables_dependent_on_query(
        self,
        *,
        query_id: str,
        cursor: Optional[str] = None,
        limit: Optional[int] = 1000,
        offset: Optional[int] = None,
        timeout: Optional[float] = None,
    ) -> httpx.Response:
        """Retrieve a list of dependents

        Returns a list of all tables that use the query with provided ID as a
        datasource.
        """
        return self._client.request(
            "GET",
            self._api,
            "/api/v1/query/{queryId}/dependents",
            path_params={
                "queryId": query_id,
            },
            query_params={
                "cursor": cursor,
                "limit": limit,
                "offset": offset,
            },
            timeout=timeout,
        )

    async def get_tables_dependent_on_query_async(
        self,
        *,
        query_id: str,
        cursor: Optional[str] = None,
        limit: Optional[int] = 1000,
        offset: Optional[int] = None,
        timeout: Optional[float] = None,
    ) -> httpx.Response:
        """Retrieve a list of dependents (async)

        Returns a list of all tables that use the query with provided ID as a
        datasource.
        """
        return await self._client.request_async(
            "GET",
            self._api,
            "/api/v1/query/{queryId}/dependents",
            path_params={
                "queryId": query_id,
            },
            query_params={
                "cursor": cursor,
                "limit": limit,
                "offset": offset,
            },
            timeout=timeout,
        )

    def describe_query(
        self,
        *,
        query_id: str,
        timeout: Optional[float] = None,
    ) -> httpx.Response:
        """List the output columns of a query

        List the output columns of a query, including the column name (or
        alias), catalog, schema,
        table, type, type size in bytes, and a boolean indicating if the column
        is aliased.
        """
        return self._client.request(
            "POST",
            self._api,
            "/api/v1/query/{queryId}/describe",
            path_params={
                "queryId": query_id,
            },
            timeout=timeout,
        )

    async def describe_query_async(
        self,
        *,
        query_id: str,
        timeout: Optional[float] = None,
    ) -> httpx.Response:
        """List the output columns of a query (async)

        List the output columns of a query, including the column name (or
        alias), catalog, schema,
        table, type, type size in bytes, and a boolean indicating if the column
        is aliased.
        """
        return await self._client.request_async(
            "POST",
            self._api,
            "/api/v1/query/{queryId}/describe",
            path_params={
                "queryId": query_id,
            },
            timeout=timeout,
        )

    def run_query(
        self,
        *,
        body: QueryResultDto,
        timeout: Optional[float] = None,
    ) -> httpx.Response:
        """Execute a query

        Runs a query and immediately returns a query result entity, which has an
        ID that
        can be used to poll the status from the GET /queryresult method. A
        status of
        COMPLETED or ERROR indicates the query has completed.
        """
        return self._client.request(
            "POST",
            self._api,
            "/api/v1/queryresult",
            json_body=body,
            timeout=timeout,
        )

    async def run_query_async(
        self,
        *,
        body: QueryResultDto,
        timeout: Optional[float] = None,
    ) -> httpx.Response:
        """Execute a query (async)

        Runs a query and immediately returns a query result entity, which has an
        ID that
        can be used to poll the status from the GET /queryresult method. A
        status of
        COMPLETED or ERROR indicates the query has completed.
        """
        return await self._client.request_async(
            "POST",
            self._api,
            "/api/v1/queryresult",
            json_body=body,
            timeout=timeout,
        )

    def list_query_results(
        self,
        *,
        query_id: str,
        user_specific: Optional[bool] = False,
        cursor: Optional[str] = None,
        limit: Optional[str] = None,
        offset: Optional[int] = 0,
        timeout: Optional[float] = None,
    ) -> httpx.Response:
        """Retrieve a list of query results

        Returns a paged list of query results that match the provided query ID,
        or an empty
        list if no matching query is found.
        """
        return self._client.request(
            "GET",
            self._api,
            "/api/v1/queryresult",
            query_params={
                "queryId": query_id,
                "userSpecific": user_specific,
                "cursor": cursor,
                "limit": limit,
                "offset": offset,
            },
            timeout=timeout,
        )

    async def list_query_results_async(
        self,
        *,
        query_id: str,
        user_specific: Optional[bool] = False,
        cursor: Optional[str] = None,
        limit: Optional[str] = None,
        offset: Optional[int] = 0,
        timeout: Optional[float] = None,
    ) -> httpx.Response:
        """Retrieve a list of query results (async)

        Returns a paged list of query results that match the provided query ID,
        or an empty
        list if no matching query is found.
        """
        return await self._client.request_async(
            "GET",
            self._api,
            "/api/v1/queryresult",
            query_params={
                "queryId": query_id,
                "userSpecific": user_specific,
                "cursor": cursor,
                "limit": limit,
                "offset": offset,
            },
            timeout=timeout,
        )

    def cancel_query(
        self,
        *,
        query_result_id: str,
        timeout: Optional[float] = None,
    ) -> httpx.Response:
        """Cancel a running query

        Cancels a running query based on the provided result ID, and returns a
        cancelled
        result unless the query's already in a COMPLETED state.
        """
        return self._client.request(
            "DELETE",
            self._api,
            "/api/v1/queryresult/{queryResultId}",
            path_params={
                "queryResultId": query_result_id,
            },
            timeout=timeout,
        )

    async def cancel_query_async(
        self,
        *,
        query_result_id: str,
        timeout: Optional[float] = None,
    ) -> httpx.Response:
        """Cancel a running query (async)

        Cancels a running query based on the provided result ID, and returns a
        cancelled
        result unless the query's already in a COMPLETED state.
        """
        return await self._client.request_async(
            "DELETE",
            self._api,
            "/api/v1/queryresult/{queryResultId}",
            path_params={
                "queryResultId": query_result_id,
            },
            timeout=timeout,
        )

    def get_query_result(
        self,
        *,
        query_result_id: str,
        timeout: Optional[float] = None,
    ) -> httpx.Response:
        """Retrieve a single query result

        Returns a single query result that matches the provided ID, or a 404 if
        no such
        query result is found.
        """
        return self._client.request(
            "GET",
            self._api,
            "/api/v1/queryresult/{queryResultId}",
            path_params={
                "queryResultId": query_result_id,
            },
            timeout=timeout,
        )

    async def get_query_result_async(
        self,
        *,
        query_result_id: str,
        timeout: Optional[float] = None,
    ) -> httpx.Response:
        """Retrieve a single query result (async)

        Returns a single query result that matches the provided ID, or a 404 if
        no such
        query result is found.
        """
        return await self._client.request_async(
            "GET",
            self._api,
            "/api/v1/queryresult/{queryResultId}",
            path_params={
                "queryResultId": query_result_id,
            },
            timeout=timeout,
        )

    def download_query_result(
        self,
        *,
        query_result_id: str,
        timeout: Optional[float] = None,
    ) -> httpx.Response:
        """Download a query result

        Uses the Token Management API to create a token with the query result
        ID, which it
        then uses to download a CSV file of the query results.
        """
        return self._client.request(
            "GET",
            self._api,
            "/api/v1/queryresult/{queryResultId}/download",
            path_params={
                "queryResultId": query_result_id,
            },
            timeout=timeout,
        )

    async def download_query_result_async(
        self,
        *,
        query_result_id: str,
        timeout: Optional[float] = None,
    ) -> httpx.Response:
        """Download a query result (async)

        Uses the Token Management API to create a token with the query result
        ID, which it
        then uses to download a CSV file of the query results.
        """
        return await self._client.request_async(
            "GET",
            self._api,
            "/api/v1/queryresult/{queryResultId}/download",
            path_params={
                "queryResultId": query_result_id,
            },
            timeout=timeout,
        )

    def export_query_result_to_spreadsheets(
        self,
        *,
        query_result_id: str,
        body: ExportQueryResultDto,
        timeout: Optional[float] = None,
    ) -> httpx.Response:
        """Export query result to spreadsheets

        Exports a query result with the provided ID to Spreadsheets. To
        determine where to
        export the results, the request body should include a URL copied and
        pasted from the
        Spreadsheets UI. Returns a 404 if no matching query result is found.
        """
        return self._client.request(
            "POST",
            self._api,
            "/api/v1/queryresult/{queryResultId}/export",
            path_params={
                "queryResultId": query_result_id,
            },
            json_body=body,
            timeout=timeout,
        )

    async def export_query_result_to_spreadsheets_async(
        self,
        *,
        query_result_id: str,
        body: ExportQueryResultDto,
        timeout: Optional[float] = None,
    ) -> httpx.Response:
        """Export query result to spreadsheets (async)

        Exports a query result with the provided ID to Spreadsheets. To
        determine where to
        export the results, the request body should include a URL copied and
        pasted from the
        Spreadsheets UI. Returns a 404 if no matching query result is found.
        """
        return await self._client.request_async(
            "POST",
            self._api,
            "/api/v1/queryresult/{queryResultId}/export",
            path_params={
                "queryResultId": query_result_id,
            },
            json_body=body,
            timeout=timeout,
        )
