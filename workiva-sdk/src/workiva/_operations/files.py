"""Platform API â€” files namespace.

Auto-generated by codegen. Do not edit manually.
"""

from __future__ import annotations

from typing import Any, Optional

import httpx

from workiva._constants import _API
from workiva._operations._base import BaseNamespace
from workiva.models.platform import (
    File,
    FileCopy,
    FileExportById,
    FileImport,
    FileRestoreOptions,
    FileTrashOptions,
    ResourcePermissionsModification,
)


class Files(BaseNamespace):
    """Files operations."""

    _api: _API = _API.PLATFORM

    def get_files(
        self,
        *,
        filter_: Optional[str] = None,
        order_by: Optional[str] = None,
        maxpagesize: Optional[int] = 1000,
        next_: Optional[str] = None,
        timeout: Optional[float] = None,
    ) -> httpx.Response:
        """Retrieve a list of files

        Returns a paginated list of [files](ref:files#file).
        """
        return self._client.request(
            "GET",
            self._api,
            "/files",
            query_params={
                "$filter": filter_,
                "$orderBy": order_by,
                "$maxpagesize": maxpagesize,
                "$next": next_,
            },
            timeout=timeout,
        )

    async def get_files_async(
        self,
        *,
        filter_: Optional[str] = None,
        order_by: Optional[str] = None,
        maxpagesize: Optional[int] = 1000,
        next_: Optional[str] = None,
        timeout: Optional[float] = None,
    ) -> httpx.Response:
        """Retrieve a list of files (async)

        Returns a paginated list of [files](ref:files#file).
        """
        return await self._client.request_async(
            "GET",
            self._api,
            "/files",
            query_params={
                "$filter": filter_,
                "$orderBy": order_by,
                "$maxpagesize": maxpagesize,
                "$next": next_,
            },
            timeout=timeout,
        )

    def create_file(
        self,
        *,
        body: File,
        timeout: Optional[float] = None,
    ) -> httpx.Response:
        """Create a new file

        Creates a new [file](ref:files#file). Requires name and kind. kind
        must be one of `Document`, `Spreadsheet`, `Presentation`, or `Folder`
        and
        is case-sensitive. Use the `container` attribute to specify the
        container that houses the file, such
        as a folder. If empty, the root folder is the container. Files are
        created
        asynchronously and may not immediately be available on a subsequent
        `GET`.

        ### Examples
        #### Create a new document at the root of the file system
        ```json
        {
          "name": "2019 Year-End Summary",
          "kind": "Document"
        }
        ```

        #### Create a folder within an existing folder
        ```json
        {
          "name": "2019 Year-End Documents",
          "kind": "Folder",
          "container":
        "V0ZFYXRhSW50aXR5IkZvbGRlcjoxSkFGOTZGRjiENDk1Qzk4RjQ4OTgzN0M6ODdDNjZENi"
        }
        ```
        """
        return self._client.request(
            "POST",
            self._api,
            "/files",
            json_body=body,
            timeout=timeout,
        )

    async def create_file_async(
        self,
        *,
        body: File,
        timeout: Optional[float] = None,
    ) -> httpx.Response:
        """Create a new file (async)

        Creates a new [file](ref:files#file). Requires name and kind. kind
        must be one of `Document`, `Spreadsheet`, `Presentation`, or `Folder`
        and
        is case-sensitive. Use the `container` attribute to specify the
        container that houses the file, such
        as a folder. If empty, the root folder is the container. Files are
        created
        asynchronously and may not immediately be available on a subsequent
        `GET`.

        ### Examples
        #### Create a new document at the root of the file system
        ```json
        {
          "name": "2019 Year-End Summary",
          "kind": "Document"
        }
        ```

        #### Create a folder within an existing folder
        ```json
        {
          "name": "2019 Year-End Documents",
          "kind": "Folder",
          "container":
        "V0ZFYXRhSW50aXR5IkZvbGRlcjoxSkFGOTZGRjiENDk1Qzk4RjQ4OTgzN0M6ODdDNjZENi"
        }
        ```
        """
        return await self._client.request_async(
            "POST",
            self._api,
            "/files",
            json_body=body,
            timeout=timeout,
        )

    def import_file(
        self,
        *,
        body: FileImport,
        timeout: Optional[float] = None,
    ) -> httpx.Response:
        """Initiate a file import

        Import a file for conversion to a Workiva equivalent. This is a long
        running operation.
        Response includes an `uploadUrl` which indicates where to upload the
        file for import. To upload the file, perform a PUT against the
        `uploadUrl` with the same authentication credentials and flow as the
        import request. For more details, see [Authentication
        documentation](ref:authentication).
        """
        return self._client.request(
            "POST",
            self._api,
            "/files/import",
            json_body=body,
            timeout=timeout,
        )

    async def import_file_async(
        self,
        *,
        body: FileImport,
        timeout: Optional[float] = None,
    ) -> httpx.Response:
        """Initiate a file import (async)

        Import a file for conversion to a Workiva equivalent. This is a long
        running operation.
        Response includes an `uploadUrl` which indicates where to upload the
        file for import. To upload the file, perform a PUT against the
        `uploadUrl` with the same authentication credentials and flow as the
        import request. For more details, see [Authentication
        documentation](ref:authentication).
        """
        return await self._client.request_async(
            "POST",
            self._api,
            "/files/import",
            json_body=body,
            timeout=timeout,
        )

    def get_trashed_files(
        self,
        *,
        maxpagesize: Optional[int] = 1000,
        next_: Optional[str] = None,
        timeout: Optional[float] = None,
    ) -> httpx.Response:
        """Retrieve a list of trashed files

        Returns a paginated list of files that have been trashed.
        """
        return self._client.request(
            "GET",
            self._api,
            "/files/trash",
            query_params={
                "$maxpagesize": maxpagesize,
                "$next": next_,
            },
            timeout=timeout,
        )

    async def get_trashed_files_async(
        self,
        *,
        maxpagesize: Optional[int] = 1000,
        next_: Optional[str] = None,
        timeout: Optional[float] = None,
    ) -> httpx.Response:
        """Retrieve a list of trashed files (async)

        Returns a paginated list of files that have been trashed.
        """
        return await self._client.request_async(
            "GET",
            self._api,
            "/files/trash",
            query_params={
                "$maxpagesize": maxpagesize,
                "$next": next_,
            },
            timeout=timeout,
        )

    def get_file_by_id(
        self,
        *,
        file_id: str,
        timeout: Optional[float] = None,
    ) -> httpx.Response:
        """Retrieve a single file

        Retrieves a [file](ref:files#file) given its ID
        """
        return self._client.request(
            "GET",
            self._api,
            "/files/{fileId}",
            path_params={
                "fileId": file_id,
            },
            timeout=timeout,
        )

    async def get_file_by_id_async(
        self,
        *,
        file_id: str,
        timeout: Optional[float] = None,
    ) -> httpx.Response:
        """Retrieve a single file (async)

        Retrieves a [file](ref:files#file) given its ID
        """
        return await self._client.request_async(
            "GET",
            self._api,
            "/files/{fileId}",
            path_params={
                "fileId": file_id,
            },
            timeout=timeout,
        )

    def partially_update_file_by_id(
        self,
        *,
        file_id: str,
        body: list[Any],
        timeout: Optional[float] = None,
    ) -> httpx.Response:
        """Partially update a single file

        Partially updates the properties of a [file](ref:files#file). Only one
        property may be updated at a time.
        Updates are applied asynchronously and may not immediately be reflected
        on a subsequent `GET`.
        ### Options
        |Path|PATCH Operations Supported|
        |---|---|
        |`/container`|`replace`|
        |`/name`|`replace`|
        """
        return self._client.request(
            "PATCH",
            self._api,
            "/files/{fileId}",
            path_params={
                "fileId": file_id,
            },
            json_body=body,
            timeout=timeout,
        )

    async def partially_update_file_by_id_async(
        self,
        *,
        file_id: str,
        body: list[Any],
        timeout: Optional[float] = None,
    ) -> httpx.Response:
        """Partially update a single file (async)

        Partially updates the properties of a [file](ref:files#file). Only one
        property may be updated at a time.
        Updates are applied asynchronously and may not immediately be reflected
        on a subsequent `GET`.
        ### Options
        |Path|PATCH Operations Supported|
        |---|---|
        |`/container`|`replace`|
        |`/name`|`replace`|
        """
        return await self._client.request_async(
            "PATCH",
            self._api,
            "/files/{fileId}",
            path_params={
                "fileId": file_id,
            },
            json_body=body,
            timeout=timeout,
        )

    def copy_file(
        self,
        *,
        file_id: str,
        body: FileCopy,
        timeout: Optional[float] = None,
    ) -> httpx.Response:
        """Initiate a file copy

        Copy a file to a new location. This is a long running operation.
        Responses include a `Location` header, which indicates where to poll for
        copy results. For more details on long-running job polling, see
        [Operations endpoint](ref:getoperationbyid).
        Once the operation is completed, the `resourceUrl` field will be
        populated with a link to the   [Retrieve copy file results for a single
        operation endpoint](ref:getcopyfileresults)  to see the results of the
        File Copy Request.
        """
        return self._client.request(
            "POST",
            self._api,
            "/files/{fileId}/copy",
            path_params={
                "fileId": file_id,
            },
            json_body=body,
            timeout=timeout,
        )

    async def copy_file_async(
        self,
        *,
        file_id: str,
        body: FileCopy,
        timeout: Optional[float] = None,
    ) -> httpx.Response:
        """Initiate a file copy (async)

        Copy a file to a new location. This is a long running operation.
        Responses include a `Location` header, which indicates where to poll for
        copy results. For more details on long-running job polling, see
        [Operations endpoint](ref:getoperationbyid).
        Once the operation is completed, the `resourceUrl` field will be
        populated with a link to the   [Retrieve copy file results for a single
        operation endpoint](ref:getcopyfileresults)  to see the results of the
        File Copy Request.
        """
        return await self._client.request_async(
            "POST",
            self._api,
            "/files/{fileId}/copy",
            path_params={
                "fileId": file_id,
            },
            json_body=body,
            timeout=timeout,
        )

    def export_file_by_id(
        self,
        *,
        file_id: str,
        body: FileExportById,
        timeout: Optional[float] = None,
    ) -> httpx.Response:
        """Initiate a file export by ID

        Export a file by its unique ID. This is a long running operation.
        Responses include a `Location` header, which indicates where to poll for
        export results. For  more details on long-running job polling, see
        [Operations endpoint](ref:getoperationbyid).
        When the export process is complete, the status of the Operation  will
        change to completed. The `resourceUrl` field of the operation will
        contain  the download url of the exported file. To download the file,
        perform a GET against  the `resourceUrl` with the same authentication
        credentials and flow as the export request.  For more details, see
        Authentication documentation.
        For more on Document, Spreadsheet, and Presentation export options, see
        the following:
        [Documents](https://developers.workiva.com/2026-01-01/platform-
        documentexport),
        [Spreadsheets](https://developers.workiva.com/2026-01-01/platform-
        spreadsheetexport), and
        [Presentations](https://developers.workiva.com/2026-01-01/platform-
        presentationexport).
        """
        return self._client.request(
            "POST",
            self._api,
            "/files/{fileId}/export",
            path_params={
                "fileId": file_id,
            },
            json_body=body,
            timeout=timeout,
        )

    async def export_file_by_id_async(
        self,
        *,
        file_id: str,
        body: FileExportById,
        timeout: Optional[float] = None,
    ) -> httpx.Response:
        """Initiate a file export by ID (async)

        Export a file by its unique ID. This is a long running operation.
        Responses include a `Location` header, which indicates where to poll for
        export results. For  more details on long-running job polling, see
        [Operations endpoint](ref:getoperationbyid).
        When the export process is complete, the status of the Operation  will
        change to completed. The `resourceUrl` field of the operation will
        contain  the download url of the exported file. To download the file,
        perform a GET against  the `resourceUrl` with the same authentication
        credentials and flow as the export request.  For more details, see
        Authentication documentation.
        For more on Document, Spreadsheet, and Presentation export options, see
        the following:
        [Documents](https://developers.workiva.com/2026-01-01/platform-
        documentexport),
        [Spreadsheets](https://developers.workiva.com/2026-01-01/platform-
        spreadsheetexport), and
        [Presentations](https://developers.workiva.com/2026-01-01/platform-
        presentationexport).
        """
        return await self._client.request_async(
            "POST",
            self._api,
            "/files/{fileId}/export",
            path_params={
                "fileId": file_id,
            },
            json_body=body,
            timeout=timeout,
        )

    def restore_file_by_id(
        self,
        *,
        file_id: str,
        body: FileRestoreOptions,
        timeout: Optional[float] = None,
    ) -> httpx.Response:
        """Initiate restoration of a single file

        Restores a file given its ID. If the file being restored is a Folder,
        its contents will be recursively restored.
        """
        return self._client.request(
            "POST",
            self._api,
            "/files/{fileId}/restore",
            path_params={
                "fileId": file_id,
            },
            json_body=body,
            timeout=timeout,
        )

    async def restore_file_by_id_async(
        self,
        *,
        file_id: str,
        body: FileRestoreOptions,
        timeout: Optional[float] = None,
    ) -> httpx.Response:
        """Initiate restoration of a single file (async)

        Restores a file given its ID. If the file being restored is a Folder,
        its contents will be recursively restored.
        """
        return await self._client.request_async(
            "POST",
            self._api,
            "/files/{fileId}/restore",
            path_params={
                "fileId": file_id,
            },
            json_body=body,
            timeout=timeout,
        )

    def trash_file_by_id(
        self,
        *,
        file_id: str,
        body: FileTrashOptions,
        timeout: Optional[float] = None,
    ) -> httpx.Response:
        """Initiate trash of a single file

        Trashes a file given its ID. If the file being trashed is a Folder, its
        contents will be recursively trashed.
        """
        return self._client.request(
            "POST",
            self._api,
            "/files/{fileId}/trash",
            path_params={
                "fileId": file_id,
            },
            json_body=body,
            timeout=timeout,
        )

    async def trash_file_by_id_async(
        self,
        *,
        file_id: str,
        body: FileTrashOptions,
        timeout: Optional[float] = None,
    ) -> httpx.Response:
        """Initiate trash of a single file (async)

        Trashes a file given its ID. If the file being trashed is a Folder, its
        contents will be recursively trashed.
        """
        return await self._client.request_async(
            "POST",
            self._api,
            "/files/{fileId}/trash",
            path_params={
                "fileId": file_id,
            },
            json_body=body,
            timeout=timeout,
        )

    def get_file_permissions(
        self,
        *,
        file_id: str,
        filter_: Optional[str] = None,
        maxpagesize: Optional[int] = 1000,
        next_: Optional[str] = None,
        timeout: Optional[float] = None,
    ) -> httpx.Response:
        """Retrieve permissions for a file

        Retrieves a paginated list of permissions for a given file
        """
        return self._client.request(
            "GET",
            self._api,
            "/files/{fileId}/permissions",
            path_params={
                "fileId": file_id,
            },
            query_params={
                "$filter": filter_,
                "$maxpagesize": maxpagesize,
                "$next": next_,
            },
            timeout=timeout,
        )

    async def get_file_permissions_async(
        self,
        *,
        file_id: str,
        filter_: Optional[str] = None,
        maxpagesize: Optional[int] = 1000,
        next_: Optional[str] = None,
        timeout: Optional[float] = None,
    ) -> httpx.Response:
        """Retrieve permissions for a file (async)

        Retrieves a paginated list of permissions for a given file
        """
        return await self._client.request_async(
            "GET",
            self._api,
            "/files/{fileId}/permissions",
            path_params={
                "fileId": file_id,
            },
            query_params={
                "$filter": filter_,
                "$maxpagesize": maxpagesize,
                "$next": next_,
            },
            timeout=timeout,
        )

    def file_permissions_modification(
        self,
        *,
        file_id: str,
        body: ResourcePermissionsModification,
        timeout: Optional[float] = None,
    ) -> httpx.Response:
        """Modify permissions on a file

        Assign and/or revoke permissions on a file. If any modification in a
        request fails, all modifications on that request fail. <br /><br /> _To
        modify an existing permission, the existing permission must first be
        explicitly revoked. Then, the new permission needs to be assigned. This
        can be done in a single request by sending `toAssign` and `toRevoke` in
        the request body._
        """
        return self._client.request(
            "POST",
            self._api,
            "/files/{fileId}/permissions/modification",
            path_params={
                "fileId": file_id,
            },
            json_body=body,
            timeout=timeout,
        )

    async def file_permissions_modification_async(
        self,
        *,
        file_id: str,
        body: ResourcePermissionsModification,
        timeout: Optional[float] = None,
    ) -> httpx.Response:
        """Modify permissions on a file (async)

        Assign and/or revoke permissions on a file. If any modification in a
        request fails, all modifications on that request fail. <br /><br /> _To
        modify an existing permission, the existing permission must first be
        explicitly revoked. Then, the new permission needs to be assigned. This
        can be done in a single request by sending `toAssign` and `toRevoke` in
        the request body._
        """
        return await self._client.request_async(
            "POST",
            self._api,
            "/files/{fileId}/permissions/modification",
            path_params={
                "fileId": file_id,
            },
            json_body=body,
            timeout=timeout,
        )
