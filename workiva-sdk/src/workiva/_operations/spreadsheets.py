"""Platform API â€” spreadsheets namespace.

Auto-generated by codegen. Do not edit manually.
"""

from __future__ import annotations

from typing import Any, Optional

import httpx

from workiva._constants import _API
from workiva._operations._base import BaseNamespace


class Spreadsheets(BaseNamespace):
    """Spreadsheets operations."""

    _api: _API = _API.PLATFORM

    def get_spreadsheets(
        self,
        *,
        filter_: Optional[str] = None,
        order_by: Optional[str] = None,
        maxpagesize: Optional[int] = 1000,
        next_: Optional[str] = None,
        timeout: Optional[float] = None,
    ) -> httpx.Response:
        """Retrieve a list of spreadsheets

        Returns a paginated list of
        [spreadsheets](ref:spreadsheets#spreadsheet).
        """
        return self._client.request(
            "GET",
            self._api,
            "/spreadsheets",
            query_params={
                "$filter": filter_,
                "$orderBy": order_by,
                "$maxpagesize": maxpagesize,
                "$next": next_,
            },
            timeout=timeout,
        )

    async def get_spreadsheets_async(
        self,
        *,
        filter_: Optional[str] = None,
        order_by: Optional[str] = None,
        maxpagesize: Optional[int] = 1000,
        next_: Optional[str] = None,
        timeout: Optional[float] = None,
    ) -> httpx.Response:
        """Retrieve a list of spreadsheets (async)

        Returns a paginated list of
        [spreadsheets](ref:spreadsheets#spreadsheet).
        """
        return await self._client.request_async(
            "GET",
            self._api,
            "/spreadsheets",
            query_params={
                "$filter": filter_,
                "$orderBy": order_by,
                "$maxpagesize": maxpagesize,
                "$next": next_,
            },
            timeout=timeout,
        )

    def get_spreadsheet_by_id(
        self,
        *,
        spreadsheet_id: str,
        revision: Optional[str] = None,
        timeout: Optional[float] = None,
    ) -> httpx.Response:
        """Retrieve a single spreadsheet

        Retrieves a [spreadsheet](ref:spreadsheets#spreadsheet) given its ID.
        """
        return self._client.request(
            "GET",
            self._api,
            "/spreadsheets/{spreadsheetId}",
            path_params={
                "spreadsheetId": spreadsheet_id,
            },
            query_params={
                "$revision": revision,
            },
            timeout=timeout,
        )

    async def get_spreadsheet_by_id_async(
        self,
        *,
        spreadsheet_id: str,
        revision: Optional[str] = None,
        timeout: Optional[float] = None,
    ) -> httpx.Response:
        """Retrieve a single spreadsheet (async)

        Retrieves a [spreadsheet](ref:spreadsheets#spreadsheet) given its ID.
        """
        return await self._client.request_async(
            "GET",
            self._api,
            "/spreadsheets/{spreadsheetId}",
            path_params={
                "spreadsheetId": spreadsheet_id,
            },
            query_params={
                "$revision": revision,
            },
            timeout=timeout,
        )

    def partially_update_spreadsheet_by_id(
        self,
        *,
        spreadsheet_id: str,
        body: JSONPatchDocument,
        timeout: Optional[float] = None,
    ) -> httpx.Response:
        """Partially update a single spreadsheet

        Updates the properties of a [spreadsheet](ref:spreadsheets#spreadsheet).

        This is a long running operation. Responses include a `Location` header,
        which indicates where to poll for results. For more details on long-
        running job polling,
        see [Operations endpoint](ref:getoperationbyid).

        ### Options
        | Path                              | PATCH Operations Supported
        |
        |-----------------------------------|-----------------------------------
        -|
        | `/customFields/<custom field id>` | `add`, `remove`, `replace`, `test`
        |
        | `/customFieldGroups`              | `add`, `remove`, `replace`, `test`
        |
        | `/sheetCustomFieldGroups`         | `add`, `remove`, `replace`, `test`
        |
        | `/lock`                           | `replace`
        |

        ### Examples

        #### Add a custom field value

        ```json
        [
          {
            "op": "add",
            "path": "/customFields/com.workiva.gsr.legal_entity",
            "value": "Workiva"
          }
        ]
        ```

        #### Remove a custom field value

        ```json
        [
          {
            "op": "remove",
            "path": "/customFields/com.workiva.gsr.legal_entity"
          }
        ]
        ```

        #### Replace a custom field value

        ```json
        [
          {
            "op": "replace",
            "path": "/customFields/com.workiva.gsr.legal_entity",
            "value": "Workiva, Inc."
          }
        ]
        ```

        #### Verifying customFieldGroup is empty before replacing the list

        ```json
        [
          {
            "op": "test",
            "path": "/customFieldGroups",
            "value": []
          },
          {
            "op": "replace",
            "path": "/customFieldGroups",
            "value": ["gsr.reporting"]
          }
        ]
        ```

        #### Adding a customFieldGroup to the end of a list

        ```json
        [
          {
            "op": "add",
            "path": "/customFieldGroups/-",
            "value": "gsr.reporting"
          }
        ]
        ```
        """
        return self._client.request(
            "PATCH",
            self._api,
            "/spreadsheets/{spreadsheetId}",
            path_params={
                "spreadsheetId": spreadsheet_id,
            },
            json_body=body,
            timeout=timeout,
        )

    async def partially_update_spreadsheet_by_id_async(
        self,
        *,
        spreadsheet_id: str,
        body: JSONPatchDocument,
        timeout: Optional[float] = None,
    ) -> httpx.Response:
        """Partially update a single spreadsheet (async)

        Updates the properties of a [spreadsheet](ref:spreadsheets#spreadsheet).

        This is a long running operation. Responses include a `Location` header,
        which indicates where to poll for results. For more details on long-
        running job polling,
        see [Operations endpoint](ref:getoperationbyid).

        ### Options
        | Path                              | PATCH Operations Supported
        |
        |-----------------------------------|-----------------------------------
        -|
        | `/customFields/<custom field id>` | `add`, `remove`, `replace`, `test`
        |
        | `/customFieldGroups`              | `add`, `remove`, `replace`, `test`
        |
        | `/sheetCustomFieldGroups`         | `add`, `remove`, `replace`, `test`
        |
        | `/lock`                           | `replace`
        |

        ### Examples

        #### Add a custom field value

        ```json
        [
          {
            "op": "add",
            "path": "/customFields/com.workiva.gsr.legal_entity",
            "value": "Workiva"
          }
        ]
        ```

        #### Remove a custom field value

        ```json
        [
          {
            "op": "remove",
            "path": "/customFields/com.workiva.gsr.legal_entity"
          }
        ]
        ```

        #### Replace a custom field value

        ```json
        [
          {
            "op": "replace",
            "path": "/customFields/com.workiva.gsr.legal_entity",
            "value": "Workiva, Inc."
          }
        ]
        ```

        #### Verifying customFieldGroup is empty before replacing the list

        ```json
        [
          {
            "op": "test",
            "path": "/customFieldGroups",
            "value": []
          },
          {
            "op": "replace",
            "path": "/customFieldGroups",
            "value": ["gsr.reporting"]
          }
        ]
        ```

        #### Adding a customFieldGroup to the end of a list

        ```json
        [
          {
            "op": "add",
            "path": "/customFieldGroups/-",
            "value": "gsr.reporting"
          }
        ]
        ```
        """
        return await self._client.request_async(
            "PATCH",
            self._api,
            "/spreadsheets/{spreadsheetId}",
            path_params={
                "spreadsheetId": spreadsheet_id,
            },
            json_body=body,
            timeout=timeout,
        )

    def get_datasets(
        self,
        *,
        spreadsheet_id: str,
        timeout: Optional[float] = None,
    ) -> httpx.Response:
        """Retrieve a list of datasets

        Returns a list of [datasets](ref:spreadsheets#dataset). <br /><br /> Use
        this endpoint to identify any datasets that exist within a given
        [spreadsheet](ref:spreadsheets#spreadsheet), up to one per
        [sheet](ref:spreadsheets#sheet).
        """
        return self._client.request(
            "GET",
            self._api,
            "/spreadsheets/{spreadsheetId}/datasets",
            path_params={
                "spreadsheetId": spreadsheet_id,
            },
            timeout=timeout,
        )

    async def get_datasets_async(
        self,
        *,
        spreadsheet_id: str,
        timeout: Optional[float] = None,
    ) -> httpx.Response:
        """Retrieve a list of datasets (async)

        Returns a list of [datasets](ref:spreadsheets#dataset). <br /><br /> Use
        this endpoint to identify any datasets that exist within a given
        [spreadsheet](ref:spreadsheets#spreadsheet), up to one per
        [sheet](ref:spreadsheets#sheet).
        """
        return await self._client.request_async(
            "GET",
            self._api,
            "/spreadsheets/{spreadsheetId}/datasets",
            path_params={
                "spreadsheetId": spreadsheet_id,
            },
            timeout=timeout,
        )

    def upsert_datasets(
        self,
        *,
        spreadsheet_id: str,
        body: Datasets,
        timeout: Optional[float] = None,
    ) -> httpx.Response:
        """Bulk upsert of datasets

        Asynchronously upserts an array of [datasets](ref:spreadsheets#dataset)
        to a [spreadsheet](ref:spreadsheets#spreadsheet), given their
        properties. Each [sheet](ref:spreadsheets#sheet) can have only one
        dataset, and its range will always start with `A1`. <br /><br /> Bulk
        upsertion creates or updates datasets in sheets and performs any
        calculations after it completes. When complete, the dataset's range is
        locked through both the UI and endpoints that write values to a sheet.
        To change the values in a dataset, either upsert new values using this
        endpoint again, or delete the dataset. <br /><br /> If any dataset fails
        to upsert, no datasets upsert, and no changes commit. <br /><br /> Each
        dataset in the array requires `sheet` and `values`. Partial upserts are
        not supported. <br /><br /> Values may be strings, numbers, integers, or
        booleans. To indicate an empty cell, provide an empty string.
        """
        return self._client.request(
            "POST",
            self._api,
            "/spreadsheets/{spreadsheetId}/datasets/bulkUpsert",
            path_params={
                "spreadsheetId": spreadsheet_id,
            },
            json_body=body,
            timeout=timeout,
        )

    async def upsert_datasets_async(
        self,
        *,
        spreadsheet_id: str,
        body: Datasets,
        timeout: Optional[float] = None,
    ) -> httpx.Response:
        """Bulk upsert of datasets (async)

        Asynchronously upserts an array of [datasets](ref:spreadsheets#dataset)
        to a [spreadsheet](ref:spreadsheets#spreadsheet), given their
        properties. Each [sheet](ref:spreadsheets#sheet) can have only one
        dataset, and its range will always start with `A1`. <br /><br /> Bulk
        upsertion creates or updates datasets in sheets and performs any
        calculations after it completes. When complete, the dataset's range is
        locked through both the UI and endpoints that write values to a sheet.
        To change the values in a dataset, either upsert new values using this
        endpoint again, or delete the dataset. <br /><br /> If any dataset fails
        to upsert, no datasets upsert, and no changes commit. <br /><br /> Each
        dataset in the array requires `sheet` and `values`. Partial upserts are
        not supported. <br /><br /> Values may be strings, numbers, integers, or
        booleans. To indicate an empty cell, provide an empty string.
        """
        return await self._client.request_async(
            "POST",
            self._api,
            "/spreadsheets/{spreadsheetId}/datasets/bulkUpsert",
            path_params={
                "spreadsheetId": spreadsheet_id,
            },
            json_body=body,
            timeout=timeout,
        )

    def spreadsheet_export(
        self,
        *,
        spreadsheet_id: str,
        body: SpreadsheetExport,
        timeout: Optional[float] = None,
    ) -> httpx.Response:
        """Initiate a spreadsheet export

        Asynchronously exports a [spreadsheet](ref:spreadsheets#spreadsheet) as
        .XLSX, .PDF, or .CSV.

        Responses include a `Location` header, which indicates where to poll for
        export results. For more details on long-running job polling, see
        [Operations endpoint](ref:getoperationbyid). When the export completes,
        its status will be `completed`, and the response body includes a
        `resourceURL`. To download the exported file, perform a GET on the
        `resourceURL` with the same authentication credentials and flow as the
        export request. For more details, see [Authentication
        documentation](ref:authentication).

        Note: To export to .PDF, the spreadsheet can have no more than 250,000
        cells.
        """
        return self._client.request(
            "POST",
            self._api,
            "/spreadsheets/{spreadsheetId}/export",
            path_params={
                "spreadsheetId": spreadsheet_id,
            },
            json_body=body,
            timeout=timeout,
        )

    async def spreadsheet_export_async(
        self,
        *,
        spreadsheet_id: str,
        body: SpreadsheetExport,
        timeout: Optional[float] = None,
    ) -> httpx.Response:
        """Initiate a spreadsheet export (async)

        Asynchronously exports a [spreadsheet](ref:spreadsheets#spreadsheet) as
        .XLSX, .PDF, or .CSV.

        Responses include a `Location` header, which indicates where to poll for
        export results. For more details on long-running job polling, see
        [Operations endpoint](ref:getoperationbyid). When the export completes,
        its status will be `completed`, and the response body includes a
        `resourceURL`. To download the exported file, perform a GET on the
        `resourceURL` with the same authentication credentials and flow as the
        export request. For more details, see [Authentication
        documentation](ref:authentication).

        Note: To export to .PDF, the spreadsheet can have no more than 250,000
        cells.
        """
        return await self._client.request_async(
            "POST",
            self._api,
            "/spreadsheets/{spreadsheetId}/export",
            path_params={
                "spreadsheetId": spreadsheet_id,
            },
            json_body=body,
            timeout=timeout,
        )

    def spreadsheet_filters_reapplication(
        self,
        *,
        spreadsheet_id: str,
        body: SpreadsheetFiltersReapplication,
        timeout: Optional[float] = None,
    ) -> httpx.Response:
        """Reapply filters to the spreadsheet

        Performs a [`SpreadsheetFiltersReapplication`](ref:content#spreadsheetfi
        ltersreapplication) on the specified spreadsheet.
        This endpoint is used to refresh the spreadsheet's filters based on the
        latest state or configuration changes.
        The filters are reapplied in the context of the spreadsheet's current
        data state.

        This is a long-running operation. Responses include a `Location` header,
        which indicates where to poll for results.
        For more details on long-running job polling, see [Operations
        endpoint](ref:getoperationbyid).
        """
        return self._client.request(
            "POST",
            self._api,
            "/spreadsheets/{spreadsheetId}/filters/reapplication",
            path_params={
                "spreadsheetId": spreadsheet_id,
            },
            json_body=body,
            timeout=timeout,
        )

    async def spreadsheet_filters_reapplication_async(
        self,
        *,
        spreadsheet_id: str,
        body: SpreadsheetFiltersReapplication,
        timeout: Optional[float] = None,
    ) -> httpx.Response:
        """Reapply filters to the spreadsheet (async)

        Performs a [`SpreadsheetFiltersReapplication`](ref:content#spreadsheetfi
        ltersreapplication) on the specified spreadsheet.
        This endpoint is used to refresh the spreadsheet's filters based on the
        latest state or configuration changes.
        The filters are reapplied in the context of the spreadsheet's current
        data state.

        This is a long-running operation. Responses include a `Location` header,
        which indicates where to poll for results.
        For more details on long-running job polling, see [Operations
        endpoint](ref:getoperationbyid).
        """
        return await self._client.request_async(
            "POST",
            self._api,
            "/spreadsheets/{spreadsheetId}/filters/reapplication",
            path_params={
                "spreadsheetId": spreadsheet_id,
            },
            json_body=body,
            timeout=timeout,
        )

    def spreadsheet_links_publication(
        self,
        *,
        spreadsheet_id: str,
        body: LinksPublicationOptions,
        timeout: Optional[float] = None,
    ) -> httpx.Response:
        """Initiate publication of links in a spreadsheet

        Publishes the links in a spreadsheet - either all (as document owner) or
        only one's own. Content at the latest spreadsheet revision will be used
        for publish.
        The response also includes a `Location` header, which indicates where to
        poll for operation results. For more details on long-running job
        polling, see [Operations endpoint](ref:getoperationbyid).
        """
        return self._client.request(
            "POST",
            self._api,
            "/spreadsheets/{spreadsheetId}/links/publication",
            path_params={
                "spreadsheetId": spreadsheet_id,
            },
            json_body=body,
            timeout=timeout,
        )

    async def spreadsheet_links_publication_async(
        self,
        *,
        spreadsheet_id: str,
        body: LinksPublicationOptions,
        timeout: Optional[float] = None,
    ) -> httpx.Response:
        """Initiate publication of links in a spreadsheet (async)

        Publishes the links in a spreadsheet - either all (as document owner) or
        only one's own. Content at the latest spreadsheet revision will be used
        for publish.
        The response also includes a `Location` header, which indicates where to
        poll for operation results. For more details on long-running job
        polling, see [Operations endpoint](ref:getoperationbyid).
        """
        return await self._client.request_async(
            "POST",
            self._api,
            "/spreadsheets/{spreadsheetId}/links/publication",
            path_params={
                "spreadsheetId": spreadsheet_id,
            },
            json_body=body,
            timeout=timeout,
        )

    def get_spreadsheet_milestones(
        self,
        *,
        spreadsheet_id: str,
        next_: Optional[str] = None,
        timeout: Optional[float] = None,
    ) -> httpx.Response:
        """Retrieve a list of milestones for a spreadsheet

        Returns [MilestoneListResult](ref:milestones#milestonelistresult).
        """
        return self._client.request(
            "GET",
            self._api,
            "/spreadsheets/{spreadsheetId}/milestones",
            path_params={
                "spreadsheetId": spreadsheet_id,
            },
            query_params={
                "$next": next_,
            },
            timeout=timeout,
        )

    async def get_spreadsheet_milestones_async(
        self,
        *,
        spreadsheet_id: str,
        next_: Optional[str] = None,
        timeout: Optional[float] = None,
    ) -> httpx.Response:
        """Retrieve a list of milestones for a spreadsheet (async)

        Returns [MilestoneListResult](ref:milestones#milestonelistresult).
        """
        return await self._client.request_async(
            "GET",
            self._api,
            "/spreadsheets/{spreadsheetId}/milestones",
            path_params={
                "spreadsheetId": spreadsheet_id,
            },
            query_params={
                "$next": next_,
            },
            timeout=timeout,
        )

    def get_spreadsheet_permissions(
        self,
        *,
        spreadsheet_id: str,
        filter_: Optional[str] = None,
        maxpagesize: Optional[int] = 1000,
        next_: Optional[str] = None,
        timeout: Optional[float] = None,
    ) -> httpx.Response:
        """Retrieve permissions for a spreadsheet

        Retrieves a paginated list of permissions for a given spreadsheet
        """
        return self._client.request(
            "GET",
            self._api,
            "/spreadsheets/{spreadsheetId}/permissions",
            path_params={
                "spreadsheetId": spreadsheet_id,
            },
            query_params={
                "$filter": filter_,
                "$maxpagesize": maxpagesize,
                "$next": next_,
            },
            timeout=timeout,
        )

    async def get_spreadsheet_permissions_async(
        self,
        *,
        spreadsheet_id: str,
        filter_: Optional[str] = None,
        maxpagesize: Optional[int] = 1000,
        next_: Optional[str] = None,
        timeout: Optional[float] = None,
    ) -> httpx.Response:
        """Retrieve permissions for a spreadsheet (async)

        Retrieves a paginated list of permissions for a given spreadsheet
        """
        return await self._client.request_async(
            "GET",
            self._api,
            "/spreadsheets/{spreadsheetId}/permissions",
            path_params={
                "spreadsheetId": spreadsheet_id,
            },
            query_params={
                "$filter": filter_,
                "$maxpagesize": maxpagesize,
                "$next": next_,
            },
            timeout=timeout,
        )

    def spreadsheet_permissions_modification(
        self,
        *,
        spreadsheet_id: str,
        body: ResourcePermissionsModification,
        timeout: Optional[float] = None,
    ) -> httpx.Response:
        """Modify permissions on a spreadsheet

        Assign and/or revoke permissions on a spreadsheet. If any modification
        in a request fails, all modifications on that request fail. <br /><br />
        _To modify an existing permission, the existing permission must first be
        explicitly revoked. Then, the new permission needs to be assigned. This
        can be done in a single request by sending `toAssign` and `toRevoke` in
        the request body._
        """
        return self._client.request(
            "POST",
            self._api,
            "/spreadsheets/{spreadsheetId}/permissions/modification",
            path_params={
                "spreadsheetId": spreadsheet_id,
            },
            json_body=body,
            timeout=timeout,
        )

    async def spreadsheet_permissions_modification_async(
        self,
        *,
        spreadsheet_id: str,
        body: ResourcePermissionsModification,
        timeout: Optional[float] = None,
    ) -> httpx.Response:
        """Modify permissions on a spreadsheet (async)

        Assign and/or revoke permissions on a spreadsheet. If any modification
        in a request fails, all modifications on that request fail. <br /><br />
        _To modify an existing permission, the existing permission must first be
        explicitly revoked. Then, the new permission needs to be assigned. This
        can be done in a single request by sending `toAssign` and `toRevoke` in
        the request body._
        """
        return await self._client.request_async(
            "POST",
            self._api,
            "/spreadsheets/{spreadsheetId}/permissions/modification",
            path_params={
                "spreadsheetId": spreadsheet_id,
            },
            json_body=body,
            timeout=timeout,
        )

    def create_sheet(
        self,
        *,
        spreadsheet_id: str,
        body: Sheet,
        timeout: Optional[float] = None,
    ) -> httpx.Response:
        """Create a new sheet in a spreadsheet

        Creates a new [sheet](ref:spreadsheets#sheet) in a
        [spreadsheet](ref:spreadsheets#spreadsheet), given its properties. If
        the sheet name provided isn't unique, a number is appended to make it
        unique. By default, creates a top-level sheet in the top-most position.
        """
        return self._client.request(
            "POST",
            self._api,
            "/spreadsheets/{spreadsheetId}/sheets",
            path_params={
                "spreadsheetId": spreadsheet_id,
            },
            json_body=body,
            timeout=timeout,
        )

    async def create_sheet_async(
        self,
        *,
        spreadsheet_id: str,
        body: Sheet,
        timeout: Optional[float] = None,
    ) -> httpx.Response:
        """Create a new sheet in a spreadsheet (async)

        Creates a new [sheet](ref:spreadsheets#sheet) in a
        [spreadsheet](ref:spreadsheets#spreadsheet), given its properties. If
        the sheet name provided isn't unique, a number is appended to make it
        unique. By default, creates a top-level sheet in the top-most position.
        """
        return await self._client.request_async(
            "POST",
            self._api,
            "/spreadsheets/{spreadsheetId}/sheets",
            path_params={
                "spreadsheetId": spreadsheet_id,
            },
            json_body=body,
            timeout=timeout,
        )

    def get_sheets(
        self,
        *,
        spreadsheet_id: str,
        revision: Optional[str] = None,
        maxpagesize: Optional[int] = 1000,
        next_: Optional[str] = None,
        timeout: Optional[float] = None,
    ) -> httpx.Response:
        """Retrieve a list of sheets

        Returns a list of [sheets](ref:spreadsheets#sheet).
        """
        return self._client.request(
            "GET",
            self._api,
            "/spreadsheets/{spreadsheetId}/sheets",
            path_params={
                "spreadsheetId": spreadsheet_id,
            },
            query_params={
                "$revision": revision,
                "$maxpagesize": maxpagesize,
                "$next": next_,
            },
            timeout=timeout,
        )

    async def get_sheets_async(
        self,
        *,
        spreadsheet_id: str,
        revision: Optional[str] = None,
        maxpagesize: Optional[int] = 1000,
        next_: Optional[str] = None,
        timeout: Optional[float] = None,
    ) -> httpx.Response:
        """Retrieve a list of sheets (async)

        Returns a list of [sheets](ref:spreadsheets#sheet).
        """
        return await self._client.request_async(
            "GET",
            self._api,
            "/spreadsheets/{spreadsheetId}/sheets",
            path_params={
                "spreadsheetId": spreadsheet_id,
            },
            query_params={
                "$revision": revision,
                "$maxpagesize": maxpagesize,
                "$next": next_,
            },
            timeout=timeout,
        )

    def delete_sheet_by_id(
        self,
        *,
        spreadsheet_id: str,
        sheet_id: str,
        timeout: Optional[float] = None,
    ) -> httpx.Response:
        """Delete a single sheet

        Deletes a [sheet](ref:spreadsheets#sheet) given its ID.
        """
        return self._client.request(
            "DELETE",
            self._api,
            "/spreadsheets/{spreadsheetId}/sheets/{sheetId}",
            path_params={
                "spreadsheetId": spreadsheet_id,
                "sheetId": sheet_id,
            },
            timeout=timeout,
        )

    async def delete_sheet_by_id_async(
        self,
        *,
        spreadsheet_id: str,
        sheet_id: str,
        timeout: Optional[float] = None,
    ) -> httpx.Response:
        """Delete a single sheet (async)

        Deletes a [sheet](ref:spreadsheets#sheet) given its ID.
        """
        return await self._client.request_async(
            "DELETE",
            self._api,
            "/spreadsheets/{spreadsheetId}/sheets/{sheetId}",
            path_params={
                "spreadsheetId": spreadsheet_id,
                "sheetId": sheet_id,
            },
            timeout=timeout,
        )

    def get_sheet_by_id(
        self,
        *,
        spreadsheet_id: str,
        sheet_id: str,
        revision: Optional[str] = None,
        timeout: Optional[float] = None,
    ) -> httpx.Response:
        """Retrieve a single sheet

        Retrieves a [sheet](ref:spreadsheets#sheet) given its ID.
        """
        return self._client.request(
            "GET",
            self._api,
            "/spreadsheets/{spreadsheetId}/sheets/{sheetId}",
            path_params={
                "spreadsheetId": spreadsheet_id,
                "sheetId": sheet_id,
            },
            query_params={
                "$revision": revision,
            },
            timeout=timeout,
        )

    async def get_sheet_by_id_async(
        self,
        *,
        spreadsheet_id: str,
        sheet_id: str,
        revision: Optional[str] = None,
        timeout: Optional[float] = None,
    ) -> httpx.Response:
        """Retrieve a single sheet (async)

        Retrieves a [sheet](ref:spreadsheets#sheet) given its ID.
        """
        return await self._client.request_async(
            "GET",
            self._api,
            "/spreadsheets/{spreadsheetId}/sheets/{sheetId}",
            path_params={
                "spreadsheetId": spreadsheet_id,
                "sheetId": sheet_id,
            },
            query_params={
                "$revision": revision,
            },
            timeout=timeout,
        )

    def partially_update_sheet_by_id(
        self,
        *,
        spreadsheet_id: str,
        sheet_id: str,
        body: JSONPatchDocument,
        timeout: Optional[float] = None,
    ) -> httpx.Response:
        """Partially update a single sheet

        Updates the properties of a [sheet](ref:spreadsheets#sheet).

        This is a long running operation. Responses include a `Location` header,
        which indicates where to poll for results. For more details on long-
        running job polling,
        see [Operations endpoint](ref:getoperationbyid).

        ### Options
        | Path                              | PATCH Operations Supported
        |
        |-----------------------------------|-----------------------------------
        -|
        | `/name`                           | `replace`
        |
        | `/index`                          | `replace`
        |
        | `/parent`                         | `replace`
        |
        | `/customFields/<custom field id>` | `add`, `remove`, `replace`, `test`
        |
        | `/lock`                           | `replace`
        |

        ### Examples

        #### Lock an unlocked sheet

        ```json
        [
          {
            "op": "replace",
            "path": "/lock",
            "value": "lock"
          }
        ]
        ```

        #### Unlock a locked sheet

        ```json
        [
          {
            "op": "replace",
            "path": "/lock",
            "value": null
          }
        ]
        ```

        #### Update the name of a sheet

        ```json
        [
          {
            "op": "replace",
            "path": "/name",
            "value": "Q1 Draft"
          }
        ]
        ```

        #### Update the parent of a sheet (preserving its index)

        ```json
        [
          {
            "op": "replace",
            "path": "/parent",
            "value": {
              "id": "242a56d3cc0742c8abad0820bd318b23"
            }
          }
        ]
        ```

        #### Update the parent of a sheet (making it the first child)

        ```json
        [
          {
            "op": "replace",
            "path": "/parent",
            "value": {
              "id": "242a56d3cc0742c8abad0820bd318b23"
            }
          },
          {
            "op": "replace",
            "path": "/index",
            "value": 0
          }
        ]
        ```

        #### Add a custom field value

        ```json
        [
          {
            "op": "add",
            "path": "/customFields/com.workiva.gsr.legal_entity",
            "value": "Workiva"
          }
        ]
        ```

        #### Remove a custom field value

        ```json
        [
          {
            "op": "remove",
            "path": "/customFields/com.workiva.gsr.legal_entity"
          }
        ]
        ```

        #### Replace a custom field value

        ```json
        [
          {
            "op": "replace",
            "path": "/customFields/com.workiva.gsr.legal_entity",
            "value": "Workiva, Inc."
          }
        ]
        ```
        """
        return self._client.request(
            "PATCH",
            self._api,
            "/spreadsheets/{spreadsheetId}/sheets/{sheetId}",
            path_params={
                "spreadsheetId": spreadsheet_id,
                "sheetId": sheet_id,
            },
            json_body=body,
            timeout=timeout,
        )

    async def partially_update_sheet_by_id_async(
        self,
        *,
        spreadsheet_id: str,
        sheet_id: str,
        body: JSONPatchDocument,
        timeout: Optional[float] = None,
    ) -> httpx.Response:
        """Partially update a single sheet (async)

        Updates the properties of a [sheet](ref:spreadsheets#sheet).

        This is a long running operation. Responses include a `Location` header,
        which indicates where to poll for results. For more details on long-
        running job polling,
        see [Operations endpoint](ref:getoperationbyid).

        ### Options
        | Path                              | PATCH Operations Supported
        |
        |-----------------------------------|-----------------------------------
        -|
        | `/name`                           | `replace`
        |
        | `/index`                          | `replace`
        |
        | `/parent`                         | `replace`
        |
        | `/customFields/<custom field id>` | `add`, `remove`, `replace`, `test`
        |
        | `/lock`                           | `replace`
        |

        ### Examples

        #### Lock an unlocked sheet

        ```json
        [
          {
            "op": "replace",
            "path": "/lock",
            "value": "lock"
          }
        ]
        ```

        #### Unlock a locked sheet

        ```json
        [
          {
            "op": "replace",
            "path": "/lock",
            "value": null
          }
        ]
        ```

        #### Update the name of a sheet

        ```json
        [
          {
            "op": "replace",
            "path": "/name",
            "value": "Q1 Draft"
          }
        ]
        ```

        #### Update the parent of a sheet (preserving its index)

        ```json
        [
          {
            "op": "replace",
            "path": "/parent",
            "value": {
              "id": "242a56d3cc0742c8abad0820bd318b23"
            }
          }
        ]
        ```

        #### Update the parent of a sheet (making it the first child)

        ```json
        [
          {
            "op": "replace",
            "path": "/parent",
            "value": {
              "id": "242a56d3cc0742c8abad0820bd318b23"
            }
          },
          {
            "op": "replace",
            "path": "/index",
            "value": 0
          }
        ]
        ```

        #### Add a custom field value

        ```json
        [
          {
            "op": "add",
            "path": "/customFields/com.workiva.gsr.legal_entity",
            "value": "Workiva"
          }
        ]
        ```

        #### Remove a custom field value

        ```json
        [
          {
            "op": "remove",
            "path": "/customFields/com.workiva.gsr.legal_entity"
          }
        ]
        ```

        #### Replace a custom field value

        ```json
        [
          {
            "op": "replace",
            "path": "/customFields/com.workiva.gsr.legal_entity",
            "value": "Workiva, Inc."
          }
        ]
        ```
        """
        return await self._client.request_async(
            "PATCH",
            self._api,
            "/spreadsheets/{spreadsheetId}/sheets/{sheetId}",
            path_params={
                "spreadsheetId": spreadsheet_id,
                "sheetId": sheet_id,
            },
            json_body=body,
            timeout=timeout,
        )

    def copy_sheet(
        self,
        *,
        spreadsheet_id: str,
        sheet_id: str,
        body: SheetCopy,
        timeout: Optional[float] = None,
    ) -> httpx.Response:
        """Copy sheet

        Asynchronously copies a [sheet](ref:spreadsheets#sheet) given details
        about the copy's destination within the same or another spreadsheet.
        Options are specified using a [SheetCopy](ref:spreadsheets#sheetcopy)
        object.

        This endpoint copies a sheet's content, but does not copy labels,
        comments, or tasks. It will copy over most formatting, however it does
        not copy user-defined style guides across spreadsheets. So if the source
        sheet has  formatting that depends on a user-defined style guide, that
        formatting will be lost when copying to a new spreadsheet.

        Unless otherwise specified, the copy appears at the top level of its
        destination spreadsheet, with an index of 0, and with the same name as
        the original sheet.
        """
        return self._client.request(
            "POST",
            self._api,
            "/spreadsheets/{spreadsheetId}/sheets/{sheetId}/copy",
            path_params={
                "spreadsheetId": spreadsheet_id,
                "sheetId": sheet_id,
            },
            json_body=body,
            timeout=timeout,
        )

    async def copy_sheet_async(
        self,
        *,
        spreadsheet_id: str,
        sheet_id: str,
        body: SheetCopy,
        timeout: Optional[float] = None,
    ) -> httpx.Response:
        """Copy sheet (async)

        Asynchronously copies a [sheet](ref:spreadsheets#sheet) given details
        about the copy's destination within the same or another spreadsheet.
        Options are specified using a [SheetCopy](ref:spreadsheets#sheetcopy)
        object.

        This endpoint copies a sheet's content, but does not copy labels,
        comments, or tasks. It will copy over most formatting, however it does
        not copy user-defined style guides across spreadsheets. So if the source
        sheet has  formatting that depends on a user-defined style guide, that
        formatting will be lost when copying to a new spreadsheet.

        Unless otherwise specified, the copy appears at the top level of its
        destination spreadsheet, with an index of 0, and with the same name as
        the original sheet.
        """
        return await self._client.request_async(
            "POST",
            self._api,
            "/spreadsheets/{spreadsheetId}/sheets/{sheetId}/copy",
            path_params={
                "spreadsheetId": spreadsheet_id,
                "sheetId": sheet_id,
            },
            json_body=body,
            timeout=timeout,
        )

    def delete_dataset_by_sheet_id(
        self,
        *,
        spreadsheet_id: str,
        sheet_id: str,
        deletevalues: Optional[bool] = False,
        timeout: Optional[float] = None,
    ) -> httpx.Response:
        """Delete a single dataset

        Deletes the [dataset](ref:spreadsheets#dataset) for the specified
        [sheet](ref:spreadsheets#sheet). <br /><br /> When you delete a dataset,
        you can select whether to leave its associated values in place. To
        delete its values, pass `true` for query parameter `$deletevalues`
        (default is `false`).
        """
        return self._client.request(
            "DELETE",
            self._api,
            "/spreadsheets/{spreadsheetId}/sheets/{sheetId}/dataset",
            path_params={
                "spreadsheetId": spreadsheet_id,
                "sheetId": sheet_id,
            },
            query_params={
                "$deletevalues": deletevalues,
            },
            timeout=timeout,
        )

    async def delete_dataset_by_sheet_id_async(
        self,
        *,
        spreadsheet_id: str,
        sheet_id: str,
        deletevalues: Optional[bool] = False,
        timeout: Optional[float] = None,
    ) -> httpx.Response:
        """Delete a single dataset (async)

        Deletes the [dataset](ref:spreadsheets#dataset) for the specified
        [sheet](ref:spreadsheets#sheet). <br /><br /> When you delete a dataset,
        you can select whether to leave its associated values in place. To
        delete its values, pass `true` for query parameter `$deletevalues`
        (default is `false`).
        """
        return await self._client.request_async(
            "DELETE",
            self._api,
            "/spreadsheets/{spreadsheetId}/sheets/{sheetId}/dataset",
            path_params={
                "spreadsheetId": spreadsheet_id,
                "sheetId": sheet_id,
            },
            query_params={
                "$deletevalues": deletevalues,
            },
            timeout=timeout,
        )

    def get_sheet_permissions(
        self,
        *,
        spreadsheet_id: str,
        sheet_id: str,
        filter_: Optional[str] = None,
        maxpagesize: Optional[int] = 1000,
        next_: Optional[str] = None,
        timeout: Optional[float] = None,
    ) -> httpx.Response:
        """Retrieve permissions for a sheet in a spreadsheet

        Retrieves a paginated list of permissions for the given sheet in a
        spreadsheet
        """
        return self._client.request(
            "GET",
            self._api,
            "/spreadsheets/{spreadsheetId}/sheets/{sheetId}/permissions",
            path_params={
                "spreadsheetId": spreadsheet_id,
                "sheetId": sheet_id,
            },
            query_params={
                "$filter": filter_,
                "$maxpagesize": maxpagesize,
                "$next": next_,
            },
            timeout=timeout,
        )

    async def get_sheet_permissions_async(
        self,
        *,
        spreadsheet_id: str,
        sheet_id: str,
        filter_: Optional[str] = None,
        maxpagesize: Optional[int] = 1000,
        next_: Optional[str] = None,
        timeout: Optional[float] = None,
    ) -> httpx.Response:
        """Retrieve permissions for a sheet in a spreadsheet (async)

        Retrieves a paginated list of permissions for the given sheet in a
        spreadsheet
        """
        return await self._client.request_async(
            "GET",
            self._api,
            "/spreadsheets/{spreadsheetId}/sheets/{sheetId}/permissions",
            path_params={
                "spreadsheetId": spreadsheet_id,
                "sheetId": sheet_id,
            },
            query_params={
                "$filter": filter_,
                "$maxpagesize": maxpagesize,
                "$next": next_,
            },
            timeout=timeout,
        )

    def sheet_permissions_modification(
        self,
        *,
        spreadsheet_id: str,
        sheet_id: str,
        body: ResourcePermissionsModification,
        timeout: Optional[float] = None,
    ) -> httpx.Response:
        """Modify permissions on a given sheet of a spreadsheet

        Assign and/or revoke permissions on a sheet. If any modification in a
        request fails, all modifications on that request fail. <br /><br /> _To
        modify an existing permission, the existing permission must first be
        explicitly revoked. Then, the new permission needs to be assigned. This
        can be done in a single request by sending `toAssign` and `toRevoke` in
        the request body._
        """
        return self._client.request(
            "POST",
            self._api,
            "/spreadsheets/{spreadsheetId}/sheets/{sheetId}/permissions/modification",
            path_params={
                "spreadsheetId": spreadsheet_id,
                "sheetId": sheet_id,
            },
            json_body=body,
            timeout=timeout,
        )

    async def sheet_permissions_modification_async(
        self,
        *,
        spreadsheet_id: str,
        sheet_id: str,
        body: ResourcePermissionsModification,
        timeout: Optional[float] = None,
    ) -> httpx.Response:
        """Modify permissions on a given sheet of a spreadsheet (async)

        Assign and/or revoke permissions on a sheet. If any modification in a
        request fails, all modifications on that request fail. <br /><br /> _To
        modify an existing permission, the existing permission must first be
        explicitly revoked. Then, the new permission needs to be assigned. This
        can be done in a single request by sending `toAssign` and `toRevoke` in
        the request body._
        """
        return await self._client.request_async(
            "POST",
            self._api,
            "/spreadsheets/{spreadsheetId}/sheets/{sheetId}/permissions/modification",
            path_params={
                "spreadsheetId": spreadsheet_id,
                "sheetId": sheet_id,
            },
            json_body=body,
            timeout=timeout,
        )

    def get_sheet_data(
        self,
        *,
        spreadsheet_id: str,
        sheet_id: str,
        cellrange: Optional[str] = None,
        maxcellsperpage: Optional[int] = 50000,
        next_: Optional[str] = None,
        fields: Optional[str] = None,
        timeout: Optional[float] = None,
    ) -> httpx.Response:
        """Retrieve data from a sheet

        Retrieve data from a range in a sheet. Includes the value & formatting
        of cells, visibility of columns and cells, merged ranges, etc.
        Limit the results to particular fields by providing a comma-separated
        list of paths, rooted at the `data` object.
        Example: $fields=cells.calculatedValue,cells.formats.valueFormat <br
        /><br /> Note: This endpoint is rate-limited. You may experience rates
        as low as 600 requests per minute.  This rate is shared across your
        workspace. When you encounter a 429, examine the `Retry-After`  header
        and retry after that many seconds.
        """
        return self._client.request(
            "GET",
            self._api,
            "/spreadsheets/{spreadsheetId}/sheets/{sheetId}/sheetdata",
            path_params={
                "spreadsheetId": spreadsheet_id,
                "sheetId": sheet_id,
            },
            query_params={
                "$cellrange": cellrange,
                "$maxcellsperpage": maxcellsperpage,
                "$next": next_,
                "$fields": fields,
            },
            timeout=timeout,
        )

    async def get_sheet_data_async(
        self,
        *,
        spreadsheet_id: str,
        sheet_id: str,
        cellrange: Optional[str] = None,
        maxcellsperpage: Optional[int] = 50000,
        next_: Optional[str] = None,
        fields: Optional[str] = None,
        timeout: Optional[float] = None,
    ) -> httpx.Response:
        """Retrieve data from a sheet (async)

        Retrieve data from a range in a sheet. Includes the value & formatting
        of cells, visibility of columns and cells, merged ranges, etc.
        Limit the results to particular fields by providing a comma-separated
        list of paths, rooted at the `data` object.
        Example: $fields=cells.calculatedValue,cells.formats.valueFormat <br
        /><br /> Note: This endpoint is rate-limited. You may experience rates
        as low as 600 requests per minute.  This rate is shared across your
        workspace. When you encounter a 429, examine the `Retry-After`  header
        and retry after that many seconds.
        """
        return await self._client.request_async(
            "GET",
            self._api,
            "/spreadsheets/{spreadsheetId}/sheets/{sheetId}/sheetdata",
            path_params={
                "spreadsheetId": spreadsheet_id,
                "sheetId": sheet_id,
            },
            query_params={
                "$cellrange": cellrange,
                "$maxcellsperpage": maxcellsperpage,
                "$next": next_,
                "$fields": fields,
            },
            timeout=timeout,
        )

    def update_sheet(
        self,
        *,
        spreadsheet_id: str,
        sheet_id: str,
        body: SheetUpdate,
        timeout: Optional[float] = None,
    ) -> httpx.Response:
        """Update sheet content

        Asynchronously submits a [SheetUpdate](ref:spreadsheets#sheetupdate) to
        a [sheet](ref:spreadsheets#sheet). Each
        [SheetUpdate](ref:spreadsheets#sheetupdate) can have only one update
        field set per request. <br /><br /> Note: This endpoint is rate-limited.
        You may experience rates as low as 60 requests per minute.  This rate is
        shared across your workspace. When you encounter a 429, examine the
        `Retry-After`  header and retry after that many seconds.
        """
        return self._client.request(
            "POST",
            self._api,
            "/spreadsheets/{spreadsheetId}/sheets/{sheetId}/update",
            path_params={
                "spreadsheetId": spreadsheet_id,
                "sheetId": sheet_id,
            },
            json_body=body,
            timeout=timeout,
        )

    async def update_sheet_async(
        self,
        *,
        spreadsheet_id: str,
        sheet_id: str,
        body: SheetUpdate,
        timeout: Optional[float] = None,
    ) -> httpx.Response:
        """Update sheet content (async)

        Asynchronously submits a [SheetUpdate](ref:spreadsheets#sheetupdate) to
        a [sheet](ref:spreadsheets#sheet). Each
        [SheetUpdate](ref:spreadsheets#sheetupdate) can have only one update
        field set per request. <br /><br /> Note: This endpoint is rate-limited.
        You may experience rates as low as 60 requests per minute.  This rate is
        shared across your workspace. When you encounter a 429, examine the
        `Retry-After`  header and retry after that many seconds.
        """
        return await self._client.request_async(
            "POST",
            self._api,
            "/spreadsheets/{spreadsheetId}/sheets/{sheetId}/update",
            path_params={
                "spreadsheetId": spreadsheet_id,
                "sheetId": sheet_id,
            },
            json_body=body,
            timeout=timeout,
        )

    def update_values_by_range(
        self,
        *,
        spreadsheet_id: str,
        sheet_id: str,
        range: str,
        body: RangeValues,
        timeout: Optional[float] = None,
    ) -> httpx.Response:
        """Update values in a range

        Overwrites all values in a range with new values. The provided range
        must not exceed the specified range. If the provided range of values is
        *smaller* than the specified range, it clears all cells in the range
        **and** those not covered by the range values. Rows of values in the
        provided range must be of equal length. An empty range of values is
        valid and may be used to clear a range.
        To indicate that a cell's value shouldn't be replaced, use the special
        cell value `null`.
        When you add a value to a cell, it uses Ones scale regardless of the
        cell's scale formatting.
        """
        return self._client.request(
            "PUT",
            self._api,
            "/spreadsheets/{spreadsheetId}/sheets/{sheetId}/values/{range}",
            path_params={
                "spreadsheetId": spreadsheet_id,
                "sheetId": sheet_id,
                "range": range,
            },
            json_body=body,
            timeout=timeout,
        )

    async def update_values_by_range_async(
        self,
        *,
        spreadsheet_id: str,
        sheet_id: str,
        range: str,
        body: RangeValues,
        timeout: Optional[float] = None,
    ) -> httpx.Response:
        """Update values in a range (async)

        Overwrites all values in a range with new values. The provided range
        must not exceed the specified range. If the provided range of values is
        *smaller* than the specified range, it clears all cells in the range
        **and** those not covered by the range values. Rows of values in the
        provided range must be of equal length. An empty range of values is
        valid and may be used to clear a range.
        To indicate that a cell's value shouldn't be replaced, use the special
        cell value `null`.
        When you add a value to a cell, it uses Ones scale regardless of the
        cell's scale formatting.
        """
        return await self._client.request_async(
            "PUT",
            self._api,
            "/spreadsheets/{spreadsheetId}/sheets/{sheetId}/values/{range}",
            path_params={
                "spreadsheetId": spreadsheet_id,
                "sheetId": sheet_id,
                "range": range,
            },
            json_body=body,
            timeout=timeout,
        )

    def get_values_by_range(
        self,
        *,
        spreadsheet_id: str,
        sheet_id: str,
        range: str,
        maxcellsperpage: Optional[int] = 50000,
        next_: Optional[str] = None,
        valuestyle: Optional[str] = "calculated",
        timeout: Optional[float] = None,
    ) -> httpx.Response:
        """Retrieve a list of range values

        Returns the paginated values for a specified range.
        When you retrieve values from a range, Ones scale is used regardless of
        the cell's scale formatting.
        """
        return self._client.request(
            "GET",
            self._api,
            "/spreadsheets/{spreadsheetId}/sheets/{sheetId}/values/{range}",
            path_params={
                "spreadsheetId": spreadsheet_id,
                "sheetId": sheet_id,
                "range": range,
            },
            query_params={
                "$maxcellsperpage": maxcellsperpage,
                "$next": next_,
                "$valuestyle": valuestyle,
            },
            timeout=timeout,
        )

    async def get_values_by_range_async(
        self,
        *,
        spreadsheet_id: str,
        sheet_id: str,
        range: str,
        maxcellsperpage: Optional[int] = 50000,
        next_: Optional[str] = None,
        valuestyle: Optional[str] = "calculated",
        timeout: Optional[float] = None,
    ) -> httpx.Response:
        """Retrieve a list of range values (async)

        Returns the paginated values for a specified range.
        When you retrieve values from a range, Ones scale is used regardless of
        the cell's scale formatting.
        """
        return await self._client.request_async(
            "GET",
            self._api,
            "/spreadsheets/{spreadsheetId}/sheets/{sheetId}/values/{range}",
            path_params={
                "spreadsheetId": spreadsheet_id,
                "sheetId": sheet_id,
                "range": range,
            },
            query_params={
                "$maxcellsperpage": maxcellsperpage,
                "$next": next_,
                "$valuestyle": valuestyle,
            },
            timeout=timeout,
        )
