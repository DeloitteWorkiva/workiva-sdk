"""Platform API â€” content namespace.

Auto-generated by codegen. Do not edit manually.
"""

from __future__ import annotations

from typing import Any, Optional

import httpx

from workiva._constants import _API
from workiva._operations._base import BaseNamespace


class Content(BaseNamespace):
    """Content operations."""

    _api: _API = _API.PLATFORM

    def get_anchor_by_id(
        self,
        *,
        anchor_id: str,
        revision: Optional[str] = None,
        timeout: Optional[float] = None,
    ) -> httpx.Response:
        """Retrieve an anchor by ID

        Returns an [`Anchor`](ref:content#anchor) given its id.
        """
        return self._client.request(
            "GET",
            self._api,
            "/content/anchors/{anchorId}",
            path_params={
                "anchorId": anchor_id,
            },
            query_params={
                "$revision": revision,
            },
            timeout=timeout,
        )

    async def get_anchor_by_id_async(
        self,
        *,
        anchor_id: str,
        revision: Optional[str] = None,
        timeout: Optional[float] = None,
    ) -> httpx.Response:
        """Retrieve an anchor by ID (async)

        Returns an [`Anchor`](ref:content#anchor) given its id.
        """
        return await self._client.request_async(
            "GET",
            self._api,
            "/content/anchors/{anchorId}",
            path_params={
                "anchorId": anchor_id,
            },
            query_params={
                "$revision": revision,
            },
            timeout=timeout,
        )

    def get_destination_link_by_id(
        self,
        *,
        destination_link_id: str,
        revision: Optional[str] = None,
        timeout: Optional[float] = None,
    ) -> httpx.Response:
        """Retrieve a destination link by id

        Returns a [`DestinationLink`](ref:content#destinationlink) given its id
        """
        return self._client.request(
            "GET",
            self._api,
            "/content/destinationLinks/{destinationLinkId}",
            path_params={
                "destinationLinkId": destination_link_id,
            },
            query_params={
                "$revision": revision,
            },
            timeout=timeout,
        )

    async def get_destination_link_by_id_async(
        self,
        *,
        destination_link_id: str,
        revision: Optional[str] = None,
        timeout: Optional[float] = None,
    ) -> httpx.Response:
        """Retrieve a destination link by id (async)

        Returns a [`DestinationLink`](ref:content#destinationlink) given its id
        """
        return await self._client.request_async(
            "GET",
            self._api,
            "/content/destinationLinks/{destinationLinkId}",
            path_params={
                "destinationLinkId": destination_link_id,
            },
            query_params={
                "$revision": revision,
            },
            timeout=timeout,
        )

    def destination_link_source_conversion(
        self,
        *,
        destination_link_id: str,
        timeout: Optional[float] = None,
    ) -> httpx.Response:
        """Initiate a destination link conversion

        Converts a destination link into a source link. The previous source, if
        any, will be converted into a destination link.

        Responses include a `Location` header, which indicates where to poll for
        results. For more details on long-running
        job polling, see [Operations endpoint](ref:getoperationbyid). When the
        source conversion
        completes, its status will be `completed`, and the response body
        includes a `resourceURL`. For more details on the `resourceURL`
        see [operation results
        endpoint](ref:getdestinationlinksourceconversionresults).
        For more details, see [Authentication
        documentation](ref:authentication).
        """
        return self._client.request(
            "POST",
            self._api,
            "/content/destinationLinks/{destinationLinkId}/sourceConversion",
            path_params={
                "destinationLinkId": destination_link_id,
            },
            timeout=timeout,
        )

    async def destination_link_source_conversion_async(
        self,
        *,
        destination_link_id: str,
        timeout: Optional[float] = None,
    ) -> httpx.Response:
        """Initiate a destination link conversion (async)

        Converts a destination link into a source link. The previous source, if
        any, will be converted into a destination link.

        Responses include a `Location` header, which indicates where to poll for
        results. For more details on long-running
        job polling, see [Operations endpoint](ref:getoperationbyid). When the
        source conversion
        completes, its status will be `completed`, and the response body
        includes a `resourceURL`. For more details on the `resourceURL`
        see [operation results
        endpoint](ref:getdestinationlinksourceconversionresults).
        For more details, see [Authentication
        documentation](ref:authentication).
        """
        return await self._client.request_async(
            "POST",
            self._api,
            "/content/destinationLinks/{destinationLinkId}/sourceConversion",
            path_params={
                "destinationLinkId": destination_link_id,
            },
            timeout=timeout,
        )

    def get_drawing_elements_by_id(
        self,
        *,
        drawing_id: str,
        revision: Optional[str] = None,
        maxpagesize: Optional[int] = 1000,
        next_: Optional[str] = None,
        timeout: Optional[float] = None,
    ) -> httpx.Response:
        """Retrieve drawing elements by id

        Returns a
        [`DrawingElementListResult`](ref:content#drawingelementlistresult) given
        its id
        """
        return self._client.request(
            "GET",
            self._api,
            "/content/drawings/{drawingId}/elements",
            path_params={
                "drawingId": drawing_id,
            },
            query_params={
                "$revision": revision,
                "$maxpagesize": maxpagesize,
                "$next": next_,
            },
            timeout=timeout,
        )

    async def get_drawing_elements_by_id_async(
        self,
        *,
        drawing_id: str,
        revision: Optional[str] = None,
        maxpagesize: Optional[int] = 1000,
        next_: Optional[str] = None,
        timeout: Optional[float] = None,
    ) -> httpx.Response:
        """Retrieve drawing elements by id (async)

        Returns a
        [`DrawingElementListResult`](ref:content#drawingelementlistresult) given
        its id
        """
        return await self._client.request_async(
            "GET",
            self._api,
            "/content/drawings/{drawingId}/elements",
            path_params={
                "drawingId": drawing_id,
            },
            query_params={
                "$revision": revision,
                "$maxpagesize": maxpagesize,
                "$next": next_,
            },
            timeout=timeout,
        )

    def get_drawing_anchors(
        self,
        *,
        drawing_id: str,
        maxpagesize: Optional[int] = 1000,
        next_: Optional[str] = None,
        revision: Optional[str] = None,
        timeout: Optional[float] = None,
    ) -> httpx.Response:
        """Retrieve a list of drawing anchors

        Returns an [`AnchorsListResult`](ref:content#anchorslistresult) for a
        given drawingId.
        """
        return self._client.request(
            "GET",
            self._api,
            "/content/drawings/{drawingId}/anchors",
            path_params={
                "drawingId": drawing_id,
            },
            query_params={
                "$maxpagesize": maxpagesize,
                "$next": next_,
                "$revision": revision,
            },
            timeout=timeout,
        )

    async def get_drawing_anchors_async(
        self,
        *,
        drawing_id: str,
        maxpagesize: Optional[int] = 1000,
        next_: Optional[str] = None,
        revision: Optional[str] = None,
        timeout: Optional[float] = None,
    ) -> httpx.Response:
        """Retrieve a list of drawing anchors (async)

        Returns an [`AnchorsListResult`](ref:content#anchorslistresult) for a
        given drawingId.
        """
        return await self._client.request_async(
            "GET",
            self._api,
            "/content/drawings/{drawingId}/anchors",
            path_params={
                "drawingId": drawing_id,
            },
            query_params={
                "$maxpagesize": maxpagesize,
                "$next": next_,
                "$revision": revision,
            },
            timeout=timeout,
        )

    def get_drawing_anchor_by_id(
        self,
        *,
        drawing_id: str,
        anchor_id: str,
        revision: Optional[str] = None,
        timeout: Optional[float] = None,
    ) -> httpx.Response:
        """Retrieve a drawing anchor by ID

        Returns an [`Anchor`](ref:content#anchor) given its id.
        """
        return self._client.request(
            "GET",
            self._api,
            "/content/drawings/{drawingId}/anchors/{anchorId}",
            path_params={
                "drawingId": drawing_id,
                "anchorId": anchor_id,
            },
            query_params={
                "$revision": revision,
            },
            timeout=timeout,
        )

    async def get_drawing_anchor_by_id_async(
        self,
        *,
        drawing_id: str,
        anchor_id: str,
        revision: Optional[str] = None,
        timeout: Optional[float] = None,
    ) -> httpx.Response:
        """Retrieve a drawing anchor by ID (async)

        Returns an [`Anchor`](ref:content#anchor) given its id.
        """
        return await self._client.request_async(
            "GET",
            self._api,
            "/content/drawings/{drawingId}/anchors/{anchorId}",
            path_params={
                "drawingId": drawing_id,
                "anchorId": anchor_id,
            },
            query_params={
                "$revision": revision,
            },
            timeout=timeout,
        )

    def get_drawing_anchor_extensions(
        self,
        *,
        drawing_id: str,
        anchor_id: str,
        maxpagesize: Optional[int] = 1000,
        next_: Optional[str] = None,
        revision: Optional[str] = None,
        timeout: Optional[float] = None,
    ) -> httpx.Response:
        """Retrieve a list of drawing anchor extensions

        Returns a paginated list of
        [`AnchorExtensions`](ref:content#anchorextension) for a given anchorId.
        """
        return self._client.request(
            "GET",
            self._api,
            "/content/drawings/{drawingId}/anchors/{anchorId}/extensions",
            path_params={
                "drawingId": drawing_id,
                "anchorId": anchor_id,
            },
            query_params={
                "$maxpagesize": maxpagesize,
                "$next": next_,
                "$revision": revision,
            },
            timeout=timeout,
        )

    async def get_drawing_anchor_extensions_async(
        self,
        *,
        drawing_id: str,
        anchor_id: str,
        maxpagesize: Optional[int] = 1000,
        next_: Optional[str] = None,
        revision: Optional[str] = None,
        timeout: Optional[float] = None,
    ) -> httpx.Response:
        """Retrieve a list of drawing anchor extensions (async)

        Returns a paginated list of
        [`AnchorExtensions`](ref:content#anchorextension) for a given anchorId.
        """
        return await self._client.request_async(
            "GET",
            self._api,
            "/content/drawings/{drawingId}/anchors/{anchorId}/extensions",
            path_params={
                "drawingId": drawing_id,
                "anchorId": anchor_id,
            },
            query_params={
                "$maxpagesize": maxpagesize,
                "$next": next_,
                "$revision": revision,
            },
            timeout=timeout,
        )

    def image_upload(
        self,
        *,
        body: Optional[ImageUpload] = None,
        timeout: Optional[float] = None,
    ) -> httpx.Response:
        """Initiate upload of an image

        Retrieves a URL that can be used to upload an image, and an operationId
        to track the image upload progress. Once uploaded, the image can be
        inserted in content.

        Image uploads must conform to the following constraints:

        - An image must be uploaded once per usage in content.
        - Image uploads must complete within ten minutes.
        - The file size of the uploaded image must 75 MB or smaller.
        - The total number of pixels in the uploaded image must be 50 Megapixels
        or smaller.
        - The image must be inserted in content within 24 hours or it will be
        removed.

        Responses include an `uploadUrl` which indicates where to upload the
        image. To upload the file,
        perform a PUT against the `uploadUrl` with the same authentication
        credentials and flow as the import request.
        For more details, see [Authentication
        documentation](ref:authentication). The response will also include
        a `Location` header, which indicates where to poll for results. For more
        details on long-running job polling, see
        [Operations endpoint](ref:getoperationbyid). When the upload completes,
        its status will be
        `completed`, and the response body includes a `resourceURL`.
        """
        return self._client.request(
            "POST",
            self._api,
            "/content/images/upload",
            json_body=body,
            timeout=timeout,
        )

    async def image_upload_async(
        self,
        *,
        body: Optional[ImageUpload] = None,
        timeout: Optional[float] = None,
    ) -> httpx.Response:
        """Initiate upload of an image (async)

        Retrieves a URL that can be used to upload an image, and an operationId
        to track the image upload progress. Once uploaded, the image can be
        inserted in content.

        Image uploads must conform to the following constraints:

        - An image must be uploaded once per usage in content.
        - Image uploads must complete within ten minutes.
        - The file size of the uploaded image must 75 MB or smaller.
        - The total number of pixels in the uploaded image must be 50 Megapixels
        or smaller.
        - The image must be inserted in content within 24 hours or it will be
        removed.

        Responses include an `uploadUrl` which indicates where to upload the
        image. To upload the file,
        perform a PUT against the `uploadUrl` with the same authentication
        credentials and flow as the import request.
        For more details, see [Authentication
        documentation](ref:authentication). The response will also include
        a `Location` header, which indicates where to poll for results. For more
        details on long-running job polling, see
        [Operations endpoint](ref:getoperationbyid). When the upload completes,
        its status will be
        `completed`, and the response body includes a `resourceURL`.
        """
        return await self._client.request_async(
            "POST",
            self._api,
            "/content/images/upload",
            json_body=body,
            timeout=timeout,
        )

    def get_image_by_id(
        self,
        *,
        image_id: str,
        timeout: Optional[float] = None,
    ) -> httpx.Response:
        """Retrieve an image by id

        Returns a [`Image`](ref:content#image) given its id
        """
        return self._client.request(
            "GET",
            self._api,
            "/content/images/{imageId}",
            path_params={
                "imageId": image_id,
            },
            timeout=timeout,
        )

    async def get_image_by_id_async(
        self,
        *,
        image_id: str,
        timeout: Optional[float] = None,
    ) -> httpx.Response:
        """Retrieve an image by id (async)

        Returns a [`Image`](ref:content#image) given its id
        """
        return await self._client.request_async(
            "GET",
            self._api,
            "/content/images/{imageId}",
            path_params={
                "imageId": image_id,
            },
            timeout=timeout,
        )

    def get_rich_text_anchors(
        self,
        *,
        rich_text_id: str,
        maxpagesize: Optional[int] = 1000,
        next_: Optional[str] = None,
        revision: Optional[str] = None,
        timeout: Optional[float] = None,
    ) -> httpx.Response:
        """Retrieve a list of rich text anchors

        Returns an [`AnchorsListResult`](ref:content#anchorslistresult) for a
        given richTextId.
        """
        return self._client.request(
            "GET",
            self._api,
            "/content/richText/{richTextId}/anchors",
            path_params={
                "richTextId": rich_text_id,
            },
            query_params={
                "$maxpagesize": maxpagesize,
                "$next": next_,
                "$revision": revision,
            },
            timeout=timeout,
        )

    async def get_rich_text_anchors_async(
        self,
        *,
        rich_text_id: str,
        maxpagesize: Optional[int] = 1000,
        next_: Optional[str] = None,
        revision: Optional[str] = None,
        timeout: Optional[float] = None,
    ) -> httpx.Response:
        """Retrieve a list of rich text anchors (async)

        Returns an [`AnchorsListResult`](ref:content#anchorslistresult) for a
        given richTextId.
        """
        return await self._client.request_async(
            "GET",
            self._api,
            "/content/richText/{richTextId}/anchors",
            path_params={
                "richTextId": rich_text_id,
            },
            query_params={
                "$maxpagesize": maxpagesize,
                "$next": next_,
                "$revision": revision,
            },
            timeout=timeout,
        )

    def rich_text_anchor_creation(
        self,
        *,
        rich_text_id: str,
        body: RichTextAnchorCreation,
        timeout: Optional[float] = None,
    ) -> httpx.Response:
        """Initiate creation of a new rich text anchor

        Create a new [`Anchor`](ref:content#anchor) using a
        [`RichTextAnchorCreation`](ref:content#richtextanchorcreation) request.
        This is a long running operation.

        Responses include a `Location` header, which indicates where to poll for
        results. For more details on long-running job polling, see
        [Operations endpoint](ref:getoperationbyid).
        When the creation completes, its status will be `completed`, and the
        response
        body includes a `resourceURL`. To GET the new rich text anchor, perform
        a GET
        on the `resourceURL` with the same authentication credentials and flow
        as the
        initial request. For more details, see
        [Authentication documentation](ref:authentication).
        """
        return self._client.request(
            "POST",
            self._api,
            "/content/richText/{richTextId}/anchors/creation",
            path_params={
                "richTextId": rich_text_id,
            },
            json_body=body,
            timeout=timeout,
        )

    async def rich_text_anchor_creation_async(
        self,
        *,
        rich_text_id: str,
        body: RichTextAnchorCreation,
        timeout: Optional[float] = None,
    ) -> httpx.Response:
        """Initiate creation of a new rich text anchor (async)

        Create a new [`Anchor`](ref:content#anchor) using a
        [`RichTextAnchorCreation`](ref:content#richtextanchorcreation) request.
        This is a long running operation.

        Responses include a `Location` header, which indicates where to poll for
        results. For more details on long-running job polling, see
        [Operations endpoint](ref:getoperationbyid).
        When the creation completes, its status will be `completed`, and the
        response
        body includes a `resourceURL`. To GET the new rich text anchor, perform
        a GET
        on the `resourceURL` with the same authentication credentials and flow
        as the
        initial request. For more details, see
        [Authentication documentation](ref:authentication).
        """
        return await self._client.request_async(
            "POST",
            self._api,
            "/content/richText/{richTextId}/anchors/creation",
            path_params={
                "richTextId": rich_text_id,
            },
            json_body=body,
            timeout=timeout,
        )

    def get_rich_text_anchor_by_id(
        self,
        *,
        rich_text_id: str,
        anchor_id: str,
        revision: Optional[str] = None,
        timeout: Optional[float] = None,
    ) -> httpx.Response:
        """Retrieve a rich text anchor by id

        Returns an [`Anchor`](ref:content#anchor) given its id.
        """
        return self._client.request(
            "GET",
            self._api,
            "/content/richText/{richTextId}/anchors/{anchorId}",
            path_params={
                "richTextId": rich_text_id,
                "anchorId": anchor_id,
            },
            query_params={
                "$revision": revision,
            },
            timeout=timeout,
        )

    async def get_rich_text_anchor_by_id_async(
        self,
        *,
        rich_text_id: str,
        anchor_id: str,
        revision: Optional[str] = None,
        timeout: Optional[float] = None,
    ) -> httpx.Response:
        """Retrieve a rich text anchor by id (async)

        Returns an [`Anchor`](ref:content#anchor) given its id.
        """
        return await self._client.request_async(
            "GET",
            self._api,
            "/content/richText/{richTextId}/anchors/{anchorId}",
            path_params={
                "richTextId": rich_text_id,
                "anchorId": anchor_id,
            },
            query_params={
                "$revision": revision,
            },
            timeout=timeout,
        )

    def get_rich_text_anchor_extensions(
        self,
        *,
        rich_text_id: str,
        anchor_id: str,
        maxpagesize: Optional[int] = 1000,
        next_: Optional[str] = None,
        revision: Optional[str] = None,
        timeout: Optional[float] = None,
    ) -> httpx.Response:
        """Retrieve a list of rich text anchor extensions

        Returns a paginated list of
        [`AnchorExtensions`](ref:content#anchorextension) for a given anchorId.
        """
        return self._client.request(
            "GET",
            self._api,
            "/content/richText/{richTextId}/anchors/{anchorId}/extensions",
            path_params={
                "richTextId": rich_text_id,
                "anchorId": anchor_id,
            },
            query_params={
                "$maxpagesize": maxpagesize,
                "$next": next_,
                "$revision": revision,
            },
            timeout=timeout,
        )

    async def get_rich_text_anchor_extensions_async(
        self,
        *,
        rich_text_id: str,
        anchor_id: str,
        maxpagesize: Optional[int] = 1000,
        next_: Optional[str] = None,
        revision: Optional[str] = None,
        timeout: Optional[float] = None,
    ) -> httpx.Response:
        """Retrieve a list of rich text anchor extensions (async)

        Returns a paginated list of
        [`AnchorExtensions`](ref:content#anchorextension) for a given anchorId.
        """
        return await self._client.request_async(
            "GET",
            self._api,
            "/content/richText/{richTextId}/anchors/{anchorId}/extensions",
            path_params={
                "richTextId": rich_text_id,
                "anchorId": anchor_id,
            },
            query_params={
                "$maxpagesize": maxpagesize,
                "$next": next_,
                "$revision": revision,
            },
            timeout=timeout,
        )

    def rich_text_duplication_edit(
        self,
        *,
        rich_text_id: str,
        body: RichTextDuplicationEdit,
        timeout: Optional[float] = None,
    ) -> httpx.Response:
        """Initiate duplication edits to rich text

        Sends a [`RichTextDuplicationEdit`](ref:content#richtextduplicationedit)
        to perform on the rich text.
        The optional revision property can be used to identify a stable version
        of the text to use for selections. The latest revision is used if not
        specified.
        This is a long running operation. Responses include a `Location` header,
        which indicates where to poll for results. For more details on long-
        running job polling, see [Operations endpoint](ref:getoperationbyid).
        The `resourceUrl` field will be populated with a link to the [Rich Text
        Duplication Edit Results
        endpoint](ref:getrichtextduplicationeditresults) to retrieve the IDs of
        the new resources.
        """
        return self._client.request(
            "POST",
            self._api,
            "/content/richText/{richTextId}/duplication/edit",
            path_params={
                "richTextId": rich_text_id,
            },
            json_body=body,
            timeout=timeout,
        )

    async def rich_text_duplication_edit_async(
        self,
        *,
        rich_text_id: str,
        body: RichTextDuplicationEdit,
        timeout: Optional[float] = None,
    ) -> httpx.Response:
        """Initiate duplication edits to rich text (async)

        Sends a [`RichTextDuplicationEdit`](ref:content#richtextduplicationedit)
        to perform on the rich text.
        The optional revision property can be used to identify a stable version
        of the text to use for selections. The latest revision is used if not
        specified.
        This is a long running operation. Responses include a `Location` header,
        which indicates where to poll for results. For more details on long-
        running job polling, see [Operations endpoint](ref:getoperationbyid).
        The `resourceUrl` field will be populated with a link to the [Rich Text
        Duplication Edit Results
        endpoint](ref:getrichtextduplicationeditresults) to retrieve the IDs of
        the new resources.
        """
        return await self._client.request_async(
            "POST",
            self._api,
            "/content/richText/{richTextId}/duplication/edit",
            path_params={
                "richTextId": rich_text_id,
            },
            json_body=body,
            timeout=timeout,
        )

    def rich_text_batch_edit(
        self,
        *,
        rich_text_id: str,
        body: RichTextBatchEdit,
        timeout: Optional[float] = None,
    ) -> httpx.Response:
        """Initiate edits to rich text

        Sends a [`RichTextBatchEdit`](ref:content#richtextbatchedit) to perform
        as a batch on the rich text.
        The optional revision property can be used to identify a stable version
        of the text to use for selections. The latest revision is used if not
        specified.
        This is a long running operation. Responses include a `Location` header,
        which indicates where to poll for results. For more details on long-
        running job polling, see [Operations endpoint](ref:getoperationbyid).
        If the batch edit creates any new resources such as embedded tables, the
        `resourceUrl` field will be populated with a link to the [Rich Text
        Batch Edit Results endpoint](ref:getrichtextbatcheditresults) to
        retrieve the IDs of the new resources.
        """
        return self._client.request(
            "POST",
            self._api,
            "/content/richText/{richTextId}/edit",
            path_params={
                "richTextId": rich_text_id,
            },
            json_body=body,
            timeout=timeout,
        )

    async def rich_text_batch_edit_async(
        self,
        *,
        rich_text_id: str,
        body: RichTextBatchEdit,
        timeout: Optional[float] = None,
    ) -> httpx.Response:
        """Initiate edits to rich text (async)

        Sends a [`RichTextBatchEdit`](ref:content#richtextbatchedit) to perform
        as a batch on the rich text.
        The optional revision property can be used to identify a stable version
        of the text to use for selections. The latest revision is used if not
        specified.
        This is a long running operation. Responses include a `Location` header,
        which indicates where to poll for results. For more details on long-
        running job polling, see [Operations endpoint](ref:getoperationbyid).
        If the batch edit creates any new resources such as embedded tables, the
        `resourceUrl` field will be populated with a link to the [Rich Text
        Batch Edit Results endpoint](ref:getrichtextbatcheditresults) to
        retrieve the IDs of the new resources.
        """
        return await self._client.request_async(
            "POST",
            self._api,
            "/content/richText/{richTextId}/edit",
            path_params={
                "richTextId": rich_text_id,
            },
            json_body=body,
            timeout=timeout,
        )

    def rich_text_links_batch_edit(
        self,
        *,
        rich_text_id: str,
        body: RichTextLinksBatchEdit,
        timeout: Optional[float] = None,
    ) -> httpx.Response:
        """Initiate edits to rich text links

        Sends a [`RichTextLinksBatchEdit`](ref:content#richtextlinksbatchedit)
        to perform as a batch on the rich text.
        The optional revision property can be used to identify a stable version
        of the text to use for selections. The latest revision is used if not
        specified.
        This is a long running operation. Responses include a `Location` header,
        which indicates where to poll for results. For more details on long-
        running job polling, see [Operations endpoint](ref:getoperationbyid).
        If the batch edit creates any new resources, such as destination links,
        the `resourceUrl` field will be populated with a link to the [Rich Text
        Links Batch Edit Results endpoint](ref:getrichtextlinksbatcheditresults)
        to retrieve the IDs of the new resources.
        """
        return self._client.request(
            "POST",
            self._api,
            "/content/richText/{richTextId}/links/edit",
            path_params={
                "richTextId": rich_text_id,
            },
            json_body=body,
            timeout=timeout,
        )

    async def rich_text_links_batch_edit_async(
        self,
        *,
        rich_text_id: str,
        body: RichTextLinksBatchEdit,
        timeout: Optional[float] = None,
    ) -> httpx.Response:
        """Initiate edits to rich text links (async)

        Sends a [`RichTextLinksBatchEdit`](ref:content#richtextlinksbatchedit)
        to perform as a batch on the rich text.
        The optional revision property can be used to identify a stable version
        of the text to use for selections. The latest revision is used if not
        specified.
        This is a long running operation. Responses include a `Location` header,
        which indicates where to poll for results. For more details on long-
        running job polling, see [Operations endpoint](ref:getoperationbyid).
        If the batch edit creates any new resources, such as destination links,
        the `resourceUrl` field will be populated with a link to the [Rich Text
        Links Batch Edit Results endpoint](ref:getrichtextlinksbatcheditresults)
        to retrieve the IDs of the new resources.
        """
        return await self._client.request_async(
            "POST",
            self._api,
            "/content/richText/{richTextId}/links/edit",
            path_params={
                "richTextId": rich_text_id,
            },
            json_body=body,
            timeout=timeout,
        )

    def get_rich_text_paragraphs(
        self,
        *,
        rich_text_id: str,
        maxpagesize: Optional[int] = 1000,
        next_: Optional[str] = None,
        revision: Optional[str] = None,
        timeout: Optional[float] = None,
    ) -> httpx.Response:
        """Retrieve rich text paragraphs

        Returns a [`ParagraphsListResult`](ref:content#paragraphslistresult) for
        a rich text object, given its id.
        """
        return self._client.request(
            "GET",
            self._api,
            "/content/richText/{richTextId}/paragraphs",
            path_params={
                "richTextId": rich_text_id,
            },
            query_params={
                "$maxpagesize": maxpagesize,
                "$next": next_,
                "$revision": revision,
            },
            timeout=timeout,
        )

    async def get_rich_text_paragraphs_async(
        self,
        *,
        rich_text_id: str,
        maxpagesize: Optional[int] = 1000,
        next_: Optional[str] = None,
        revision: Optional[str] = None,
        timeout: Optional[float] = None,
    ) -> httpx.Response:
        """Retrieve rich text paragraphs (async)

        Returns a [`ParagraphsListResult`](ref:content#paragraphslistresult) for
        a rich text object, given its id.
        """
        return await self._client.request_async(
            "GET",
            self._api,
            "/content/richText/{richTextId}/paragraphs",
            path_params={
                "richTextId": rich_text_id,
            },
            query_params={
                "$maxpagesize": maxpagesize,
                "$next": next_,
                "$revision": revision,
            },
            timeout=timeout,
        )

    def get_style_guide_by_id(
        self,
        *,
        style_guide_id: str,
        revision: Optional[str] = None,
        timeout: Optional[float] = None,
    ) -> httpx.Response:
        """Retrieve a style guide by id

        Returns the [`StyleGuide`](ref:content#styleguide) populated with the
        text styles, list styles, etc. The revision will ensure a static
        content.
        """
        return self._client.request(
            "GET",
            self._api,
            "/content/styleGuides/{styleGuideId}",
            path_params={
                "styleGuideId": style_guide_id,
            },
            query_params={
                "$revision": revision,
            },
            timeout=timeout,
        )

    async def get_style_guide_by_id_async(
        self,
        *,
        style_guide_id: str,
        revision: Optional[str] = None,
        timeout: Optional[float] = None,
    ) -> httpx.Response:
        """Retrieve a style guide by id (async)

        Returns the [`StyleGuide`](ref:content#styleguide) populated with the
        text styles, list styles, etc. The revision will ensure a static
        content.
        """
        return await self._client.request_async(
            "GET",
            self._api,
            "/content/styleGuides/{styleGuideId}",
            path_params={
                "styleGuideId": style_guide_id,
            },
            query_params={
                "$revision": revision,
            },
            timeout=timeout,
        )

    def style_guide_export(
        self,
        *,
        style_guide_id: str,
        body: Optional[StyleGuideExport] = None,
        timeout: Optional[float] = None,
    ) -> httpx.Response:
        """Initiate a style guide export

        Export the style guide with the given identifier. Options are
        specified using a
        [StyleGuideExport](ref:content#styleguideexport) object.

        Responses include a `Location` header, which indicates where to poll for
        results. For more details on long-running job polling, see
        [Operations endpoint](ref:getoperationbyid).
        When the export completes, its status will be `completed`, and the
        response
        body includes a `resourceURL`. To GET the exported style guide, perform
        a GET
        on the `resourceURL` with the same authentication credentials and flow
        as the
        initial request. For more details, see
        [Authentication documentation](ref:authentication).
        """
        return self._client.request(
            "POST",
            self._api,
            "/content/styleGuides/{styleGuideId}/export",
            path_params={
                "styleGuideId": style_guide_id,
            },
            json_body=body,
            timeout=timeout,
        )

    async def style_guide_export_async(
        self,
        *,
        style_guide_id: str,
        body: Optional[StyleGuideExport] = None,
        timeout: Optional[float] = None,
    ) -> httpx.Response:
        """Initiate a style guide export (async)

        Export the style guide with the given identifier. Options are
        specified using a
        [StyleGuideExport](ref:content#styleguideexport) object.

        Responses include a `Location` header, which indicates where to poll for
        results. For more details on long-running job polling, see
        [Operations endpoint](ref:getoperationbyid).
        When the export completes, its status will be `completed`, and the
        response
        body includes a `resourceURL`. To GET the exported style guide, perform
        a GET
        on the `resourceURL` with the same authentication credentials and flow
        as the
        initial request. For more details, see
        [Authentication documentation](ref:authentication).
        """
        return await self._client.request_async(
            "POST",
            self._api,
            "/content/styleGuides/{styleGuideId}/export",
            path_params={
                "styleGuideId": style_guide_id,
            },
            json_body=body,
            timeout=timeout,
        )

    def style_guide_import(
        self,
        *,
        style_guide_id: str,
        timeout: Optional[float] = None,
    ) -> httpx.Response:
        """Initiate import of a style guide

        Imports a style guide to the given identifier. This operation will
        replace the current style guide.

        Responses include an `uploadUrl` which indicates where to upload the
        style guide import. To upload the file,
        perform a PUT against the `uploadUrl` with the same authentication
        credentials and flow as the import request.
        For more details, see [Authentication
        documentation](ref:authentication). The response will also include
        a `Location` header, which indicates where to poll for results. For more
        details on long-running job polling, see
        [Operations endpoint](ref:getoperationbyid). When the upload completes,
        its status will be
        `completed`, and the response body includes a `resourceURL`. To GET the
        style guide, perform a GET
        on the `resourceURL` with the same authentication credentials and flow
        as the initial request.
        """
        return self._client.request(
            "POST",
            self._api,
            "/content/styleGuides/{styleGuideId}/import",
            path_params={
                "styleGuideId": style_guide_id,
            },
            timeout=timeout,
        )

    async def style_guide_import_async(
        self,
        *,
        style_guide_id: str,
        timeout: Optional[float] = None,
    ) -> httpx.Response:
        """Initiate import of a style guide (async)

        Imports a style guide to the given identifier. This operation will
        replace the current style guide.

        Responses include an `uploadUrl` which indicates where to upload the
        style guide import. To upload the file,
        perform a PUT against the `uploadUrl` with the same authentication
        credentials and flow as the import request.
        For more details, see [Authentication
        documentation](ref:authentication). The response will also include
        a `Location` header, which indicates where to poll for results. For more
        details on long-running job polling, see
        [Operations endpoint](ref:getoperationbyid). When the upload completes,
        its status will be
        `completed`, and the response body includes a `resourceURL`. To GET the
        style guide, perform a GET
        on the `resourceURL` with the same authentication credentials and flow
        as the initial request.
        """
        return await self._client.request_async(
            "POST",
            self._api,
            "/content/styleGuides/{styleGuideId}/import",
            path_params={
                "styleGuideId": style_guide_id,
            },
            timeout=timeout,
        )

    def get_table_anchors(
        self,
        *,
        table_id: str,
        maxpagesize: Optional[int] = 1000,
        next_: Optional[str] = None,
        revision: Optional[str] = None,
        timeout: Optional[float] = None,
    ) -> httpx.Response:
        """Retrieve a list of table anchors

        Returns an [`AnchorsListResult`](ref:content#anchorslistresult) given
        tableId.
        """
        return self._client.request(
            "GET",
            self._api,
            "/content/tables/{tableId}/anchors",
            path_params={
                "tableId": table_id,
            },
            query_params={
                "$maxpagesize": maxpagesize,
                "$next": next_,
                "$revision": revision,
            },
            timeout=timeout,
        )

    async def get_table_anchors_async(
        self,
        *,
        table_id: str,
        maxpagesize: Optional[int] = 1000,
        next_: Optional[str] = None,
        revision: Optional[str] = None,
        timeout: Optional[float] = None,
    ) -> httpx.Response:
        """Retrieve a list of table anchors (async)

        Returns an [`AnchorsListResult`](ref:content#anchorslistresult) given
        tableId.
        """
        return await self._client.request_async(
            "GET",
            self._api,
            "/content/tables/{tableId}/anchors",
            path_params={
                "tableId": table_id,
            },
            query_params={
                "$maxpagesize": maxpagesize,
                "$next": next_,
                "$revision": revision,
            },
            timeout=timeout,
        )

    def table_anchor_creation(
        self,
        *,
        table_id: str,
        body: TableAnchorCreation,
        timeout: Optional[float] = None,
    ) -> httpx.Response:
        """Initiate creation of a new table anchor

        Create a new [`Anchor`](ref:content#anchor) using a
        [`TableAnchorCreation`](ref:content#tableanchorcreation) request. This
        is a long running operation.

        Responses include a `Location` header, which indicates where to poll for
        results. For more details on long-running job polling, see
        [Operations endpoint](ref:getoperationbyid).
        When the creation completes, its status will be `completed`, and the
        response
        body includes a `resourceURL`. To GET the new table anchor, perform a
        GET
        on the `resourceURL` with the same authentication credentials and flow
        as the
        initial request. For more details, see
        [Authentication documentation](ref:authentication).
        """
        return self._client.request(
            "POST",
            self._api,
            "/content/tables/{tableId}/anchors/creation",
            path_params={
                "tableId": table_id,
            },
            json_body=body,
            timeout=timeout,
        )

    async def table_anchor_creation_async(
        self,
        *,
        table_id: str,
        body: TableAnchorCreation,
        timeout: Optional[float] = None,
    ) -> httpx.Response:
        """Initiate creation of a new table anchor (async)

        Create a new [`Anchor`](ref:content#anchor) using a
        [`TableAnchorCreation`](ref:content#tableanchorcreation) request. This
        is a long running operation.

        Responses include a `Location` header, which indicates where to poll for
        results. For more details on long-running job polling, see
        [Operations endpoint](ref:getoperationbyid).
        When the creation completes, its status will be `completed`, and the
        response
        body includes a `resourceURL`. To GET the new table anchor, perform a
        GET
        on the `resourceURL` with the same authentication credentials and flow
        as the
        initial request. For more details, see
        [Authentication documentation](ref:authentication).
        """
        return await self._client.request_async(
            "POST",
            self._api,
            "/content/tables/{tableId}/anchors/creation",
            path_params={
                "tableId": table_id,
            },
            json_body=body,
            timeout=timeout,
        )

    def get_table_anchor_by_id(
        self,
        *,
        table_id: str,
        anchor_id: str,
        revision: Optional[str] = None,
        timeout: Optional[float] = None,
    ) -> httpx.Response:
        """Retrieve a table anchor by ID

        Returns an [`Anchor`](ref:content#anchor) given its id.
        """
        return self._client.request(
            "GET",
            self._api,
            "/content/tables/{tableId}/anchors/{anchorId}",
            path_params={
                "tableId": table_id,
                "anchorId": anchor_id,
            },
            query_params={
                "$revision": revision,
            },
            timeout=timeout,
        )

    async def get_table_anchor_by_id_async(
        self,
        *,
        table_id: str,
        anchor_id: str,
        revision: Optional[str] = None,
        timeout: Optional[float] = None,
    ) -> httpx.Response:
        """Retrieve a table anchor by ID (async)

        Returns an [`Anchor`](ref:content#anchor) given its id.
        """
        return await self._client.request_async(
            "GET",
            self._api,
            "/content/tables/{tableId}/anchors/{anchorId}",
            path_params={
                "tableId": table_id,
                "anchorId": anchor_id,
            },
            query_params={
                "$revision": revision,
            },
            timeout=timeout,
        )

    def get_table_anchor_extensions(
        self,
        *,
        table_id: str,
        anchor_id: str,
        maxpagesize: Optional[int] = 1000,
        next_: Optional[str] = None,
        revision: Optional[str] = None,
        timeout: Optional[float] = None,
    ) -> httpx.Response:
        """Retrieve a list of table anchor extensions

        Returns a paginated list of
        [`AnchorExtensions`](ref:content#anchorextension) for a given anchorId.
        """
        return self._client.request(
            "GET",
            self._api,
            "/content/tables/{tableId}/anchors/{anchorId}/extensions",
            path_params={
                "tableId": table_id,
                "anchorId": anchor_id,
            },
            query_params={
                "$maxpagesize": maxpagesize,
                "$next": next_,
                "$revision": revision,
            },
            timeout=timeout,
        )

    async def get_table_anchor_extensions_async(
        self,
        *,
        table_id: str,
        anchor_id: str,
        maxpagesize: Optional[int] = 1000,
        next_: Optional[str] = None,
        revision: Optional[str] = None,
        timeout: Optional[float] = None,
    ) -> httpx.Response:
        """Retrieve a list of table anchor extensions (async)

        Returns a paginated list of
        [`AnchorExtensions`](ref:content#anchorextension) for a given anchorId.
        """
        return await self._client.request_async(
            "GET",
            self._api,
            "/content/tables/{tableId}/anchors/{anchorId}/extensions",
            path_params={
                "tableId": table_id,
                "anchorId": anchor_id,
            },
            query_params={
                "$maxpagesize": maxpagesize,
                "$next": next_,
                "$revision": revision,
            },
            timeout=timeout,
        )

    def get_table_cells(
        self,
        *,
        table_id: str,
        revision: Optional[str] = None,
        maxcellsperpage: Optional[int] = 50000,
        next_: Optional[str] = None,
        start_row: Optional[int] = None,
        stop_row: Optional[int] = None,
        start_column: Optional[int] = None,
        stop_column: Optional[int] = None,
        timeout: Optional[float] = None,
    ) -> httpx.Response:
        """Retrieve table cell content

        Returns a [`TableCellsResult`](ref:content#tablecellsresult) for a given
        tableId.
        """
        return self._client.request(
            "GET",
            self._api,
            "/content/tables/{tableId}/cells",
            path_params={
                "tableId": table_id,
            },
            query_params={
                "$revision": revision,
                "$maxcellsperpage": maxcellsperpage,
                "$next": next_,
                "startRow": start_row,
                "stopRow": stop_row,
                "startColumn": start_column,
                "stopColumn": stop_column,
            },
            timeout=timeout,
        )

    async def get_table_cells_async(
        self,
        *,
        table_id: str,
        revision: Optional[str] = None,
        maxcellsperpage: Optional[int] = 50000,
        next_: Optional[str] = None,
        start_row: Optional[int] = None,
        stop_row: Optional[int] = None,
        start_column: Optional[int] = None,
        stop_column: Optional[int] = None,
        timeout: Optional[float] = None,
    ) -> httpx.Response:
        """Retrieve table cell content (async)

        Returns a [`TableCellsResult`](ref:content#tablecellsresult) for a given
        tableId.
        """
        return await self._client.request_async(
            "GET",
            self._api,
            "/content/tables/{tableId}/cells",
            path_params={
                "tableId": table_id,
            },
            query_params={
                "$revision": revision,
                "$maxcellsperpage": maxcellsperpage,
                "$next": next_,
                "startRow": start_row,
                "stopRow": stop_row,
                "startColumn": start_column,
                "stopColumn": stop_column,
            },
            timeout=timeout,
        )

    def table_cells_batch_edit(
        self,
        *,
        table_id: str,
        body: TableCellsBatchEdit,
        timeout: Optional[float] = None,
    ) -> httpx.Response:
        """Initiate edits to table cells

        Sends a [`TableCellsBatchEdit`](ref:content#tablecellsbatchedit) to
        perform on the cells in a table.

        The optional revision property can be used to identify a stable cell
        location in the table. The latest revision is used if not specified.

        Responses include a `Location` header, which indicates where to poll for
        results. For more details on long-running job polling, see[ Operations
        endpoint ](ref:getoperationbyid). When the creation completes, its
        status will be `completed`, and the response\nbody includes a
        `resourceURL`.\n"
        """
        return self._client.request(
            "POST",
            self._api,
            "/content/tables/{tableId}/cells/edit",
            path_params={
                "tableId": table_id,
            },
            json_body=body,
            timeout=timeout,
        )

    async def table_cells_batch_edit_async(
        self,
        *,
        table_id: str,
        body: TableCellsBatchEdit,
        timeout: Optional[float] = None,
    ) -> httpx.Response:
        """Initiate edits to table cells (async)

        Sends a [`TableCellsBatchEdit`](ref:content#tablecellsbatchedit) to
        perform on the cells in a table.

        The optional revision property can be used to identify a stable cell
        location in the table. The latest revision is used if not specified.

        Responses include a `Location` header, which indicates where to poll for
        results. For more details on long-running job polling, see[ Operations
        endpoint ](ref:getoperationbyid). When the creation completes, its
        status will be `completed`, and the response\nbody includes a
        `resourceURL`.\n"
        """
        return await self._client.request_async(
            "POST",
            self._api,
            "/content/tables/{tableId}/cells/edit",
            path_params={
                "tableId": table_id,
            },
            json_body=body,
            timeout=timeout,
        )

    def get_column_properties(
        self,
        *,
        table_id: str,
        revision: Optional[str] = None,
        maxpagesize: Optional[int] = 1000,
        next_: Optional[str] = None,
        start_column: Optional[int] = None,
        stop_column: Optional[int] = None,
        timeout: Optional[float] = None,
    ) -> httpx.Response:
        """Retrieve table column properties

        Returns a
        [`ColumnPropertiesListResult`](ref:content#columnpropertieslistresult)
        for a table
        """
        return self._client.request(
            "GET",
            self._api,
            "/content/tables/{tableId}/properties/columns",
            path_params={
                "tableId": table_id,
            },
            query_params={
                "$revision": revision,
                "$maxpagesize": maxpagesize,
                "$next": next_,
                "startColumn": start_column,
                "stopColumn": stop_column,
            },
            timeout=timeout,
        )

    async def get_column_properties_async(
        self,
        *,
        table_id: str,
        revision: Optional[str] = None,
        maxpagesize: Optional[int] = 1000,
        next_: Optional[str] = None,
        start_column: Optional[int] = None,
        stop_column: Optional[int] = None,
        timeout: Optional[float] = None,
    ) -> httpx.Response:
        """Retrieve table column properties (async)

        Returns a
        [`ColumnPropertiesListResult`](ref:content#columnpropertieslistresult)
        for a table
        """
        return await self._client.request_async(
            "GET",
            self._api,
            "/content/tables/{tableId}/properties/columns",
            path_params={
                "tableId": table_id,
            },
            query_params={
                "$revision": revision,
                "$maxpagesize": maxpagesize,
                "$next": next_,
                "startColumn": start_column,
                "stopColumn": stop_column,
            },
            timeout=timeout,
        )

    def table_edit(
        self,
        *,
        table_id: str,
        body: TableEdit,
        timeout: Optional[float] = None,
    ) -> httpx.Response:
        """Initiate edit to a table

        Sends a single [`TableEdit`](ref:content#tableedit) to perform on the
        table.

        Responses include a `Location` header, which indicates where to poll for
        results. For more details on long-running job polling, see
        [ Operations endpoint ](ref:getoperationbyid). When the creation
        completes, its status will be `completed`, and the response
        body includes a `resourceURL`.
        """
        return self._client.request(
            "POST",
            self._api,
            "/content/tables/{tableId}/edit",
            path_params={
                "tableId": table_id,
            },
            json_body=body,
            timeout=timeout,
        )

    async def table_edit_async(
        self,
        *,
        table_id: str,
        body: TableEdit,
        timeout: Optional[float] = None,
    ) -> httpx.Response:
        """Initiate edit to a table (async)

        Sends a single [`TableEdit`](ref:content#tableedit) to perform on the
        table.

        Responses include a `Location` header, which indicates where to poll for
        results. For more details on long-running job polling, see
        [ Operations endpoint ](ref:getoperationbyid). When the creation
        completes, its status will be `completed`, and the response
        body includes a `resourceURL`.
        """
        return await self._client.request_async(
            "POST",
            self._api,
            "/content/tables/{tableId}/edit",
            path_params={
                "tableId": table_id,
            },
            json_body=body,
            timeout=timeout,
        )

    def table_filters_reapplication(
        self,
        *,
        table_id: str,
        body: TableFiltersReapplication,
        timeout: Optional[float] = None,
    ) -> httpx.Response:
        """Reapply filters to the table

        Performs a
        [`TableFiltersReapplication`](ref:content#tablefiltersreapplication) on
        the specified table.
        This endpoint is used to refresh the table's filters based on the latest
        state or configuration changes.
        The filters are reapplied in the context of the table's current data
        state.
        This is a long running operation. Responses include a `Location` header,
        which indicates where to poll for results. For more details on
        long-running job polling, see [Operations
        endpoint](ref:getoperationbyid).
        """
        return self._client.request(
            "POST",
            self._api,
            "/content/tables/{tableId}/filters/reapplication",
            path_params={
                "tableId": table_id,
            },
            json_body=body,
            timeout=timeout,
        )

    async def table_filters_reapplication_async(
        self,
        *,
        table_id: str,
        body: TableFiltersReapplication,
        timeout: Optional[float] = None,
    ) -> httpx.Response:
        """Reapply filters to the table (async)

        Performs a
        [`TableFiltersReapplication`](ref:content#tablefiltersreapplication) on
        the specified table.
        This endpoint is used to refresh the table's filters based on the latest
        state or configuration changes.
        The filters are reapplied in the context of the table's current data
        state.
        This is a long running operation. Responses include a `Location` header,
        which indicates where to poll for results. For more details on
        long-running job polling, see [Operations
        endpoint](ref:getoperationbyid).
        """
        return await self._client.request_async(
            "POST",
            self._api,
            "/content/tables/{tableId}/filters/reapplication",
            path_params={
                "tableId": table_id,
            },
            json_body=body,
            timeout=timeout,
        )

    def table_links_batch_edit(
        self,
        *,
        table_id: str,
        body: TableLinksBatchEdit,
        timeout: Optional[float] = None,
    ) -> httpx.Response:
        """Initiate edit to table links

        Sends a [`TableLinksBatchEdit`](ref:content#tablelinksbatchedit) to
        perform on the links in a table.

        The optional revision property can be used to identify a stable cell
        location in the table. The latest revision is used if not specified.

        If the edit creates any new resources, such as destination links, the
        `resourceUrl` field will be populated with a link to the [Table Links
        Edit Results endpoint](ref:gettablelinkseditresults) to retrieve the IDs
        of the new resources.
        """
        return self._client.request(
            "POST",
            self._api,
            "/content/tables/{tableId}/links/edit",
            path_params={
                "tableId": table_id,
            },
            json_body=body,
            timeout=timeout,
        )

    async def table_links_batch_edit_async(
        self,
        *,
        table_id: str,
        body: TableLinksBatchEdit,
        timeout: Optional[float] = None,
    ) -> httpx.Response:
        """Initiate edit to table links (async)

        Sends a [`TableLinksBatchEdit`](ref:content#tablelinksbatchedit) to
        perform on the links in a table.

        The optional revision property can be used to identify a stable cell
        location in the table. The latest revision is used if not specified.

        If the edit creates any new resources, such as destination links, the
        `resourceUrl` field will be populated with a link to the [Table Links
        Edit Results endpoint](ref:gettablelinkseditresults) to retrieve the IDs
        of the new resources.
        """
        return await self._client.request_async(
            "POST",
            self._api,
            "/content/tables/{tableId}/links/edit",
            path_params={
                "tableId": table_id,
            },
            json_body=body,
            timeout=timeout,
        )

    def get_range_links(
        self,
        *,
        table_id: str,
        maxpagesize: Optional[int] = 1000,
        next_: Optional[str] = None,
        revision: Optional[str] = None,
        timeout: Optional[float] = None,
    ) -> httpx.Response:
        """Retrieve a list of range links

        Returns a [`RangeLinkListResult`](ref:content#rangelinklistresult) for a
        given tableId.
        """
        return self._client.request(
            "GET",
            self._api,
            "/content/tables/{tableId}/rangeLinks",
            path_params={
                "tableId": table_id,
            },
            query_params={
                "$maxpagesize": maxpagesize,
                "$next": next_,
                "$revision": revision,
            },
            timeout=timeout,
        )

    async def get_range_links_async(
        self,
        *,
        table_id: str,
        maxpagesize: Optional[int] = 1000,
        next_: Optional[str] = None,
        revision: Optional[str] = None,
        timeout: Optional[float] = None,
    ) -> httpx.Response:
        """Retrieve a list of range links (async)

        Returns a [`RangeLinkListResult`](ref:content#rangelinklistresult) for a
        given tableId.
        """
        return await self._client.request_async(
            "GET",
            self._api,
            "/content/tables/{tableId}/rangeLinks",
            path_params={
                "tableId": table_id,
            },
            query_params={
                "$maxpagesize": maxpagesize,
                "$next": next_,
                "$revision": revision,
            },
            timeout=timeout,
        )

    def get_range_link_by_id(
        self,
        *,
        table_id: str,
        range_link_id: str,
        revision: Optional[str] = None,
        timeout: Optional[float] = None,
    ) -> httpx.Response:
        """Retrieve a range link by id

        Returns a [`RangeLink`](ref:content#rangelink) given its id
        """
        return self._client.request(
            "GET",
            self._api,
            "/content/tables/{tableId}/rangeLinks/{rangeLinkId}",
            path_params={
                "tableId": table_id,
                "rangeLinkId": range_link_id,
            },
            query_params={
                "$revision": revision,
            },
            timeout=timeout,
        )

    async def get_range_link_by_id_async(
        self,
        *,
        table_id: str,
        range_link_id: str,
        revision: Optional[str] = None,
        timeout: Optional[float] = None,
    ) -> httpx.Response:
        """Retrieve a range link by id (async)

        Returns a [`RangeLink`](ref:content#rangelink) given its id
        """
        return await self._client.request_async(
            "GET",
            self._api,
            "/content/tables/{tableId}/rangeLinks/{rangeLinkId}",
            path_params={
                "tableId": table_id,
                "rangeLinkId": range_link_id,
            },
            query_params={
                "$revision": revision,
            },
            timeout=timeout,
        )

    def get_range_link_destinations(
        self,
        *,
        table_id: str,
        range_link_id: str,
        maxpagesize: Optional[int] = 1000,
        next_: Optional[str] = None,
        revision: Optional[str] = None,
        timeout: Optional[float] = None,
    ) -> httpx.Response:
        """Retrieve range link destinations for a source

        Returns a [`RangeLinkListResult`](ref:content#rangelinklistresult) of
        destinations for a given source range link.
        """
        return self._client.request(
            "GET",
            self._api,
            "/content/tables/{tableId}/rangeLinks/{rangeLinkId}/destinations",
            path_params={
                "tableId": table_id,
                "rangeLinkId": range_link_id,
            },
            query_params={
                "$maxpagesize": maxpagesize,
                "$next": next_,
                "$revision": revision,
            },
            timeout=timeout,
        )

    async def get_range_link_destinations_async(
        self,
        *,
        table_id: str,
        range_link_id: str,
        maxpagesize: Optional[int] = 1000,
        next_: Optional[str] = None,
        revision: Optional[str] = None,
        timeout: Optional[float] = None,
    ) -> httpx.Response:
        """Retrieve range link destinations for a source (async)

        Returns a [`RangeLinkListResult`](ref:content#rangelinklistresult) of
        destinations for a given source range link.
        """
        return await self._client.request_async(
            "GET",
            self._api,
            "/content/tables/{tableId}/rangeLinks/{rangeLinkId}/destinations",
            path_params={
                "tableId": table_id,
                "rangeLinkId": range_link_id,
            },
            query_params={
                "$maxpagesize": maxpagesize,
                "$next": next_,
                "$revision": revision,
            },
            timeout=timeout,
        )

    def table_range_links_edit(
        self,
        *,
        table_id: str,
        body: RangeLinkEdit,
        timeout: Optional[float] = None,
    ) -> httpx.Response:
        """Initiate range links edits on a table

        Sends a [`RangeLinkEdit`](ref:content#rangelinkedit) to perform on the
        range links in a table.
        This is a long running operation. Responses include a `Location` header,
        which indicates where to poll for results. For more details on long-
        running job polling, see [Operations endpoint](ref:getoperationbyid).
        """
        return self._client.request(
            "POST",
            self._api,
            "/content/tables/{tableId}/rangeLinks/edit",
            path_params={
                "tableId": table_id,
            },
            json_body=body,
            timeout=timeout,
        )

    async def table_range_links_edit_async(
        self,
        *,
        table_id: str,
        body: RangeLinkEdit,
        timeout: Optional[float] = None,
    ) -> httpx.Response:
        """Initiate range links edits on a table (async)

        Sends a [`RangeLinkEdit`](ref:content#rangelinkedit) to perform on the
        range links in a table.
        This is a long running operation. Responses include a `Location` header,
        which indicates where to poll for results. For more details on long-
        running job polling, see [Operations endpoint](ref:getoperationbyid).
        """
        return await self._client.request_async(
            "POST",
            self._api,
            "/content/tables/{tableId}/rangeLinks/edit",
            path_params={
                "tableId": table_id,
            },
            json_body=body,
            timeout=timeout,
        )

    def get_table_properties(
        self,
        *,
        table_id: str,
        revision: Optional[str] = None,
        timeout: Optional[float] = None,
    ) -> httpx.Response:
        """Retrieve a table's properties by id

        Returns a [`TableProperties`](ref:content#tableproperties) for a table
        """
        return self._client.request(
            "GET",
            self._api,
            "/content/tables/{tableId}/properties",
            path_params={
                "tableId": table_id,
            },
            query_params={
                "$revision": revision,
            },
            timeout=timeout,
        )

    async def get_table_properties_async(
        self,
        *,
        table_id: str,
        revision: Optional[str] = None,
        timeout: Optional[float] = None,
    ) -> httpx.Response:
        """Retrieve a table's properties by id (async)

        Returns a [`TableProperties`](ref:content#tableproperties) for a table
        """
        return await self._client.request_async(
            "GET",
            self._api,
            "/content/tables/{tableId}/properties",
            path_params={
                "tableId": table_id,
            },
            query_params={
                "$revision": revision,
            },
            timeout=timeout,
        )

    def partially_update_table_properties(
        self,
        *,
        table_id: str,
        body: JSONPatchDocument,
        timeout: Optional[float] = None,
    ) -> httpx.Response:
        """Partially update a table's properties

        Partially updates a table's properties given its ID.

        This is a long running operation. Responses include a `Location` header,
        which indicates where to poll for results.
        For more details on long-running job polling, see [Operations
        endpoint](ref:getoperationbyid).

        ### Options
        | Path               | PATCH Operations Supported |
        |--------------------|----------------------------|
        | `/name`            | `replace`                  |
        | `/resizeRowsToFit` | `replace`                  |
        | `/lock`            | `replace`                  |
        """
        return self._client.request(
            "PATCH",
            self._api,
            "/content/tables/{tableId}/properties",
            path_params={
                "tableId": table_id,
            },
            json_body=body,
            timeout=timeout,
        )

    async def partially_update_table_properties_async(
        self,
        *,
        table_id: str,
        body: JSONPatchDocument,
        timeout: Optional[float] = None,
    ) -> httpx.Response:
        """Partially update a table's properties (async)

        Partially updates a table's properties given its ID.

        This is a long running operation. Responses include a `Location` header,
        which indicates where to poll for results.
        For more details on long-running job polling, see [Operations
        endpoint](ref:getoperationbyid).

        ### Options
        | Path               | PATCH Operations Supported |
        |--------------------|----------------------------|
        | `/name`            | `replace`                  |
        | `/resizeRowsToFit` | `replace`                  |
        | `/lock`            | `replace`                  |
        """
        return await self._client.request_async(
            "PATCH",
            self._api,
            "/content/tables/{tableId}/properties",
            path_params={
                "tableId": table_id,
            },
            json_body=body,
            timeout=timeout,
        )

    def get_row_properties(
        self,
        *,
        table_id: str,
        revision: Optional[str] = None,
        maxpagesize: Optional[int] = 1000,
        next_: Optional[str] = None,
        start_row: Optional[int] = None,
        stop_row: Optional[int] = None,
        timeout: Optional[float] = None,
    ) -> httpx.Response:
        """Retrieve table row properties

        Returns a
        [`RowPropertiesListResult`](ref:content#rowpropertieslistresult) for a
        table
        """
        return self._client.request(
            "GET",
            self._api,
            "/content/tables/{tableId}/properties/rows",
            path_params={
                "tableId": table_id,
            },
            query_params={
                "$revision": revision,
                "$maxpagesize": maxpagesize,
                "$next": next_,
                "startRow": start_row,
                "stopRow": stop_row,
            },
            timeout=timeout,
        )

    async def get_row_properties_async(
        self,
        *,
        table_id: str,
        revision: Optional[str] = None,
        maxpagesize: Optional[int] = 1000,
        next_: Optional[str] = None,
        start_row: Optional[int] = None,
        stop_row: Optional[int] = None,
        timeout: Optional[float] = None,
    ) -> httpx.Response:
        """Retrieve table row properties (async)

        Returns a
        [`RowPropertiesListResult`](ref:content#rowpropertieslistresult) for a
        table
        """
        return await self._client.request_async(
            "GET",
            self._api,
            "/content/tables/{tableId}/properties/rows",
            path_params={
                "tableId": table_id,
            },
            query_params={
                "$revision": revision,
                "$maxpagesize": maxpagesize,
                "$next": next_,
                "startRow": start_row,
                "stopRow": stop_row,
            },
            timeout=timeout,
        )
