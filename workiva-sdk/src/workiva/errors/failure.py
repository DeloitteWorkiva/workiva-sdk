"""Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT."""

from __future__ import annotations
from dataclasses import dataclass, field
import httpx
from pydantic import model_serializer
from typing import Any, Dict, List, Optional
from typing_extensions import NotRequired, TypedDict
from workiva.errors import SDKBaseError
from workiva.types import BaseModel, UNSET_SENTINEL


class LinksTypedDict(TypedDict):
    about: NotRequired[str]
    r"""A link that leads to further details about this particular occurrence of the problem"""


class Links(BaseModel):
    about: Optional[str] = None
    r"""A link that leads to further details about this particular occurrence of the problem"""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["about"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class SourceTypedDict(TypedDict):
    parameter: NotRequired[str]
    r"""A string indicating which URI query parameter caused the error"""
    pointer: NotRequired[str]
    r"""A JSON Pointer [RFC6901] to the associated entity in the request document"""


class Source(BaseModel):
    parameter: Optional[str] = None
    r"""A string indicating which URI query parameter caused the error"""

    pointer: Optional[str] = None
    r"""A JSON Pointer [RFC6901] to the associated entity in the request document"""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["parameter", "pointer"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class ErrorsTypedDict(TypedDict):
    code: NotRequired[str]
    r"""An application-specific error code, expressed as a string value"""
    detail: NotRequired[str]
    r"""A human-readable explanation specific to this occurrence of the problem. Like 'title', this field's value can be localized."""
    id: NotRequired[str]
    r"""A unique identifier for this particular occurrence of the problem"""
    links: NotRequired[LinksTypedDict]
    meta: NotRequired[Dict[str, Any]]
    r"""Non-standard meta-information that cannot be represented as an attribute or relationship."""
    source: NotRequired[SourceTypedDict]
    status: NotRequired[str]
    r"""The HTTP status code applicable to this problem, expressed as a string value"""
    title: NotRequired[str]
    r"""A short, human-readable summary of the problem that SHOULD NOT change from occurrence to occurrence of the problem, except for purposes of localization"""


class Errors(BaseModel):
    code: Optional[str] = None
    r"""An application-specific error code, expressed as a string value"""

    detail: Optional[str] = None
    r"""A human-readable explanation specific to this occurrence of the problem. Like 'title', this field's value can be localized."""

    id: Optional[str] = None
    r"""A unique identifier for this particular occurrence of the problem"""

    links: Optional[Links] = None

    meta: Optional[Dict[str, Any]] = None
    r"""Non-standard meta-information that cannot be represented as an attribute or relationship."""

    source: Optional[Source] = None

    status: Optional[str] = None
    r"""The HTTP status code applicable to this problem, expressed as a string value"""

    title: Optional[str] = None
    r"""A short, human-readable summary of the problem that SHOULD NOT change from occurrence to occurrence of the problem, except for purposes of localization"""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            ["code", "detail", "id", "links", "meta", "source", "status", "title"]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class JsonapiTypedDict(TypedDict):
    version: NotRequired[str]


class Jsonapi(BaseModel):
    version: Optional[str] = None

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["version"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class FailureData(BaseModel):
    errors: List[Errors]
    jsonapi: Optional[Jsonapi] = None
    links: Optional[Dict[str, Any]] = None
    r"""A list of URLs."""
    meta: Optional[Dict[str, Any]] = None
    r"""Non-standard meta-information that cannot be represented as an attribute or relationship."""


@dataclass(unsafe_hash=True)
class Failure(SDKBaseError):
    r"""An error response. All fields other than \"errors\" are optional"""

    data: FailureData = field(hash=False)

    def __init__(
        self,
        data: FailureData,
        raw_response: httpx.Response,
        body: Optional[str] = None,
    ):
        message = body or raw_response.text
        super().__init__(message, raw_response, body)
        object.__setattr__(self, "data", data)
