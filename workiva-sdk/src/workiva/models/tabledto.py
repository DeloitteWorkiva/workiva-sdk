"""Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT."""

from __future__ import annotations
from .hierarchymetadata import HierarchyMetadata, HierarchyMetadataTypedDict
from .tableschema import TableSchema, TableSchemaTypedDict
from .uniqueconstraintdto import UniqueConstraintDto, UniqueConstraintDtoTypedDict
from datetime import datetime
from enum import Enum
import pydantic
from pydantic import field_serializer, model_serializer
from typing import List, Optional
from typing_extensions import Annotated, NotRequired, TypedDict
from workiva import models, utils
from workiva.types import BaseModel, UNSET_SENTINEL


class TableDtoType(str, Enum, metaclass=utils.OpenEnumMeta):
    r"""The type of table"""

    DATA = "data"
    LOOKUP = "lookup"
    HIERARCHY = "hierarchy"


class TableDtoTypedDict(TypedDict):
    is_shared: bool
    r"""A property indicating if this table is shared to any destination."""
    name: str
    r"""May be at most 150 characters in length"""
    table_schema: TableSchemaTypedDict
    type: TableDtoType
    r"""The type of table"""
    unique_table_constraints: List[UniqueConstraintDtoTypedDict]
    r"""A property indicating the unique constraints on the table."""
    created: NotRequired[datetime]
    r"""When the entity was created"""
    database_id: NotRequired[str]
    r"""The unique identifier of the database where the table resides."""
    dataset_updated: NotRequired[datetime]
    r"""The last time that the data set for this table was modified."""
    deleted: NotRequired[bool]
    r"""This is for backwards compatibility only and will always return false."""
    description: NotRequired[str]
    r"""May be at most 255 characters in length"""
    hierarchy_metadata: NotRequired[HierarchyMetadataTypedDict]
    id: NotRequired[str]
    r"""The entity's unique identifier"""
    last_uploaded: NotRequired[datetime]
    r"""Contains the date and time of the last file that was imported into the table. Valuable for determining if the data is stale."""
    parent_id: NotRequired[str]
    r"""If non-null, indicates the parent of this entity. Must be modified through the
    folder api.
    """
    read_only: NotRequired[bool]
    r"""Indicates if this table is readonly in the account receiving this table. If so, any
    attempt to edit the table will fail.
    """
    updated: NotRequired[datetime]
    r"""When the entity was last updated"""
    user_id: NotRequired[str]
    r"""The owner of the entity"""
    version: NotRequired[int]
    r"""The version of the current representation of the entity"""


class TableDto(BaseModel):
    is_shared: Annotated[bool, pydantic.Field(alias="isShared")]
    r"""A property indicating if this table is shared to any destination."""

    name: str
    r"""May be at most 150 characters in length"""

    table_schema: Annotated[TableSchema, pydantic.Field(alias="tableSchema")]

    type: TableDtoType
    r"""The type of table"""

    unique_table_constraints: Annotated[
        List[UniqueConstraintDto], pydantic.Field(alias="uniqueTableConstraints")
    ]
    r"""A property indicating the unique constraints on the table."""

    created: Optional[datetime] = None
    r"""When the entity was created"""

    database_id: Annotated[Optional[str], pydantic.Field(alias="databaseId")] = None
    r"""The unique identifier of the database where the table resides."""

    dataset_updated: Annotated[
        Optional[datetime], pydantic.Field(alias="datasetUpdated")
    ] = None
    r"""The last time that the data set for this table was modified."""

    deleted: Annotated[
        Optional[bool],
        pydantic.Field(
            deprecated="warning: ** DEPRECATED ** - This will be removed in a future release, please migrate away from it as soon as possible."
        ),
    ] = None
    r"""This is for backwards compatibility only and will always return false."""

    description: Optional[str] = None
    r"""May be at most 255 characters in length"""

    hierarchy_metadata: Annotated[
        Optional[HierarchyMetadata], pydantic.Field(alias="hierarchyMetadata")
    ] = None

    id: Optional[str] = None
    r"""The entity's unique identifier"""

    last_uploaded: Annotated[
        Optional[datetime], pydantic.Field(alias="lastUploaded")
    ] = None
    r"""Contains the date and time of the last file that was imported into the table. Valuable for determining if the data is stale."""

    parent_id: Annotated[Optional[str], pydantic.Field(alias="parentId")] = None
    r"""If non-null, indicates the parent of this entity. Must be modified through the
    folder api.
    """

    read_only: Annotated[Optional[bool], pydantic.Field(alias="readOnly")] = None
    r"""Indicates if this table is readonly in the account receiving this table. If so, any
    attempt to edit the table will fail.
    """

    updated: Optional[datetime] = None
    r"""When the entity was last updated"""

    user_id: Annotated[Optional[str], pydantic.Field(alias="userId")] = None
    r"""The owner of the entity"""

    version: Optional[int] = None
    r"""The version of the current representation of the entity"""

    @field_serializer("type")
    def serialize_type(self, value):
        if isinstance(value, str):
            try:
                return models.TableDtoType(value)
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            [
                "created",
                "databaseId",
                "datasetUpdated",
                "deleted",
                "description",
                "hierarchyMetadata",
                "id",
                "lastUploaded",
                "parentId",
                "readOnly",
                "updated",
                "userId",
                "version",
            ]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class TableDtoInputTypedDict(TypedDict):
    name: str
    r"""May be at most 150 characters in length"""
    table_schema: TableSchemaTypedDict
    type: TableDtoType
    r"""The type of table"""
    unique_table_constraints: List[UniqueConstraintDtoTypedDict]
    r"""A property indicating the unique constraints on the table."""
    dataset_updated: NotRequired[datetime]
    r"""The last time that the data set for this table was modified."""
    description: NotRequired[str]
    r"""May be at most 255 characters in length"""
    hierarchy_metadata: NotRequired[HierarchyMetadataTypedDict]


class TableDtoInput(BaseModel):
    name: str
    r"""May be at most 150 characters in length"""

    table_schema: Annotated[TableSchema, pydantic.Field(alias="tableSchema")]

    type: TableDtoType
    r"""The type of table"""

    unique_table_constraints: Annotated[
        List[UniqueConstraintDto], pydantic.Field(alias="uniqueTableConstraints")
    ]
    r"""A property indicating the unique constraints on the table."""

    dataset_updated: Annotated[
        Optional[datetime], pydantic.Field(alias="datasetUpdated")
    ] = None
    r"""The last time that the data set for this table was modified."""

    description: Optional[str] = None
    r"""May be at most 255 characters in length"""

    hierarchy_metadata: Annotated[
        Optional[HierarchyMetadata], pydantic.Field(alias="hierarchyMetadata")
    ] = None

    @field_serializer("type")
    def serialize_type(self, value):
        if isinstance(value, str):
            try:
                return models.TableDtoType(value)
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["datasetUpdated", "description", "hierarchyMetadata"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


try:
    TableDto.model_rebuild()
except NameError:
    pass
try:
    TableDtoInput.model_rebuild()
except NameError:
    pass
