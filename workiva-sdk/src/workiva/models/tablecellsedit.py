"""Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT."""

from __future__ import annotations
from .cell import Cell, CellTypedDict
from .cellrange import CellRange, CellRangeTypedDict
from .color import Color, ColorTypedDict
from .textedit import TextEdit, TextEditTypedDict
from enum import Enum
import pydantic
from pydantic import model_serializer
from typing import List, Optional
from typing_extensions import Annotated, NotRequired, TypedDict
from workiva.types import BaseModel, Nullable, OptionalNullable, UNSET, UNSET_SENTINEL


class ClearCellsBordersTypedDict(TypedDict):
    r"""Clears the cell borders from all the cells in the given ranges of a table."""

    ranges: List[CellRangeTypedDict]
    r"""A collection of cell ranges in a table.

    """
    clear_all: NotRequired[bool]
    r"""Whether to clear all cell borders.

    """


class ClearCellsBorders(BaseModel):
    r"""Clears the cell borders from all the cells in the given ranges of a table."""

    ranges: List[CellRange]
    r"""A collection of cell ranges in a table.

    """

    clear_all: Annotated[Optional[bool], pydantic.Field(alias="clearAll")] = False
    r"""Whether to clear all cell borders.

    """

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["clearAll"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class ClearCellsFormatTypedDict(TypedDict):
    r"""Clears the text formatting from all the cells in the given ranges of a table. This will not clear out styles nor hyperlinks."""

    ranges: List[CellRangeTypedDict]
    r"""A collection of cell ranges in a table.

    """
    clear_all: NotRequired[bool]
    r"""Whether or not to clear all cell formats. This is the same as setting every other option to true. When new text formats are added those will also be cleared. When true, all other clear option values are ignored."""
    clear_background_color: NotRequired[bool]
    r"""Whether or not clear the background color."""
    clear_bold: NotRequired[bool]
    r"""Whether or not clear the bold format."""
    clear_character_spacing: NotRequired[bool]
    r"""Whether or not clear the character spacing."""
    clear_font: NotRequired[bool]
    r"""Whether or not to clear the font."""
    clear_italic: NotRequired[bool]
    r"""Whether or not clear the italic format."""
    clear_size: NotRequired[bool]
    r"""Whether or not clear the font size."""
    clear_strike_through: NotRequired[bool]
    r"""Whether or not clear the strikethrough."""
    clear_text_color: NotRequired[bool]
    r"""Whether or not clear the text color."""
    clear_underline: NotRequired[bool]
    r"""Whether or not clear the underline."""


class ClearCellsFormat(BaseModel):
    r"""Clears the text formatting from all the cells in the given ranges of a table. This will not clear out styles nor hyperlinks."""

    ranges: List[CellRange]
    r"""A collection of cell ranges in a table.

    """

    clear_all: Annotated[Optional[bool], pydantic.Field(alias="clearAll")] = False
    r"""Whether or not to clear all cell formats. This is the same as setting every other option to true. When new text formats are added those will also be cleared. When true, all other clear option values are ignored."""

    clear_background_color: Annotated[
        Optional[bool], pydantic.Field(alias="clearBackgroundColor")
    ] = False
    r"""Whether or not clear the background color."""

    clear_bold: Annotated[Optional[bool], pydantic.Field(alias="clearBold")] = False
    r"""Whether or not clear the bold format."""

    clear_character_spacing: Annotated[
        Optional[bool], pydantic.Field(alias="clearCharacterSpacing")
    ] = False
    r"""Whether or not clear the character spacing."""

    clear_font: Annotated[Optional[bool], pydantic.Field(alias="clearFont")] = False
    r"""Whether or not to clear the font."""

    clear_italic: Annotated[Optional[bool], pydantic.Field(alias="clearItalic")] = False
    r"""Whether or not clear the italic format."""

    clear_size: Annotated[Optional[bool], pydantic.Field(alias="clearSize")] = False
    r"""Whether or not clear the font size."""

    clear_strike_through: Annotated[
        Optional[bool], pydantic.Field(alias="clearStrikeThrough")
    ] = False
    r"""Whether or not clear the strikethrough."""

    clear_text_color: Annotated[
        Optional[bool], pydantic.Field(alias="clearTextColor")
    ] = False
    r"""Whether or not clear the text color."""

    clear_underline: Annotated[
        Optional[bool], pydantic.Field(alias="clearUnderline")
    ] = False
    r"""Whether or not clear the underline."""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            [
                "clearAll",
                "clearBackgroundColor",
                "clearBold",
                "clearCharacterSpacing",
                "clearFont",
                "clearItalic",
                "clearSize",
                "clearStrikeThrough",
                "clearTextColor",
                "clearUnderline",
            ]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class ClearCellsPropertiesTypedDict(TypedDict):
    r"""Clears the cell properties from all the cells in the given ranges of a table. This will not clear out styles, formats, or hyperlinks."""

    ranges: List[CellRangeTypedDict]
    r"""A collection of cell ranges in a table.

    """
    clear_all: NotRequired[bool]
    r"""Whether to clear all cell properties.
    This is the same as setting every other option to true. When new cell properties are added those will also be cleared.
    When true, all other clear option values are ignored.

    """
    clear_fill_color: NotRequired[bool]
    r"""Whether to clear the fill color."""
    clear_horizontal_alignment: NotRequired[bool]
    r"""Whether to clear the horizontal alignment."""
    clear_indent: NotRequired[bool]
    r"""Whether to clear the indent."""
    clear_vertical_alignment: NotRequired[bool]
    r"""Whether to clear the vertical alignment."""


class ClearCellsProperties(BaseModel):
    r"""Clears the cell properties from all the cells in the given ranges of a table. This will not clear out styles, formats, or hyperlinks."""

    ranges: List[CellRange]
    r"""A collection of cell ranges in a table.

    """

    clear_all: Annotated[Optional[bool], pydantic.Field(alias="clearAll")] = False
    r"""Whether to clear all cell properties.
    This is the same as setting every other option to true. When new cell properties are added those will also be cleared.
    When true, all other clear option values are ignored.

    """

    clear_fill_color: Annotated[
        Optional[bool], pydantic.Field(alias="clearFillColor")
    ] = False
    r"""Whether to clear the fill color."""

    clear_horizontal_alignment: Annotated[
        Optional[bool], pydantic.Field(alias="clearHorizontalAlignment")
    ] = False
    r"""Whether to clear the horizontal alignment."""

    clear_indent: Annotated[Optional[bool], pydantic.Field(alias="clearIndent")] = False
    r"""Whether to clear the indent."""

    clear_vertical_alignment: Annotated[
        Optional[bool], pydantic.Field(alias="clearVerticalAlignment")
    ] = False
    r"""Whether to clear the vertical alignment."""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            [
                "clearAll",
                "clearFillColor",
                "clearHorizontalAlignment",
                "clearIndent",
                "clearVerticalAlignment",
            ]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class ClearCellsTextTypedDict(TypedDict):
    r"""Deletes the text from all the cells in the ranges of a table. This will not remove the text formatting applied to the cells. The cells locations will remain, although empty, even if a complete row or column is specified by the range."""

    ranges: List[CellRangeTypedDict]
    r"""A collection of cell ranges in a table.

    """


class ClearCellsText(BaseModel):
    r"""Deletes the text from all the cells in the ranges of a table. This will not remove the text formatting applied to the cells. The cells locations will remain, although empty, even if a complete row or column is specified by the range."""

    ranges: List[CellRange]
    r"""A collection of cell ranges in a table.

    """


class BaselineShift(str, Enum):
    r"""baseline shift apply to the text"""

    BASELINE = "baseline"
    SUPERSCRIPT = "superscript"
    SUBSCRIPT = "subscript"


class FormatCellsTypedDict(TypedDict):
    r"""Applies formatting to cells in the given ranges of a table. Null properties are ignored."""

    ranges: List[CellRangeTypedDict]
    r"""A collection of cell ranges in a table.

    """
    background_color: NotRequired[Nullable[str]]
    r"""color to apply to the background represented as a hex-code"""
    baseline_shift: NotRequired[Nullable[BaselineShift]]
    r"""baseline shift apply to the text"""
    bold: NotRequired[Nullable[bool]]
    r"""whether or not to bold the text"""
    character_spacing: NotRequired[Nullable[int]]
    r"""space between characters"""
    font: NotRequired[Nullable[str]]
    r"""name of the font"""
    italic: NotRequired[Nullable[bool]]
    r"""whether or not to italicise the text"""
    size: NotRequired[Nullable[float]]
    r"""font size in points"""
    strikethrough: NotRequired[Nullable[bool]]
    r"""whether or not to apply strikethrough to the text"""
    text_color: NotRequired[ColorTypedDict]
    r"""Represents a color."""
    underline: NotRequired[Nullable[bool]]
    r"""whether or not to underline the text"""


class FormatCells(BaseModel):
    r"""Applies formatting to cells in the given ranges of a table. Null properties are ignored."""

    ranges: List[CellRange]
    r"""A collection of cell ranges in a table.

    """

    background_color: Annotated[
        OptionalNullable[str], pydantic.Field(alias="backgroundColor")
    ] = UNSET
    r"""color to apply to the background represented as a hex-code"""

    baseline_shift: Annotated[
        OptionalNullable[BaselineShift], pydantic.Field(alias="baselineShift")
    ] = UNSET
    r"""baseline shift apply to the text"""

    bold: OptionalNullable[bool] = UNSET
    r"""whether or not to bold the text"""

    character_spacing: Annotated[
        OptionalNullable[int], pydantic.Field(alias="characterSpacing")
    ] = UNSET
    r"""space between characters"""

    font: OptionalNullable[str] = UNSET
    r"""name of the font"""

    italic: OptionalNullable[bool] = UNSET
    r"""whether or not to italicise the text"""

    size: OptionalNullable[float] = UNSET
    r"""font size in points"""

    strikethrough: OptionalNullable[bool] = UNSET
    r"""whether or not to apply strikethrough to the text"""

    text_color: Annotated[Optional[Color], pydantic.Field(alias="textColor")] = None
    r"""Represents a color."""

    underline: OptionalNullable[bool] = UNSET
    r"""whether or not to underline the text"""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            [
                "backgroundColor",
                "baselineShift",
                "bold",
                "characterSpacing",
                "font",
                "italic",
                "size",
                "strikethrough",
                "textColor",
                "underline",
            ]
        )
        nullable_fields = set(
            [
                "backgroundColor",
                "baselineShift",
                "bold",
                "characterSpacing",
                "font",
                "italic",
                "size",
                "strikethrough",
                "underline",
            ]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            is_nullable_and_explicitly_set = (
                k in nullable_fields
                and (self.__pydantic_fields_set__.intersection({n}))  # pylint: disable=no-member
            )

            if val != UNSET_SENTINEL:
                if (
                    val is not None
                    or k not in optional_fields
                    or is_nullable_and_explicitly_set
                ):
                    m[k] = val

        return m


class RichCellBatchEditTypedDict(TypedDict):
    r"""Collection of edits to perform on the rich text of a cell in the table."""

    cell: CellTypedDict
    r"""A cell indicates a single cell in a table. All indexes are zero based.

    """
    data: List[TextEditTypedDict]
    isolate_edits: bool
    r"""Whether the edits in a batch should be isolated from one-another. The edits will still be applied in order, but subsequent edits are unaffected by the previous edits in the same batch. For example, if one edit inserts some content, the next edits will act as if the content doesn't exist yet. Or if an edit deletes some content, the next edits will act as if the content is still there. This mode makes it easier to apply many edits on existing content because you don't need to manually keep track of how the previous edits have moved the content. For example, if you want to replace all instances of one word with another it will be easier to do this with isolated edits."""


class RichCellBatchEdit(BaseModel):
    r"""Collection of edits to perform on the rich text of a cell in the table."""

    cell: Cell
    r"""A cell indicates a single cell in a table. All indexes are zero based.

    """

    data: List[TextEdit]

    isolate_edits: Annotated[bool, pydantic.Field(alias="isolateEdits")]
    r"""Whether the edits in a batch should be isolated from one-another. The edits will still be applied in order, but subsequent edits are unaffected by the previous edits in the same batch. For example, if one edit inserts some content, the next edits will act as if the content doesn't exist yet. Or if an edit deletes some content, the next edits will act as if the content is still there. This mode makes it easier to apply many edits on existing content because you don't need to manually keep track of how the previous edits have moved the content. For example, if you want to replace all instances of one word with another it will be easier to do this with isolated edits."""


class TableCellsEditSchemasSetCellsBordersBottomStyle(str, Enum):
    r"""The style of the border to apply."""

    SINGLE = "single"
    DOUBLE = "double"
    DASHED1 = "dashed1"
    DASHED2 = "dashed2"
    DASHED3 = "dashed3"
    DASHED4 = "dashed4"
    DASHED5 = "dashed5"


class BottomTypedDict(TypedDict):
    r"""The border of a rectangle for properties of objects such as a table cell."""

    color: ColorTypedDict
    r"""Represents a color."""
    style: TableCellsEditSchemasSetCellsBordersBottomStyle
    r"""The style of the border to apply."""
    weight: float
    r"""The thickness of the border, in points. Rounded to the nearest hundredth."""


class Bottom(BaseModel):
    r"""The border of a rectangle for properties of objects such as a table cell."""

    color: Color
    r"""Represents a color."""

    style: TableCellsEditSchemasSetCellsBordersBottomStyle
    r"""The style of the border to apply."""

    weight: float
    r"""The thickness of the border, in points. Rounded to the nearest hundredth."""


class TableCellsEditStyle(str, Enum):
    r"""The style of the border to apply."""

    SINGLE = "single"
    DOUBLE = "double"
    DASHED1 = "dashed1"
    DASHED2 = "dashed2"
    DASHED3 = "dashed3"
    DASHED4 = "dashed4"
    DASHED5 = "dashed5"


class LeftTypedDict(TypedDict):
    r"""The border of a rectangle for properties of objects such as a table cell."""

    color: ColorTypedDict
    r"""Represents a color."""
    style: TableCellsEditStyle
    r"""The style of the border to apply."""
    weight: float
    r"""The thickness of the border, in points. Rounded to the nearest hundredth."""


class Left(BaseModel):
    r"""The border of a rectangle for properties of objects such as a table cell."""

    color: Color
    r"""Represents a color."""

    style: TableCellsEditStyle
    r"""The style of the border to apply."""

    weight: float
    r"""The thickness of the border, in points. Rounded to the nearest hundredth."""


class TableCellsEditSchemasStyle(str, Enum):
    r"""The style of the border to apply."""

    SINGLE = "single"
    DOUBLE = "double"
    DASHED1 = "dashed1"
    DASHED2 = "dashed2"
    DASHED3 = "dashed3"
    DASHED4 = "dashed4"
    DASHED5 = "dashed5"


class RightTypedDict(TypedDict):
    r"""The border of a rectangle for properties of objects such as a table cell."""

    color: ColorTypedDict
    r"""Represents a color."""
    style: TableCellsEditSchemasStyle
    r"""The style of the border to apply."""
    weight: float
    r"""The thickness of the border, in points. Rounded to the nearest hundredth."""


class Right(BaseModel):
    r"""The border of a rectangle for properties of objects such as a table cell."""

    color: Color
    r"""Represents a color."""

    style: TableCellsEditSchemasStyle
    r"""The style of the border to apply."""

    weight: float
    r"""The thickness of the border, in points. Rounded to the nearest hundredth."""


class TableCellsEditSchemasSetCellsBordersStyle(str, Enum):
    r"""The style of the border to apply."""

    SINGLE = "single"
    DOUBLE = "double"
    DASHED1 = "dashed1"
    DASHED2 = "dashed2"
    DASHED3 = "dashed3"
    DASHED4 = "dashed4"
    DASHED5 = "dashed5"


class TopTypedDict(TypedDict):
    r"""The border of a rectangle for properties of objects such as a table cell."""

    color: ColorTypedDict
    r"""Represents a color."""
    style: TableCellsEditSchemasSetCellsBordersStyle
    r"""The style of the border to apply."""
    weight: float
    r"""The thickness of the border, in points. Rounded to the nearest hundredth."""


class Top(BaseModel):
    r"""The border of a rectangle for properties of objects such as a table cell."""

    color: Color
    r"""Represents a color."""

    style: TableCellsEditSchemasSetCellsBordersStyle
    r"""The style of the border to apply."""

    weight: float
    r"""The thickness of the border, in points. Rounded to the nearest hundredth."""


class SetCellsBordersTypedDict(TypedDict):
    r"""Applies borders to cells in the given ranges of a table."""

    ranges: List[CellRangeTypedDict]
    r"""A collection of cell ranges in a table.

    """
    bottom: NotRequired[Nullable[BottomTypedDict]]
    left: NotRequired[Nullable[LeftTypedDict]]
    right: NotRequired[Nullable[RightTypedDict]]
    top: NotRequired[Nullable[TopTypedDict]]


class SetCellsBorders(BaseModel):
    r"""Applies borders to cells in the given ranges of a table."""

    ranges: List[CellRange]
    r"""A collection of cell ranges in a table.

    """

    bottom: OptionalNullable[Bottom] = UNSET

    left: OptionalNullable[Left] = UNSET

    right: OptionalNullable[Right] = UNSET

    top: OptionalNullable[Top] = UNSET

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["bottom", "left", "right", "top"])
        nullable_fields = set(["bottom", "left", "right", "top"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            is_nullable_and_explicitly_set = (
                k in nullable_fields
                and (self.__pydantic_fields_set__.intersection({n}))  # pylint: disable=no-member
            )

            if val != UNSET_SENTINEL:
                if (
                    val is not None
                    or k not in optional_fields
                    or is_nullable_and_explicitly_set
                ):
                    m[k] = val

        return m


class SetCellsLockTypedDict(TypedDict):
    r"""Locks or unlocks cells in the given ranges of a table. The operation will no-op if the cell is already in the state associated with the lock."""

    lock: bool
    r"""Whether to lock or unlock the ranges of cells."""
    ranges: List[CellRangeTypedDict]
    r"""A collection of cell ranges in a table.

    """


class SetCellsLock(BaseModel):
    r"""Locks or unlocks cells in the given ranges of a table. The operation will no-op if the cell is already in the state associated with the lock."""

    lock: bool
    r"""Whether to lock or unlock the ranges of cells."""

    ranges: List[CellRange]
    r"""A collection of cell ranges in a table.

    """


class TableCellsEditFillColorTypedDict(TypedDict):
    r"""The fill color in RGB format"""

    blue: int
    r"""The blue component of the color."""
    green: int
    r"""The green component of the color."""
    red: int
    r"""The red component of the color."""


class TableCellsEditFillColor(BaseModel):
    r"""The fill color in RGB format"""

    blue: int
    r"""The blue component of the color."""

    green: int
    r"""The green component of the color."""

    red: int
    r"""The red component of the color."""


class HorizontalAlignment(str, Enum):
    r"""The horizontal alignment of the content in the cell."""

    LEFT = "left"
    CENTER = "center"
    RIGHT = "right"
    JUSTIFIED = "justified"


class TableCellsEditVerticalAlignment(str, Enum):
    r"""The vertical alignment of the content in the cell."""

    TOP = "top"
    MIDDLE = "middle"
    BOTTOM = "bottom"


class SetCellsPropertiesTypedDict(TypedDict):
    r"""Applies properties to cells in the given ranges of a table."""

    ranges: List[CellRangeTypedDict]
    r"""A collection of cell ranges in a table.

    """
    fill_color: NotRequired[Nullable[TableCellsEditFillColorTypedDict]]
    r"""The fill color in RGB format"""
    horizontal_alignment: NotRequired[Nullable[HorizontalAlignment]]
    r"""The horizontal alignment of the content in the cell."""
    indent: NotRequired[Nullable[float]]
    r"""The indentation of content in the cell."""
    vertical_alignment: NotRequired[Nullable[TableCellsEditVerticalAlignment]]
    r"""The vertical alignment of the content in the cell."""


class SetCellsProperties(BaseModel):
    r"""Applies properties to cells in the given ranges of a table."""

    ranges: List[CellRange]
    r"""A collection of cell ranges in a table.

    """

    fill_color: Annotated[
        OptionalNullable[TableCellsEditFillColor], pydantic.Field(alias="fillColor")
    ] = UNSET
    r"""The fill color in RGB format"""

    horizontal_alignment: Annotated[
        OptionalNullable[HorizontalAlignment],
        pydantic.Field(alias="horizontalAlignment"),
    ] = UNSET
    r"""The horizontal alignment of the content in the cell."""

    indent: OptionalNullable[float] = UNSET
    r"""The indentation of content in the cell."""

    vertical_alignment: Annotated[
        OptionalNullable[TableCellsEditVerticalAlignment],
        pydantic.Field(alias="verticalAlignment"),
    ] = UNSET
    r"""The vertical alignment of the content in the cell."""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            ["fillColor", "horizontalAlignment", "indent", "verticalAlignment"]
        )
        nullable_fields = set(
            ["fillColor", "horizontalAlignment", "indent", "verticalAlignment"]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            is_nullable_and_explicitly_set = (
                k in nullable_fields
                and (self.__pydantic_fields_set__.intersection({n}))  # pylint: disable=no-member
            )

            if val != UNSET_SENTINEL:
                if (
                    val is not None
                    or k not in optional_fields
                    or is_nullable_and_explicitly_set
                ):
                    m[k] = val

        return m


class SetCellsStyleTypedDict(TypedDict):
    r"""Applies a style to cells in the given ranges of a table. The \"Normal\" text style is not supported in table cells. Use the \"Table (Normal)\" style to apply normal styles to text in a table cell."""

    ranges: List[CellRangeTypedDict]
    r"""A collection of cell ranges in a table.

    """
    style: str
    r"""The unique identifier of a style."""


class SetCellsStyle(BaseModel):
    r"""Applies a style to cells in the given ranges of a table. The \"Normal\" text style is not supported in table cells. Use the \"Table (Normal)\" style to apply normal styles to text in a table cell."""

    ranges: List[CellRange]
    r"""A collection of cell ranges in a table.

    """

    style: str
    r"""The unique identifier of a style."""


class SetCellsTextTypedDict(TypedDict):
    r"""Writes text to a range of a table. This will overwrite any existing text with the given text. Cell properties and some formatting will be preserved. Some formatting on text will be removed by the overwrite.
    The provided text may not be larger than the specified range. Any null or missing elements in the text will not modify the corresponding cell.

    """

    range: CellRangeTypedDict
    r"""A range of cells in a table. If any field is omitted or null, the range is unbounded in that direction. All indexes  are zero based.

    """
    text: List[List[str]]


class SetCellsText(BaseModel):
    r"""Writes text to a range of a table. This will overwrite any existing text with the given text. Cell properties and some formatting will be preserved. Some formatting on text will be removed by the overwrite.
    The provided text may not be larger than the specified range. Any null or missing elements in the text will not modify the corresponding cell.

    """

    range: CellRange
    r"""A range of cells in a table. If any field is omitted or null, the range is unbounded in that direction. All indexes  are zero based.

    """

    text: List[List[str]]


class SetInputCellsTypedDict(TypedDict):
    r"""Sets the input cells for a range of cells in a table. Setting input cells requires the input mode ability. The operation will no-op if the cell is already in the state associated with the input cell."""

    ranges: List[CellRangeTypedDict]
    r"""A collection of cell ranges in a table.

    """
    input_cell: bool
    r"""Whether the cells should be input cells."""


class SetInputCells(BaseModel):
    r"""Sets the input cells for a range of cells in a table. Setting input cells requires the input mode ability. The operation will no-op if the cell is already in the state associated with the input cell."""

    ranges: List[CellRange]
    r"""A collection of cell ranges in a table.

    """

    input_cell: Annotated[bool, pydantic.Field(alias="inputCell")]
    r"""Whether the cells should be input cells."""


class TableCellsEditType(str, Enum):
    r"""The type of cells edit"""

    CLEAR_CELLS_BORDERS = "clearCellsBorders"
    CLEAR_CELLS_FORMAT = "clearCellsFormat"
    CLEAR_CELLS_PROPERTIES = "clearCellsProperties"
    CLEAR_CELLS_TEXT = "clearCellsText"
    FORMAT_CELLS = "formatCells"
    RICH_CELL_BATCH_EDIT = "richCellBatchEdit"
    SET_CELLS_BORDERS = "setCellsBorders"
    SET_CELLS_LOCK = "setCellsLock"
    SET_CELLS_PROPERTIES = "setCellsProperties"
    SET_CELLS_STYLE = "setCellsStyle"
    SET_CELLS_TEXT = "setCellsText"
    SET_INPUT_CELLS = "setInputCells"


class TableCellsEditTypedDict(TypedDict):
    r"""An edit for modifying a table cells. The edit property associated with the edit type is required. Any edit property that doesn't correspond to its type will be ignored."""

    type: TableCellsEditType
    r"""The type of cells edit"""
    clear_cells_borders: NotRequired[Nullable[ClearCellsBordersTypedDict]]
    clear_cells_format: NotRequired[Nullable[ClearCellsFormatTypedDict]]
    clear_cells_properties: NotRequired[Nullable[ClearCellsPropertiesTypedDict]]
    clear_cells_text: NotRequired[Nullable[ClearCellsTextTypedDict]]
    format_cells: NotRequired[Nullable[FormatCellsTypedDict]]
    rich_cell_batch_edit: NotRequired[Nullable[RichCellBatchEditTypedDict]]
    set_cells_borders: NotRequired[Nullable[SetCellsBordersTypedDict]]
    set_cells_lock: NotRequired[Nullable[SetCellsLockTypedDict]]
    set_cells_properties: NotRequired[Nullable[SetCellsPropertiesTypedDict]]
    set_cells_style: NotRequired[Nullable[SetCellsStyleTypedDict]]
    set_cells_text: NotRequired[Nullable[SetCellsTextTypedDict]]
    set_input_cells: NotRequired[Nullable[SetInputCellsTypedDict]]


class TableCellsEdit(BaseModel):
    r"""An edit for modifying a table cells. The edit property associated with the edit type is required. Any edit property that doesn't correspond to its type will be ignored."""

    type: TableCellsEditType
    r"""The type of cells edit"""

    clear_cells_borders: Annotated[
        OptionalNullable[ClearCellsBorders], pydantic.Field(alias="clearCellsBorders")
    ] = UNSET

    clear_cells_format: Annotated[
        OptionalNullable[ClearCellsFormat], pydantic.Field(alias="clearCellsFormat")
    ] = UNSET

    clear_cells_properties: Annotated[
        OptionalNullable[ClearCellsProperties],
        pydantic.Field(alias="clearCellsProperties"),
    ] = UNSET

    clear_cells_text: Annotated[
        OptionalNullable[ClearCellsText], pydantic.Field(alias="clearCellsText")
    ] = UNSET

    format_cells: Annotated[
        OptionalNullable[FormatCells], pydantic.Field(alias="formatCells")
    ] = UNSET

    rich_cell_batch_edit: Annotated[
        OptionalNullable[RichCellBatchEdit], pydantic.Field(alias="richCellBatchEdit")
    ] = UNSET

    set_cells_borders: Annotated[
        OptionalNullable[SetCellsBorders], pydantic.Field(alias="setCellsBorders")
    ] = UNSET

    set_cells_lock: Annotated[
        OptionalNullable[SetCellsLock], pydantic.Field(alias="setCellsLock")
    ] = UNSET

    set_cells_properties: Annotated[
        OptionalNullable[SetCellsProperties], pydantic.Field(alias="setCellsProperties")
    ] = UNSET

    set_cells_style: Annotated[
        OptionalNullable[SetCellsStyle], pydantic.Field(alias="setCellsStyle")
    ] = UNSET

    set_cells_text: Annotated[
        OptionalNullable[SetCellsText], pydantic.Field(alias="setCellsText")
    ] = UNSET

    set_input_cells: Annotated[
        OptionalNullable[SetInputCells], pydantic.Field(alias="setInputCells")
    ] = UNSET

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            [
                "clearCellsBorders",
                "clearCellsFormat",
                "clearCellsProperties",
                "clearCellsText",
                "formatCells",
                "richCellBatchEdit",
                "setCellsBorders",
                "setCellsLock",
                "setCellsProperties",
                "setCellsStyle",
                "setCellsText",
                "setInputCells",
            ]
        )
        nullable_fields = set(
            [
                "clearCellsBorders",
                "clearCellsFormat",
                "clearCellsProperties",
                "clearCellsText",
                "formatCells",
                "richCellBatchEdit",
                "setCellsBorders",
                "setCellsLock",
                "setCellsProperties",
                "setCellsStyle",
                "setCellsText",
                "setInputCells",
            ]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            is_nullable_and_explicitly_set = (
                k in nullable_fields
                and (self.__pydantic_fields_set__.intersection({n}))  # pylint: disable=no-member
            )

            if val != UNSET_SENTINEL:
                if (
                    val is not None
                    or k not in optional_fields
                    or is_nullable_and_explicitly_set
                ):
                    m[k] = val

        return m
