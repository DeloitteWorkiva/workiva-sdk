"""Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT."""

from __future__ import annotations
from .activityaction import ActivityAction, ActivityActionTypedDict
from .activityattachments import ActivityAttachments, ActivityAttachmentsTypedDict
from .organization import Organization, OrganizationTypedDict
from .outcome import Outcome
from .performer import Performer, PerformerTypedDict
from .solution import Solution, SolutionTypedDict
from .target import Target, TargetTypedDict
from datetime import datetime
from enum import Enum
import pydantic
from pydantic import field_serializer, model_serializer
from typing import List, Optional
from typing_extensions import Annotated, NotRequired, TypedDict
from workiva import models, utils
from workiva.types import BaseModel, Nullable, OptionalNullable, UNSET, UNSET_SENTINEL


class ActivityUserTypedDict(TypedDict):
    r"""A user refernenced by their unique identifier"""

    id: NotRequired[str]
    r"""The unique identifier of the user"""


class ActivityUser(BaseModel):
    r"""A user refernenced by their unique identifier"""

    id: Optional[str] = None
    r"""The unique identifier of the user"""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["id"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class ActivityCreatedTypedDict(TypedDict):
    r"""When the action was performed, and details about the user who did it"""

    date_time: NotRequired[datetime]
    r"""When the action was performed"""
    user: NotRequired[Nullable[ActivityUserTypedDict]]


class ActivityCreated(BaseModel):
    r"""When the action was performed, and details about the user who did it"""

    date_time: Annotated[Optional[datetime], pydantic.Field(alias="dateTime")] = None
    r"""When the action was performed"""

    user: OptionalNullable[ActivityUser] = UNSET

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["dateTime", "user"])
        nullable_fields = set(["user"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            is_nullable_and_explicitly_set = (
                k in nullable_fields
                and (self.__pydantic_fields_set__.intersection({n}))  # pylint: disable=no-member
            )

            if val != UNSET_SENTINEL:
                if (
                    val is not None
                    or k not in optional_fields
                    or is_nullable_and_explicitly_set
                ):
                    m[k] = val

        return m


class ActivitySchemasUserTypedDict(TypedDict):
    r"""A user refernenced by their unique identifier"""

    id: NotRequired[str]
    r"""The unique identifier of the user"""


class ActivitySchemasUser(BaseModel):
    r"""A user refernenced by their unique identifier"""

    id: Optional[str] = None
    r"""The unique identifier of the user"""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["id"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class ActivityModifiedTypedDict(TypedDict):
    r"""When the action was performed, and details about the user who did it"""

    date_time: NotRequired[datetime]
    r"""When the action was performed"""
    user: NotRequired[Nullable[ActivitySchemasUserTypedDict]]


class ActivityModified(BaseModel):
    r"""When the action was performed, and details about the user who did it"""

    date_time: Annotated[Optional[datetime], pydantic.Field(alias="dateTime")] = None
    r"""When the action was performed"""

    user: OptionalNullable[ActivitySchemasUser] = UNSET

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["dateTime", "user"])
        nullable_fields = set(["user"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            is_nullable_and_explicitly_set = (
                k in nullable_fields
                and (self.__pydantic_fields_set__.intersection({n}))  # pylint: disable=no-member
            )

            if val != UNSET_SENTINEL:
                if (
                    val is not None
                    or k not in optional_fields
                    or is_nullable_and_explicitly_set
                ):
                    m[k] = val

        return m


class ActivitySchemasWorkspaceUserTypedDict(TypedDict):
    r"""A user refernenced by their unique identifier"""

    id: NotRequired[str]
    r"""The unique identifier of the user"""


class ActivitySchemasWorkspaceUser(BaseModel):
    r"""A user refernenced by their unique identifier"""

    id: Optional[str] = None
    r"""The unique identifier of the user"""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["id"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class ActivitySchemasCreatedTypedDict(TypedDict):
    r"""When the action was performed, and details about the user who did it"""

    date_time: NotRequired[datetime]
    r"""When the action was performed"""
    user: NotRequired[Nullable[ActivitySchemasWorkspaceUserTypedDict]]


class ActivitySchemasCreated(BaseModel):
    r"""When the action was performed, and details about the user who did it"""

    date_time: Annotated[Optional[datetime], pydantic.Field(alias="dateTime")] = None
    r"""When the action was performed"""

    user: OptionalNullable[ActivitySchemasWorkspaceUser] = UNSET

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["dateTime", "user"])
        nullable_fields = set(["user"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            is_nullable_and_explicitly_set = (
                k in nullable_fields
                and (self.__pydantic_fields_set__.intersection({n}))  # pylint: disable=no-member
            )

            if val != UNSET_SENTINEL:
                if (
                    val is not None
                    or k not in optional_fields
                    or is_nullable_and_explicitly_set
                ):
                    m[k] = val

        return m


class ActivitySchemasWorkspaceOrganizationUserTypedDict(TypedDict):
    r"""A user refernenced by their unique identifier"""

    id: NotRequired[str]
    r"""The unique identifier of the user"""


class ActivitySchemasWorkspaceOrganizationUser(BaseModel):
    r"""A user refernenced by their unique identifier"""

    id: Optional[str] = None
    r"""The unique identifier of the user"""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["id"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class ActivitySchemasModifiedTypedDict(TypedDict):
    r"""When the action was performed, and details about the user who did it"""

    date_time: NotRequired[datetime]
    r"""When the action was performed"""
    user: NotRequired[Nullable[ActivitySchemasWorkspaceOrganizationUserTypedDict]]


class ActivitySchemasModified(BaseModel):
    r"""When the action was performed, and details about the user who did it"""

    date_time: Annotated[Optional[datetime], pydantic.Field(alias="dateTime")] = None
    r"""When the action was performed"""

    user: OptionalNullable[ActivitySchemasWorkspaceOrganizationUser] = UNSET

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["dateTime", "user"])
        nullable_fields = set(["user"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            is_nullable_and_explicitly_set = (
                k in nullable_fields
                and (self.__pydantic_fields_set__.intersection({n}))  # pylint: disable=no-member
            )

            if val != UNSET_SENTINEL:
                if (
                    val is not None
                    or k not in optional_fields
                    or is_nullable_and_explicitly_set
                ):
                    m[k] = val

        return m


class ActivityStatus(str, Enum, metaclass=utils.OpenEnumMeta):
    ACTIVE = "active"
    INACTIVE = "inactive"


class ActivityOrganizationTypedDict(TypedDict):
    r"""The organization that this workspace belongs to"""

    created: NotRequired[ActivitySchemasCreatedTypedDict]
    id: NotRequired[str]
    r"""The unique identifier of the organization"""
    modified: NotRequired[ActivitySchemasModifiedTypedDict]
    name: NotRequired[str]
    r"""The name of the organization"""
    status: NotRequired[ActivityStatus]


class ActivityOrganization(BaseModel):
    r"""The organization that this workspace belongs to"""

    created: Optional[ActivitySchemasCreated] = None

    id: Optional[str] = None
    r"""The unique identifier of the organization"""

    modified: Optional[ActivitySchemasModified] = None

    name: Optional[str] = None
    r"""The name of the organization"""

    status: Optional[ActivityStatus] = None

    @field_serializer("status")
    def serialize_status(self, value):
        if isinstance(value, str):
            try:
                return models.ActivityStatus(value)
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["created", "id", "modified", "name", "status"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class ActivityWorkspaceTypedDict(TypedDict):
    r"""The workspace's ID and name"""

    created: NotRequired[Nullable[ActivityCreatedTypedDict]]
    id: NotRequired[Nullable[str]]
    r"""The unique identifier of the workspace"""
    modified: NotRequired[Nullable[ActivityModifiedTypedDict]]
    name: NotRequired[str]
    r"""The name of the workspace"""
    organization: NotRequired[Nullable[ActivityOrganizationTypedDict]]
    r"""The organization that this workspace belongs to"""
    solutions: NotRequired[Nullable[List[SolutionTypedDict]]]


class ActivityWorkspace(BaseModel):
    r"""The workspace's ID and name"""

    created: OptionalNullable[ActivityCreated] = UNSET

    id: OptionalNullable[str] = UNSET
    r"""The unique identifier of the workspace"""

    modified: OptionalNullable[ActivityModified] = UNSET

    name: Optional[str] = None
    r"""The name of the workspace"""

    organization: OptionalNullable[ActivityOrganization] = UNSET
    r"""The organization that this workspace belongs to"""

    solutions: OptionalNullable[List[Solution]] = UNSET

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            ["created", "id", "modified", "name", "organization", "solutions"]
        )
        nullable_fields = set(
            ["created", "id", "modified", "organization", "solutions"]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            is_nullable_and_explicitly_set = (
                k in nullable_fields
                and (self.__pydantic_fields_set__.intersection({n}))  # pylint: disable=no-member
            )

            if val != UNSET_SENTINEL:
                if (
                    val is not None
                    or k not in optional_fields
                    or is_nullable_and_explicitly_set
                ):
                    m[k] = val

        return m


class ActivityTypedDict(TypedDict):
    r"""Details about the activity"""

    action: ActivityActionTypedDict
    r"""Details about the activity action"""
    activity_date_time: datetime
    r"""When the activity occurred"""
    id: str
    r"""The unique identifier of the activity"""
    performer: PerformerTypedDict
    r"""Details about the resource that performed an activity"""
    targets: List[TargetTypedDict]
    attachments: NotRequired[List[ActivityAttachmentsTypedDict]]
    r"""An array of activity attachments which are generic JSON elements which can provide more context and information"""
    organization: NotRequired[OrganizationTypedDict]
    r"""The organization's ID and name"""
    outcome: NotRequired[Outcome]
    r"""Result of the activity action performed"""
    summary: NotRequired[str]
    r"""Summary of the activity performed"""
    tags: NotRequired[List[str]]
    r"""An array of tags for the activity"""
    workspace: NotRequired[Nullable[ActivityWorkspaceTypedDict]]
    r"""The workspace's ID and name"""


class Activity(BaseModel):
    r"""Details about the activity"""

    action: ActivityAction
    r"""Details about the activity action"""

    activity_date_time: Annotated[datetime, pydantic.Field(alias="activityDateTime")]
    r"""When the activity occurred"""

    id: str
    r"""The unique identifier of the activity"""

    performer: Performer
    r"""Details about the resource that performed an activity"""

    targets: List[Target]

    attachments: Optional[List[ActivityAttachments]] = None
    r"""An array of activity attachments which are generic JSON elements which can provide more context and information"""

    organization: Optional[Organization] = None
    r"""The organization's ID and name"""

    outcome: Optional[Outcome] = None
    r"""Result of the activity action performed"""

    summary: Optional[str] = None
    r"""Summary of the activity performed"""

    tags: Optional[List[str]] = None
    r"""An array of tags for the activity"""

    workspace: OptionalNullable[ActivityWorkspace] = UNSET
    r"""The workspace's ID and name"""

    @field_serializer("outcome")
    def serialize_outcome(self, value):
        if isinstance(value, str):
            try:
                return models.Outcome(value)
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            ["attachments", "organization", "outcome", "summary", "tags", "workspace"]
        )
        nullable_fields = set(["workspace"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            is_nullable_and_explicitly_set = (
                k in nullable_fields
                and (self.__pydantic_fields_set__.intersection({n}))  # pylint: disable=no-member
            )

            if val != UNSET_SENTINEL:
                if (
                    val is not None
                    or k not in optional_fields
                    or is_nullable_and_explicitly_set
                ):
                    m[k] = val

        return m
