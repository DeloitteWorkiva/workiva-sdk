"""Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT."""

from __future__ import annotations
from .background import Background, BackgroundTypedDict
from .footerproperties import FooterProperties, FooterPropertiesTypedDict
from .headerproperties import HeaderProperties, HeaderPropertiesTypedDict
from .margins import Margins, MarginsTypedDict
from enum import Enum
import pydantic
from pydantic import model_serializer
from typing import Any, List, Optional
from typing_extensions import Annotated, NotRequired, TypedDict
from workiva.types import BaseModel, Nullable, OptionalNullable, UNSET, UNSET_SENTINEL


class BodyTypedDict(TypedDict):
    r"""Reference to the RichText content for this section"""

    revision: NotRequired[str]
    r"""The revision of the rich text being referred to"""
    rich_text: NotRequired[str]


class Body(BaseModel):
    r"""Reference to the RichText content for this section"""

    revision: Optional[str] = None
    r"""The revision of the rich text being referred to"""

    rich_text: Annotated[Optional[str], pydantic.Field(alias="richText")] = None

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["revision", "richText"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class DrawingBodyTypedDict(TypedDict):
    r"""Reference to the Drawing content for this section"""

    drawing: NotRequired[str]
    r"""The unique identifier of the drawing being referred to"""
    revision: NotRequired[str]
    r"""Identifies a unique revision of content."""


class DrawingBody(BaseModel):
    r"""Reference to the Drawing content for this section"""

    drawing: Optional[str] = None
    r"""The unique identifier of the drawing being referred to"""

    revision: Optional[str] = None
    r"""Identifies a unique revision of content."""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["drawing", "revision"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class EvenTypedDict(TypedDict):
    r"""Reference to the RichText for even pages"""

    revision: NotRequired[str]
    r"""The revision of the rich text being referred to"""
    rich_text: NotRequired[str]


class Even(BaseModel):
    r"""Reference to the RichText for even pages"""

    revision: Optional[str] = None
    r"""The revision of the rich text being referred to"""

    rich_text: Annotated[Optional[str], pydantic.Field(alias="richText")] = None

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["revision", "richText"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class FirstTypedDict(TypedDict):
    r"""Reference to the RichText for the first header"""

    revision: NotRequired[str]
    r"""The revision of the rich text being referred to"""
    rich_text: NotRequired[str]


class First(BaseModel):
    r"""Reference to the RichText for the first header"""

    revision: Optional[str] = None
    r"""The revision of the rich text being referred to"""

    rich_text: Annotated[Optional[str], pydantic.Field(alias="richText")] = None

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["revision", "richText"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class LastTypedDict(TypedDict):
    r"""Reference to the RichText for the last header"""

    revision: NotRequired[str]
    r"""The revision of the rich text being referred to"""
    rich_text: NotRequired[str]


class Last(BaseModel):
    r"""Reference to the RichText for the last header"""

    revision: Optional[str] = None
    r"""The revision of the rich text being referred to"""

    rich_text: Annotated[Optional[str], pydantic.Field(alias="richText")] = None

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["revision", "richText"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class OddTypedDict(TypedDict):
    r"""Reference to the RichText for odd pages"""

    revision: NotRequired[str]
    r"""The revision of the rich text being referred to"""
    rich_text: NotRequired[str]


class Odd(BaseModel):
    r"""Reference to the RichText for odd pages"""

    revision: Optional[str] = None
    r"""The revision of the rich text being referred to"""

    rich_text: Annotated[Optional[str], pydantic.Field(alias="richText")] = None

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["revision", "richText"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class FootersTypedDict(TypedDict):
    r"""Footers for this section"""

    even: NotRequired[Nullable[EvenTypedDict]]
    r"""Reference to the RichText for even pages"""
    first: NotRequired[Nullable[FirstTypedDict]]
    r"""Reference to the RichText for the first header"""
    last: NotRequired[Nullable[LastTypedDict]]
    r"""Reference to the RichText for the last header"""
    odd: NotRequired[Nullable[OddTypedDict]]
    r"""Reference to the RichText for odd pages"""


class Footers(BaseModel):
    r"""Footers for this section"""

    even: OptionalNullable[Even] = UNSET
    r"""Reference to the RichText for even pages"""

    first: OptionalNullable[First] = UNSET
    r"""Reference to the RichText for the first header"""

    last: OptionalNullable[Last] = UNSET
    r"""Reference to the RichText for the last header"""

    odd: OptionalNullable[Odd] = UNSET
    r"""Reference to the RichText for odd pages"""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["even", "first", "last", "odd"])
        nullable_fields = set(["even", "first", "last", "odd"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            is_nullable_and_explicitly_set = (
                k in nullable_fields
                and (self.__pydantic_fields_set__.intersection({n}))  # pylint: disable=no-member
            )

            if val != UNSET_SENTINEL:
                if (
                    val is not None
                    or k not in optional_fields
                    or is_nullable_and_explicitly_set
                ):
                    m[k] = val

        return m


class SectionEvenTypedDict(TypedDict):
    r"""Reference to the RichText for even pages"""

    revision: NotRequired[str]
    r"""The revision of the rich text being referred to"""
    rich_text: NotRequired[str]


class SectionEven(BaseModel):
    r"""Reference to the RichText for even pages"""

    revision: Optional[str] = None
    r"""The revision of the rich text being referred to"""

    rich_text: Annotated[Optional[str], pydantic.Field(alias="richText")] = None

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["revision", "richText"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class SectionFirstTypedDict(TypedDict):
    r"""Reference to the RichText for the first header"""

    revision: NotRequired[str]
    r"""The revision of the rich text being referred to"""
    rich_text: NotRequired[str]


class SectionFirst(BaseModel):
    r"""Reference to the RichText for the first header"""

    revision: Optional[str] = None
    r"""The revision of the rich text being referred to"""

    rich_text: Annotated[Optional[str], pydantic.Field(alias="richText")] = None

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["revision", "richText"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class SectionLastTypedDict(TypedDict):
    r"""Reference to the RichText for the last header"""

    revision: NotRequired[str]
    r"""The revision of the rich text being referred to"""
    rich_text: NotRequired[str]


class SectionLast(BaseModel):
    r"""Reference to the RichText for the last header"""

    revision: Optional[str] = None
    r"""The revision of the rich text being referred to"""

    rich_text: Annotated[Optional[str], pydantic.Field(alias="richText")] = None

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["revision", "richText"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class SectionOddTypedDict(TypedDict):
    r"""Reference to the RichText for odd pages"""

    revision: NotRequired[str]
    r"""The revision of the rich text being referred to"""
    rich_text: NotRequired[str]


class SectionOdd(BaseModel):
    r"""Reference to the RichText for odd pages"""

    revision: Optional[str] = None
    r"""The revision of the rich text being referred to"""

    rich_text: Annotated[Optional[str], pydantic.Field(alias="richText")] = None

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["revision", "richText"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class HeadersTypedDict(TypedDict):
    r"""Headers for this section"""

    even: NotRequired[Nullable[SectionEvenTypedDict]]
    r"""Reference to the RichText for even pages"""
    first: NotRequired[Nullable[SectionFirstTypedDict]]
    r"""Reference to the RichText for the first header"""
    last: NotRequired[Nullable[SectionLastTypedDict]]
    r"""Reference to the RichText for the last header"""
    odd: NotRequired[Nullable[SectionOddTypedDict]]
    r"""Reference to the RichText for odd pages"""


class Headers(BaseModel):
    r"""Headers for this section"""

    even: OptionalNullable[SectionEven] = UNSET
    r"""Reference to the RichText for even pages"""

    first: OptionalNullable[SectionFirst] = UNSET
    r"""Reference to the RichText for the first header"""

    last: OptionalNullable[SectionLast] = UNSET
    r"""Reference to the RichText for the last header"""

    odd: OptionalNullable[SectionOdd] = UNSET
    r"""Reference to the RichText for odd pages"""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["even", "first", "last", "odd"])
        nullable_fields = set(["even", "first", "last", "odd"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            is_nullable_and_explicitly_set = (
                k in nullable_fields
                and (self.__pydantic_fields_set__.intersection({n}))  # pylint: disable=no-member
            )

            if val != UNSET_SENTINEL:
                if (
                    val is not None
                    or k not in optional_fields
                    or is_nullable_and_explicitly_set
                ):
                    m[k] = val

        return m


class SectionLock(str, Enum):
    r"""The type of lock applied to this section, if any. Note this property is not tied to revision and will always reflect the section's current lock state."""

    LOCK = "lock"


class ParentTypedDict(TypedDict):
    r"""Partial reference to the parent section"""

    id: NotRequired[str]
    name: NotRequired[str]


class Parent(BaseModel):
    r"""Partial reference to the parent section"""

    id: Optional[str] = None

    name: Optional[str] = None

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["id", "name"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class PageDimensionsTypedDict(TypedDict):
    r"""Dimensions of each page"""

    height: float
    r"""The vertical measurement in points."""
    width: float
    r"""The horizontal measurement in points."""


class PageDimensions(BaseModel):
    r"""Dimensions of each page"""

    height: float
    r"""The vertical measurement in points."""

    width: float
    r"""The horizontal measurement in points."""


class SectionSchemasPageNumberTypedDict(TypedDict):
    r"""Page number properties"""

    reset: NotRequired[bool]
    r"""Whether the page numbers should restart at the section"""
    start_at: NotRequired[int]
    r"""The page number to start numbering at in this section"""


class SectionSchemasPageNumber(BaseModel):
    r"""Page number properties"""

    reset: Optional[bool] = False
    r"""Whether the page numbers should restart at the section"""

    start_at: Annotated[Optional[int], pydantic.Field(alias="startAt")] = 1
    r"""The page number to start numbering at in this section"""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["reset", "startAt"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class SectionPropertiesTypedDict(TypedDict):
    r"""Properties of this section"""

    background: NotRequired[Nullable[BackgroundTypedDict]]
    r"""The formatting for a background color/image of a section (page), or slide/layout.

    """
    edgar_keep_together: NotRequired[Nullable[bool]]
    r"""Determines if page breaks should be ignored for this section in Edgar export

    """
    exhibit: NotRequired[Nullable[bool]]
    r"""Whether or not the section is an exhibit"""
    footer: NotRequired[Nullable[FooterPropertiesTypedDict]]
    r"""Properties for the footer"""
    header: NotRequired[Nullable[HeaderPropertiesTypedDict]]
    r"""Properties for the header"""
    margins: NotRequired[Nullable[MarginsTypedDict]]
    r"""Margins for each page"""
    page_break_before: NotRequired[bool]
    r"""Whether or not there should be a page break before the section"""
    page_dimensions: NotRequired[Nullable[PageDimensionsTypedDict]]
    r"""Dimensions of each page"""
    page_number: NotRequired[SectionSchemasPageNumberTypedDict]
    r"""Page number properties"""
    restart_footnote_numbering: NotRequired[bool]
    r"""Whether or not to restart footnote numbering in the section"""
    track_changes: NotRequired[bool]
    r"""Whether or not track changes is enabled"""


class SectionProperties(BaseModel):
    r"""Properties of this section"""

    background: OptionalNullable[Background] = UNSET
    r"""The formatting for a background color/image of a section (page), or slide/layout.

    """

    edgar_keep_together: Annotated[
        OptionalNullable[bool], pydantic.Field(alias="edgarKeepTogether")
    ] = False
    r"""Determines if page breaks should be ignored for this section in Edgar export

    """

    exhibit: OptionalNullable[bool] = False
    r"""Whether or not the section is an exhibit"""

    footer: OptionalNullable[FooterProperties] = UNSET
    r"""Properties for the footer"""

    header: OptionalNullable[HeaderProperties] = UNSET
    r"""Properties for the header"""

    margins: OptionalNullable[Margins] = UNSET
    r"""Margins for each page"""

    page_break_before: Annotated[
        Optional[bool], pydantic.Field(alias="pageBreakBefore")
    ] = False
    r"""Whether or not there should be a page break before the section"""

    page_dimensions: Annotated[
        OptionalNullable[PageDimensions], pydantic.Field(alias="pageDimensions")
    ] = UNSET
    r"""Dimensions of each page"""

    page_number: Annotated[
        Optional[SectionSchemasPageNumber], pydantic.Field(alias="pageNumber")
    ] = None
    r"""Page number properties"""

    restart_footnote_numbering: Annotated[
        Optional[bool], pydantic.Field(alias="restartFootnoteNumbering")
    ] = False
    r"""Whether or not to restart footnote numbering in the section"""

    track_changes: Annotated[Optional[bool], pydantic.Field(alias="trackChanges")] = (
        False
    )
    r"""Whether or not track changes is enabled"""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            [
                "background",
                "edgarKeepTogether",
                "exhibit",
                "footer",
                "header",
                "margins",
                "pageBreakBefore",
                "pageDimensions",
                "pageNumber",
                "restartFootnoteNumbering",
                "trackChanges",
            ]
        )
        nullable_fields = set(
            [
                "background",
                "edgarKeepTogether",
                "exhibit",
                "footer",
                "header",
                "margins",
                "pageDimensions",
            ]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            is_nullable_and_explicitly_set = (
                k in nullable_fields
                and (self.__pydantic_fields_set__.intersection({n}))  # pylint: disable=no-member
            )

            if val != UNSET_SENTINEL:
                if (
                    val is not None
                    or k not in optional_fields
                    or is_nullable_and_explicitly_set
                ):
                    m[k] = val

        return m


class SectionTypedDict(TypedDict):
    r"""Details about the section, including its ID and name."""

    body: NotRequired[Nullable[BodyTypedDict]]
    r"""Reference to the RichText content for this section"""
    drawing_body: NotRequired[Nullable[DrawingBodyTypedDict]]
    r"""Reference to the Drawing content for this section"""
    children: NotRequired[List[SectionTypedDict]]
    r"""An array of partial information about any sections within the section"""
    custom_fields: NotRequired[Any]
    r"""A map of ids to values representing Custom Fields on the section.

    """
    footers: NotRequired[Nullable[FootersTypedDict]]
    r"""Footers for this section"""
    headers: NotRequired[Nullable[HeadersTypedDict]]
    r"""Headers for this section"""
    id: NotRequired[Nullable[str]]
    r"""The unique identifier of the section"""
    index: NotRequired[int]
    r"""The integer index of the section relative to its parent section (or to the document if no parent section). The special value -1 may be used to position a section at the end of its siblings list."""
    lock: NotRequired[Nullable[SectionLock]]
    r"""The type of lock applied to this section, if any. Note this property is not tied to revision and will always reflect the section's current lock state."""
    name: NotRequired[str]
    r"""The name of the section"""
    non_printing: NotRequired[bool]
    r"""Whether or not the section is non-printing"""
    parent: NotRequired[Nullable[ParentTypedDict]]
    r"""Partial reference to the parent section"""
    properties: NotRequired[Nullable[SectionPropertiesTypedDict]]
    r"""Properties of this section"""
    revision: NotRequired[Nullable[str]]
    r"""Current revision of this section"""


class Section(BaseModel):
    r"""Details about the section, including its ID and name."""

    body: OptionalNullable[Body] = UNSET
    r"""Reference to the RichText content for this section"""

    drawing_body: Annotated[
        OptionalNullable[DrawingBody], pydantic.Field(alias="drawingBody")
    ] = UNSET
    r"""Reference to the Drawing content for this section"""

    children: Optional[List[Section]] = None
    r"""An array of partial information about any sections within the section"""

    custom_fields: Annotated[Optional[Any], pydantic.Field(alias="customFields")] = None
    r"""A map of ids to values representing Custom Fields on the section.

    """

    footers: OptionalNullable[Footers] = UNSET
    r"""Footers for this section"""

    headers: OptionalNullable[Headers] = UNSET
    r"""Headers for this section"""

    id: OptionalNullable[str] = UNSET
    r"""The unique identifier of the section"""

    index: Optional[int] = None
    r"""The integer index of the section relative to its parent section (or to the document if no parent section). The special value -1 may be used to position a section at the end of its siblings list."""

    lock: OptionalNullable[SectionLock] = UNSET
    r"""The type of lock applied to this section, if any. Note this property is not tied to revision and will always reflect the section's current lock state."""

    name: Optional[str] = None
    r"""The name of the section"""

    non_printing: Annotated[Optional[bool], pydantic.Field(alias="nonPrinting")] = None
    r"""Whether or not the section is non-printing"""

    parent: OptionalNullable[Parent] = UNSET
    r"""Partial reference to the parent section"""

    properties: OptionalNullable[SectionProperties] = UNSET
    r"""Properties of this section"""

    revision: OptionalNullable[str] = UNSET
    r"""Current revision of this section"""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            [
                "body",
                "drawingBody",
                "children",
                "customFields",
                "footers",
                "headers",
                "id",
                "index",
                "lock",
                "name",
                "nonPrinting",
                "parent",
                "properties",
                "revision",
            ]
        )
        nullable_fields = set(
            [
                "body",
                "drawingBody",
                "footers",
                "headers",
                "id",
                "lock",
                "parent",
                "properties",
                "revision",
            ]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            is_nullable_and_explicitly_set = (
                k in nullable_fields
                and (self.__pydantic_fields_set__.intersection({n}))  # pylint: disable=no-member
            )

            if val != UNSET_SENTINEL:
                if (
                    val is not None
                    or k not in optional_fields
                    or is_nullable_and_explicitly_set
                ):
                    m[k] = val

        return m


class SectionInputTypedDict(TypedDict):
    r"""Details about the section, including its ID and name."""

    custom_fields: NotRequired[Any]
    r"""A map of ids to values representing Custom Fields on the section.

    """
    id: NotRequired[Nullable[str]]
    r"""The unique identifier of the section"""
    index: NotRequired[int]
    r"""The integer index of the section relative to its parent section (or to the document if no parent section). The special value -1 may be used to position a section at the end of its siblings list."""
    lock: NotRequired[Nullable[SectionLock]]
    r"""The type of lock applied to this section, if any. Note this property is not tied to revision and will always reflect the section's current lock state."""
    name: NotRequired[str]
    r"""The name of the section"""
    non_printing: NotRequired[bool]
    r"""Whether or not the section is non-printing"""
    parent: NotRequired[Nullable[ParentTypedDict]]
    r"""Partial reference to the parent section"""


class SectionInput(BaseModel):
    r"""Details about the section, including its ID and name."""

    custom_fields: Annotated[Optional[Any], pydantic.Field(alias="customFields")] = None
    r"""A map of ids to values representing Custom Fields on the section.

    """

    id: OptionalNullable[str] = UNSET
    r"""The unique identifier of the section"""

    index: Optional[int] = None
    r"""The integer index of the section relative to its parent section (or to the document if no parent section). The special value -1 may be used to position a section at the end of its siblings list."""

    lock: OptionalNullable[SectionLock] = UNSET
    r"""The type of lock applied to this section, if any. Note this property is not tied to revision and will always reflect the section's current lock state."""

    name: Optional[str] = None
    r"""The name of the section"""

    non_printing: Annotated[Optional[bool], pydantic.Field(alias="nonPrinting")] = None
    r"""Whether or not the section is non-printing"""

    parent: OptionalNullable[Parent] = UNSET
    r"""Partial reference to the parent section"""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            ["customFields", "id", "index", "lock", "name", "nonPrinting", "parent"]
        )
        nullable_fields = set(["id", "lock", "parent"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            is_nullable_and_explicitly_set = (
                k in nullable_fields
                and (self.__pydantic_fields_set__.intersection({n}))  # pylint: disable=no-member
            )

            if val != UNSET_SENTINEL:
                if (
                    val is not None
                    or k not in optional_fields
                    or is_nullable_and_explicitly_set
                ):
                    m[k] = val

        return m
