"""Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT."""

from __future__ import annotations
from .cellhorizontalalignment import CellHorizontalAlignment
from .cellvalue import CellValue, CellValueTypedDict
from .color import Color, ColorTypedDict
from enum import Enum
import pydantic
from pydantic import field_serializer, model_serializer
from typing import Optional
from typing_extensions import Annotated, NotRequired, TypedDict
from workiva import models, utils
from workiva.types import BaseModel, Nullable, OptionalNullable, UNSET, UNSET_SENTINEL


class ChildOfTypedDict(TypedDict):
    r"""The parent cell containing the content associated with this cell's merge."""

    column: int
    r"""The zero-based index of a column in a table."""
    row: int
    r"""The zero-based index of a row in a table."""


class ChildOf(BaseModel):
    r"""The parent cell containing the content associated with this cell's merge."""

    column: int
    r"""The zero-based index of a column in a table."""

    row: int
    r"""The zero-based index of a row in a table."""


class ParentOfTypedDict(TypedDict):
    r"""The range of cells included in this cell's merge."""

    start_column: NotRequired[Nullable[int]]
    r"""The index of the first column (inclusive) of the range."""
    start_row: NotRequired[Nullable[int]]
    r"""The index of the first row (inclusive) of the range."""
    stop_column: NotRequired[Nullable[int]]
    r"""The index of the last column (inclusive) of the range."""
    stop_row: NotRequired[Nullable[int]]
    r"""The index of the last row (inclusive) of the range."""


class ParentOf(BaseModel):
    r"""The range of cells included in this cell's merge."""

    start_column: Annotated[
        OptionalNullable[int], pydantic.Field(alias="startColumn")
    ] = UNSET
    r"""The index of the first column (inclusive) of the range."""

    start_row: Annotated[OptionalNullable[int], pydantic.Field(alias="startRow")] = (
        UNSET
    )
    r"""The index of the first row (inclusive) of the range."""

    stop_column: Annotated[
        OptionalNullable[int], pydantic.Field(alias="stopColumn")
    ] = UNSET
    r"""The index of the last column (inclusive) of the range."""

    stop_row: Annotated[OptionalNullable[int], pydantic.Field(alias="stopRow")] = UNSET
    r"""The index of the last row (inclusive) of the range."""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["startColumn", "startRow", "stopColumn", "stopRow"])
        nullable_fields = set(["startColumn", "startRow", "stopColumn", "stopRow"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            is_nullable_and_explicitly_set = (
                k in nullable_fields
                and (self.__pydantic_fields_set__.intersection({n}))  # pylint: disable=no-member
            )

            if val != UNSET_SENTINEL:
                if (
                    val is not None
                    or k not in optional_fields
                    or is_nullable_and_explicitly_set
                ):
                    m[k] = val

        return m


class TableCellType(str, Enum, metaclass=utils.OpenEnumMeta):
    r"""The raw value or formula of the cell with no value formatting applied. This matches the formula bar value in the app."""

    PARENT_OF = "parentOf"
    CHILD_OF = "childOf"


class MergesTypedDict(TypedDict):
    r"""Describes whether the current cell is merged with other cells. If the cell is the top left cell in a merge the  parentOf type will be set. If a cell is not the top left cell in a merge the childOf type will be set."""

    type: TableCellType
    r"""The raw value or formula of the cell with no value formatting applied. This matches the formula bar value in the app."""
    child_of: NotRequired[Nullable[ChildOfTypedDict]]
    r"""The parent cell containing the content associated with this cell's merge."""
    parent_of: NotRequired[Nullable[ParentOfTypedDict]]
    r"""The range of cells included in this cell's merge."""


class Merges(BaseModel):
    r"""Describes whether the current cell is merged with other cells. If the cell is the top left cell in a merge the  parentOf type will be set. If a cell is not the top left cell in a merge the childOf type will be set."""

    type: TableCellType
    r"""The raw value or formula of the cell with no value formatting applied. This matches the formula bar value in the app."""

    child_of: Annotated[OptionalNullable[ChildOf], pydantic.Field(alias="childOf")] = (
        UNSET
    )
    r"""The parent cell containing the content associated with this cell's merge."""

    parent_of: Annotated[
        OptionalNullable[ParentOf], pydantic.Field(alias="parentOf")
    ] = UNSET
    r"""The range of cells included in this cell's merge."""

    @field_serializer("type")
    def serialize_type(self, value):
        if isinstance(value, str):
            try:
                return models.TableCellType(value)
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["childOf", "parentOf"])
        nullable_fields = set(["childOf", "parentOf"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            is_nullable_and_explicitly_set = (
                k in nullable_fields
                and (self.__pydantic_fields_set__.intersection({n}))  # pylint: disable=no-member
            )

            if val != UNSET_SENTINEL:
                if (
                    val is not None
                    or k not in optional_fields
                    or is_nullable_and_explicitly_set
                ):
                    m[k] = val

        return m


class TableCellSchemasPropertiesBordersStyle(str, Enum, metaclass=utils.OpenEnumMeta):
    r"""The style of the border to apply."""

    SINGLE = "single"
    DOUBLE = "double"
    DASHED1 = "dashed1"
    DASHED2 = "dashed2"
    DASHED3 = "dashed3"
    DASHED4 = "dashed4"
    DASHED5 = "dashed5"


class TableCellBottomTypedDict(TypedDict):
    r"""The border of a rectangle for properties of objects such as a table cell."""

    color: ColorTypedDict
    r"""Represents a color."""
    style: TableCellSchemasPropertiesBordersStyle
    r"""The style of the border to apply."""
    weight: float
    r"""The thickness of the border, in points. Rounded to the nearest hundredth."""


class TableCellBottom(BaseModel):
    r"""The border of a rectangle for properties of objects such as a table cell."""

    color: Color
    r"""Represents a color."""

    style: TableCellSchemasPropertiesBordersStyle
    r"""The style of the border to apply."""

    weight: float
    r"""The thickness of the border, in points. Rounded to the nearest hundredth."""

    @field_serializer("style")
    def serialize_style(self, value):
        if isinstance(value, str):
            try:
                return models.TableCellSchemasPropertiesBordersStyle(value)
            except ValueError:
                return value
        return value


class TableCellStyle(str, Enum, metaclass=utils.OpenEnumMeta):
    r"""The style of the border to apply."""

    SINGLE = "single"
    DOUBLE = "double"
    DASHED1 = "dashed1"
    DASHED2 = "dashed2"
    DASHED3 = "dashed3"
    DASHED4 = "dashed4"
    DASHED5 = "dashed5"


class TableCellLeftTypedDict(TypedDict):
    r"""The border of a rectangle for properties of objects such as a table cell."""

    color: ColorTypedDict
    r"""Represents a color."""
    style: TableCellStyle
    r"""The style of the border to apply."""
    weight: float
    r"""The thickness of the border, in points. Rounded to the nearest hundredth."""


class TableCellLeft(BaseModel):
    r"""The border of a rectangle for properties of objects such as a table cell."""

    color: Color
    r"""Represents a color."""

    style: TableCellStyle
    r"""The style of the border to apply."""

    weight: float
    r"""The thickness of the border, in points. Rounded to the nearest hundredth."""

    @field_serializer("style")
    def serialize_style(self, value):
        if isinstance(value, str):
            try:
                return models.TableCellStyle(value)
            except ValueError:
                return value
        return value


class TableCellSchemasStyle(str, Enum, metaclass=utils.OpenEnumMeta):
    r"""The style of the border to apply."""

    SINGLE = "single"
    DOUBLE = "double"
    DASHED1 = "dashed1"
    DASHED2 = "dashed2"
    DASHED3 = "dashed3"
    DASHED4 = "dashed4"
    DASHED5 = "dashed5"


class TableCellRightTypedDict(TypedDict):
    r"""The border of a rectangle for properties of objects such as a table cell."""

    color: ColorTypedDict
    r"""Represents a color."""
    style: TableCellSchemasStyle
    r"""The style of the border to apply."""
    weight: float
    r"""The thickness of the border, in points. Rounded to the nearest hundredth."""


class TableCellRight(BaseModel):
    r"""The border of a rectangle for properties of objects such as a table cell."""

    color: Color
    r"""Represents a color."""

    style: TableCellSchemasStyle
    r"""The style of the border to apply."""

    weight: float
    r"""The thickness of the border, in points. Rounded to the nearest hundredth."""

    @field_serializer("style")
    def serialize_style(self, value):
        if isinstance(value, str):
            try:
                return models.TableCellSchemasStyle(value)
            except ValueError:
                return value
        return value


class TableCellSchemasPropertiesStyle(str, Enum, metaclass=utils.OpenEnumMeta):
    r"""The style of the border to apply."""

    SINGLE = "single"
    DOUBLE = "double"
    DASHED1 = "dashed1"
    DASHED2 = "dashed2"
    DASHED3 = "dashed3"
    DASHED4 = "dashed4"
    DASHED5 = "dashed5"


class TableCellTopTypedDict(TypedDict):
    r"""The border of a rectangle for properties of objects such as a table cell."""

    color: ColorTypedDict
    r"""Represents a color."""
    style: TableCellSchemasPropertiesStyle
    r"""The style of the border to apply."""
    weight: float
    r"""The thickness of the border, in points. Rounded to the nearest hundredth."""


class TableCellTop(BaseModel):
    r"""The border of a rectangle for properties of objects such as a table cell."""

    color: Color
    r"""Represents a color."""

    style: TableCellSchemasPropertiesStyle
    r"""The style of the border to apply."""

    weight: float
    r"""The thickness of the border, in points. Rounded to the nearest hundredth."""

    @field_serializer("style")
    def serialize_style(self, value):
        if isinstance(value, str):
            try:
                return models.TableCellSchemasPropertiesStyle(value)
            except ValueError:
                return value
        return value


class TableCellBordersTypedDict(TypedDict):
    r"""The borders of the table cell."""

    bottom: NotRequired[Nullable[TableCellBottomTypedDict]]
    left: NotRequired[Nullable[TableCellLeftTypedDict]]
    right: NotRequired[Nullable[TableCellRightTypedDict]]
    top: NotRequired[Nullable[TableCellTopTypedDict]]


class TableCellBorders(BaseModel):
    r"""The borders of the table cell."""

    bottom: OptionalNullable[TableCellBottom] = UNSET

    left: OptionalNullable[TableCellLeft] = UNSET

    right: OptionalNullable[TableCellRight] = UNSET

    top: OptionalNullable[TableCellTop] = UNSET

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["bottom", "left", "right", "top"])
        nullable_fields = set(["bottom", "left", "right", "top"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            is_nullable_and_explicitly_set = (
                k in nullable_fields
                and (self.__pydantic_fields_set__.intersection({n}))  # pylint: disable=no-member
            )

            if val != UNSET_SENTINEL:
                if (
                    val is not None
                    or k not in optional_fields
                    or is_nullable_and_explicitly_set
                ):
                    m[k] = val

        return m


class FillColorTypedDict(TypedDict):
    r"""Represents a color."""

    blue: int
    r"""The blue component of the color."""
    green: int
    r"""The green component of the color."""
    red: int
    r"""The red component of the color."""


class FillColor(BaseModel):
    r"""Represents a color."""

    blue: int
    r"""The blue component of the color."""

    green: int
    r"""The green component of the color."""

    red: int
    r"""The red component of the color."""


class VerticalAlignment(str, Enum, metaclass=utils.OpenEnumMeta):
    r"""The vertical alignment of the content in the cell."""

    TOP = "top"
    MIDDLE = "middle"
    BOTTOM = "bottom"


class TableCellPropertiesTypedDict(TypedDict):
    r"""The properties for a table cell. Null values indicate that the property is inheriting from style or the container when reading. Null values will not be modified when writing."""

    borders: NotRequired[Nullable[TableCellBordersTypedDict]]
    fill_color: NotRequired[Nullable[FillColorTypedDict]]
    horizontal_alignment: NotRequired[Nullable[CellHorizontalAlignment]]
    r"""The horizontal alignment of the content in the cell."""
    indent: NotRequired[Nullable[float]]
    r"""The indentation of content in the cell."""
    vertical_alignment: NotRequired[Nullable[VerticalAlignment]]
    r"""The vertical alignment of the content in the cell."""


class TableCellProperties(BaseModel):
    r"""The properties for a table cell. Null values indicate that the property is inheriting from style or the container when reading. Null values will not be modified when writing."""

    borders: OptionalNullable[TableCellBorders] = UNSET

    fill_color: Annotated[
        OptionalNullable[FillColor], pydantic.Field(alias="fillColor")
    ] = UNSET

    horizontal_alignment: Annotated[
        OptionalNullable[CellHorizontalAlignment],
        pydantic.Field(alias="horizontalAlignment"),
    ] = UNSET
    r"""The horizontal alignment of the content in the cell."""

    indent: OptionalNullable[float] = UNSET
    r"""The indentation of content in the cell."""

    vertical_alignment: Annotated[
        OptionalNullable[VerticalAlignment], pydantic.Field(alias="verticalAlignment")
    ] = UNSET
    r"""The vertical alignment of the content in the cell."""

    @field_serializer("horizontal_alignment")
    def serialize_horizontal_alignment(self, value):
        if isinstance(value, str):
            try:
                return models.CellHorizontalAlignment(value)
            except ValueError:
                return value
        return value

    @field_serializer("vertical_alignment")
    def serialize_vertical_alignment(self, value):
        if isinstance(value, str):
            try:
                return models.VerticalAlignment(value)
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            [
                "borders",
                "fillColor",
                "horizontalAlignment",
                "indent",
                "verticalAlignment",
            ]
        )
        nullable_fields = set(
            [
                "borders",
                "fillColor",
                "horizontalAlignment",
                "indent",
                "verticalAlignment",
            ]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            is_nullable_and_explicitly_set = (
                k in nullable_fields
                and (self.__pydantic_fields_set__.intersection({n}))  # pylint: disable=no-member
            )

            if val != UNSET_SENTINEL:
                if (
                    val is not None
                    or k not in optional_fields
                    or is_nullable_and_explicitly_set
                ):
                    m[k] = val

        return m


class TableCellTypedDict(TypedDict):
    r"""Content containing a cell of a table."""

    input_cell: NotRequired[bool]
    r"""Whether this cell is an input cell."""
    locked: NotRequired[bool]
    r"""Whether this cell is locked."""
    merges: NotRequired[Nullable[MergesTypedDict]]
    properties: NotRequired[Nullable[TableCellPropertiesTypedDict]]
    raw_value: NotRequired[str]
    r"""The raw value or formula of the cell with no value formatting applied. This matches the formula bar value in the app."""
    value: NotRequired[CellValueTypedDict]
    r"""The content of a cell."""


class TableCell(BaseModel):
    r"""Content containing a cell of a table."""

    input_cell: Annotated[Optional[bool], pydantic.Field(alias="inputCell")] = None
    r"""Whether this cell is an input cell."""

    locked: Optional[bool] = None
    r"""Whether this cell is locked."""

    merges: OptionalNullable[Merges] = UNSET

    properties: OptionalNullable[TableCellProperties] = UNSET

    raw_value: Annotated[Optional[str], pydantic.Field(alias="rawValue")] = None
    r"""The raw value or formula of the cell with no value formatting applied. This matches the formula bar value in the app."""

    value: Optional[CellValue] = None
    r"""The content of a cell."""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            ["inputCell", "locked", "merges", "properties", "rawValue", "value"]
        )
        nullable_fields = set(["merges", "properties"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            is_nullable_and_explicitly_set = (
                k in nullable_fields
                and (self.__pydantic_fields_set__.intersection({n}))  # pylint: disable=no-member
            )

            if val != UNSET_SENTINEL:
                if (
                    val is not None
                    or k not in optional_fields
                    or is_nullable_and_explicitly_set
                ):
                    m[k] = val

        return m


try:
    ParentOf.model_rebuild()
except NameError:
    pass
try:
    Merges.model_rebuild()
except NameError:
    pass
try:
    TableCellProperties.model_rebuild()
except NameError:
    pass
try:
    TableCell.model_rebuild()
except NameError:
    pass
