"""Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT."""

from __future__ import annotations
from .frameworkreference import FrameworkReference, FrameworkReferenceTypedDict
from .tag import Tag, TagTypedDict
from enum import Enum
import pydantic
from pydantic import field_serializer, model_serializer
from typing import List, Optional
from typing_extensions import Annotated, NotRequired, TypedDict
from workiva import models, utils
from workiva.types import BaseModel, UNSET_SENTINEL


class DataType(str, Enum, metaclass=utils.OpenEnumMeta):
    r"""Used to specify the type of data for a metric."""

    TEXT = "text"
    NUMBER = "number"
    DATE = "date"
    CURRENCY = "currency"
    PERCENT = "percent"


class MetricTypedDict(TypedDict):
    r"""Represents a metric, which are used to track and collect material data to your company."""

    allowed_dimensions: NotRequired[List[str]]
    r"""A list of dimension ids that may be used when creating values for this metric."""
    code: NotRequired[int]
    r"""An optional user-specified metric code as an integer greater than 0, unique to each metric.
    If not provided, the system assigns the next available integer.

    """
    data_type: NotRequired[DataType]
    r"""Used to specify the type of data for a metric."""
    description: NotRequired[str]
    r"""An optional description of the metric, explaining its purpose and main aspects, up to 32767 characters."""
    framework_references: NotRequired[List[FrameworkReferenceTypedDict]]
    r"""A list of framework/standard references or other related content, up to 20 references."""
    id: NotRequired[str]
    r"""The unique UUID identifier of the metric."""
    index: NotRequired[int]
    r"""The index in the outline. If unset, the metric will be ordered last."""
    name: NotRequired[str]
    r"""The name of the metric, up to 300 characters."""
    require_notes: NotRequired[bool]
    r"""Indicates whether notes are required for this metric."""
    require_supporting_attachments: NotRequired[bool]
    r"""Indicates whether supporting attachments are required for this metric."""
    str_code: NotRequired[str]
    r"""The system-generated string representation of the metric code, read-only."""
    tags: NotRequired[List[TagTypedDict]]
    r"""A collection of tags associated with the metric. A metric can have up to 20 tags."""
    topic: NotRequired[str]
    r"""The unique UUID identifier of the parent topic."""
    unit: NotRequired[str]
    r"""The unit of measurement for the metric, up to 300 characters."""


class Metric(BaseModel):
    r"""Represents a metric, which are used to track and collect material data to your company."""

    allowed_dimensions: Annotated[
        Optional[List[str]], pydantic.Field(alias="allowedDimensions")
    ] = None
    r"""A list of dimension ids that may be used when creating values for this metric."""

    code: Optional[int] = None
    r"""An optional user-specified metric code as an integer greater than 0, unique to each metric.
    If not provided, the system assigns the next available integer.

    """

    data_type: Annotated[Optional[DataType], pydantic.Field(alias="dataType")] = (
        DataType.TEXT
    )
    r"""Used to specify the type of data for a metric."""

    description: Optional[str] = None
    r"""An optional description of the metric, explaining its purpose and main aspects, up to 32767 characters."""

    framework_references: Annotated[
        Optional[List[FrameworkReference]], pydantic.Field(alias="frameworkReferences")
    ] = None
    r"""A list of framework/standard references or other related content, up to 20 references."""

    id: Optional[str] = None
    r"""The unique UUID identifier of the metric."""

    index: Optional[int] = None
    r"""The index in the outline. If unset, the metric will be ordered last."""

    name: Optional[str] = None
    r"""The name of the metric, up to 300 characters."""

    require_notes: Annotated[Optional[bool], pydantic.Field(alias="requireNotes")] = (
        False
    )
    r"""Indicates whether notes are required for this metric."""

    require_supporting_attachments: Annotated[
        Optional[bool], pydantic.Field(alias="requireSupportingAttachments")
    ] = False
    r"""Indicates whether supporting attachments are required for this metric."""

    str_code: Annotated[Optional[str], pydantic.Field(alias="strCode")] = None
    r"""The system-generated string representation of the metric code, read-only."""

    tags: Optional[List[Tag]] = None
    r"""A collection of tags associated with the metric. A metric can have up to 20 tags."""

    topic: Optional[str] = None
    r"""The unique UUID identifier of the parent topic."""

    unit: Optional[str] = None
    r"""The unit of measurement for the metric, up to 300 characters."""

    @field_serializer("data_type")
    def serialize_data_type(self, value):
        if isinstance(value, str):
            try:
                return models.DataType(value)
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            [
                "allowedDimensions",
                "code",
                "dataType",
                "description",
                "frameworkReferences",
                "id",
                "index",
                "name",
                "requireNotes",
                "requireSupportingAttachments",
                "strCode",
                "tags",
                "topic",
                "unit",
            ]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class MetricInputTypedDict(TypedDict):
    r"""Represents a metric, which are used to track and collect material data to your company."""

    allowed_dimensions: NotRequired[List[str]]
    r"""A list of dimension ids that may be used when creating values for this metric."""
    code: NotRequired[int]
    r"""An optional user-specified metric code as an integer greater than 0, unique to each metric.
    If not provided, the system assigns the next available integer.

    """
    data_type: NotRequired[DataType]
    r"""Used to specify the type of data for a metric."""
    description: NotRequired[str]
    r"""An optional description of the metric, explaining its purpose and main aspects, up to 32767 characters."""
    framework_references: NotRequired[List[FrameworkReferenceTypedDict]]
    r"""A list of framework/standard references or other related content, up to 20 references."""
    id: NotRequired[str]
    r"""The unique UUID identifier of the metric."""
    index: NotRequired[int]
    r"""The index in the outline. If unset, the metric will be ordered last."""
    name: NotRequired[str]
    r"""The name of the metric, up to 300 characters."""
    require_notes: NotRequired[bool]
    r"""Indicates whether notes are required for this metric."""
    require_supporting_attachments: NotRequired[bool]
    r"""Indicates whether supporting attachments are required for this metric."""
    tags: NotRequired[List[TagTypedDict]]
    r"""A collection of tags associated with the metric. A metric can have up to 20 tags."""
    topic: NotRequired[str]
    r"""The unique UUID identifier of the parent topic."""
    unit: NotRequired[str]
    r"""The unit of measurement for the metric, up to 300 characters."""


class MetricInput(BaseModel):
    r"""Represents a metric, which are used to track and collect material data to your company."""

    allowed_dimensions: Annotated[
        Optional[List[str]], pydantic.Field(alias="allowedDimensions")
    ] = None
    r"""A list of dimension ids that may be used when creating values for this metric."""

    code: Optional[int] = None
    r"""An optional user-specified metric code as an integer greater than 0, unique to each metric.
    If not provided, the system assigns the next available integer.

    """

    data_type: Annotated[Optional[DataType], pydantic.Field(alias="dataType")] = (
        DataType.TEXT
    )
    r"""Used to specify the type of data for a metric."""

    description: Optional[str] = None
    r"""An optional description of the metric, explaining its purpose and main aspects, up to 32767 characters."""

    framework_references: Annotated[
        Optional[List[FrameworkReference]], pydantic.Field(alias="frameworkReferences")
    ] = None
    r"""A list of framework/standard references or other related content, up to 20 references."""

    id: Optional[str] = None
    r"""The unique UUID identifier of the metric."""

    index: Optional[int] = None
    r"""The index in the outline. If unset, the metric will be ordered last."""

    name: Optional[str] = None
    r"""The name of the metric, up to 300 characters."""

    require_notes: Annotated[Optional[bool], pydantic.Field(alias="requireNotes")] = (
        False
    )
    r"""Indicates whether notes are required for this metric."""

    require_supporting_attachments: Annotated[
        Optional[bool], pydantic.Field(alias="requireSupportingAttachments")
    ] = False
    r"""Indicates whether supporting attachments are required for this metric."""

    tags: Optional[List[Tag]] = None
    r"""A collection of tags associated with the metric. A metric can have up to 20 tags."""

    topic: Optional[str] = None
    r"""The unique UUID identifier of the parent topic."""

    unit: Optional[str] = None
    r"""The unit of measurement for the metric, up to 300 characters."""

    @field_serializer("data_type")
    def serialize_data_type(self, value):
        if isinstance(value, str):
            try:
                return models.DataType(value)
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            [
                "allowedDimensions",
                "code",
                "dataType",
                "description",
                "frameworkReferences",
                "id",
                "index",
                "name",
                "requireNotes",
                "requireSupportingAttachments",
                "tags",
                "topic",
                "unit",
            ]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


try:
    Metric.model_rebuild()
except NameError:
    pass
try:
    MetricInput.model_rebuild()
except NameError:
    pass
