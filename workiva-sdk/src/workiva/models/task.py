"""Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT."""

from __future__ import annotations
from .taskapprovalstep import (
    TaskApprovalStep,
    TaskApprovalStepInput,
    TaskApprovalStepInputTypedDict,
    TaskApprovalStepTypedDict,
)
from .taskuser import TaskUser, TaskUserTypedDict
from datetime import datetime
import pydantic
from pydantic import model_serializer
from typing import List, Optional
from typing_extensions import Annotated, NotRequired, TypedDict
from workiva.types import BaseModel, Nullable, OptionalNullable, UNSET, UNSET_SENTINEL


class TaskSchemasUserTypedDict(TypedDict):
    r"""A user refernenced by their unique identifier"""

    id: NotRequired[str]
    r"""The unique identifier of the user"""


class TaskSchemasUser(BaseModel):
    r"""A user refernenced by their unique identifier"""

    id: Optional[str] = None
    r"""The unique identifier of the user"""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["id"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class TaskCreatedTypedDict(TypedDict):
    r"""When the action was performed, and details about the user who did it"""

    date_time: NotRequired[datetime]
    r"""When the action was performed"""
    user: NotRequired[Nullable[TaskSchemasUserTypedDict]]


class TaskCreated(BaseModel):
    r"""When the action was performed, and details about the user who did it"""

    date_time: Annotated[Optional[datetime], pydantic.Field(alias="dateTime")] = None
    r"""When the action was performed"""

    user: OptionalNullable[TaskSchemasUser] = UNSET

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["dateTime", "user"])
        nullable_fields = set(["user"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            is_nullable_and_explicitly_set = (
                k in nullable_fields
                and (self.__pydantic_fields_set__.intersection({n}))  # pylint: disable=no-member
            )

            if val != UNSET_SENTINEL:
                if (
                    val is not None
                    or k not in optional_fields
                    or is_nullable_and_explicitly_set
                ):
                    m[k] = val

        return m


class LocationTypedDict(TypedDict):
    r"""Details about what the task is attached to, such as a file ID. If null, the task isn't attached to anything. Once a location is attached to a task, that location cannot be changed."""

    resource: NotRequired[str]
    r"""The unique identifier of the resource. This is the ID of the Document, Spreadsheet, Presentation or Sustainability resource."""
    segment: NotRequired[Nullable[str]]
    r"""The unique identifier of the segment. A segment is a Section in a Document, a Sheet in a Spreadsheet, or a Slide in a Presentation."""


class Location(BaseModel):
    r"""Details about what the task is attached to, such as a file ID. If null, the task isn't attached to anything. Once a location is attached to a task, that location cannot be changed."""

    resource: Optional[str] = None
    r"""The unique identifier of the resource. This is the ID of the Document, Spreadsheet, Presentation or Sustainability resource."""

    segment: OptionalNullable[str] = UNSET
    r"""The unique identifier of the segment. A segment is a Section in a Document, a Sheet in a Spreadsheet, or a Slide in a Presentation."""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["resource", "segment"])
        nullable_fields = set(["segment"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            is_nullable_and_explicitly_set = (
                k in nullable_fields
                and (self.__pydantic_fields_set__.intersection({n}))  # pylint: disable=no-member
            )

            if val != UNSET_SENTINEL:
                if (
                    val is not None
                    or k not in optional_fields
                    or is_nullable_and_explicitly_set
                ):
                    m[k] = val

        return m


class TaskSchemasModifiedUserTypedDict(TypedDict):
    r"""A user refernenced by their unique identifier"""

    id: NotRequired[str]
    r"""The unique identifier of the user"""


class TaskSchemasModifiedUser(BaseModel):
    r"""A user refernenced by their unique identifier"""

    id: Optional[str] = None
    r"""The unique identifier of the user"""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["id"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class TaskModifiedTypedDict(TypedDict):
    r"""When the action was performed, and details about the user who did it"""

    date_time: NotRequired[datetime]
    r"""When the action was performed"""
    user: NotRequired[Nullable[TaskSchemasModifiedUserTypedDict]]


class TaskModified(BaseModel):
    r"""When the action was performed, and details about the user who did it"""

    date_time: Annotated[Optional[datetime], pydantic.Field(alias="dateTime")] = None
    r"""When the action was performed"""

    user: OptionalNullable[TaskSchemasModifiedUser] = UNSET

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["dateTime", "user"])
        nullable_fields = set(["user"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            is_nullable_and_explicitly_set = (
                k in nullable_fields
                and (self.__pydantic_fields_set__.intersection({n}))  # pylint: disable=no-member
            )

            if val != UNSET_SENTINEL:
                if (
                    val is not None
                    or k not in optional_fields
                    or is_nullable_and_explicitly_set
                ):
                    m[k] = val

        return m


class TaskTypedDict(TypedDict):
    r"""Details about the task, including its title, description, type, deadlines, participants, and additional metadata. Please note that the Task object has been updated to accommodate the new task approval process which results in breaking changes to the Tasking endpoints. Some fields like assignee and approvers have been removed, and new fields like approvalSteps have been added. The status field can now only be updated for tasks with a single approval step. For a task with multiple approval steps, the status field will be updated automatically when actions are taken on the task. See the endpoint [Submit Task Action](ref:submittaskaction) for more details."""

    title: str
    r"""The title of the task."""
    id: NotRequired[str]
    r"""The unique identifier of the task."""
    approval_steps: NotRequired[List[TaskApprovalStepTypedDict]]
    r"""The approval process for the task where applicable."""
    assignees: NotRequired[List[TaskUserTypedDict]]
    r"""A list of assignees for the task."""
    created: NotRequired[TaskCreatedTypedDict]
    description: NotRequired[str]
    r"""The task description."""
    due_date: NotRequired[Nullable[datetime]]
    r"""An ISO 8601 datetime indicating a deadline for the task to be completed. Will be converted to UTC if another time zone is included."""
    location: NotRequired[Nullable[LocationTypedDict]]
    modified: NotRequired[TaskModifiedTypedDict]
    notifications_disabled: NotRequired[bool]
    r"""Suspend notifications during create/updates. Automated and manual reminders will still be sent. The default value is false."""
    owner: NotRequired[str]
    r"""The unique identifier of the user who owns the task."""
    source_url: NotRequired[str]
    r"""The URL of a WDesk resource that is associated with a task."""
    status: NotRequired[str]
    r"""> The status for the task. The default value is Created. The status of the task will be updated automatically as it
    > progresses through the multiple steps of the approval process.

    """


class Task(BaseModel):
    r"""Details about the task, including its title, description, type, deadlines, participants, and additional metadata. Please note that the Task object has been updated to accommodate the new task approval process which results in breaking changes to the Tasking endpoints. Some fields like assignee and approvers have been removed, and new fields like approvalSteps have been added. The status field can now only be updated for tasks with a single approval step. For a task with multiple approval steps, the status field will be updated automatically when actions are taken on the task. See the endpoint [Submit Task Action](ref:submittaskaction) for more details."""

    title: str
    r"""The title of the task."""

    id: Optional[str] = None
    r"""The unique identifier of the task."""

    approval_steps: Annotated[
        Optional[List[TaskApprovalStep]], pydantic.Field(alias="approvalSteps")
    ] = None
    r"""The approval process for the task where applicable."""

    assignees: Optional[List[TaskUser]] = None
    r"""A list of assignees for the task."""

    created: Optional[TaskCreated] = None

    description: Optional[str] = None
    r"""The task description."""

    due_date: Annotated[OptionalNullable[datetime], pydantic.Field(alias="dueDate")] = (
        UNSET
    )
    r"""An ISO 8601 datetime indicating a deadline for the task to be completed. Will be converted to UTC if another time zone is included."""

    location: OptionalNullable[Location] = UNSET

    modified: Optional[TaskModified] = None

    notifications_disabled: Annotated[
        Optional[bool], pydantic.Field(alias="notificationsDisabled")
    ] = None
    r"""Suspend notifications during create/updates. Automated and manual reminders will still be sent. The default value is false."""

    owner: Optional[str] = None
    r"""The unique identifier of the user who owns the task."""

    source_url: Annotated[Optional[str], pydantic.Field(alias="sourceUrl")] = None
    r"""The URL of a WDesk resource that is associated with a task."""

    status: Optional[str] = "Created"
    r"""> The status for the task. The default value is Created. The status of the task will be updated automatically as it
    > progresses through the multiple steps of the approval process.

    """

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            [
                "id",
                "approvalSteps",
                "assignees",
                "created",
                "description",
                "dueDate",
                "location",
                "modified",
                "notificationsDisabled",
                "owner",
                "sourceUrl",
                "status",
            ]
        )
        nullable_fields = set(["dueDate", "location"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            is_nullable_and_explicitly_set = (
                k in nullable_fields
                and (self.__pydantic_fields_set__.intersection({n}))  # pylint: disable=no-member
            )

            if val != UNSET_SENTINEL:
                if (
                    val is not None
                    or k not in optional_fields
                    or is_nullable_and_explicitly_set
                ):
                    m[k] = val

        return m


class TaskInputTypedDict(TypedDict):
    r"""Details about the task, including its title, description, type, deadlines, participants, and additional metadata. Please note that the Task object has been updated to accommodate the new task approval process which results in breaking changes to the Tasking endpoints. Some fields like assignee and approvers have been removed, and new fields like approvalSteps have been added. The status field can now only be updated for tasks with a single approval step. For a task with multiple approval steps, the status field will be updated automatically when actions are taken on the task. See the endpoint [Submit Task Action](ref:submittaskaction) for more details."""

    title: str
    r"""The title of the task."""
    approval_steps: NotRequired[List[TaskApprovalStepInputTypedDict]]
    r"""The approval process for the task where applicable."""
    assignees: NotRequired[List[TaskUserTypedDict]]
    r"""A list of assignees for the task."""
    description: NotRequired[str]
    r"""The task description."""
    due_date: NotRequired[Nullable[datetime]]
    r"""An ISO 8601 datetime indicating a deadline for the task to be completed. Will be converted to UTC if another time zone is included."""
    location: NotRequired[Nullable[LocationTypedDict]]
    notifications_disabled: NotRequired[bool]
    r"""Suspend notifications during create/updates. Automated and manual reminders will still be sent. The default value is false."""
    status: NotRequired[str]
    r"""> The status for the task. The default value is Created. The status of the task will be updated automatically as it
    > progresses through the multiple steps of the approval process.

    """


class TaskInput(BaseModel):
    r"""Details about the task, including its title, description, type, deadlines, participants, and additional metadata. Please note that the Task object has been updated to accommodate the new task approval process which results in breaking changes to the Tasking endpoints. Some fields like assignee and approvers have been removed, and new fields like approvalSteps have been added. The status field can now only be updated for tasks with a single approval step. For a task with multiple approval steps, the status field will be updated automatically when actions are taken on the task. See the endpoint [Submit Task Action](ref:submittaskaction) for more details."""

    title: str
    r"""The title of the task."""

    approval_steps: Annotated[
        Optional[List[TaskApprovalStepInput]], pydantic.Field(alias="approvalSteps")
    ] = None
    r"""The approval process for the task where applicable."""

    assignees: Optional[List[TaskUser]] = None
    r"""A list of assignees for the task."""

    description: Optional[str] = None
    r"""The task description."""

    due_date: Annotated[OptionalNullable[datetime], pydantic.Field(alias="dueDate")] = (
        UNSET
    )
    r"""An ISO 8601 datetime indicating a deadline for the task to be completed. Will be converted to UTC if another time zone is included."""

    location: OptionalNullable[Location] = UNSET

    notifications_disabled: Annotated[
        Optional[bool], pydantic.Field(alias="notificationsDisabled")
    ] = None
    r"""Suspend notifications during create/updates. Automated and manual reminders will still be sent. The default value is false."""

    status: Optional[str] = "Created"
    r"""> The status for the task. The default value is Created. The status of the task will be updated automatically as it
    > progresses through the multiple steps of the approval process.

    """

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            [
                "approvalSteps",
                "assignees",
                "description",
                "dueDate",
                "location",
                "notificationsDisabled",
                "status",
            ]
        )
        nullable_fields = set(["dueDate", "location"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            is_nullable_and_explicitly_set = (
                k in nullable_fields
                and (self.__pydantic_fields_set__.intersection({n}))  # pylint: disable=no-member
            )

            if val != UNSET_SENTINEL:
                if (
                    val is not None
                    or k not in optional_fields
                    or is_nullable_and_explicitly_set
                ):
                    m[k] = val

        return m


try:
    TaskCreated.model_rebuild()
except NameError:
    pass
try:
    TaskModified.model_rebuild()
except NameError:
    pass
try:
    Task.model_rebuild()
except NameError:
    pass
try:
    TaskInput.model_rebuild()
except NameError:
    pass
