"""Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT."""

from __future__ import annotations
from enum import Enum
import pydantic
from pydantic import model_serializer
from typing import List, Optional
from typing_extensions import Annotated, NotRequired, TypedDict
from workiva.types import BaseModel, Nullable, OptionalNullable, UNSET, UNSET_SENTINEL


class DocxOptionsTypedDict(TypedDict):
    r"""Optional options to export the document as a Microsoft Word document (.DOCX). If no options are provided, all options default to False."""

    include_leader_dots: NotRequired[bool]
    r"""Whether to include leader dots when exporting to .DOCX. False by default."""
    show_table_cell_shading: NotRequired[bool]
    r"""Whether to show table cell shading when exporting to .DOCX. False by default."""


class DocxOptions(BaseModel):
    r"""Optional options to export the document as a Microsoft Word document (.DOCX). If no options are provided, all options default to False."""

    include_leader_dots: Annotated[
        Optional[bool], pydantic.Field(alias="includeLeaderDots")
    ] = False
    r"""Whether to include leader dots when exporting to .DOCX. False by default."""

    show_table_cell_shading: Annotated[
        Optional[bool], pydantic.Field(alias="showTableCellShading")
    ] = False
    r"""Whether to show table cell shading when exporting to .DOCX. False by default."""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["includeLeaderDots", "showTableCellShading"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class Format(str, Enum):
    r"""The file format to export the document as."""

    PDF = "pdf"
    DOCX = "docx"
    XHTML = "xhtml"


class PdfOptionsTypedDict(TypedDict):
    r"""Optional options to export the document as a portable document file (.PDF). If no options are provided, all options default to False."""

    include_alternate_row_fill: NotRequired[bool]
    r"""Whether to include alternate row fill when exporting to .PDF. False by default."""
    include_attachment_labels: NotRequired[bool]
    r"""Whether to include attachment labels when exporting to .PDF. False by default."""
    include_comments: NotRequired[bool]
    r"""Whether to include comments when exporting to .PDF. False by default. When True, all comments are included, even those already resolved."""
    include_draft_watermark: NotRequired[bool]
    r"""Whether to include a \"Draft\" watermark when exporting to .PDF. False by default."""
    include_hyperlinks: NotRequired[bool]
    r"""Whether to include hyperlinks when exporting to .PDF. False by default."""
    include_leader_dots: NotRequired[bool]
    r"""Whether to include leader dots when exporting to .PDF. False by default."""
    include_track_changes: NotRequired[bool]
    r"""Whether to include track changes when exporting to .PDF. False by default."""
    remove_space_from_partial_export: NotRequired[bool]
    r"""Whether to remove space from partial exports when exporting to .PDF. False by default."""
    tag_for_web_accessibility: NotRequired[bool]
    r"""Whether to tag for web accessibility when exporting to .PDF. False by default."""
    use_cmyk_colorspace: NotRequired[bool]
    r"""Whether to use CMYK colorspace when exporting to .PDF. False by default."""


class PdfOptions(BaseModel):
    r"""Optional options to export the document as a portable document file (.PDF). If no options are provided, all options default to False."""

    include_alternate_row_fill: Annotated[
        Optional[bool], pydantic.Field(alias="includeAlternateRowFill")
    ] = False
    r"""Whether to include alternate row fill when exporting to .PDF. False by default."""

    include_attachment_labels: Annotated[
        Optional[bool], pydantic.Field(alias="includeAttachmentLabels")
    ] = False
    r"""Whether to include attachment labels when exporting to .PDF. False by default."""

    include_comments: Annotated[
        Optional[bool], pydantic.Field(alias="includeComments")
    ] = False
    r"""Whether to include comments when exporting to .PDF. False by default. When True, all comments are included, even those already resolved."""

    include_draft_watermark: Annotated[
        Optional[bool], pydantic.Field(alias="includeDraftWatermark")
    ] = False
    r"""Whether to include a \"Draft\" watermark when exporting to .PDF. False by default."""

    include_hyperlinks: Annotated[
        Optional[bool], pydantic.Field(alias="includeHyperlinks")
    ] = False
    r"""Whether to include hyperlinks when exporting to .PDF. False by default."""

    include_leader_dots: Annotated[
        Optional[bool], pydantic.Field(alias="includeLeaderDots")
    ] = False
    r"""Whether to include leader dots when exporting to .PDF. False by default."""

    include_track_changes: Annotated[
        Optional[bool], pydantic.Field(alias="includeTrackChanges")
    ] = False
    r"""Whether to include track changes when exporting to .PDF. False by default."""

    remove_space_from_partial_export: Annotated[
        Optional[bool], pydantic.Field(alias="removeSpaceFromPartialExport")
    ] = False
    r"""Whether to remove space from partial exports when exporting to .PDF. False by default."""

    tag_for_web_accessibility: Annotated[
        Optional[bool], pydantic.Field(alias="tagForWebAccessibility")
    ] = False
    r"""Whether to tag for web accessibility when exporting to .PDF. False by default."""

    use_cmyk_colorspace: Annotated[
        Optional[bool], pydantic.Field(alias="useCmykColorspace")
    ] = False
    r"""Whether to use CMYK colorspace when exporting to .PDF. False by default."""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            [
                "includeAlternateRowFill",
                "includeAttachmentLabels",
                "includeComments",
                "includeDraftWatermark",
                "includeHyperlinks",
                "includeLeaderDots",
                "includeTrackChanges",
                "removeSpaceFromPartialExport",
                "tagForWebAccessibility",
                "useCmykColorspace",
            ]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class XhtmlOptionsTypedDict(TypedDict):
    r"""Optional options to export the document as .XHTML. If no options are provided, `editableXhtml` will be true and all other options will be false."""

    editable_simple: NotRequired[bool]
    r"""Whether to produce simplified editable XHTML. This option produces editable XHTML that is simpler than the  editableXHTML option. Use this option when you only need the textual and numeric content of a document, but not  any of the images or complex formatting. When this option is true, all other XHTML export options must be false.

    """
    editable_xhtml: NotRequired[bool]
    r"""Whether the resulting XHTML is editable when exporting to .XHTML. False by default. If set to true, other options must be false.
    When exporting XHTML that you plan to edit or modify, use this option. Otherwise, the export retains fidelity so it visually matches the document as it appears in the browser.

    """
    include_external_hyperlinks: NotRequired[bool]
    r"""Whether to include external hyperlinks when exporting to .XHTML. False by default."""
    include_headers_and_footers: NotRequired[bool]
    r"""Whether to include the headers and footers when exporting to .XHTML. False by default."""


class XhtmlOptions(BaseModel):
    r"""Optional options to export the document as .XHTML. If no options are provided, `editableXhtml` will be true and all other options will be false."""

    editable_simple: Annotated[
        Optional[bool], pydantic.Field(alias="editableSimple")
    ] = False
    r"""Whether to produce simplified editable XHTML. This option produces editable XHTML that is simpler than the  editableXHTML option. Use this option when you only need the textual and numeric content of a document, but not  any of the images or complex formatting. When this option is true, all other XHTML export options must be false.

    """

    editable_xhtml: Annotated[Optional[bool], pydantic.Field(alias="editableXhtml")] = (
        False
    )
    r"""Whether the resulting XHTML is editable when exporting to .XHTML. False by default. If set to true, other options must be false.
    When exporting XHTML that you plan to edit or modify, use this option. Otherwise, the export retains fidelity so it visually matches the document as it appears in the browser.

    """

    include_external_hyperlinks: Annotated[
        Optional[bool], pydantic.Field(alias="includeExternalHyperlinks")
    ] = False
    r"""Whether to include external hyperlinks when exporting to .XHTML. False by default."""

    include_headers_and_footers: Annotated[
        Optional[bool], pydantic.Field(alias="includeHeadersAndFooters")
    ] = False
    r"""Whether to include the headers and footers when exporting to .XHTML. False by default."""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            [
                "editableSimple",
                "editableXhtml",
                "includeExternalHyperlinks",
                "includeHeadersAndFooters",
            ]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class DocumentExportTypedDict(TypedDict):
    r"""Details about the document export, including its format and options"""

    format_: Format
    r"""The file format to export the document as."""
    docx_options: NotRequired[Nullable[DocxOptionsTypedDict]]
    pdf_options: NotRequired[Nullable[PdfOptionsTypedDict]]
    sections: NotRequired[List[str]]
    r"""The IDs of the sections of the document to export. Omit to export the entire document."""
    xhtml_options: NotRequired[Nullable[XhtmlOptionsTypedDict]]


class DocumentExport(BaseModel):
    r"""Details about the document export, including its format and options"""

    format_: Annotated[Format, pydantic.Field(alias="format")]
    r"""The file format to export the document as."""

    docx_options: Annotated[
        OptionalNullable[DocxOptions], pydantic.Field(alias="docxOptions")
    ] = UNSET

    pdf_options: Annotated[
        OptionalNullable[PdfOptions], pydantic.Field(alias="pdfOptions")
    ] = UNSET

    sections: Optional[List[str]] = None
    r"""The IDs of the sections of the document to export. Omit to export the entire document."""

    xhtml_options: Annotated[
        OptionalNullable[XhtmlOptions], pydantic.Field(alias="xhtmlOptions")
    ] = UNSET

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["docxOptions", "pdfOptions", "sections", "xhtmlOptions"])
        nullable_fields = set(["docxOptions", "pdfOptions", "xhtmlOptions"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            is_nullable_and_explicitly_set = (
                k in nullable_fields
                and (self.__pydantic_fields_set__.intersection({n}))  # pylint: disable=no-member
            )

            if val != UNSET_SENTINEL:
                if (
                    val is not None
                    or k not in optional_fields
                    or is_nullable_and_explicitly_set
                ):
                    m[k] = val

        return m
