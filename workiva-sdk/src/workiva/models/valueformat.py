"""Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT."""

from __future__ import annotations
from enum import Enum
import pydantic
from pydantic import field_serializer, model_serializer
from typing_extensions import Annotated, NotRequired, TypedDict
from workiva import models, utils
from workiva.types import BaseModel, Nullable, OptionalNullable, UNSET, UNSET_SENTINEL


class Code(str, Enum, metaclass=utils.OpenEnumMeta):
    r"""The ISO currency identifier"""

    AUD = "AUD"
    BGN = "BGN"
    BRL = "BRL"
    CAD = "CAD"
    CHF = "CHF"
    CNH = "CNH"
    CNY = "CNY"
    CZK = "CZK"
    DKK = "DKK"
    EUR = "EUR"
    GBP = "GBP"
    HKD = "HKD"
    HRK = "HRK"
    HUF = "HUF"
    INR = "INR"
    ISK = "ISK"
    IDR = "IDR"
    JPY = "JPY"
    KRW = "KRW"
    MXN = "MXN"
    MYR = "MYR"
    NOK = "NOK"
    PHP = "PHP"
    PLN = "PLN"
    RON = "RON"
    RSD = "RSD"
    RUB = "RUB"
    SEK = "SEK"
    SGD = "SGD"
    THB = "THB"
    TRY = "TRY"
    TWD = "TWD"
    UAH = "UAH"
    USD = "USD"
    ZAR = "ZAR"
    VND = "VND"


class ValueFormatDisplay(str, Enum, metaclass=utils.OpenEnumMeta):
    r"""How to display the currency. CODE simply displays the ISO currency code while SYMBOL displays the corresponding currency symbol.
    For codes where we support two different symbols, SYMBOL and SYMBOL2 display as follows:
    | code | SYMBOL | SYMBOL2 |
    | ---- | ------ | ------- |
    | INR  | ₹      | Rs      |
    | RSD  | дин    | din     |
    | UAH  | ₴      | грн     |

    """

    SYMBOL = "SYMBOL"
    SYMBOL2 = "SYMBOL2"
    CODE = "CODE"


class CurrencyTypedDict(TypedDict):
    r"""An ISO currency format"""

    code: Nullable[Code]
    r"""The ISO currency identifier"""
    display: Nullable[ValueFormatDisplay]
    r"""How to display the currency. CODE simply displays the ISO currency code while SYMBOL displays the corresponding currency symbol.
    For codes where we support two different symbols, SYMBOL and SYMBOL2 display as follows:
    | code | SYMBOL | SYMBOL2 |
    | ---- | ------ | ------- |
    | INR  | ₹      | Rs      |
    | RSD  | дин    | din     |
    | UAH  | ₴      | грн     |

    """


class Currency(BaseModel):
    r"""An ISO currency format"""

    code: Nullable[Code]
    r"""The ISO currency identifier"""

    display: Nullable[ValueFormatDisplay]
    r"""How to display the currency. CODE simply displays the ISO currency code while SYMBOL displays the corresponding currency symbol.
    For codes where we support two different symbols, SYMBOL and SYMBOL2 display as follows:
    | code | SYMBOL | SYMBOL2 |
    | ---- | ------ | ------- |
    | INR  | ₹      | Rs      |
    | RSD  | дин    | din     |
    | UAH  | ₴      | грн     |

    """

    @field_serializer("code")
    def serialize_code(self, value):
        if isinstance(value, str):
            try:
                return models.Code(value)
            except ValueError:
                return value
        return value

    @field_serializer("display")
    def serialize_display(self, value):
        if isinstance(value, str):
            try:
                return models.ValueFormatDisplay(value)
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                m[k] = val

        return m


class Generic(str, Enum, metaclass=utils.OpenEnumMeta):
    r"""Generic currency options"""

    DOLLAR = "DOLLAR"
    CENT = "CENT"


class CurrencySymbolTypedDict(TypedDict):
    r"""The currency symbol to display. Valid for ACCOUNTING and CURRENCY. Either generic or currency should be set, but not both."""

    currency: NotRequired[Nullable[CurrencyTypedDict]]
    r"""An ISO currency format"""
    generic: NotRequired[Nullable[Generic]]
    r"""Generic currency options"""


class CurrencySymbol(BaseModel):
    r"""The currency symbol to display. Valid for ACCOUNTING and CURRENCY. Either generic or currency should be set, but not both."""

    currency: OptionalNullable[Currency] = UNSET
    r"""An ISO currency format"""

    generic: OptionalNullable[Generic] = UNSET
    r"""Generic currency options"""

    @field_serializer("generic")
    def serialize_generic(self, value):
        if isinstance(value, str):
            try:
                return models.Generic(value)
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["currency", "generic"])
        nullable_fields = set(["currency", "generic"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            is_nullable_and_explicitly_set = (
                k in nullable_fields
                and (self.__pydantic_fields_set__.intersection({n}))  # pylint: disable=no-member
            )

            if val != UNSET_SENTINEL:
                if (
                    val is not None
                    or k not in optional_fields
                    or is_nullable_and_explicitly_set
                ):
                    m[k] = val

        return m


class DisplayZeroAs(str, Enum, metaclass=utils.OpenEnumMeta):
    r"""The symbol to use for zero. Valid for ACCOUNTING, CURRENCY, NUMBER, and PERCENT. This field controls the symbol to use for zero when
    not using showNumbersAsWords.

    """

    ZERO = "ZERO"
    EM_DASH = "EM DASH"
    EN_DASH = "EN DASH"
    HYPHEN = "HYPHEN"
    BLANK = "BLANK"


class EnteredIn(str, Enum, metaclass=utils.OpenEnumMeta):
    r"""The scale cell values are entered in. Valid for AUTOMATIC, ACCOUNTING, CURRENCY, and NUMBER."""

    MILLIONTHS = "MILLIONTHS"
    BASIS_POINTS = "BASIS POINTS"
    THOUSANDTHS = "THOUSANDTHS"
    HUNDREDTHS = "HUNDREDTHS"
    ONES = "ONES"
    THOUSANDS = "THOUSANDS"
    TEN_THOUSANDS = "TEN THOUSANDS"
    MILLIONS = "MILLIONS"
    HUNDRED_MILLIONS = "HUNDRED MILLIONS"
    BILLIONS = "BILLIONS"
    TRILLIONS = "TRILLIONS"


class ValueFormatDisplayZeroAs(str, Enum, metaclass=utils.OpenEnumMeta):
    r"""The word to use for zero. Valid for ACCOUNTING, CURRENCY, NUMBER, and PERCENT."""

    ZERO = "ZERO"
    NO = "NO"
    NONE = "NONE"
    NOTHING = "NOTHING"
    NIL = "NIL"
    NOT = "NOT"
    NOMINAL = "NOMINAL"
    IMMATERIAL = "IMMATERIAL"


class NumbersAsWordsOptionsTypedDict(TypedDict):
    r"""Options relevant when showing numbers as words. Valid for ACCOUNTING, CURRENCY, NUMBER, and PERCENT. In order for these options to
    take effect showNumbersAsWords must be set to true.

    """

    capitalize_first_word: NotRequired[Nullable[bool]]
    r"""Capitalize the first word. Valid for ACCOUNTING, CURRENCY, NUMBER, and PERCENT."""
    display_zero_as: NotRequired[Nullable[ValueFormatDisplayZeroAs]]
    r"""The word to use for zero. Valid for ACCOUNTING, CURRENCY, NUMBER, and PERCENT."""


class NumbersAsWordsOptions(BaseModel):
    r"""Options relevant when showing numbers as words. Valid for ACCOUNTING, CURRENCY, NUMBER, and PERCENT. In order for these options to
    take effect showNumbersAsWords must be set to true.

    """

    capitalize_first_word: Annotated[
        OptionalNullable[bool], pydantic.Field(alias="capitalizeFirstWord")
    ] = False
    r"""Capitalize the first word. Valid for ACCOUNTING, CURRENCY, NUMBER, and PERCENT."""

    display_zero_as: Annotated[
        OptionalNullable[ValueFormatDisplayZeroAs],
        pydantic.Field(alias="displayZeroAs"),
    ] = ValueFormatDisplayZeroAs.ZERO
    r"""The word to use for zero. Valid for ACCOUNTING, CURRENCY, NUMBER, and PERCENT."""

    @field_serializer("display_zero_as")
    def serialize_display_zero_as(self, value):
        if isinstance(value, str):
            try:
                return models.ValueFormatDisplayZeroAs(value)
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["capitalizeFirstWord", "displayZeroAs"])
        nullable_fields = set(["capitalizeFirstWord", "displayZeroAs"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            is_nullable_and_explicitly_set = (
                k in nullable_fields
                and (self.__pydantic_fields_set__.intersection({n}))  # pylint: disable=no-member
            )

            if val != UNSET_SENTINEL:
                if (
                    val is not None
                    or k not in optional_fields
                    or is_nullable_and_explicitly_set
                ):
                    m[k] = val

        return m


class PercentSymbol(str, Enum, metaclass=utils.OpenEnumMeta):
    r"""Render numbers with a percent symbol. Valid for PERCENT."""

    NONE = "NONE"
    SYMBOL = "SYMBOL"
    WORD = "WORD"


class Display(str, Enum, metaclass=utils.OpenEnumMeta):
    r"""Method of displaying the period value"""

    RAW = "RAW"
    LARGEST = "LARGEST"
    YEARS = "YEARS"
    ALL = "ALL"


class Separator(str, Enum, metaclass=utils.OpenEnumMeta):
    r"""The separator to use between denominations if multiple are displayed"""

    NONE = "NONE"
    COMMA = "COMMA"


class PeriodFormatTypedDict(TypedDict):
    r"""Options for formatting a duration string. Valid for PERIOD"""

    display: Nullable[Display]
    r"""Method of displaying the period value"""
    capitalize_first_word: NotRequired[Nullable[bool]]
    r"""Capitalize the first word"""
    precision: NotRequired[Nullable[int]]
    r"""Precision to use when rounding decimal numbers for display. Renders with automatic precision if null."""
    separator: NotRequired[Nullable[Separator]]
    r"""The separator to use between denominations if multiple are displayed"""
    show_labels: NotRequired[Nullable[bool]]
    r"""Render a label after each denomination"""
    show_numbers_as_words: NotRequired[Nullable[bool]]
    r"""Render the numbers as words instead of digits"""


class PeriodFormat(BaseModel):
    r"""Options for formatting a duration string. Valid for PERIOD"""

    display: Nullable[Display]
    r"""Method of displaying the period value"""

    capitalize_first_word: Annotated[
        OptionalNullable[bool], pydantic.Field(alias="capitalizeFirstWord")
    ] = False
    r"""Capitalize the first word"""

    precision: OptionalNullable[int] = None
    r"""Precision to use when rounding decimal numbers for display. Renders with automatic precision if null."""

    separator: OptionalNullable[Separator] = Separator.COMMA
    r"""The separator to use between denominations if multiple are displayed"""

    show_labels: Annotated[
        OptionalNullable[bool], pydantic.Field(alias="showLabels")
    ] = True
    r"""Render a label after each denomination"""

    show_numbers_as_words: Annotated[
        OptionalNullable[bool], pydantic.Field(alias="showNumbersAsWords")
    ] = False
    r"""Render the numbers as words instead of digits"""

    @field_serializer("display")
    def serialize_display(self, value):
        if isinstance(value, str):
            try:
                return models.Display(value)
            except ValueError:
                return value
        return value

    @field_serializer("separator")
    def serialize_separator(self, value):
        if isinstance(value, str):
            try:
                return models.Separator(value)
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            [
                "capitalizeFirstWord",
                "precision",
                "separator",
                "showLabels",
                "showNumbersAsWords",
            ]
        )
        nullable_fields = set(
            [
                "capitalizeFirstWord",
                "display",
                "precision",
                "separator",
                "showLabels",
                "showNumbersAsWords",
            ]
        )
        null_default_fields = set(["precision"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            is_nullable_and_explicitly_set = (
                k in nullable_fields
                and (
                    self.__pydantic_fields_set__.intersection({n})
                    or k in null_default_fields
                )  # pylint: disable=no-member
            )

            if val != UNSET_SENTINEL:
                if (
                    val is not None
                    or k not in optional_fields
                    or is_nullable_and_explicitly_set
                ):
                    m[k] = val

        return m


class PrecisionTypedDict(TypedDict):
    r"""Precision to use when rounding numbers for display. Valid for AUTOMATIC, ACCOUNTING, CURRENCY, NUMBER, and PERCENT."""

    auto: NotRequired[Nullable[bool]]
    r"""Render with automatic precision based on the value in the cell"""
    value: NotRequired[Nullable[int]]
    r"""Explicit precision value to use. Required unless auto is true."""


class Precision(BaseModel):
    r"""Precision to use when rounding numbers for display. Valid for AUTOMATIC, ACCOUNTING, CURRENCY, NUMBER, and PERCENT."""

    auto: OptionalNullable[bool] = False
    r"""Render with automatic precision based on the value in the cell"""

    value: OptionalNullable[int] = UNSET
    r"""Explicit precision value to use. Required unless auto is true."""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["auto", "value"])
        nullable_fields = set(["auto", "value"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            is_nullable_and_explicitly_set = (
                k in nullable_fields
                and (self.__pydantic_fields_set__.intersection({n}))  # pylint: disable=no-member
            )

            if val != UNSET_SENTINEL:
                if (
                    val is not None
                    or k not in optional_fields
                    or is_nullable_and_explicitly_set
                ):
                    m[k] = val

        return m


class ShownIn(str, Enum, metaclass=utils.OpenEnumMeta):
    r"""The scale cell values are displayed in. Valid for AUTOMATIC, ACCOUNTING, CURRENCY, and NUMBER."""

    MILLIONTHS = "MILLIONTHS"
    BASIS_POINTS = "BASIS POINTS"
    THOUSANDTHS = "THOUSANDTHS"
    HUNDREDTHS = "HUNDREDTHS"
    ONES = "ONES"
    THOUSANDS = "THOUSANDS"
    TEN_THOUSANDS = "TEN THOUSANDS"
    MILLIONS = "MILLIONS"
    HUNDRED_MILLIONS = "HUNDRED MILLIONS"
    BILLIONS = "BILLIONS"
    TRILLIONS = "TRILLIONS"


class SymbolAlign(str, Enum, metaclass=utils.OpenEnumMeta):
    r"""Where to render the symbol relative to the value. All values valid for ACCOUNTING and CURRENCY. Left values valid for NUMBER. Right values valid for PERCENT."""

    SYMBOL_DEFAULT = "SYMBOL DEFAULT"
    LEFT = "LEFT"
    LEFT_INSIDE = "LEFT INSIDE"
    RIGHT = "RIGHT"
    RIGHT_INSIDE = "RIGHT INSIDE"
    RIGHT_SPACED_INSIDE = "RIGHT SPACED INSIDE"
    RIGHT_SPACED = "RIGHT SPACED"


class ValueFormatType(str, Enum, metaclass=utils.OpenEnumMeta):
    r"""The value format type of the content. Setting this property will clear any other ValueFormat properties that are not valid for the new value format type."""

    AUTOMATIC = "AUTOMATIC"
    AUTOMATIC_ACCOUNTING = "AUTOMATIC ACCOUNTING"
    AUTOMATIC_CURRENCY = "AUTOMATIC CURRENCY"
    AUTOMATIC_NUMBER = "AUTOMATIC NUMBER"
    AUTOMATIC_PERCENT = "AUTOMATIC PERCENT"
    AUTOMATIC_DATE = "AUTOMATIC DATE"
    AUTOMATIC_PERIOD = "AUTOMATIC PERIOD"
    AUTOMATIC_TEXT = "AUTOMATIC TEXT"
    ACCOUNTING = "ACCOUNTING"
    CURRENCY = "CURRENCY"
    NUMBER = "NUMBER"
    PERCENT = "PERCENT"
    DATE = "DATE"
    PERIOD = "PERIOD"
    TEXT = "TEXT"


class ValueFormatTypedDict(TypedDict):
    r"""Value Formats. Fields that are omitted will be ignored."""

    currency_symbol: NotRequired[Nullable[CurrencySymbolTypedDict]]
    r"""The currency symbol to display. Valid for ACCOUNTING and CURRENCY. Either generic or currency should be set, but not both."""
    date_abbreviate_month: NotRequired[Nullable[bool]]
    r"""Use month abbreviations instead of full month names. Valid for DATE."""
    date_format_string: NotRequired[Nullable[str]]
    r"""Format to use when rendering the date. Valid for DATE."""
    date_uppercase_all: NotRequired[Nullable[bool]]
    r"""Uppercase all characters in the date string. Valid for DATE."""
    display_zero_as: NotRequired[Nullable[DisplayZeroAs]]
    r"""The symbol to use for zero. Valid for ACCOUNTING, CURRENCY, NUMBER, and PERCENT. This field controls the symbol to use for zero when
    not using showNumbersAsWords.

    """
    entered_in: NotRequired[Nullable[EnteredIn]]
    r"""The scale cell values are entered in. Valid for AUTOMATIC, ACCOUNTING, CURRENCY, and NUMBER."""
    numbers_as_words_options: NotRequired[Nullable[NumbersAsWordsOptionsTypedDict]]
    r"""Options relevant when showing numbers as words. Valid for ACCOUNTING, CURRENCY, NUMBER, and PERCENT. In order for these options to
    take effect showNumbersAsWords must be set to true.

    """
    percent_symbol: NotRequired[Nullable[PercentSymbol]]
    r"""Render numbers with a percent symbol. Valid for PERCENT."""
    period_format: NotRequired[Nullable[PeriodFormatTypedDict]]
    r"""Options for formatting a duration string. Valid for PERIOD"""
    precision: NotRequired[Nullable[PrecisionTypedDict]]
    r"""Precision to use when rounding numbers for display. Valid for AUTOMATIC, ACCOUNTING, CURRENCY, NUMBER, and PERCENT."""
    prefix: NotRequired[Nullable[str]]
    r"""Custom prefix value to render in the cell. Valid for ACCOUNTING, CURRENCY, NUMBER, PERCENT, and DATE."""
    show_currency_symbol: NotRequired[Nullable[bool]]
    r"""Render numbers with a currency symbol. Valid for ACCOUNTING and CURRENCY."""
    show_leading_zero: NotRequired[Nullable[bool]]
    r"""Include a leading zero for decimal numbers with no whole number part. Valid for ACCOUNTING, CURRENCY, NUMBER, and PERCENT."""
    show_numbers_as_words: NotRequired[Nullable[bool]]
    r"""Render the number as words instead of digits. Valid for ACCOUNTING, CURRENCY, NUMBER, and PERCENT."""
    show_positive_sign: NotRequired[Nullable[bool]]
    r"""Render the positive sign on numbers greater than zero. Valid for ACCOUNTING, CURRENCY, NUMBER, and PERCENT."""
    show_sign_rounded_zero: NotRequired[Nullable[bool]]
    r"""Render the sign on values rounded to zero. Valid for ACCOUNTING, CURRENCY, NUMBER, and PERCENT."""
    show_thousands_separator: NotRequired[Nullable[bool]]
    r"""Render the thousands separator. Valid for ACCOUNTING, CURRENCY, NUMBER, and PERCENT."""
    shown_in: NotRequired[Nullable[ShownIn]]
    r"""The scale cell values are displayed in. Valid for AUTOMATIC, ACCOUNTING, CURRENCY, and NUMBER."""
    suffix: NotRequired[Nullable[str]]
    r"""Custom suffix value to render in the cell. Valid for ACCOUNTING, CURRENCY, NUMBER, PERCENT, and DATE."""
    symbol_align: NotRequired[Nullable[SymbolAlign]]
    r"""Where to render the symbol relative to the value. All values valid for ACCOUNTING and CURRENCY. Left values valid for NUMBER. Right values valid for PERCENT."""
    use_parens_for_negatives: NotRequired[Nullable[bool]]
    r"""Render parentheses around the number instead of a negative symbol. Valid for ACCOUNTING, CURRENCY, NUMBER, and PERCENT."""
    value_format_type: NotRequired[Nullable[ValueFormatType]]
    r"""The value format type of the content. Setting this property will clear any other ValueFormat properties that are not valid for the new value format type."""


class ValueFormat(BaseModel):
    r"""Value Formats. Fields that are omitted will be ignored."""

    currency_symbol: Annotated[
        OptionalNullable[CurrencySymbol], pydantic.Field(alias="currencySymbol")
    ] = UNSET
    r"""The currency symbol to display. Valid for ACCOUNTING and CURRENCY. Either generic or currency should be set, but not both."""

    date_abbreviate_month: Annotated[
        OptionalNullable[bool], pydantic.Field(alias="dateAbbreviateMonth")
    ] = UNSET
    r"""Use month abbreviations instead of full month names. Valid for DATE."""

    date_format_string: Annotated[
        OptionalNullable[str], pydantic.Field(alias="dateFormatString")
    ] = UNSET
    r"""Format to use when rendering the date. Valid for DATE."""

    date_uppercase_all: Annotated[
        OptionalNullable[bool], pydantic.Field(alias="dateUppercaseAll")
    ] = UNSET
    r"""Uppercase all characters in the date string. Valid for DATE."""

    display_zero_as: Annotated[
        OptionalNullable[DisplayZeroAs], pydantic.Field(alias="displayZeroAs")
    ] = UNSET
    r"""The symbol to use for zero. Valid for ACCOUNTING, CURRENCY, NUMBER, and PERCENT. This field controls the symbol to use for zero when
    not using showNumbersAsWords.

    """

    entered_in: Annotated[
        OptionalNullable[EnteredIn], pydantic.Field(alias="enteredIn")
    ] = UNSET
    r"""The scale cell values are entered in. Valid for AUTOMATIC, ACCOUNTING, CURRENCY, and NUMBER."""

    numbers_as_words_options: Annotated[
        OptionalNullable[NumbersAsWordsOptions],
        pydantic.Field(alias="numbersAsWordsOptions"),
    ] = UNSET
    r"""Options relevant when showing numbers as words. Valid for ACCOUNTING, CURRENCY, NUMBER, and PERCENT. In order for these options to
    take effect showNumbersAsWords must be set to true.

    """

    percent_symbol: Annotated[
        OptionalNullable[PercentSymbol], pydantic.Field(alias="percentSymbol")
    ] = UNSET
    r"""Render numbers with a percent symbol. Valid for PERCENT."""

    period_format: Annotated[
        OptionalNullable[PeriodFormat], pydantic.Field(alias="periodFormat")
    ] = UNSET
    r"""Options for formatting a duration string. Valid for PERIOD"""

    precision: OptionalNullable[Precision] = UNSET
    r"""Precision to use when rounding numbers for display. Valid for AUTOMATIC, ACCOUNTING, CURRENCY, NUMBER, and PERCENT."""

    prefix: OptionalNullable[str] = UNSET
    r"""Custom prefix value to render in the cell. Valid for ACCOUNTING, CURRENCY, NUMBER, PERCENT, and DATE."""

    show_currency_symbol: Annotated[
        OptionalNullable[bool], pydantic.Field(alias="showCurrencySymbol")
    ] = UNSET
    r"""Render numbers with a currency symbol. Valid for ACCOUNTING and CURRENCY."""

    show_leading_zero: Annotated[
        OptionalNullable[bool], pydantic.Field(alias="showLeadingZero")
    ] = UNSET
    r"""Include a leading zero for decimal numbers with no whole number part. Valid for ACCOUNTING, CURRENCY, NUMBER, and PERCENT."""

    show_numbers_as_words: Annotated[
        OptionalNullable[bool], pydantic.Field(alias="showNumbersAsWords")
    ] = UNSET
    r"""Render the number as words instead of digits. Valid for ACCOUNTING, CURRENCY, NUMBER, and PERCENT."""

    show_positive_sign: Annotated[
        OptionalNullable[bool], pydantic.Field(alias="showPositiveSign")
    ] = UNSET
    r"""Render the positive sign on numbers greater than zero. Valid for ACCOUNTING, CURRENCY, NUMBER, and PERCENT."""

    show_sign_rounded_zero: Annotated[
        OptionalNullable[bool], pydantic.Field(alias="showSignRoundedZero")
    ] = UNSET
    r"""Render the sign on values rounded to zero. Valid for ACCOUNTING, CURRENCY, NUMBER, and PERCENT."""

    show_thousands_separator: Annotated[
        OptionalNullable[bool], pydantic.Field(alias="showThousandsSeparator")
    ] = UNSET
    r"""Render the thousands separator. Valid for ACCOUNTING, CURRENCY, NUMBER, and PERCENT."""

    shown_in: Annotated[OptionalNullable[ShownIn], pydantic.Field(alias="shownIn")] = (
        UNSET
    )
    r"""The scale cell values are displayed in. Valid for AUTOMATIC, ACCOUNTING, CURRENCY, and NUMBER."""

    suffix: OptionalNullable[str] = UNSET
    r"""Custom suffix value to render in the cell. Valid for ACCOUNTING, CURRENCY, NUMBER, PERCENT, and DATE."""

    symbol_align: Annotated[
        OptionalNullable[SymbolAlign], pydantic.Field(alias="symbolAlign")
    ] = UNSET
    r"""Where to render the symbol relative to the value. All values valid for ACCOUNTING and CURRENCY. Left values valid for NUMBER. Right values valid for PERCENT."""

    use_parens_for_negatives: Annotated[
        OptionalNullable[bool], pydantic.Field(alias="useParensForNegatives")
    ] = UNSET
    r"""Render parentheses around the number instead of a negative symbol. Valid for ACCOUNTING, CURRENCY, NUMBER, and PERCENT."""

    value_format_type: Annotated[
        OptionalNullable[ValueFormatType], pydantic.Field(alias="valueFormatType")
    ] = UNSET
    r"""The value format type of the content. Setting this property will clear any other ValueFormat properties that are not valid for the new value format type."""

    @field_serializer("display_zero_as")
    def serialize_display_zero_as(self, value):
        if isinstance(value, str):
            try:
                return models.DisplayZeroAs(value)
            except ValueError:
                return value
        return value

    @field_serializer("entered_in")
    def serialize_entered_in(self, value):
        if isinstance(value, str):
            try:
                return models.EnteredIn(value)
            except ValueError:
                return value
        return value

    @field_serializer("percent_symbol")
    def serialize_percent_symbol(self, value):
        if isinstance(value, str):
            try:
                return models.PercentSymbol(value)
            except ValueError:
                return value
        return value

    @field_serializer("shown_in")
    def serialize_shown_in(self, value):
        if isinstance(value, str):
            try:
                return models.ShownIn(value)
            except ValueError:
                return value
        return value

    @field_serializer("symbol_align")
    def serialize_symbol_align(self, value):
        if isinstance(value, str):
            try:
                return models.SymbolAlign(value)
            except ValueError:
                return value
        return value

    @field_serializer("value_format_type")
    def serialize_value_format_type(self, value):
        if isinstance(value, str):
            try:
                return models.ValueFormatType(value)
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            [
                "currencySymbol",
                "dateAbbreviateMonth",
                "dateFormatString",
                "dateUppercaseAll",
                "displayZeroAs",
                "enteredIn",
                "numbersAsWordsOptions",
                "percentSymbol",
                "periodFormat",
                "precision",
                "prefix",
                "showCurrencySymbol",
                "showLeadingZero",
                "showNumbersAsWords",
                "showPositiveSign",
                "showSignRoundedZero",
                "showThousandsSeparator",
                "shownIn",
                "suffix",
                "symbolAlign",
                "useParensForNegatives",
                "valueFormatType",
            ]
        )
        nullable_fields = set(
            [
                "currencySymbol",
                "dateAbbreviateMonth",
                "dateFormatString",
                "dateUppercaseAll",
                "displayZeroAs",
                "enteredIn",
                "numbersAsWordsOptions",
                "percentSymbol",
                "periodFormat",
                "precision",
                "prefix",
                "showCurrencySymbol",
                "showLeadingZero",
                "showNumbersAsWords",
                "showPositiveSign",
                "showSignRoundedZero",
                "showThousandsSeparator",
                "shownIn",
                "suffix",
                "symbolAlign",
                "useParensForNegatives",
                "valueFormatType",
            ]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            is_nullable_and_explicitly_set = (
                k in nullable_fields
                and (self.__pydantic_fields_set__.intersection({n}))  # pylint: disable=no-member
            )

            if val != UNSET_SENTINEL:
                if (
                    val is not None
                    or k not in optional_fields
                    or is_nullable_and_explicitly_set
                ):
                    m[k] = val

        return m
