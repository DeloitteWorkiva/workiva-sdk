"""Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT."""

from __future__ import annotations
import httpx
import pydantic
from pydantic import model_serializer
from typing import Dict, List, Optional
from typing_extensions import Annotated, NotRequired, TypedDict
from workiva.types import BaseModel, UNSET_SENTINEL
from workiva.utils import FieldMetadata, HeaderMetadata, PathParamMetadata


CHAINS_EXPORT_CHAIN_OP_SERVERS = [
    # EU
    "https://h.eu.wdesk.com/s/wdata/oc/api",
    # US
    "https://h.app.wdesk.com/s/wdata/oc/api",
    # APAC
    "https://h.apac.wdesk.com/s/wdata/oc/api",
]


class ChainsExportChainRequestTypedDict(TypedDict):
    chain_id: str
    r"""The ID of the Chain."""
    wk_target_workspace: NotRequired[str]
    r"""The `wk-target-workspace` header is only required for requests made by a service provider application. This does not apply to the majority of Workiva Chains API users. This header specifies the ID of the target workspace on which the service provider application wishes to take action. This workspace must be managed by the service provider.

    """


class ChainsExportChainRequest(BaseModel):
    chain_id: Annotated[
        str, FieldMetadata(path=PathParamMetadata(style="simple", explode=False))
    ]
    r"""The ID of the Chain."""

    wk_target_workspace: Annotated[
        Optional[str],
        pydantic.Field(alias="wk-target-workspace"),
        FieldMetadata(header=HeaderMetadata(style="simple", explode=False)),
    ] = None
    r"""The `wk-target-workspace` header is only required for requests made by a service provider application. This does not apply to the majority of Workiva Chains API users. This header specifies the ID of the target workspace on which the service provider application wishes to take action. This workspace must be managed by the service provider.

    """

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["wk-target-workspace"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class ChainsExportChainResponseTypedDict(TypedDict):
    headers: Dict[str, List[str]]
    result: httpx.Response


class ChainsExportChainResponse(BaseModel):
    headers: Dict[str, List[str]]

    result: httpx.Response
