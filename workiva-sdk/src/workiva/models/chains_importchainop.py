"""Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT."""

from __future__ import annotations
from .chainresponse import ChainResponse, ChainResponseTypedDict
import io
import pydantic
from pydantic import model_serializer
from typing import Dict, IO, List, Optional, Union
from typing_extensions import Annotated, NotRequired, TypedDict
from workiva.types import BaseModel, UNSET_SENTINEL
from workiva.utils import (
    FieldMetadata,
    HeaderMetadata,
    MultipartFormMetadata,
    PathParamMetadata,
    RequestMetadata,
)


CHAINS_IMPORT_CHAIN_OP_SERVERS = [
    # EU
    "https://h.eu.wdesk.com/s/wdata/oc/api",
    # US
    "https://h.app.wdesk.com/s/wdata/oc/api",
    # APAC
    "https://h.apac.wdesk.com/s/wdata/oc/api",
]


class ChainsImportChainFileTypedDict(TypedDict):
    file_name: str
    content: Union[bytes, IO[bytes], io.BufferedReader]
    content_type: NotRequired[str]


class ChainsImportChainFile(BaseModel):
    file_name: Annotated[
        str, pydantic.Field(alias="fileName"), FieldMetadata(multipart=True)
    ]

    content: Annotated[
        Union[bytes, IO[bytes], io.BufferedReader],
        pydantic.Field(alias=""),
        FieldMetadata(multipart=MultipartFormMetadata(content=True)),
    ]

    content_type: Annotated[
        Optional[str],
        pydantic.Field(alias="Content-Type"),
        FieldMetadata(multipart=True),
    ] = None

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["contentType"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class ChainsImportChainRequestBodyTypedDict(TypedDict):
    r"""The .chain file to import."""

    file: NotRequired[ChainsImportChainFileTypedDict]
    r"""Must be a .chain file."""


class ChainsImportChainRequestBody(BaseModel):
    r"""The .chain file to import."""

    file: Annotated[
        Optional[ChainsImportChainFile],
        FieldMetadata(multipart=MultipartFormMetadata(file=True)),
    ] = None
    r"""Must be a .chain file."""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["file"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class ChainsImportChainRequestTypedDict(TypedDict):
    environment_id: str
    r"""The ID of the Environment."""
    request_body: ChainsImportChainRequestBodyTypedDict
    r"""The .chain file to import."""
    wk_target_workspace: NotRequired[str]
    r"""The `wk-target-workspace` header is only required for requests made by a service provider application. This does not apply to the majority of Workiva Chains API users. This header specifies the ID of the target workspace on which the service provider application wishes to take action. This workspace must be managed by the service provider.

    """


class ChainsImportChainRequest(BaseModel):
    environment_id: Annotated[
        str, FieldMetadata(path=PathParamMetadata(style="simple", explode=False))
    ]
    r"""The ID of the Environment."""

    request_body: Annotated[
        ChainsImportChainRequestBody,
        FieldMetadata(request=RequestMetadata(media_type="multipart/form-data")),
    ]
    r"""The .chain file to import."""

    wk_target_workspace: Annotated[
        Optional[str],
        pydantic.Field(alias="wk-target-workspace"),
        FieldMetadata(header=HeaderMetadata(style="simple", explode=False)),
    ] = None
    r"""The `wk-target-workspace` header is only required for requests made by a service provider application. This does not apply to the majority of Workiva Chains API users. This header specifies the ID of the target workspace on which the service provider application wishes to take action. This workspace must be managed by the service provider.

    """

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["wk-target-workspace"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class ChainsImportChainResponseTypedDict(TypedDict):
    headers: Dict[str, List[str]]
    result: ChainResponseTypedDict


class ChainsImportChainResponse(BaseModel):
    headers: Dict[str, List[str]]

    result: ChainResponse
