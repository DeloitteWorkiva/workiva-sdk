"""Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT."""

from __future__ import annotations
from .destinationlinkref import DestinationLinkRef, DestinationLinkRefTypedDict
from .paragraph import Paragraph, ParagraphTypedDict
from .richtextbaselineshift import RichTextBaselineShift
from .sourceparagraph import SourceParagraph, SourceParagraphTypedDict
from .styleref import StyleRef, StyleRefTypedDict
from enum import Enum
import pydantic
from pydantic import field_serializer, model_serializer
from typing import List
from typing_extensions import Annotated, NotRequired, TypedDict
from workiva import models, utils
from workiva.types import BaseModel, Nullable, OptionalNullable, UNSET, UNSET_SENTINEL


class CellValueDestinationLinkTypedDict(TypedDict):
    r"""A cell-level destination link. The content of cell destination links cannot be edited with rich cell edits, but other  cell edits are supported."""

    destination_link: DestinationLinkRefTypedDict
    r"""A reference to a destination link."""
    paragraphs: List[SourceParagraphTypedDict]
    r"""Paragraphs contained in this cell."""


class CellValueDestinationLink(BaseModel):
    r"""A cell-level destination link. The content of cell destination links cannot be edited with rich cell edits, but other  cell edits are supported."""

    destination_link: Annotated[
        DestinationLinkRef, pydantic.Field(alias="destinationLink")
    ]
    r"""A reference to a destination link."""

    paragraphs: List[SourceParagraph]
    r"""Paragraphs contained in this cell."""


class CellValueBackgroundColorTypedDict(TypedDict):
    r"""The background color in RGB format"""

    blue: int
    r"""The blue component of the color."""
    green: int
    r"""The green component of the color."""
    red: int
    r"""The red component of the color."""


class CellValueBackgroundColor(BaseModel):
    r"""The background color in RGB format"""

    blue: int
    r"""The blue component of the color."""

    green: int
    r"""The green component of the color."""

    red: int
    r"""The red component of the color."""


class CellValueTextColorTypedDict(TypedDict):
    r"""The text color in RGB format"""

    blue: int
    r"""The blue component of the color."""
    green: int
    r"""The green component of the color."""
    red: int
    r"""The red component of the color."""


class CellValueTextColor(BaseModel):
    r"""The text color in RGB format"""

    blue: int
    r"""The blue component of the color."""

    green: int
    r"""The green component of the color."""

    red: int
    r"""The red component of the color."""


class CellValueFormatTypedDict(TypedDict):
    r"""The formatting options applied to rich text elements."""

    background_color: NotRequired[Nullable[CellValueBackgroundColorTypedDict]]
    r"""The background color in RGB format"""
    baseline_shift: NotRequired[Nullable[RichTextBaselineShift]]
    r"""Indicates the offset from the baseline of the characters. The baseline is the imaginary bottom line for a line of text which the bottom of the characters are placed, not including any descender such as g, j, p, and y have. `superscript` shifts the baseline up and reduces the rendered font size to 65% of the specified font size. `subscript` works the same as `superscript` except it moves the baseline down. `baseline` uses the default size and baseline for regular text. type: string

    """
    bold: NotRequired[Nullable[bool]]
    r"""Whether or not the text is bold"""
    character_spacing: NotRequired[Nullable[int]]
    r"""The amount of space, in 1/1000 of an em, between characters."""
    font: NotRequired[Nullable[str]]
    r"""The name of the font"""
    italic: NotRequired[Nullable[bool]]
    r"""Whether or not the text is italicized"""
    size: NotRequired[Nullable[float]]
    r"""The font size of the characters in points"""
    strikethrough: NotRequired[Nullable[bool]]
    r"""Whether or not the text is struck through"""
    text_color: NotRequired[Nullable[CellValueTextColorTypedDict]]
    r"""The text color in RGB format"""
    underline: NotRequired[Nullable[bool]]
    r"""Whether or not the text is underlined"""


class CellValueFormat(BaseModel):
    r"""The formatting options applied to rich text elements."""

    background_color: Annotated[
        OptionalNullable[CellValueBackgroundColor],
        pydantic.Field(alias="backgroundColor"),
    ] = UNSET
    r"""The background color in RGB format"""

    baseline_shift: Annotated[
        OptionalNullable[RichTextBaselineShift], pydantic.Field(alias="baselineShift")
    ] = UNSET
    r"""Indicates the offset from the baseline of the characters. The baseline is the imaginary bottom line for a line of text which the bottom of the characters are placed, not including any descender such as g, j, p, and y have. `superscript` shifts the baseline up and reduces the rendered font size to 65% of the specified font size. `subscript` works the same as `superscript` except it moves the baseline down. `baseline` uses the default size and baseline for regular text. type: string

    """

    bold: OptionalNullable[bool] = UNSET
    r"""Whether or not the text is bold"""

    character_spacing: Annotated[
        OptionalNullable[int], pydantic.Field(alias="characterSpacing")
    ] = UNSET
    r"""The amount of space, in 1/1000 of an em, between characters."""

    font: OptionalNullable[str] = UNSET
    r"""The name of the font"""

    italic: OptionalNullable[bool] = UNSET
    r"""Whether or not the text is italicized"""

    size: OptionalNullable[float] = UNSET
    r"""The font size of the characters in points"""

    strikethrough: OptionalNullable[bool] = UNSET
    r"""Whether or not the text is struck through"""

    text_color: Annotated[
        OptionalNullable[CellValueTextColor], pydantic.Field(alias="textColor")
    ] = UNSET
    r"""The text color in RGB format"""

    underline: OptionalNullable[bool] = UNSET
    r"""Whether or not the text is underlined"""

    @field_serializer("baseline_shift")
    def serialize_baseline_shift(self, value):
        if isinstance(value, str):
            try:
                return models.RichTextBaselineShift(value)
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            [
                "backgroundColor",
                "baselineShift",
                "bold",
                "characterSpacing",
                "font",
                "italic",
                "size",
                "strikethrough",
                "textColor",
                "underline",
            ]
        )
        nullable_fields = set(
            [
                "backgroundColor",
                "baselineShift",
                "bold",
                "characterSpacing",
                "font",
                "italic",
                "size",
                "strikethrough",
                "textColor",
                "underline",
            ]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            is_nullable_and_explicitly_set = (
                k in nullable_fields
                and (self.__pydantic_fields_set__.intersection({n}))  # pylint: disable=no-member
            )

            if val != UNSET_SENTINEL:
                if (
                    val is not None
                    or k not in optional_fields
                    or is_nullable_and_explicitly_set
                ):
                    m[k] = val

        return m


class FormulaTypedDict(TypedDict):
    r"""The content of a formula cell. These cells cannot be edited with rich cell edits, but other cell edits are supported."""

    calculated_value: str
    r"""The computed value of the formula without any value formatting applied The formula itself is in the \"rawValue\" property of the cell."""
    effective_value: str
    r"""The computed value of the formula with value formatting applied, exactly as it is displayed in the app. The formula itself is in the cell's \"rawValue\" property."""
    format_: Nullable[CellValueFormatTypedDict]
    style: StyleRefTypedDict
    r"""A reference to a style."""


class Formula(BaseModel):
    r"""The content of a formula cell. These cells cannot be edited with rich cell edits, but other cell edits are supported."""

    calculated_value: Annotated[str, pydantic.Field(alias="calculatedValue")]
    r"""The computed value of the formula without any value formatting applied The formula itself is in the \"rawValue\" property of the cell."""

    effective_value: Annotated[str, pydantic.Field(alias="effectiveValue")]
    r"""The computed value of the formula with value formatting applied, exactly as it is displayed in the app. The formula itself is in the cell's \"rawValue\" property."""

    format_: Annotated[Nullable[CellValueFormat], pydantic.Field(alias="format")]

    style: StyleRef
    r"""A reference to a style."""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                m[k] = val

        return m


class CellValueSchemasBackgroundColorTypedDict(TypedDict):
    r"""The background color in RGB format"""

    blue: int
    r"""The blue component of the color."""
    green: int
    r"""The green component of the color."""
    red: int
    r"""The red component of the color."""


class CellValueSchemasBackgroundColor(BaseModel):
    r"""The background color in RGB format"""

    blue: int
    r"""The blue component of the color."""

    green: int
    r"""The green component of the color."""

    red: int
    r"""The red component of the color."""


class CellValueSchemasTextColorTypedDict(TypedDict):
    r"""The text color in RGB format"""

    blue: int
    r"""The blue component of the color."""
    green: int
    r"""The green component of the color."""
    red: int
    r"""The red component of the color."""


class CellValueSchemasTextColor(BaseModel):
    r"""The text color in RGB format"""

    blue: int
    r"""The blue component of the color."""

    green: int
    r"""The green component of the color."""

    red: int
    r"""The red component of the color."""


class CellValueSchemasFormatTypedDict(TypedDict):
    r"""The formatting options applied to rich text elements."""

    background_color: NotRequired[Nullable[CellValueSchemasBackgroundColorTypedDict]]
    r"""The background color in RGB format"""
    baseline_shift: NotRequired[Nullable[RichTextBaselineShift]]
    r"""Indicates the offset from the baseline of the characters. The baseline is the imaginary bottom line for a line of text which the bottom of the characters are placed, not including any descender such as g, j, p, and y have. `superscript` shifts the baseline up and reduces the rendered font size to 65% of the specified font size. `subscript` works the same as `superscript` except it moves the baseline down. `baseline` uses the default size and baseline for regular text. type: string

    """
    bold: NotRequired[Nullable[bool]]
    r"""Whether or not the text is bold"""
    character_spacing: NotRequired[Nullable[int]]
    r"""The amount of space, in 1/1000 of an em, between characters."""
    font: NotRequired[Nullable[str]]
    r"""The name of the font"""
    italic: NotRequired[Nullable[bool]]
    r"""Whether or not the text is italicized"""
    size: NotRequired[Nullable[float]]
    r"""The font size of the characters in points"""
    strikethrough: NotRequired[Nullable[bool]]
    r"""Whether or not the text is struck through"""
    text_color: NotRequired[Nullable[CellValueSchemasTextColorTypedDict]]
    r"""The text color in RGB format"""
    underline: NotRequired[Nullable[bool]]
    r"""Whether or not the text is underlined"""


class CellValueSchemasFormat(BaseModel):
    r"""The formatting options applied to rich text elements."""

    background_color: Annotated[
        OptionalNullable[CellValueSchemasBackgroundColor],
        pydantic.Field(alias="backgroundColor"),
    ] = UNSET
    r"""The background color in RGB format"""

    baseline_shift: Annotated[
        OptionalNullable[RichTextBaselineShift], pydantic.Field(alias="baselineShift")
    ] = UNSET
    r"""Indicates the offset from the baseline of the characters. The baseline is the imaginary bottom line for a line of text which the bottom of the characters are placed, not including any descender such as g, j, p, and y have. `superscript` shifts the baseline up and reduces the rendered font size to 65% of the specified font size. `subscript` works the same as `superscript` except it moves the baseline down. `baseline` uses the default size and baseline for regular text. type: string

    """

    bold: OptionalNullable[bool] = UNSET
    r"""Whether or not the text is bold"""

    character_spacing: Annotated[
        OptionalNullable[int], pydantic.Field(alias="characterSpacing")
    ] = UNSET
    r"""The amount of space, in 1/1000 of an em, between characters."""

    font: OptionalNullable[str] = UNSET
    r"""The name of the font"""

    italic: OptionalNullable[bool] = UNSET
    r"""Whether or not the text is italicized"""

    size: OptionalNullable[float] = UNSET
    r"""The font size of the characters in points"""

    strikethrough: OptionalNullable[bool] = UNSET
    r"""Whether or not the text is struck through"""

    text_color: Annotated[
        OptionalNullable[CellValueSchemasTextColor], pydantic.Field(alias="textColor")
    ] = UNSET
    r"""The text color in RGB format"""

    underline: OptionalNullable[bool] = UNSET
    r"""Whether or not the text is underlined"""

    @field_serializer("baseline_shift")
    def serialize_baseline_shift(self, value):
        if isinstance(value, str):
            try:
                return models.RichTextBaselineShift(value)
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            [
                "backgroundColor",
                "baselineShift",
                "bold",
                "characterSpacing",
                "font",
                "italic",
                "size",
                "strikethrough",
                "textColor",
                "underline",
            ]
        )
        nullable_fields = set(
            [
                "backgroundColor",
                "baselineShift",
                "bold",
                "characterSpacing",
                "font",
                "italic",
                "size",
                "strikethrough",
                "textColor",
                "underline",
            ]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            is_nullable_and_explicitly_set = (
                k in nullable_fields
                and (self.__pydantic_fields_set__.intersection({n}))  # pylint: disable=no-member
            )

            if val != UNSET_SENTINEL:
                if (
                    val is not None
                    or k not in optional_fields
                    or is_nullable_and_explicitly_set
                ):
                    m[k] = val

        return m


class PlainTextTypedDict(TypedDict):
    r"""The content of a plain text cell. These cells contain a non-text value formatted value (such as a number or a date) and thus cannot be edited with rich cell edits, but other cell edits are supported. To perform rich edits on this cell you first need to either change the value format to \"Text\" or assign the cell's value to something that cannot be value formatted."""

    effective_value: str
    r"""The value after it has been value formatted, exactly as it is displayed in the app. The original value is in the cell's \"rawValue\" property."""
    format_: Nullable[CellValueSchemasFormatTypedDict]
    style: StyleRefTypedDict
    r"""A reference to a style."""


class PlainText(BaseModel):
    r"""The content of a plain text cell. These cells contain a non-text value formatted value (such as a number or a date) and thus cannot be edited with rich cell edits, but other cell edits are supported. To perform rich edits on this cell you first need to either change the value format to \"Text\" or assign the cell's value to something that cannot be value formatted."""

    effective_value: Annotated[str, pydantic.Field(alias="effectiveValue")]
    r"""The value after it has been value formatted, exactly as it is displayed in the app. The original value is in the cell's \"rawValue\" property."""

    format_: Annotated[Nullable[CellValueSchemasFormat], pydantic.Field(alias="format")]

    style: StyleRef
    r"""A reference to a style."""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                m[k] = val

        return m


class RichTextTypedDict(TypedDict):
    r"""The content of a rich text cell. This is the default type for cells before any content is set on them."""

    paragraphs: List[ParagraphTypedDict]
    r"""Paragraphs contained in this cell."""


class RichText(BaseModel):
    r"""The content of a rich text cell. This is the default type for cells before any content is set on them."""

    paragraphs: List[Paragraph]
    r"""Paragraphs contained in this cell."""


class CellValueType(str, Enum, metaclass=utils.OpenEnumMeta):
    r"""The type of content in a cell."""

    DESTINATION_LINK = "destinationLink"
    FORMULA = "formula"
    PLAIN_TEXT = "plainText"
    RICH_TEXT = "richText"


class CellValueTypedDict(TypedDict):
    r"""The content of a cell."""

    type: CellValueType
    r"""The type of content in a cell."""
    destination_link: NotRequired[Nullable[CellValueDestinationLinkTypedDict]]
    formula: NotRequired[Nullable[FormulaTypedDict]]
    plain_text: NotRequired[Nullable[PlainTextTypedDict]]
    rich_text: NotRequired[Nullable[RichTextTypedDict]]


class CellValue(BaseModel):
    r"""The content of a cell."""

    type: CellValueType
    r"""The type of content in a cell."""

    destination_link: Annotated[
        OptionalNullable[CellValueDestinationLink],
        pydantic.Field(alias="destinationLink"),
    ] = UNSET

    formula: OptionalNullable[Formula] = UNSET

    plain_text: Annotated[
        OptionalNullable[PlainText], pydantic.Field(alias="plainText")
    ] = UNSET

    rich_text: Annotated[
        OptionalNullable[RichText], pydantic.Field(alias="richText")
    ] = UNSET

    @field_serializer("type")
    def serialize_type(self, value):
        if isinstance(value, str):
            try:
                return models.CellValueType(value)
            except ValueError:
                return value
        return value

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["destinationLink", "formula", "plainText", "richText"])
        nullable_fields = set(["destinationLink", "formula", "plainText", "richText"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            is_nullable_and_explicitly_set = (
                k in nullable_fields
                and (self.__pydantic_fields_set__.intersection({n}))  # pylint: disable=no-member
            )

            if val != UNSET_SENTINEL:
                if (
                    val is not None
                    or k not in optional_fields
                    or is_nullable_and_explicitly_set
                ):
                    m[k] = val

        return m
