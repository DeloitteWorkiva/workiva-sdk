"""Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT."""

from __future__ import annotations
from .cellrange import CellRange, CellRangeTypedDict
from .tablerow import TableRow, TableRowTypedDict
import pydantic
from pydantic import model_serializer
from typing import List, Optional
from typing_extensions import Annotated, NotRequired, TypedDict
from workiva.types import BaseModel, Nullable, OptionalNullable, UNSET, UNSET_SENTINEL


class TableCellsResultTypedDict(TypedDict):
    r"""This represents a page of table cell results.
    Table content is paginated into smaller rectangles (pages) based on the limit in the given page range. The  limit represents the total number of cells in a page such that each page `page.rows * page.columns <= maxcellsperpage`.
    The page will try to fill a whole row or column based off the offset and limit, filling either vertically from  top to bottom or horizontally left to right. If the limit is less than the number of cells in a row or column,  the page at the end of a row or column may be less than the limit to prevent a page from spanning across rows  or columns.

    """

    revision: str
    r"""The revision of the table."""
    at_next_link: NotRequired[Nullable[str]]
    r"""Pagination link for the next page of results."""
    data: NotRequired[List[TableRowTypedDict]]
    r"""Cells for the current page of results."""
    range: NotRequired[CellRangeTypedDict]
    r"""A range of cells in a table. If any field is omitted or null, the range is unbounded in that direction. All indexes  are zero based.

    """


class TableCellsResult(BaseModel):
    r"""This represents a page of table cell results.
    Table content is paginated into smaller rectangles (pages) based on the limit in the given page range. The  limit represents the total number of cells in a page such that each page `page.rows * page.columns <= maxcellsperpage`.
    The page will try to fill a whole row or column based off the offset and limit, filling either vertically from  top to bottom or horizontally left to right. If the limit is less than the number of cells in a row or column,  the page at the end of a row or column may be less than the limit to prevent a page from spanning across rows  or columns.

    """

    revision: str
    r"""The revision of the table."""

    at_next_link: Annotated[
        OptionalNullable[str], pydantic.Field(alias="@nextLink")
    ] = UNSET
    r"""Pagination link for the next page of results."""

    data: Optional[List[TableRow]] = None
    r"""Cells for the current page of results."""

    range: Optional[CellRange] = None
    r"""A range of cells in a table. If any field is omitted or null, the range is unbounded in that direction. All indexes  are zero based.

    """

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["@nextLink", "data", "range"])
        nullable_fields = set(["@nextLink"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            is_nullable_and_explicitly_set = (
                k in nullable_fields
                and (self.__pydantic_fields_set__.intersection({n}))  # pylint: disable=no-member
            )

            if val != UNSET_SENTINEL:
                if (
                    val is not None
                    or k not in optional_fields
                    or is_nullable_and_explicitly_set
                ):
                    m[k] = val

        return m
