"""Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT."""

from __future__ import annotations
from enum import Enum
import pydantic
from pydantic import model_serializer
from typing import List, Optional
from typing_extensions import Annotated, NotRequired, TypedDict
from workiva.types import BaseModel, Nullable, OptionalNullable, UNSET, UNSET_SENTINEL


class CsvOptionsTypedDict(TypedDict):
    r"""Optional options to export the spreadsheet as a comma-separated values (.CSV) file. If no options are provided, `exportAsFormulas` defaults to False."""

    export_as_formulas: NotRequired[bool]
    r"""Whether to export cells containing formulas as the formula or the formula result. False by default."""


class CsvOptions(BaseModel):
    r"""Optional options to export the spreadsheet as a comma-separated values (.CSV) file. If no options are provided, `exportAsFormulas` defaults to False."""

    export_as_formulas: Annotated[
        Optional[bool], pydantic.Field(alias="exportAsFormulas")
    ] = False
    r"""Whether to export cells containing formulas as the formula or the formula result. False by default."""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["exportAsFormulas"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class SpreadsheetExportFormat(str, Enum):
    r"""The file format to export the spreadsheet as."""

    PDF = "pdf"
    XLSX = "xlsx"
    CSV = "csv"


class PageOrientation(str, Enum):
    r"""The orientation of the exported .PDF, such as \"portrait\" or \"landscape\". \"portrait\" by default."""

    PORTRAIT = "portrait"
    LANDSCAPE = "landscape"


class PageScale(str, Enum):
    r"""The scale of the exported .PDF. \"actualSize\" by default."""

    ACTUAL_SIZE = "actualSize"
    FIT_TO_WIDTH = "fitToWidth"


class SpreadsheetExportPdfOptionsTypedDict(TypedDict):
    r"""Optional options to export the spreadsheet as a portable document file (.PDF). If no options are provided, all options default to False except:
    - `pageHeight`, which defaults to 11
    - `pageWidth`, which defaults to 8.5
    - `pageOrientation`, which defaults to \"portrait\"
    - `pageScale`, which defaults to \"actualSize\"
    """

    include_comments: NotRequired[bool]
    r"""Whether to include comments when exporting to .PDF False by default."""
    include_draft_watermark: NotRequired[bool]
    r"""Whether to include draft watermark when exporting to .PDF. False by default."""
    include_hyperlinks: NotRequired[bool]
    r"""Whether to include hyperlinks when exporting to .PDF. False by default."""
    include_leader_dots: NotRequired[bool]
    r"""Whether to include leader dots when exporting to .PDF. False by default."""
    include_track_changes: NotRequired[bool]
    r"""Whether to include track changes when exporting to .PDF. False by default."""
    only_export_print_areas: NotRequired[bool]
    r"""Whether to only export print areas when exporting to .PDF. False by default."""
    page_height: NotRequired[float]
    r"""The height of the exported .PDF, in inches. 11 by default."""
    page_orientation: NotRequired[PageOrientation]
    r"""The orientation of the exported .PDF, such as \"portrait\" or \"landscape\". \"portrait\" by default.

    """
    page_scale: NotRequired[PageScale]
    r"""The scale of the exported .PDF. \"actualSize\" by default."""
    page_width: NotRequired[float]
    r"""The width of the exported .PDF, in inches. 8.5 by default."""
    show_cell_fills: NotRequired[bool]
    r"""Whether to show cell fills when exporting to .PDF. False by default."""
    show_gridlines: NotRequired[bool]
    r"""Whether to show gridlines when exporting to .PDF. False by default."""
    use_cmyk_colorspace: NotRequired[bool]
    r"""Whether to use CMYK colorspace when exporting to .PDF. False by default."""


class SpreadsheetExportPdfOptions(BaseModel):
    r"""Optional options to export the spreadsheet as a portable document file (.PDF). If no options are provided, all options default to False except:
    - `pageHeight`, which defaults to 11
    - `pageWidth`, which defaults to 8.5
    - `pageOrientation`, which defaults to \"portrait\"
    - `pageScale`, which defaults to \"actualSize\"
    """

    include_comments: Annotated[
        Optional[bool], pydantic.Field(alias="includeComments")
    ] = False
    r"""Whether to include comments when exporting to .PDF False by default."""

    include_draft_watermark: Annotated[
        Optional[bool], pydantic.Field(alias="includeDraftWatermark")
    ] = False
    r"""Whether to include draft watermark when exporting to .PDF. False by default."""

    include_hyperlinks: Annotated[
        Optional[bool], pydantic.Field(alias="includeHyperlinks")
    ] = False
    r"""Whether to include hyperlinks when exporting to .PDF. False by default."""

    include_leader_dots: Annotated[
        Optional[bool], pydantic.Field(alias="includeLeaderDots")
    ] = False
    r"""Whether to include leader dots when exporting to .PDF. False by default."""

    include_track_changes: Annotated[
        Optional[bool], pydantic.Field(alias="includeTrackChanges")
    ] = False
    r"""Whether to include track changes when exporting to .PDF. False by default."""

    only_export_print_areas: Annotated[
        Optional[bool], pydantic.Field(alias="onlyExportPrintAreas")
    ] = False
    r"""Whether to only export print areas when exporting to .PDF. False by default."""

    page_height: Annotated[Optional[float], pydantic.Field(alias="pageHeight")] = 11
    r"""The height of the exported .PDF, in inches. 11 by default."""

    page_orientation: Annotated[
        Optional[PageOrientation], pydantic.Field(alias="pageOrientation")
    ] = PageOrientation.PORTRAIT
    r"""The orientation of the exported .PDF, such as \"portrait\" or \"landscape\". \"portrait\" by default.

    """

    page_scale: Annotated[Optional[PageScale], pydantic.Field(alias="pageScale")] = (
        PageScale.ACTUAL_SIZE
    )
    r"""The scale of the exported .PDF. \"actualSize\" by default."""

    page_width: Annotated[Optional[float], pydantic.Field(alias="pageWidth")] = 8.5
    r"""The width of the exported .PDF, in inches. 8.5 by default."""

    show_cell_fills: Annotated[
        Optional[bool], pydantic.Field(alias="showCellFills")
    ] = False
    r"""Whether to show cell fills when exporting to .PDF. False by default."""

    show_gridlines: Annotated[Optional[bool], pydantic.Field(alias="showGridlines")] = (
        False
    )
    r"""Whether to show gridlines when exporting to .PDF. False by default."""

    use_cmyk_colorspace: Annotated[
        Optional[bool], pydantic.Field(alias="useCmykColorspace")
    ] = False
    r"""Whether to use CMYK colorspace when exporting to .PDF. False by default."""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            [
                "includeComments",
                "includeDraftWatermark",
                "includeHyperlinks",
                "includeLeaderDots",
                "includeTrackChanges",
                "onlyExportPrintAreas",
                "pageHeight",
                "pageOrientation",
                "pageScale",
                "pageWidth",
                "showCellFills",
                "showGridlines",
                "useCmykColorspace",
            ]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class ExportPrecision(str, Enum):
    r"""How to export values in the sheet when exporting to .XLSX \"fullPrecision\" by default."""

    FULL_PRECISION = "fullPrecision"
    ROUNDED = "rounded"
    DISPLAYED = "displayed"


class XlsxOptionsTypedDict(TypedDict):
    r"""Optional options to export the spreadsheet as a Microsoft Excel (.XLSX) file. If no options are provided, `exportAsFormulas` defaults to False, and `exportPrecision` defaults to `fullPrecision`."""

    export_as_formulas: NotRequired[bool]
    r"""Whether to export cells that contain formulas as the formula or its result when exporting to .XLSX. False by default."""
    export_precision: NotRequired[ExportPrecision]
    r"""How to export values in the sheet when exporting to .XLSX \"fullPrecision\" by default.

    """


class XlsxOptions(BaseModel):
    r"""Optional options to export the spreadsheet as a Microsoft Excel (.XLSX) file. If no options are provided, `exportAsFormulas` defaults to False, and `exportPrecision` defaults to `fullPrecision`."""

    export_as_formulas: Annotated[
        Optional[bool], pydantic.Field(alias="exportAsFormulas")
    ] = False
    r"""Whether to export cells that contain formulas as the formula or its result when exporting to .XLSX. False by default."""

    export_precision: Annotated[
        Optional[ExportPrecision], pydantic.Field(alias="exportPrecision")
    ] = ExportPrecision.FULL_PRECISION
    r"""How to export values in the sheet when exporting to .XLSX \"fullPrecision\" by default.

    """

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["exportAsFormulas", "exportPrecision"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                if val is not None or k not in optional_fields:
                    m[k] = val

        return m


class SpreadsheetExportTypedDict(TypedDict):
    r"""Details about a spreadsheet export."""

    format_: SpreadsheetExportFormat
    r"""The file format to export the spreadsheet as."""
    csv_options: NotRequired[Nullable[CsvOptionsTypedDict]]
    pdf_options: NotRequired[Nullable[SpreadsheetExportPdfOptionsTypedDict]]
    sheets: NotRequired[List[str]]
    r"""The IDs of the sheets within the spreadsheet to export. Omit to export the entire spreadsheet.

    Note: When exporting to .CSV, you can export only the entire spreadsheet or a single sheet. When exporting the entire spreadsheet, the resulting file is a .ZIP of .CSV files, with one .CSV file per sheet.
    """
    xlsx_options: NotRequired[Nullable[XlsxOptionsTypedDict]]


class SpreadsheetExport(BaseModel):
    r"""Details about a spreadsheet export."""

    format_: Annotated[SpreadsheetExportFormat, pydantic.Field(alias="format")]
    r"""The file format to export the spreadsheet as."""

    csv_options: Annotated[
        OptionalNullable[CsvOptions], pydantic.Field(alias="csvOptions")
    ] = UNSET

    pdf_options: Annotated[
        OptionalNullable[SpreadsheetExportPdfOptions],
        pydantic.Field(alias="pdfOptions"),
    ] = UNSET

    sheets: Optional[List[str]] = None
    r"""The IDs of the sheets within the spreadsheet to export. Omit to export the entire spreadsheet.

    Note: When exporting to .CSV, you can export only the entire spreadsheet or a single sheet. When exporting the entire spreadsheet, the resulting file is a .ZIP of .CSV files, with one .CSV file per sheet.
    """

    xlsx_options: Annotated[
        OptionalNullable[XlsxOptions], pydantic.Field(alias="xlsxOptions")
    ] = UNSET

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["csvOptions", "pdfOptions", "sheets", "xlsxOptions"])
        nullable_fields = set(["csvOptions", "pdfOptions", "xlsxOptions"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            is_nullable_and_explicitly_set = (
                k in nullable_fields
                and (self.__pydantic_fields_set__.intersection({n}))  # pylint: disable=no-member
            )

            if val != UNSET_SENTINEL:
                if (
                    val is not None
                    or k not in optional_fields
                    or is_nullable_and_explicitly_set
                ):
                    m[k] = val

        return m
