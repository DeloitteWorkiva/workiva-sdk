"""Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT."""

from .basesdk import BaseSDK
from jsonpath import JSONPath
from typing import Any, Awaitable, Dict, List, Mapping, Optional, Union, cast
from workiva import errors, models, utils
from workiva._hooks import HookContext
from workiva.types import BaseModel, OptionalNullable, UNSET
from workiva.utils.unmarshal_json_response import unmarshal_json_response


class Documents(BaseSDK):
    r"""Documents enable you to organize and review data in collaborative files with linked text, documents, and images. Use these endpoints to manage documents and their sections in the Workiva Platform."""

    def get_documents(
        self,
        *,
        filter_: Optional[str] = None,
        order_by: Optional[str] = None,
        maxpagesize: Optional[int] = 1000,
        next: Optional[str] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> Optional[models.GetDocumentsResponse]:
        r"""Retrieve a list of documents

        Returns a paginated list of [documents](ref:documents#document).

        :param filter_: The properties to filter the results by.
        :param order_by: One or more comma-separated expressions to indicate the order in which to sort the results.
        :param maxpagesize: The maximum number of results to retrieve
        :param next: Pagination cursor for next set of results.
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.GetDocumentsRequest(
            filter_=filter_,
            order_by=order_by,
            maxpagesize=maxpagesize,
            next=next,
        )

        req = self._build_request(
            method="GET",
            path="/documents",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            allow_empty_value=None,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="getDocuments",
                oauth2_scopes=["file:read"],
                security_source=self.sdk_configuration.security,
            ),
            request=req,
            error_status_codes=[
                "400",
                "401",
                "403",
                "404",
                "409",
                "429",
                "4XX",
                "500",
                "503",
                "5XX",
            ],
            retry_config=retry_config,
        )

        def next_func() -> Optional[models.GetDocumentsResponse]:
            body = utils.unmarshal_json(http_res.text, Union[Dict[Any, Any], List[Any]])

            next_cursor = JSONPath("$['@nextLink']").parse(body)

            if len(next_cursor) == 0:
                return None

            next_cursor = next_cursor[0]
            if next_cursor is None or str(next_cursor).strip() == "":
                return None

            return self.get_documents(
                filter_=filter_,
                order_by=order_by,
                maxpagesize=maxpagesize,
                next=next,
                retries=retries,
            )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return models.GetDocumentsResponse(
                result=unmarshal_json_response(models.DocumentsListResult, http_res),
                next=next_func,
            )
        if utils.match_response(
            http_res, ["400", "401", "403", "404", "409", "429"], "application/json"
        ):
            response_data = unmarshal_json_response(errors.ErrorResponseData, http_res)
            raise errors.ErrorResponse(response_data, http_res)
        if utils.match_response(http_res, ["500", "503"], "application/json"):
            response_data = unmarshal_json_response(errors.ErrorResponseData, http_res)
            raise errors.ErrorResponse(response_data, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)

        raise errors.SDKError("Unexpected response received", http_res)

    async def get_documents_async(
        self,
        *,
        filter_: Optional[str] = None,
        order_by: Optional[str] = None,
        maxpagesize: Optional[int] = 1000,
        next: Optional[str] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> Optional[models.GetDocumentsResponse]:
        r"""Retrieve a list of documents

        Returns a paginated list of [documents](ref:documents#document).

        :param filter_: The properties to filter the results by.
        :param order_by: One or more comma-separated expressions to indicate the order in which to sort the results.
        :param maxpagesize: The maximum number of results to retrieve
        :param next: Pagination cursor for next set of results.
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.GetDocumentsRequest(
            filter_=filter_,
            order_by=order_by,
            maxpagesize=maxpagesize,
            next=next,
        )

        req = self._build_request_async(
            method="GET",
            path="/documents",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            allow_empty_value=None,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="getDocuments",
                oauth2_scopes=["file:read"],
                security_source=self.sdk_configuration.security,
            ),
            request=req,
            error_status_codes=[
                "400",
                "401",
                "403",
                "404",
                "409",
                "429",
                "4XX",
                "500",
                "503",
                "5XX",
            ],
            retry_config=retry_config,
        )

        def next_func() -> Awaitable[Optional[models.GetDocumentsResponse]]:
            body = utils.unmarshal_json(http_res.text, Union[Dict[Any, Any], List[Any]])

            async def empty_result():
                return None

            next_cursor = JSONPath("$['@nextLink']").parse(body)

            if len(next_cursor) == 0:
                return empty_result()

            next_cursor = next_cursor[0]
            if next_cursor is None or str(next_cursor).strip() == "":
                return empty_result()

            return self.get_documents_async(
                filter_=filter_,
                order_by=order_by,
                maxpagesize=maxpagesize,
                next=next,
                retries=retries,
            )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return models.GetDocumentsResponse(
                result=unmarshal_json_response(models.DocumentsListResult, http_res),
                next=next_func,
            )
        if utils.match_response(
            http_res, ["400", "401", "403", "404", "409", "429"], "application/json"
        ):
            response_data = unmarshal_json_response(errors.ErrorResponseData, http_res)
            raise errors.ErrorResponse(response_data, http_res)
        if utils.match_response(http_res, ["500", "503"], "application/json"):
            response_data = unmarshal_json_response(errors.ErrorResponseData, http_res)
            raise errors.ErrorResponse(response_data, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)

        raise errors.SDKError("Unexpected response received", http_res)

    def get_document_by_id(
        self,
        *,
        document_id: str,
        expand: Optional[str] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.Document:
        r"""Retrieve a single document

        Retrieves a [document](ref:documents#document) given its ID.


        :param document_id: The unique identifier of the document
        :param expand: Returns related resources inline with the main resource
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.GetDocumentByIDRequest(
            document_id=document_id,
            expand=expand,
        )

        req = self._build_request(
            method="GET",
            path="/documents/{documentId}",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            allow_empty_value=None,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="getDocumentById",
                oauth2_scopes=["file:read"],
                security_source=self.sdk_configuration.security,
            ),
            request=req,
            error_status_codes=[
                "400",
                "401",
                "403",
                "404",
                "409",
                "429",
                "4XX",
                "500",
                "503",
                "5XX",
            ],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(models.Document, http_res)
        if utils.match_response(
            http_res, ["400", "401", "403", "404", "409", "429"], "application/json"
        ):
            response_data = unmarshal_json_response(errors.ErrorResponseData, http_res)
            raise errors.ErrorResponse(response_data, http_res)
        if utils.match_response(http_res, ["500", "503"], "application/json"):
            response_data = unmarshal_json_response(errors.ErrorResponseData, http_res)
            raise errors.ErrorResponse(response_data, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)

        raise errors.SDKError("Unexpected response received", http_res)

    async def get_document_by_id_async(
        self,
        *,
        document_id: str,
        expand: Optional[str] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.Document:
        r"""Retrieve a single document

        Retrieves a [document](ref:documents#document) given its ID.


        :param document_id: The unique identifier of the document
        :param expand: Returns related resources inline with the main resource
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.GetDocumentByIDRequest(
            document_id=document_id,
            expand=expand,
        )

        req = self._build_request_async(
            method="GET",
            path="/documents/{documentId}",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            allow_empty_value=None,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="getDocumentById",
                oauth2_scopes=["file:read"],
                security_source=self.sdk_configuration.security,
            ),
            request=req,
            error_status_codes=[
                "400",
                "401",
                "403",
                "404",
                "409",
                "429",
                "4XX",
                "500",
                "503",
                "5XX",
            ],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(models.Document, http_res)
        if utils.match_response(
            http_res, ["400", "401", "403", "404", "409", "429"], "application/json"
        ):
            response_data = unmarshal_json_response(errors.ErrorResponseData, http_res)
            raise errors.ErrorResponse(response_data, http_res)
        if utils.match_response(http_res, ["500", "503"], "application/json"):
            response_data = unmarshal_json_response(errors.ErrorResponseData, http_res)
            raise errors.ErrorResponse(response_data, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)

        raise errors.SDKError("Unexpected response received", http_res)

    def partially_update_document_by_id(
        self,
        *,
        document_id: str,
        request_body: Union[
            List[models.JSONPatchOperation], List[models.JSONPatchOperationTypedDict]
        ],
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.PartiallyUpdateDocumentByIDResponse:
        r"""Partially update a single document

        Updates the properties of a [document](ref:documents#document).

        This is a long running operation. Responses include a `Location` header,
        which indicates where to poll for results. For more details on long-running job polling,
        see [Operations endpoint](ref:getoperationbyid).

        ### Options

        |Path                             |PATCH Operations Supported        |
        |---------------------------------|----------------------------------|
        |`/customFields/<custom field id>`|`add`, `remove`, `replace`, `test`|
        |`/customFieldGroups`             |`add`, `remove`, `replace`, `test`|
        |`/sectionCustomFieldGroups`      |`add`, `remove`, `replace`, `test`|
        |`/lock`                          |`replace`                         |

        ### Examples

        #### Add a custom field value

        ```json
        [
        {
        \"op\": \"add\",
        \"path\": \"/customFields/com.workiva.gsr.legal_entity\",
        \"value\": \"Workiva\"
        }
        ]
        ```

        #### Remove a custom field value

        ```json
        [
        {
        \"op\": \"remove\",
        \"path\": \"/customFields/com.workiva.gsr.legal_entity\"
        }
        ]
        ```

        #### Replace a custom field value

        ```json
        [
        {
        \"op\": \"replace\",
        \"path\": \"/customFields/com.workiva.gsr.legal_entity\",
        \"value\": \"Workiva, Inc.\"
        }
        ]
        ```

        #### Verifying customFieldGroup is empty before replacing the list

        ```json
        [
        {
        \"op\": \"test\",
        \"path\": \"/customFieldGroups\",
        \"value\": []
        },
        {
        \"op\": \"replace\",
        \"path\": \"/customFieldGroups\",
        \"value\": [\"gsr.reporting\"]
        }
        ]
        ```

        #### Adding a customFieldGroup to the end of a list

        ```json
        [
        {
        \"op\": \"add\",
        \"path\": \"/customFieldGroups/-\",
        \"value\": \"gsr.reporting\"
        }
        ]
        ```


        :param document_id: The unique identifier of the document
        :param request_body: A collection of patch operations to apply to the document.
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.PartiallyUpdateDocumentByIDRequest(
            document_id=document_id,
            request_body=utils.get_pydantic_model(
                request_body, List[models.JSONPatchOperation]
            ),
        )

        req = self._build_request(
            method="PATCH",
            path="/documents/{documentId}",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request.request_body,
                False,
                False,
                "json",
                List[models.JSONPatchOperation],
            ),
            allow_empty_value=None,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="partiallyUpdateDocumentById",
                oauth2_scopes=["file:write"],
                security_source=self.sdk_configuration.security,
            ),
            request=req,
            error_status_codes=[
                "400",
                "401",
                "403",
                "404",
                "409",
                "429",
                "4XX",
                "500",
                "503",
                "5XX",
            ],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "202", "*"):
            return models.PartiallyUpdateDocumentByIDResponse(
                headers=utils.get_response_headers(http_res.headers)
            )
        if utils.match_response(
            http_res, ["400", "401", "403", "404", "409", "429"], "application/json"
        ):
            response_data = unmarshal_json_response(errors.ErrorResponseData, http_res)
            raise errors.ErrorResponse(response_data, http_res)
        if utils.match_response(http_res, ["500", "503"], "application/json"):
            response_data = unmarshal_json_response(errors.ErrorResponseData, http_res)
            raise errors.ErrorResponse(response_data, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)

        raise errors.SDKError("Unexpected response received", http_res)

    async def partially_update_document_by_id_async(
        self,
        *,
        document_id: str,
        request_body: Union[
            List[models.JSONPatchOperation], List[models.JSONPatchOperationTypedDict]
        ],
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.PartiallyUpdateDocumentByIDResponse:
        r"""Partially update a single document

        Updates the properties of a [document](ref:documents#document).

        This is a long running operation. Responses include a `Location` header,
        which indicates where to poll for results. For more details on long-running job polling,
        see [Operations endpoint](ref:getoperationbyid).

        ### Options

        |Path                             |PATCH Operations Supported        |
        |---------------------------------|----------------------------------|
        |`/customFields/<custom field id>`|`add`, `remove`, `replace`, `test`|
        |`/customFieldGroups`             |`add`, `remove`, `replace`, `test`|
        |`/sectionCustomFieldGroups`      |`add`, `remove`, `replace`, `test`|
        |`/lock`                          |`replace`                         |

        ### Examples

        #### Add a custom field value

        ```json
        [
        {
        \"op\": \"add\",
        \"path\": \"/customFields/com.workiva.gsr.legal_entity\",
        \"value\": \"Workiva\"
        }
        ]
        ```

        #### Remove a custom field value

        ```json
        [
        {
        \"op\": \"remove\",
        \"path\": \"/customFields/com.workiva.gsr.legal_entity\"
        }
        ]
        ```

        #### Replace a custom field value

        ```json
        [
        {
        \"op\": \"replace\",
        \"path\": \"/customFields/com.workiva.gsr.legal_entity\",
        \"value\": \"Workiva, Inc.\"
        }
        ]
        ```

        #### Verifying customFieldGroup is empty before replacing the list

        ```json
        [
        {
        \"op\": \"test\",
        \"path\": \"/customFieldGroups\",
        \"value\": []
        },
        {
        \"op\": \"replace\",
        \"path\": \"/customFieldGroups\",
        \"value\": [\"gsr.reporting\"]
        }
        ]
        ```

        #### Adding a customFieldGroup to the end of a list

        ```json
        [
        {
        \"op\": \"add\",
        \"path\": \"/customFieldGroups/-\",
        \"value\": \"gsr.reporting\"
        }
        ]
        ```


        :param document_id: The unique identifier of the document
        :param request_body: A collection of patch operations to apply to the document.
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.PartiallyUpdateDocumentByIDRequest(
            document_id=document_id,
            request_body=utils.get_pydantic_model(
                request_body, List[models.JSONPatchOperation]
            ),
        )

        req = self._build_request_async(
            method="PATCH",
            path="/documents/{documentId}",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request.request_body,
                False,
                False,
                "json",
                List[models.JSONPatchOperation],
            ),
            allow_empty_value=None,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="partiallyUpdateDocumentById",
                oauth2_scopes=["file:write"],
                security_source=self.sdk_configuration.security,
            ),
            request=req,
            error_status_codes=[
                "400",
                "401",
                "403",
                "404",
                "409",
                "429",
                "4XX",
                "500",
                "503",
                "5XX",
            ],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "202", "*"):
            return models.PartiallyUpdateDocumentByIDResponse(
                headers=utils.get_response_headers(http_res.headers)
            )
        if utils.match_response(
            http_res, ["400", "401", "403", "404", "409", "429"], "application/json"
        ):
            response_data = unmarshal_json_response(errors.ErrorResponseData, http_res)
            raise errors.ErrorResponse(response_data, http_res)
        if utils.match_response(http_res, ["500", "503"], "application/json"):
            response_data = unmarshal_json_response(errors.ErrorResponseData, http_res)
            raise errors.ErrorResponse(response_data, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)

        raise errors.SDKError("Unexpected response received", http_res)

    def document_export(
        self,
        *,
        document_id: str,
        document_export: Union[models.DocumentExport, models.DocumentExportTypedDict],
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.DocumentExportResponse:
        r"""Initiate a document export

        Asynchronously exports a [document](ref:documents#document) as .PDF or .DOCX., or .XHTML. Options are specified using a [DocumentExport](ref:documents#documentexport) object.
        When exporting XHTML that you plan to edit or modify, use the `editableXhtml` option. Otherwise, the export retains fidelity so it visually matches the document as it appears in the browser.
        Responses include a `Location` header, which indicates where to poll for export results. For more details on long-running job polling, see [Operations endpoint](ref:getoperationbyid). When the export completes, its status will be `completed`, and the response body includes a `resourceURL`. To download the exported file, perform a GET on the `resourceURL` with the same authentication credentials and flow as the export request. For more details, see [Authentication documentation](ref:authentication).


        :param document_id: The unique identifier of the document
        :param document_export: Details about the document export.
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.DocumentExportRequest(
            document_id=document_id,
            document_export=utils.get_pydantic_model(
                document_export, models.DocumentExport
            ),
        )

        req = self._build_request(
            method="POST",
            path="/documents/{documentId}/export",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request.document_export, False, False, "json", models.DocumentExport
            ),
            allow_empty_value=None,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="documentExport",
                oauth2_scopes=["file:read"],
                security_source=self.sdk_configuration.security,
            ),
            request=req,
            error_status_codes=[
                "400",
                "401",
                "403",
                "404",
                "409",
                "429",
                "4XX",
                "500",
                "503",
                "5XX",
            ],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "202", "*"):
            return models.DocumentExportResponse(
                headers=utils.get_response_headers(http_res.headers)
            )
        if utils.match_response(
            http_res, ["400", "401", "403", "404", "409", "429"], "application/json"
        ):
            response_data = unmarshal_json_response(errors.ErrorResponseData, http_res)
            raise errors.ErrorResponse(response_data, http_res)
        if utils.match_response(http_res, ["500", "503"], "application/json"):
            response_data = unmarshal_json_response(errors.ErrorResponseData, http_res)
            raise errors.ErrorResponse(response_data, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)

        raise errors.SDKError("Unexpected response received", http_res)

    async def document_export_async(
        self,
        *,
        document_id: str,
        document_export: Union[models.DocumentExport, models.DocumentExportTypedDict],
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.DocumentExportResponse:
        r"""Initiate a document export

        Asynchronously exports a [document](ref:documents#document) as .PDF or .DOCX., or .XHTML. Options are specified using a [DocumentExport](ref:documents#documentexport) object.
        When exporting XHTML that you plan to edit or modify, use the `editableXhtml` option. Otherwise, the export retains fidelity so it visually matches the document as it appears in the browser.
        Responses include a `Location` header, which indicates where to poll for export results. For more details on long-running job polling, see [Operations endpoint](ref:getoperationbyid). When the export completes, its status will be `completed`, and the response body includes a `resourceURL`. To download the exported file, perform a GET on the `resourceURL` with the same authentication credentials and flow as the export request. For more details, see [Authentication documentation](ref:authentication).


        :param document_id: The unique identifier of the document
        :param document_export: Details about the document export.
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.DocumentExportRequest(
            document_id=document_id,
            document_export=utils.get_pydantic_model(
                document_export, models.DocumentExport
            ),
        )

        req = self._build_request_async(
            method="POST",
            path="/documents/{documentId}/export",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request.document_export, False, False, "json", models.DocumentExport
            ),
            allow_empty_value=None,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="documentExport",
                oauth2_scopes=["file:read"],
                security_source=self.sdk_configuration.security,
            ),
            request=req,
            error_status_codes=[
                "400",
                "401",
                "403",
                "404",
                "409",
                "429",
                "4XX",
                "500",
                "503",
                "5XX",
            ],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "202", "*"):
            return models.DocumentExportResponse(
                headers=utils.get_response_headers(http_res.headers)
            )
        if utils.match_response(
            http_res, ["400", "401", "403", "404", "409", "429"], "application/json"
        ):
            response_data = unmarshal_json_response(errors.ErrorResponseData, http_res)
            raise errors.ErrorResponse(response_data, http_res)
        if utils.match_response(http_res, ["500", "503"], "application/json"):
            response_data = unmarshal_json_response(errors.ErrorResponseData, http_res)
            raise errors.ErrorResponse(response_data, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)

        raise errors.SDKError("Unexpected response received", http_res)

    def document_filters_reapplication(
        self,
        *,
        document_id: str,
        document_filters_reapplication: Union[
            models.DocumentFiltersReapplication,
            models.DocumentFiltersReapplicationTypedDict,
        ],
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.DocumentFiltersReapplicationResponse:
        r"""Reapply filters to the document

        Performs a [`DocumentFiltersReapplication`](ref:content#documentfiltersreapplication) on the specified document.
        This endpoint is used to refresh the document's filters based on the latest state or configuration changes.
        The filters are reapplied in the context of the document's current data state.

        This is a long-running operation. Responses include a `Location` header, which indicates where to poll for results.
        For more details on long-running job polling, see [Operations endpoint](ref:getoperationbyid).


        :param document_id: The unique identifier of the document
        :param document_filters_reapplication: The filter reapplication request to apply
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.DocumentFiltersReapplicationRequest(
            document_id=document_id,
            document_filters_reapplication=utils.get_pydantic_model(
                document_filters_reapplication, models.DocumentFiltersReapplication
            ),
        )

        req = self._build_request(
            method="POST",
            path="/documents/{documentId}/filters/reapplication",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request.document_filters_reapplication,
                False,
                False,
                "json",
                models.DocumentFiltersReapplication,
            ),
            allow_empty_value=None,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="documentFiltersReapplication",
                oauth2_scopes=["file:write"],
                security_source=self.sdk_configuration.security,
            ),
            request=req,
            error_status_codes=[
                "400",
                "401",
                "403",
                "404",
                "409",
                "429",
                "4XX",
                "500",
                "503",
                "5XX",
            ],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "202", "*"):
            return models.DocumentFiltersReapplicationResponse(
                headers=utils.get_response_headers(http_res.headers)
            )
        if utils.match_response(
            http_res, ["400", "401", "403", "404", "409", "429"], "application/json"
        ):
            response_data = unmarshal_json_response(errors.ErrorResponseData, http_res)
            raise errors.ErrorResponse(response_data, http_res)
        if utils.match_response(http_res, ["500", "503"], "application/json"):
            response_data = unmarshal_json_response(errors.ErrorResponseData, http_res)
            raise errors.ErrorResponse(response_data, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)

        raise errors.SDKError("Unexpected response received", http_res)

    async def document_filters_reapplication_async(
        self,
        *,
        document_id: str,
        document_filters_reapplication: Union[
            models.DocumentFiltersReapplication,
            models.DocumentFiltersReapplicationTypedDict,
        ],
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.DocumentFiltersReapplicationResponse:
        r"""Reapply filters to the document

        Performs a [`DocumentFiltersReapplication`](ref:content#documentfiltersreapplication) on the specified document.
        This endpoint is used to refresh the document's filters based on the latest state or configuration changes.
        The filters are reapplied in the context of the document's current data state.

        This is a long-running operation. Responses include a `Location` header, which indicates where to poll for results.
        For more details on long-running job polling, see [Operations endpoint](ref:getoperationbyid).


        :param document_id: The unique identifier of the document
        :param document_filters_reapplication: The filter reapplication request to apply
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.DocumentFiltersReapplicationRequest(
            document_id=document_id,
            document_filters_reapplication=utils.get_pydantic_model(
                document_filters_reapplication, models.DocumentFiltersReapplication
            ),
        )

        req = self._build_request_async(
            method="POST",
            path="/documents/{documentId}/filters/reapplication",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request.document_filters_reapplication,
                False,
                False,
                "json",
                models.DocumentFiltersReapplication,
            ),
            allow_empty_value=None,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="documentFiltersReapplication",
                oauth2_scopes=["file:write"],
                security_source=self.sdk_configuration.security,
            ),
            request=req,
            error_status_codes=[
                "400",
                "401",
                "403",
                "404",
                "409",
                "429",
                "4XX",
                "500",
                "503",
                "5XX",
            ],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "202", "*"):
            return models.DocumentFiltersReapplicationResponse(
                headers=utils.get_response_headers(http_res.headers)
            )
        if utils.match_response(
            http_res, ["400", "401", "403", "404", "409", "429"], "application/json"
        ):
            response_data = unmarshal_json_response(errors.ErrorResponseData, http_res)
            raise errors.ErrorResponse(response_data, http_res)
        if utils.match_response(http_res, ["500", "503"], "application/json"):
            response_data = unmarshal_json_response(errors.ErrorResponseData, http_res)
            raise errors.ErrorResponse(response_data, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)

        raise errors.SDKError("Unexpected response received", http_res)

    def document_links_publication(
        self,
        *,
        document_id: str,
        links_publication_options: Union[
            models.LinksPublicationOptions, models.LinksPublicationOptionsTypedDict
        ],
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.DocumentLinksPublicationResponse:
        r"""Initiate publication of links in a document

        Publishes the links in a document - either all (as document owner) or only one's own. Content at the latest document revision will be used for publish.
        The response also includes a `Location` header, which indicates where to poll for operation results. For more details on long-running job polling, see [Operations endpoint](ref:getoperationbyid).


        :param document_id: The unique identifier of the document
        :param links_publication_options: Details about the link publication.
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.DocumentLinksPublicationRequest(
            document_id=document_id,
            links_publication_options=utils.get_pydantic_model(
                links_publication_options, models.LinksPublicationOptions
            ),
        )

        req = self._build_request(
            method="POST",
            path="/documents/{documentId}/links/publication",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request.links_publication_options,
                False,
                False,
                "json",
                models.LinksPublicationOptions,
            ),
            allow_empty_value=None,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="documentLinksPublication",
                oauth2_scopes=["file:write"],
                security_source=self.sdk_configuration.security,
            ),
            request=req,
            error_status_codes=[
                "400",
                "401",
                "403",
                "404",
                "409",
                "429",
                "4XX",
                "500",
                "503",
                "5XX",
            ],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "202", "*"):
            return models.DocumentLinksPublicationResponse(
                headers=utils.get_response_headers(http_res.headers)
            )
        if utils.match_response(
            http_res, ["400", "401", "403", "404", "409", "429"], "application/json"
        ):
            response_data = unmarshal_json_response(errors.ErrorResponseData, http_res)
            raise errors.ErrorResponse(response_data, http_res)
        if utils.match_response(http_res, ["500", "503"], "application/json"):
            response_data = unmarshal_json_response(errors.ErrorResponseData, http_res)
            raise errors.ErrorResponse(response_data, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)

        raise errors.SDKError("Unexpected response received", http_res)

    async def document_links_publication_async(
        self,
        *,
        document_id: str,
        links_publication_options: Union[
            models.LinksPublicationOptions, models.LinksPublicationOptionsTypedDict
        ],
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.DocumentLinksPublicationResponse:
        r"""Initiate publication of links in a document

        Publishes the links in a document - either all (as document owner) or only one's own. Content at the latest document revision will be used for publish.
        The response also includes a `Location` header, which indicates where to poll for operation results. For more details on long-running job polling, see [Operations endpoint](ref:getoperationbyid).


        :param document_id: The unique identifier of the document
        :param links_publication_options: Details about the link publication.
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.DocumentLinksPublicationRequest(
            document_id=document_id,
            links_publication_options=utils.get_pydantic_model(
                links_publication_options, models.LinksPublicationOptions
            ),
        )

        req = self._build_request_async(
            method="POST",
            path="/documents/{documentId}/links/publication",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request.links_publication_options,
                False,
                False,
                "json",
                models.LinksPublicationOptions,
            ),
            allow_empty_value=None,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="documentLinksPublication",
                oauth2_scopes=["file:write"],
                security_source=self.sdk_configuration.security,
            ),
            request=req,
            error_status_codes=[
                "400",
                "401",
                "403",
                "404",
                "409",
                "429",
                "4XX",
                "500",
                "503",
                "5XX",
            ],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "202", "*"):
            return models.DocumentLinksPublicationResponse(
                headers=utils.get_response_headers(http_res.headers)
            )
        if utils.match_response(
            http_res, ["400", "401", "403", "404", "409", "429"], "application/json"
        ):
            response_data = unmarshal_json_response(errors.ErrorResponseData, http_res)
            raise errors.ErrorResponse(response_data, http_res)
        if utils.match_response(http_res, ["500", "503"], "application/json"):
            response_data = unmarshal_json_response(errors.ErrorResponseData, http_res)
            raise errors.ErrorResponse(response_data, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)

        raise errors.SDKError("Unexpected response received", http_res)

    def get_document_milestones(
        self,
        *,
        document_id: str,
        next: Optional[str] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> Optional[models.GetDocumentMilestonesResponse]:
        r"""Retrieve a list of milestones for a document

        Returns [MilestoneListResult](ref:milestones#milestonelistresult).

        :param document_id: The unique identifier of the document
        :param next: Pagination cursor for next set of results.
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.GetDocumentMilestonesRequest(
            document_id=document_id,
            next=next,
        )

        req = self._build_request(
            method="GET",
            path="/documents/{documentId}/milestones",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            allow_empty_value=None,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="getDocumentMilestones",
                oauth2_scopes=["file:read"],
                security_source=self.sdk_configuration.security,
            ),
            request=req,
            error_status_codes=[
                "400",
                "401",
                "403",
                "404",
                "409",
                "429",
                "4XX",
                "500",
                "503",
                "5XX",
            ],
            retry_config=retry_config,
        )

        def next_func() -> Optional[models.GetDocumentMilestonesResponse]:
            body = utils.unmarshal_json(http_res.text, Union[Dict[Any, Any], List[Any]])

            next_cursor = JSONPath("$['@nextLink']").parse(body)

            if len(next_cursor) == 0:
                return None

            next_cursor = next_cursor[0]
            if next_cursor is None or str(next_cursor).strip() == "":
                return None

            return self.get_document_milestones(
                document_id=document_id,
                next=next,
                retries=retries,
            )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return models.GetDocumentMilestonesResponse(
                result=unmarshal_json_response(models.MilestoneListResult, http_res),
                next=next_func,
            )
        if utils.match_response(
            http_res, ["400", "401", "403", "404", "409", "429"], "application/json"
        ):
            response_data = unmarshal_json_response(errors.ErrorResponseData, http_res)
            raise errors.ErrorResponse(response_data, http_res)
        if utils.match_response(http_res, ["500", "503"], "application/json"):
            response_data = unmarshal_json_response(errors.ErrorResponseData, http_res)
            raise errors.ErrorResponse(response_data, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)

        raise errors.SDKError("Unexpected response received", http_res)

    async def get_document_milestones_async(
        self,
        *,
        document_id: str,
        next: Optional[str] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> Optional[models.GetDocumentMilestonesResponse]:
        r"""Retrieve a list of milestones for a document

        Returns [MilestoneListResult](ref:milestones#milestonelistresult).

        :param document_id: The unique identifier of the document
        :param next: Pagination cursor for next set of results.
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.GetDocumentMilestonesRequest(
            document_id=document_id,
            next=next,
        )

        req = self._build_request_async(
            method="GET",
            path="/documents/{documentId}/milestones",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            allow_empty_value=None,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="getDocumentMilestones",
                oauth2_scopes=["file:read"],
                security_source=self.sdk_configuration.security,
            ),
            request=req,
            error_status_codes=[
                "400",
                "401",
                "403",
                "404",
                "409",
                "429",
                "4XX",
                "500",
                "503",
                "5XX",
            ],
            retry_config=retry_config,
        )

        def next_func() -> Awaitable[Optional[models.GetDocumentMilestonesResponse]]:
            body = utils.unmarshal_json(http_res.text, Union[Dict[Any, Any], List[Any]])

            async def empty_result():
                return None

            next_cursor = JSONPath("$['@nextLink']").parse(body)

            if len(next_cursor) == 0:
                return empty_result()

            next_cursor = next_cursor[0]
            if next_cursor is None or str(next_cursor).strip() == "":
                return empty_result()

            return self.get_document_milestones_async(
                document_id=document_id,
                next=next,
                retries=retries,
            )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return models.GetDocumentMilestonesResponse(
                result=unmarshal_json_response(models.MilestoneListResult, http_res),
                next=next_func,
            )
        if utils.match_response(
            http_res, ["400", "401", "403", "404", "409", "429"], "application/json"
        ):
            response_data = unmarshal_json_response(errors.ErrorResponseData, http_res)
            raise errors.ErrorResponse(response_data, http_res)
        if utils.match_response(http_res, ["500", "503"], "application/json"):
            response_data = unmarshal_json_response(errors.ErrorResponseData, http_res)
            raise errors.ErrorResponse(response_data, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)

        raise errors.SDKError("Unexpected response received", http_res)

    def get_document_permissions(
        self,
        *,
        document_id: str,
        filter_: Optional[str] = None,
        maxpagesize: Optional[int] = 1000,
        next: Optional[str] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> Optional[models.GetDocumentPermissionsResponse]:
        r"""Retrieve permissions for a document

        Retrieves a paginated list of permissions for a given document


        :param document_id: The unique identifier of the document
        :param filter_: The properties to filter the results by.
        :param maxpagesize: The maximum number of results to retrieve
        :param next: Pagination cursor for next set of results.
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.GetDocumentPermissionsRequest(
            document_id=document_id,
            filter_=filter_,
            maxpagesize=maxpagesize,
            next=next,
        )

        req = self._build_request(
            method="GET",
            path="/documents/{documentId}/permissions",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            allow_empty_value=None,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="getDocumentPermissions",
                oauth2_scopes=["file:read"],
                security_source=self.sdk_configuration.security,
            ),
            request=req,
            error_status_codes=[
                "400",
                "401",
                "403",
                "404",
                "409",
                "429",
                "4XX",
                "500",
                "503",
                "5XX",
            ],
            retry_config=retry_config,
        )

        def next_func() -> Optional[models.GetDocumentPermissionsResponse]:
            body = utils.unmarshal_json(http_res.text, Union[Dict[Any, Any], List[Any]])

            next_cursor = JSONPath("$['@nextLink']").parse(body)

            if len(next_cursor) == 0:
                return None

            next_cursor = next_cursor[0]
            if next_cursor is None or str(next_cursor).strip() == "":
                return None

            return self.get_document_permissions(
                document_id=document_id,
                filter_=filter_,
                maxpagesize=maxpagesize,
                next=next,
                retries=retries,
            )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return models.GetDocumentPermissionsResponse(
                result=unmarshal_json_response(
                    models.ResourcePermissionsListResult, http_res
                ),
                next=next_func,
            )
        if utils.match_response(
            http_res, ["400", "401", "403", "404", "409", "429"], "application/json"
        ):
            response_data = unmarshal_json_response(errors.ErrorResponseData, http_res)
            raise errors.ErrorResponse(response_data, http_res)
        if utils.match_response(http_res, ["500", "503"], "application/json"):
            response_data = unmarshal_json_response(errors.ErrorResponseData, http_res)
            raise errors.ErrorResponse(response_data, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)

        raise errors.SDKError("Unexpected response received", http_res)

    async def get_document_permissions_async(
        self,
        *,
        document_id: str,
        filter_: Optional[str] = None,
        maxpagesize: Optional[int] = 1000,
        next: Optional[str] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> Optional[models.GetDocumentPermissionsResponse]:
        r"""Retrieve permissions for a document

        Retrieves a paginated list of permissions for a given document


        :param document_id: The unique identifier of the document
        :param filter_: The properties to filter the results by.
        :param maxpagesize: The maximum number of results to retrieve
        :param next: Pagination cursor for next set of results.
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.GetDocumentPermissionsRequest(
            document_id=document_id,
            filter_=filter_,
            maxpagesize=maxpagesize,
            next=next,
        )

        req = self._build_request_async(
            method="GET",
            path="/documents/{documentId}/permissions",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            allow_empty_value=None,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="getDocumentPermissions",
                oauth2_scopes=["file:read"],
                security_source=self.sdk_configuration.security,
            ),
            request=req,
            error_status_codes=[
                "400",
                "401",
                "403",
                "404",
                "409",
                "429",
                "4XX",
                "500",
                "503",
                "5XX",
            ],
            retry_config=retry_config,
        )

        def next_func() -> Awaitable[Optional[models.GetDocumentPermissionsResponse]]:
            body = utils.unmarshal_json(http_res.text, Union[Dict[Any, Any], List[Any]])

            async def empty_result():
                return None

            next_cursor = JSONPath("$['@nextLink']").parse(body)

            if len(next_cursor) == 0:
                return empty_result()

            next_cursor = next_cursor[0]
            if next_cursor is None or str(next_cursor).strip() == "":
                return empty_result()

            return self.get_document_permissions_async(
                document_id=document_id,
                filter_=filter_,
                maxpagesize=maxpagesize,
                next=next,
                retries=retries,
            )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return models.GetDocumentPermissionsResponse(
                result=unmarshal_json_response(
                    models.ResourcePermissionsListResult, http_res
                ),
                next=next_func,
            )
        if utils.match_response(
            http_res, ["400", "401", "403", "404", "409", "429"], "application/json"
        ):
            response_data = unmarshal_json_response(errors.ErrorResponseData, http_res)
            raise errors.ErrorResponse(response_data, http_res)
        if utils.match_response(http_res, ["500", "503"], "application/json"):
            response_data = unmarshal_json_response(errors.ErrorResponseData, http_res)
            raise errors.ErrorResponse(response_data, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)

        raise errors.SDKError("Unexpected response received", http_res)

    def document_permissions_modification(
        self,
        *,
        document_id: str,
        resource_permissions_modification: Union[
            models.ResourcePermissionsModification,
            models.ResourcePermissionsModificationTypedDict,
        ],
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ):
        r"""Modify permissions on a document

        Assign and/or revoke permissions on a document. If any modification in a request fails, all modifications on that request fail. <br /><br /> _To modify an existing permission, the existing permission must first be  explicitly revoked. Then, the new permission needs to be assigned. This  can be done in a single request by sending `toAssign` and `toRevoke` in  the request body._


        :param document_id: The unique identifier of the document
        :param resource_permissions_modification: Details about the document permissions modification.
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.DocumentPermissionsModificationRequest(
            document_id=document_id,
            resource_permissions_modification=utils.get_pydantic_model(
                resource_permissions_modification,
                models.ResourcePermissionsModification,
            ),
        )

        req = self._build_request(
            method="POST",
            path="/documents/{documentId}/permissions/modification",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request.resource_permissions_modification,
                False,
                False,
                "json",
                models.ResourcePermissionsModification,
            ),
            allow_empty_value=None,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="documentPermissionsModification",
                oauth2_scopes=["file:write"],
                security_source=self.sdk_configuration.security,
            ),
            request=req,
            error_status_codes=[
                "400",
                "401",
                "403",
                "404",
                "409",
                "429",
                "4XX",
                "500",
                "503",
                "5XX",
            ],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "204", "*"):
            return
        if utils.match_response(
            http_res, ["400", "401", "403", "404", "409", "429"], "application/json"
        ):
            response_data = unmarshal_json_response(errors.ErrorResponseData, http_res)
            raise errors.ErrorResponse(response_data, http_res)
        if utils.match_response(http_res, ["500", "503"], "application/json"):
            response_data = unmarshal_json_response(errors.ErrorResponseData, http_res)
            raise errors.ErrorResponse(response_data, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)

        raise errors.SDKError("Unexpected response received", http_res)

    async def document_permissions_modification_async(
        self,
        *,
        document_id: str,
        resource_permissions_modification: Union[
            models.ResourcePermissionsModification,
            models.ResourcePermissionsModificationTypedDict,
        ],
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ):
        r"""Modify permissions on a document

        Assign and/or revoke permissions on a document. If any modification in a request fails, all modifications on that request fail. <br /><br /> _To modify an existing permission, the existing permission must first be  explicitly revoked. Then, the new permission needs to be assigned. This  can be done in a single request by sending `toAssign` and `toRevoke` in  the request body._


        :param document_id: The unique identifier of the document
        :param resource_permissions_modification: Details about the document permissions modification.
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.DocumentPermissionsModificationRequest(
            document_id=document_id,
            resource_permissions_modification=utils.get_pydantic_model(
                resource_permissions_modification,
                models.ResourcePermissionsModification,
            ),
        )

        req = self._build_request_async(
            method="POST",
            path="/documents/{documentId}/permissions/modification",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request.resource_permissions_modification,
                False,
                False,
                "json",
                models.ResourcePermissionsModification,
            ),
            allow_empty_value=None,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="documentPermissionsModification",
                oauth2_scopes=["file:write"],
                security_source=self.sdk_configuration.security,
            ),
            request=req,
            error_status_codes=[
                "400",
                "401",
                "403",
                "404",
                "409",
                "429",
                "4XX",
                "500",
                "503",
                "5XX",
            ],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "204", "*"):
            return
        if utils.match_response(
            http_res, ["400", "401", "403", "404", "409", "429"], "application/json"
        ):
            response_data = unmarshal_json_response(errors.ErrorResponseData, http_res)
            raise errors.ErrorResponse(response_data, http_res)
        if utils.match_response(http_res, ["500", "503"], "application/json"):
            response_data = unmarshal_json_response(errors.ErrorResponseData, http_res)
            raise errors.ErrorResponse(response_data, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)

        raise errors.SDKError("Unexpected response received", http_res)

    def get_sections(
        self,
        *,
        document_id: str,
        revision: Optional[str] = None,
        maxpagesize: Optional[int] = 1000,
        next: Optional[str] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> Optional[models.GetSectionsResponse]:
        r"""Retrieve a list of sections

        Returns a list of [sections](ref:documents#section).


        :param document_id: The unique identifier of the document
        :param revision: Returns resources at a specific revision
        :param maxpagesize: The maximum number of results to retrieve
        :param next: Pagination cursor for next set of results.
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.GetSectionsRequest(
            document_id=document_id,
            revision=revision,
            maxpagesize=maxpagesize,
            next=next,
        )

        req = self._build_request(
            method="GET",
            path="/documents/{documentId}/sections",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            allow_empty_value=None,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="getSections",
                oauth2_scopes=["file:read"],
                security_source=self.sdk_configuration.security,
            ),
            request=req,
            error_status_codes=[
                "400",
                "401",
                "403",
                "404",
                "409",
                "429",
                "4XX",
                "500",
                "503",
                "5XX",
            ],
            retry_config=retry_config,
        )

        def next_func() -> Optional[models.GetSectionsResponse]:
            body = utils.unmarshal_json(http_res.text, Union[Dict[Any, Any], List[Any]])

            next_cursor = JSONPath("$['@nextLink']").parse(body)

            if len(next_cursor) == 0:
                return None

            next_cursor = next_cursor[0]
            if next_cursor is None or str(next_cursor).strip() == "":
                return None

            return self.get_sections(
                document_id=document_id,
                revision=revision,
                maxpagesize=maxpagesize,
                next=next,
                retries=retries,
            )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return models.GetSectionsResponse(
                result=unmarshal_json_response(models.SectionsListResult, http_res),
                next=next_func,
            )
        if utils.match_response(
            http_res, ["400", "401", "403", "404", "409", "429"], "application/json"
        ):
            response_data = unmarshal_json_response(errors.ErrorResponseData, http_res)
            raise errors.ErrorResponse(response_data, http_res)
        if utils.match_response(http_res, ["500", "503"], "application/json"):
            response_data = unmarshal_json_response(errors.ErrorResponseData, http_res)
            raise errors.ErrorResponse(response_data, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)

        raise errors.SDKError("Unexpected response received", http_res)

    async def get_sections_async(
        self,
        *,
        document_id: str,
        revision: Optional[str] = None,
        maxpagesize: Optional[int] = 1000,
        next: Optional[str] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> Optional[models.GetSectionsResponse]:
        r"""Retrieve a list of sections

        Returns a list of [sections](ref:documents#section).


        :param document_id: The unique identifier of the document
        :param revision: Returns resources at a specific revision
        :param maxpagesize: The maximum number of results to retrieve
        :param next: Pagination cursor for next set of results.
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.GetSectionsRequest(
            document_id=document_id,
            revision=revision,
            maxpagesize=maxpagesize,
            next=next,
        )

        req = self._build_request_async(
            method="GET",
            path="/documents/{documentId}/sections",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            allow_empty_value=None,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="getSections",
                oauth2_scopes=["file:read"],
                security_source=self.sdk_configuration.security,
            ),
            request=req,
            error_status_codes=[
                "400",
                "401",
                "403",
                "404",
                "409",
                "429",
                "4XX",
                "500",
                "503",
                "5XX",
            ],
            retry_config=retry_config,
        )

        def next_func() -> Awaitable[Optional[models.GetSectionsResponse]]:
            body = utils.unmarshal_json(http_res.text, Union[Dict[Any, Any], List[Any]])

            async def empty_result():
                return None

            next_cursor = JSONPath("$['@nextLink']").parse(body)

            if len(next_cursor) == 0:
                return empty_result()

            next_cursor = next_cursor[0]
            if next_cursor is None or str(next_cursor).strip() == "":
                return empty_result()

            return self.get_sections_async(
                document_id=document_id,
                revision=revision,
                maxpagesize=maxpagesize,
                next=next,
                retries=retries,
            )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return models.GetSectionsResponse(
                result=unmarshal_json_response(models.SectionsListResult, http_res),
                next=next_func,
            )
        if utils.match_response(
            http_res, ["400", "401", "403", "404", "409", "429"], "application/json"
        ):
            response_data = unmarshal_json_response(errors.ErrorResponseData, http_res)
            raise errors.ErrorResponse(response_data, http_res)
        if utils.match_response(http_res, ["500", "503"], "application/json"):
            response_data = unmarshal_json_response(errors.ErrorResponseData, http_res)
            raise errors.ErrorResponse(response_data, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)

        raise errors.SDKError("Unexpected response received", http_res)

    def create_section(
        self,
        *,
        document_id: str,
        section: Union[models.SectionInput, models.SectionInputTypedDict],
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.Section:
        r"""Create a new section in a document

        Creates a new [section](ref:documents#section) in a [document](ref:documents#document), given its properties. By default, the new section appears at the top-most position.


        :param document_id: The unique identifier of the document
        :param section: The properties of the section to create
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.CreateSectionRequest(
            document_id=document_id,
            section=utils.get_pydantic_model(section, models.SectionInput),
        )

        req = self._build_request(
            method="POST",
            path="/documents/{documentId}/sections",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request.section, False, False, "json", models.SectionInput
            ),
            allow_empty_value=None,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="createSection",
                oauth2_scopes=["file:write"],
                security_source=self.sdk_configuration.security,
            ),
            request=req,
            error_status_codes=[
                "400",
                "401",
                "403",
                "404",
                "409",
                "429",
                "4XX",
                "500",
                "503",
                "5XX",
            ],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "201", "application/json"):
            return unmarshal_json_response(models.Section, http_res)
        if utils.match_response(
            http_res, ["400", "401", "403", "404", "409", "429"], "application/json"
        ):
            response_data = unmarshal_json_response(errors.ErrorResponseData, http_res)
            raise errors.ErrorResponse(response_data, http_res)
        if utils.match_response(http_res, ["500", "503"], "application/json"):
            response_data = unmarshal_json_response(errors.ErrorResponseData, http_res)
            raise errors.ErrorResponse(response_data, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)

        raise errors.SDKError("Unexpected response received", http_res)

    async def create_section_async(
        self,
        *,
        document_id: str,
        section: Union[models.SectionInput, models.SectionInputTypedDict],
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.Section:
        r"""Create a new section in a document

        Creates a new [section](ref:documents#section) in a [document](ref:documents#document), given its properties. By default, the new section appears at the top-most position.


        :param document_id: The unique identifier of the document
        :param section: The properties of the section to create
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.CreateSectionRequest(
            document_id=document_id,
            section=utils.get_pydantic_model(section, models.SectionInput),
        )

        req = self._build_request_async(
            method="POST",
            path="/documents/{documentId}/sections",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request.section, False, False, "json", models.SectionInput
            ),
            allow_empty_value=None,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="createSection",
                oauth2_scopes=["file:write"],
                security_source=self.sdk_configuration.security,
            ),
            request=req,
            error_status_codes=[
                "400",
                "401",
                "403",
                "404",
                "409",
                "429",
                "4XX",
                "500",
                "503",
                "5XX",
            ],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "201", "application/json"):
            return unmarshal_json_response(models.Section, http_res)
        if utils.match_response(
            http_res, ["400", "401", "403", "404", "409", "429"], "application/json"
        ):
            response_data = unmarshal_json_response(errors.ErrorResponseData, http_res)
            raise errors.ErrorResponse(response_data, http_res)
        if utils.match_response(http_res, ["500", "503"], "application/json"):
            response_data = unmarshal_json_response(errors.ErrorResponseData, http_res)
            raise errors.ErrorResponse(response_data, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)

        raise errors.SDKError("Unexpected response received", http_res)

    def delete_section_by_id(
        self,
        *,
        document_id: str,
        section_id: str,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ):
        r"""Delete a single section

        Deletes a [section](ref:documents#section) given its ID.


        :param document_id: The unique identifier of the document
        :param section_id: The unique identifier of the section
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.DeleteSectionByIDRequest(
            document_id=document_id,
            section_id=section_id,
        )

        req = self._build_request(
            method="DELETE",
            path="/documents/{documentId}/sections/{sectionId}",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            allow_empty_value=None,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="deleteSectionById",
                oauth2_scopes=["file:write"],
                security_source=self.sdk_configuration.security,
            ),
            request=req,
            error_status_codes=[
                "400",
                "401",
                "403",
                "404",
                "409",
                "429",
                "4XX",
                "500",
                "503",
                "5XX",
            ],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "204", "*"):
            return
        if utils.match_response(
            http_res, ["400", "401", "403", "404", "409", "429"], "application/json"
        ):
            response_data = unmarshal_json_response(errors.ErrorResponseData, http_res)
            raise errors.ErrorResponse(response_data, http_res)
        if utils.match_response(http_res, ["500", "503"], "application/json"):
            response_data = unmarshal_json_response(errors.ErrorResponseData, http_res)
            raise errors.ErrorResponse(response_data, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)

        raise errors.SDKError("Unexpected response received", http_res)

    async def delete_section_by_id_async(
        self,
        *,
        document_id: str,
        section_id: str,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ):
        r"""Delete a single section

        Deletes a [section](ref:documents#section) given its ID.


        :param document_id: The unique identifier of the document
        :param section_id: The unique identifier of the section
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.DeleteSectionByIDRequest(
            document_id=document_id,
            section_id=section_id,
        )

        req = self._build_request_async(
            method="DELETE",
            path="/documents/{documentId}/sections/{sectionId}",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            allow_empty_value=None,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="deleteSectionById",
                oauth2_scopes=["file:write"],
                security_source=self.sdk_configuration.security,
            ),
            request=req,
            error_status_codes=[
                "400",
                "401",
                "403",
                "404",
                "409",
                "429",
                "4XX",
                "500",
                "503",
                "5XX",
            ],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "204", "*"):
            return
        if utils.match_response(
            http_res, ["400", "401", "403", "404", "409", "429"], "application/json"
        ):
            response_data = unmarshal_json_response(errors.ErrorResponseData, http_res)
            raise errors.ErrorResponse(response_data, http_res)
        if utils.match_response(http_res, ["500", "503"], "application/json"):
            response_data = unmarshal_json_response(errors.ErrorResponseData, http_res)
            raise errors.ErrorResponse(response_data, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)

        raise errors.SDKError("Unexpected response received", http_res)

    def get_section_by_id(
        self,
        *,
        document_id: str,
        section_id: str,
        expand: Optional[str] = None,
        revision: Optional[str] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.Section:
        r"""Retrieve a single section

        Retrieves a [section](ref:documents#section) given its ID.


        :param document_id: The unique identifier of the document
        :param section_id: The unique identifier of the section
        :param expand: Returns related resources inline with the main resource
        :param revision: Returns resources at a specific revision
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.GetSectionByIDRequest(
            document_id=document_id,
            section_id=section_id,
            expand=expand,
            revision=revision,
        )

        req = self._build_request(
            method="GET",
            path="/documents/{documentId}/sections/{sectionId}",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            allow_empty_value=None,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="getSectionById",
                oauth2_scopes=["file:read"],
                security_source=self.sdk_configuration.security,
            ),
            request=req,
            error_status_codes=[
                "400",
                "401",
                "403",
                "404",
                "409",
                "429",
                "4XX",
                "500",
                "503",
                "5XX",
            ],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(models.Section, http_res)
        if utils.match_response(
            http_res, ["400", "401", "403", "404", "409", "429"], "application/json"
        ):
            response_data = unmarshal_json_response(errors.ErrorResponseData, http_res)
            raise errors.ErrorResponse(response_data, http_res)
        if utils.match_response(http_res, ["500", "503"], "application/json"):
            response_data = unmarshal_json_response(errors.ErrorResponseData, http_res)
            raise errors.ErrorResponse(response_data, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)

        raise errors.SDKError("Unexpected response received", http_res)

    async def get_section_by_id_async(
        self,
        *,
        document_id: str,
        section_id: str,
        expand: Optional[str] = None,
        revision: Optional[str] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.Section:
        r"""Retrieve a single section

        Retrieves a [section](ref:documents#section) given its ID.


        :param document_id: The unique identifier of the document
        :param section_id: The unique identifier of the section
        :param expand: Returns related resources inline with the main resource
        :param revision: Returns resources at a specific revision
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.GetSectionByIDRequest(
            document_id=document_id,
            section_id=section_id,
            expand=expand,
            revision=revision,
        )

        req = self._build_request_async(
            method="GET",
            path="/documents/{documentId}/sections/{sectionId}",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            allow_empty_value=None,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="getSectionById",
                oauth2_scopes=["file:read"],
                security_source=self.sdk_configuration.security,
            ),
            request=req,
            error_status_codes=[
                "400",
                "401",
                "403",
                "404",
                "409",
                "429",
                "4XX",
                "500",
                "503",
                "5XX",
            ],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(models.Section, http_res)
        if utils.match_response(
            http_res, ["400", "401", "403", "404", "409", "429"], "application/json"
        ):
            response_data = unmarshal_json_response(errors.ErrorResponseData, http_res)
            raise errors.ErrorResponse(response_data, http_res)
        if utils.match_response(http_res, ["500", "503"], "application/json"):
            response_data = unmarshal_json_response(errors.ErrorResponseData, http_res)
            raise errors.ErrorResponse(response_data, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)

        raise errors.SDKError("Unexpected response received", http_res)

    def partially_update_section_by_id(
        self,
        *,
        document_id: str,
        section_id: str,
        request_body: Union[
            List[models.JSONPatchOperation], List[models.JSONPatchOperationTypedDict]
        ],
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.PartiallyUpdateSectionByIDResponse:
        r"""Partially update a single section

        Updates the properties of a [section](ref:documents#section).

        This is a long running operation. Responses include a `Location` header,
        which indicates where to poll for results. For more details on long-running job polling,
        see [Operations endpoint](ref:getoperationbyid).

        ### Options

        | Path                                     | PATCH Operations Supported         |
        |------------------------------------------|------------------------------------|
        | `/name`                                  | `replace`                          |
        | `/parent`                                | `replace`                          |
        | `/parent/id`                             | `replace`                          |
        | `/index`                                 | `replace`                          |
        | `/nonPrinting`                           | `replace`                          |
        | `/customFields`                          | `add`, `remove`, `replace`, `test` |
        | `/customFields/<customFieldId>`          | `add`, `remove`, `replace`, `test` |
        | `/lock`                                  | `replace`                          |
        | `/properties/margins/top`                | `replace`                          |
        | `/properties/margins/bottom`             | `replace`                          |
        | `/properties/margins/right`              | `replace`                          |
        | `/properties/margins/left`               | `replace`                          |
        | `/properties/pageBreakBefore`            | `replace`                          |
        | `/properties/exhibit`                    | `replace`                          |
        | `/properties/edgarKeepTogether`          | `replace`                          |
        | `/properties/pageNumber/reset`           | `replace`                          |
        | `/properties/pageNumber/startAt`         | `replace`                          |
        | `/properties/background/color`           | `replace`                          |
        | `/properties/background/image`           | `replace`                          |
        | `/properties/restartFootnoteNumbering`   | `replace`                          |
        | `/properties/header/alternatingPage`     | `replace`                          |
        | `/properties/header/differentFirstPage`  | `replace`                          |
        | `/properties/header/differentLastPage`   | `replace`                          |
        | `/properties/header/margin/right`        | `replace`                          |
        | `/properties/header/margin/left`         | `replace`                          |
        | `/properties/header/matchSectionMargins` | `replace`                          |
        | `/properties/header/positionFromTop`     | `replace`                          |
        | `/properties/header/sameAsPrevious`      | `replace`                          |
        | `/properties/footer/alternatingPage`     | `replace`                          |
        | `/properties/footer/differentFirstPage`  | `replace`                          |
        | `/properties/footer/differentLastPage`   | `replace`                          |
        | `/properties/footer/margin/right`        | `replace`                          |
        | `/properties/footer/margin/left`         | `replace`                          |
        | `/properties/footer/matchSectionMargins` | `replace`                          |
        | `/properties/footer/positionFromBottom`  | `replace`                          |
        | `/properties/footer/sameAsPrevious`      | `replace`                          |

        ### Examples

        #### Update the name of a section

        ```json
        [
        {
        \"op\": \"replace\",
        \"path\": \"/name\",
        \"value\": \"Introduction\"
        }
        ]
        ```

        #### Update the parent of a section (preserving its index)

        ```json
        [
        {
        \"op\": \"replace\",
        \"path\": \"/parent\",
        \"value\": {
        \"id\": \"b9b3ddb587744a27aafda3c9865f1f0a_1\"
        }
        }
        ]
        ```

        #### Update the parent of a section (making it the first child)

        ```json
        [
        {
        \"op\": \"replace\",
        \"path\": \"/parent\",
        \"value\": {
        \"id\": \"b9b3ddb587744a27aafda3c9865f1f0a_1\"
        }
        },
        {
        \"op\": \"replace\",
        \"path\": \"/index\",
        \"value\": 0
        }
        ]
        ```

        #### Add a custom field value
        ```json

        [
        {
        \"op\": \"add\",
        \"path\": \"/customFields/com.workiva.gsr.legal_entity\",
        \"value\": \"Workiva\"
        }
        ]
        ```

        #### Remove a custom field value

        ```json
        [
        {
        \"op\": \"remove\",
        \"path\": \"/customFields/com.workiva.gsr.legal_entity\"
        }
        ]
        ```

        #### Replace a custom field value
        ```json

        [
        {
        \"op\": \"replace\",
        \"path\": \"/customFields/com.workiva.gsr.legal_entity\",
        \"value\": \"Workiva, Inc.\"
        }
        ]
        ```


        :param document_id: The unique identifier of the document
        :param section_id: The unique identifier of the section
        :param request_body: A collection of patch operations to apply to the section.
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.PartiallyUpdateSectionByIDRequest(
            document_id=document_id,
            section_id=section_id,
            request_body=utils.get_pydantic_model(
                request_body, List[models.JSONPatchOperation]
            ),
        )

        req = self._build_request(
            method="PATCH",
            path="/documents/{documentId}/sections/{sectionId}",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request.request_body,
                False,
                False,
                "json",
                List[models.JSONPatchOperation],
            ),
            allow_empty_value=None,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="partiallyUpdateSectionById",
                oauth2_scopes=["file:write"],
                security_source=self.sdk_configuration.security,
            ),
            request=req,
            error_status_codes=[
                "400",
                "401",
                "403",
                "404",
                "409",
                "429",
                "4XX",
                "500",
                "503",
                "5XX",
            ],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "202", "*"):
            return models.PartiallyUpdateSectionByIDResponse(
                headers=utils.get_response_headers(http_res.headers)
            )
        if utils.match_response(
            http_res, ["400", "401", "403", "404", "409", "429"], "application/json"
        ):
            response_data = unmarshal_json_response(errors.ErrorResponseData, http_res)
            raise errors.ErrorResponse(response_data, http_res)
        if utils.match_response(http_res, ["500", "503"], "application/json"):
            response_data = unmarshal_json_response(errors.ErrorResponseData, http_res)
            raise errors.ErrorResponse(response_data, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)

        raise errors.SDKError("Unexpected response received", http_res)

    async def partially_update_section_by_id_async(
        self,
        *,
        document_id: str,
        section_id: str,
        request_body: Union[
            List[models.JSONPatchOperation], List[models.JSONPatchOperationTypedDict]
        ],
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.PartiallyUpdateSectionByIDResponse:
        r"""Partially update a single section

        Updates the properties of a [section](ref:documents#section).

        This is a long running operation. Responses include a `Location` header,
        which indicates where to poll for results. For more details on long-running job polling,
        see [Operations endpoint](ref:getoperationbyid).

        ### Options

        | Path                                     | PATCH Operations Supported         |
        |------------------------------------------|------------------------------------|
        | `/name`                                  | `replace`                          |
        | `/parent`                                | `replace`                          |
        | `/parent/id`                             | `replace`                          |
        | `/index`                                 | `replace`                          |
        | `/nonPrinting`                           | `replace`                          |
        | `/customFields`                          | `add`, `remove`, `replace`, `test` |
        | `/customFields/<customFieldId>`          | `add`, `remove`, `replace`, `test` |
        | `/lock`                                  | `replace`                          |
        | `/properties/margins/top`                | `replace`                          |
        | `/properties/margins/bottom`             | `replace`                          |
        | `/properties/margins/right`              | `replace`                          |
        | `/properties/margins/left`               | `replace`                          |
        | `/properties/pageBreakBefore`            | `replace`                          |
        | `/properties/exhibit`                    | `replace`                          |
        | `/properties/edgarKeepTogether`          | `replace`                          |
        | `/properties/pageNumber/reset`           | `replace`                          |
        | `/properties/pageNumber/startAt`         | `replace`                          |
        | `/properties/background/color`           | `replace`                          |
        | `/properties/background/image`           | `replace`                          |
        | `/properties/restartFootnoteNumbering`   | `replace`                          |
        | `/properties/header/alternatingPage`     | `replace`                          |
        | `/properties/header/differentFirstPage`  | `replace`                          |
        | `/properties/header/differentLastPage`   | `replace`                          |
        | `/properties/header/margin/right`        | `replace`                          |
        | `/properties/header/margin/left`         | `replace`                          |
        | `/properties/header/matchSectionMargins` | `replace`                          |
        | `/properties/header/positionFromTop`     | `replace`                          |
        | `/properties/header/sameAsPrevious`      | `replace`                          |
        | `/properties/footer/alternatingPage`     | `replace`                          |
        | `/properties/footer/differentFirstPage`  | `replace`                          |
        | `/properties/footer/differentLastPage`   | `replace`                          |
        | `/properties/footer/margin/right`        | `replace`                          |
        | `/properties/footer/margin/left`         | `replace`                          |
        | `/properties/footer/matchSectionMargins` | `replace`                          |
        | `/properties/footer/positionFromBottom`  | `replace`                          |
        | `/properties/footer/sameAsPrevious`      | `replace`                          |

        ### Examples

        #### Update the name of a section

        ```json
        [
        {
        \"op\": \"replace\",
        \"path\": \"/name\",
        \"value\": \"Introduction\"
        }
        ]
        ```

        #### Update the parent of a section (preserving its index)

        ```json
        [
        {
        \"op\": \"replace\",
        \"path\": \"/parent\",
        \"value\": {
        \"id\": \"b9b3ddb587744a27aafda3c9865f1f0a_1\"
        }
        }
        ]
        ```

        #### Update the parent of a section (making it the first child)

        ```json
        [
        {
        \"op\": \"replace\",
        \"path\": \"/parent\",
        \"value\": {
        \"id\": \"b9b3ddb587744a27aafda3c9865f1f0a_1\"
        }
        },
        {
        \"op\": \"replace\",
        \"path\": \"/index\",
        \"value\": 0
        }
        ]
        ```

        #### Add a custom field value
        ```json

        [
        {
        \"op\": \"add\",
        \"path\": \"/customFields/com.workiva.gsr.legal_entity\",
        \"value\": \"Workiva\"
        }
        ]
        ```

        #### Remove a custom field value

        ```json
        [
        {
        \"op\": \"remove\",
        \"path\": \"/customFields/com.workiva.gsr.legal_entity\"
        }
        ]
        ```

        #### Replace a custom field value
        ```json

        [
        {
        \"op\": \"replace\",
        \"path\": \"/customFields/com.workiva.gsr.legal_entity\",
        \"value\": \"Workiva, Inc.\"
        }
        ]
        ```


        :param document_id: The unique identifier of the document
        :param section_id: The unique identifier of the section
        :param request_body: A collection of patch operations to apply to the section.
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.PartiallyUpdateSectionByIDRequest(
            document_id=document_id,
            section_id=section_id,
            request_body=utils.get_pydantic_model(
                request_body, List[models.JSONPatchOperation]
            ),
        )

        req = self._build_request_async(
            method="PATCH",
            path="/documents/{documentId}/sections/{sectionId}",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request.request_body,
                False,
                False,
                "json",
                List[models.JSONPatchOperation],
            ),
            allow_empty_value=None,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="partiallyUpdateSectionById",
                oauth2_scopes=["file:write"],
                security_source=self.sdk_configuration.security,
            ),
            request=req,
            error_status_codes=[
                "400",
                "401",
                "403",
                "404",
                "409",
                "429",
                "4XX",
                "500",
                "503",
                "5XX",
            ],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "202", "*"):
            return models.PartiallyUpdateSectionByIDResponse(
                headers=utils.get_response_headers(http_res.headers)
            )
        if utils.match_response(
            http_res, ["400", "401", "403", "404", "409", "429"], "application/json"
        ):
            response_data = unmarshal_json_response(errors.ErrorResponseData, http_res)
            raise errors.ErrorResponse(response_data, http_res)
        if utils.match_response(http_res, ["500", "503"], "application/json"):
            response_data = unmarshal_json_response(errors.ErrorResponseData, http_res)
            raise errors.ErrorResponse(response_data, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)

        raise errors.SDKError("Unexpected response received", http_res)

    def copy_section(
        self,
        *,
        document_id: str,
        section_id: str,
        section_copy: Union[models.SectionCopy, models.SectionCopyTypedDict],
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.CopySectionResponse:
        r"""Copy section

        Asynchronously copies a [section](ref:documents#section) given details about the copy's destination within the same or another document. Options are specified using a [SectionCopy](ref:documents#sectioncopy) object.

        Copies only the section's content  not any labels, comments, tasks, or formatting from a style guide. Unless otherwise specified, the copy appears at the top level of its destination document, with an index of 0, and with the same name as the original section.

        :param document_id: The unique identifier of the document
        :param section_id: The unique identifier of the section
        :param section_copy: A SectionCopy object
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.CopySectionRequest(
            document_id=document_id,
            section_id=section_id,
            section_copy=utils.get_pydantic_model(section_copy, models.SectionCopy),
        )

        req = self._build_request(
            method="POST",
            path="/documents/{documentId}/sections/{sectionId}/copy",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request.section_copy, False, False, "json", models.SectionCopy
            ),
            allow_empty_value=None,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="copySection",
                oauth2_scopes=["file:write"],
                security_source=self.sdk_configuration.security,
            ),
            request=req,
            error_status_codes=[
                "400",
                "401",
                "403",
                "404",
                "409",
                "429",
                "4XX",
                "500",
                "503",
                "5XX",
            ],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "202", "*"):
            return models.CopySectionResponse(
                headers=utils.get_response_headers(http_res.headers)
            )
        if utils.match_response(
            http_res, ["400", "401", "403", "404", "409", "429"], "application/json"
        ):
            response_data = unmarshal_json_response(errors.ErrorResponseData, http_res)
            raise errors.ErrorResponse(response_data, http_res)
        if utils.match_response(http_res, ["500", "503"], "application/json"):
            response_data = unmarshal_json_response(errors.ErrorResponseData, http_res)
            raise errors.ErrorResponse(response_data, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)

        raise errors.SDKError("Unexpected response received", http_res)

    async def copy_section_async(
        self,
        *,
        document_id: str,
        section_id: str,
        section_copy: Union[models.SectionCopy, models.SectionCopyTypedDict],
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.CopySectionResponse:
        r"""Copy section

        Asynchronously copies a [section](ref:documents#section) given details about the copy's destination within the same or another document. Options are specified using a [SectionCopy](ref:documents#sectioncopy) object.

        Copies only the section's content  not any labels, comments, tasks, or formatting from a style guide. Unless otherwise specified, the copy appears at the top level of its destination document, with an index of 0, and with the same name as the original section.

        :param document_id: The unique identifier of the document
        :param section_id: The unique identifier of the section
        :param section_copy: A SectionCopy object
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.CopySectionRequest(
            document_id=document_id,
            section_id=section_id,
            section_copy=utils.get_pydantic_model(section_copy, models.SectionCopy),
        )

        req = self._build_request_async(
            method="POST",
            path="/documents/{documentId}/sections/{sectionId}/copy",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request.section_copy, False, False, "json", models.SectionCopy
            ),
            allow_empty_value=None,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="copySection",
                oauth2_scopes=["file:write"],
                security_source=self.sdk_configuration.security,
            ),
            request=req,
            error_status_codes=[
                "400",
                "401",
                "403",
                "404",
                "409",
                "429",
                "4XX",
                "500",
                "503",
                "5XX",
            ],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "202", "*"):
            return models.CopySectionResponse(
                headers=utils.get_response_headers(http_res.headers)
            )
        if utils.match_response(
            http_res, ["400", "401", "403", "404", "409", "429"], "application/json"
        ):
            response_data = unmarshal_json_response(errors.ErrorResponseData, http_res)
            raise errors.ErrorResponse(response_data, http_res)
        if utils.match_response(http_res, ["500", "503"], "application/json"):
            response_data = unmarshal_json_response(errors.ErrorResponseData, http_res)
            raise errors.ErrorResponse(response_data, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)

        raise errors.SDKError("Unexpected response received", http_res)

    def edit_sections(
        self,
        *,
        document_id: str,
        sections_edits: Union[models.SectionsEdits, models.SectionsEditsTypedDict],
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.EditSectionsResponse:
        r"""Initiate sections edits

        Updates the properties of a collection of [sections](ref:documents#section) in a document using [SectionsEdits](ref:documents#sectionsedit) request. This is a long running operation.
        Responses include a `Location` header, which indicates where to poll for results. For more details on long-running job polling, see [Operations endpoint](ref:getoperationbyid). When the update completes, its status will be `completed`.


        :param document_id: The unique identifier of the document
        :param sections_edits: The edits for one or more sections in a document
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.EditSectionsRequest(
            document_id=document_id,
            sections_edits=utils.get_pydantic_model(
                sections_edits, models.SectionsEdits
            ),
        )

        req = self._build_request(
            method="POST",
            path="/documents/{documentId}/sections/edit",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request.sections_edits, False, False, "json", models.SectionsEdits
            ),
            allow_empty_value=None,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="editSections",
                oauth2_scopes=["file:write"],
                security_source=self.sdk_configuration.security,
            ),
            request=req,
            error_status_codes=[
                "400",
                "401",
                "403",
                "404",
                "409",
                "429",
                "4XX",
                "500",
                "503",
                "5XX",
            ],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "202", "*"):
            return models.EditSectionsResponse(
                headers=utils.get_response_headers(http_res.headers)
            )
        if utils.match_response(
            http_res, ["400", "401", "403", "404", "409", "429"], "application/json"
        ):
            response_data = unmarshal_json_response(errors.ErrorResponseData, http_res)
            raise errors.ErrorResponse(response_data, http_res)
        if utils.match_response(http_res, ["500", "503"], "application/json"):
            response_data = unmarshal_json_response(errors.ErrorResponseData, http_res)
            raise errors.ErrorResponse(response_data, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)

        raise errors.SDKError("Unexpected response received", http_res)

    async def edit_sections_async(
        self,
        *,
        document_id: str,
        sections_edits: Union[models.SectionsEdits, models.SectionsEditsTypedDict],
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.EditSectionsResponse:
        r"""Initiate sections edits

        Updates the properties of a collection of [sections](ref:documents#section) in a document using [SectionsEdits](ref:documents#sectionsedit) request. This is a long running operation.
        Responses include a `Location` header, which indicates where to poll for results. For more details on long-running job polling, see [Operations endpoint](ref:getoperationbyid). When the update completes, its status will be `completed`.


        :param document_id: The unique identifier of the document
        :param sections_edits: The edits for one or more sections in a document
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.EditSectionsRequest(
            document_id=document_id,
            sections_edits=utils.get_pydantic_model(
                sections_edits, models.SectionsEdits
            ),
        )

        req = self._build_request_async(
            method="POST",
            path="/documents/{documentId}/sections/edit",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request.sections_edits, False, False, "json", models.SectionsEdits
            ),
            allow_empty_value=None,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="editSections",
                oauth2_scopes=["file:write"],
                security_source=self.sdk_configuration.security,
            ),
            request=req,
            error_status_codes=[
                "400",
                "401",
                "403",
                "404",
                "409",
                "429",
                "4XX",
                "500",
                "503",
                "5XX",
            ],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "202", "*"):
            return models.EditSectionsResponse(
                headers=utils.get_response_headers(http_res.headers)
            )
        if utils.match_response(
            http_res, ["400", "401", "403", "404", "409", "429"], "application/json"
        ):
            response_data = unmarshal_json_response(errors.ErrorResponseData, http_res)
            raise errors.ErrorResponse(response_data, http_res)
        if utils.match_response(http_res, ["500", "503"], "application/json"):
            response_data = unmarshal_json_response(errors.ErrorResponseData, http_res)
            raise errors.ErrorResponse(response_data, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)

        raise errors.SDKError("Unexpected response received", http_res)

    def get_section_permissions(
        self,
        *,
        request: Union[
            models.GetSectionPermissionsRequest,
            models.GetSectionPermissionsRequestTypedDict,
        ],
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> Optional[models.GetSectionPermissionsResponse]:
        r"""Retrieve permissions for a section in a document

        Retrieves a paginated list of permissions for the given section in a document


        :param request: The request object to send.
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        if not isinstance(request, BaseModel):
            request = utils.unmarshal(request, models.GetSectionPermissionsRequest)
        request = cast(models.GetSectionPermissionsRequest, request)

        req = self._build_request(
            method="GET",
            path="/documents/{documentId}/sections/{sectionId}/permissions",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            allow_empty_value=None,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="getSectionPermissions",
                oauth2_scopes=["file:read"],
                security_source=self.sdk_configuration.security,
            ),
            request=req,
            error_status_codes=[
                "400",
                "401",
                "403",
                "404",
                "409",
                "429",
                "4XX",
                "500",
                "503",
                "5XX",
            ],
            retry_config=retry_config,
        )

        def next_func() -> Optional[models.GetSectionPermissionsResponse]:
            body = utils.unmarshal_json(http_res.text, Union[Dict[Any, Any], List[Any]])

            next_cursor = JSONPath("$['@nextLink']").parse(body)

            if len(next_cursor) == 0:
                return None

            next_cursor = next_cursor[0]
            if next_cursor is None or str(next_cursor).strip() == "":
                return None

            return self.get_section_permissions(
                request=models.GetSectionPermissionsRequest(
                    document_id=request.document_id,
                    section_id=request.section_id,
                    filter_=request.filter_,
                    maxpagesize=request.maxpagesize,
                    next=request.next,
                ),
                retries=retries,
            )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return models.GetSectionPermissionsResponse(
                result=unmarshal_json_response(
                    models.ResourcePermissionsListResult, http_res
                ),
                next=next_func,
            )
        if utils.match_response(
            http_res, ["400", "401", "403", "404", "409", "429"], "application/json"
        ):
            response_data = unmarshal_json_response(errors.ErrorResponseData, http_res)
            raise errors.ErrorResponse(response_data, http_res)
        if utils.match_response(http_res, ["500", "503"], "application/json"):
            response_data = unmarshal_json_response(errors.ErrorResponseData, http_res)
            raise errors.ErrorResponse(response_data, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)

        raise errors.SDKError("Unexpected response received", http_res)

    async def get_section_permissions_async(
        self,
        *,
        request: Union[
            models.GetSectionPermissionsRequest,
            models.GetSectionPermissionsRequestTypedDict,
        ],
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> Optional[models.GetSectionPermissionsResponse]:
        r"""Retrieve permissions for a section in a document

        Retrieves a paginated list of permissions for the given section in a document


        :param request: The request object to send.
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        if not isinstance(request, BaseModel):
            request = utils.unmarshal(request, models.GetSectionPermissionsRequest)
        request = cast(models.GetSectionPermissionsRequest, request)

        req = self._build_request_async(
            method="GET",
            path="/documents/{documentId}/sections/{sectionId}/permissions",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            allow_empty_value=None,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="getSectionPermissions",
                oauth2_scopes=["file:read"],
                security_source=self.sdk_configuration.security,
            ),
            request=req,
            error_status_codes=[
                "400",
                "401",
                "403",
                "404",
                "409",
                "429",
                "4XX",
                "500",
                "503",
                "5XX",
            ],
            retry_config=retry_config,
        )

        def next_func() -> Awaitable[Optional[models.GetSectionPermissionsResponse]]:
            body = utils.unmarshal_json(http_res.text, Union[Dict[Any, Any], List[Any]])

            async def empty_result():
                return None

            next_cursor = JSONPath("$['@nextLink']").parse(body)

            if len(next_cursor) == 0:
                return empty_result()

            next_cursor = next_cursor[0]
            if next_cursor is None or str(next_cursor).strip() == "":
                return empty_result()

            return self.get_section_permissions_async(
                request=models.GetSectionPermissionsRequest(
                    document_id=request.document_id,
                    section_id=request.section_id,
                    filter_=request.filter_,
                    maxpagesize=request.maxpagesize,
                    next=request.next,
                ),
                retries=retries,
            )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return models.GetSectionPermissionsResponse(
                result=unmarshal_json_response(
                    models.ResourcePermissionsListResult, http_res
                ),
                next=next_func,
            )
        if utils.match_response(
            http_res, ["400", "401", "403", "404", "409", "429"], "application/json"
        ):
            response_data = unmarshal_json_response(errors.ErrorResponseData, http_res)
            raise errors.ErrorResponse(response_data, http_res)
        if utils.match_response(http_res, ["500", "503"], "application/json"):
            response_data = unmarshal_json_response(errors.ErrorResponseData, http_res)
            raise errors.ErrorResponse(response_data, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)

        raise errors.SDKError("Unexpected response received", http_res)

    def section_permissions_modification(
        self,
        *,
        document_id: str,
        section_id: str,
        resource_permissions_modification: Union[
            models.ResourcePermissionsModification,
            models.ResourcePermissionsModificationTypedDict,
        ],
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ):
        r"""Modify permissions on a given section of a document

        Assign and/or revoke permissions on a section. If any modification in a request fails, all modifications on that request fail. <br /><br /> _To modify an existing permission, the existing permission must first be  explicitly revoked. Then, the new permission needs to be assigned. This  can be done in a single request by sending `toAssign` and `toRevoke` in  the request body._


        :param document_id: The unique identifier of the document
        :param section_id: The unique identifier of the section
        :param resource_permissions_modification: Details about the section permissions modification.
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.SectionPermissionsModificationRequest(
            document_id=document_id,
            section_id=section_id,
            resource_permissions_modification=utils.get_pydantic_model(
                resource_permissions_modification,
                models.ResourcePermissionsModification,
            ),
        )

        req = self._build_request(
            method="POST",
            path="/documents/{documentId}/sections/{sectionId}/permissions/modification",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request.resource_permissions_modification,
                False,
                False,
                "json",
                models.ResourcePermissionsModification,
            ),
            allow_empty_value=None,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="sectionPermissionsModification",
                oauth2_scopes=["file:write"],
                security_source=self.sdk_configuration.security,
            ),
            request=req,
            error_status_codes=[
                "400",
                "401",
                "403",
                "404",
                "409",
                "429",
                "4XX",
                "500",
                "503",
                "5XX",
            ],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "204", "*"):
            return
        if utils.match_response(
            http_res, ["400", "401", "403", "404", "409", "429"], "application/json"
        ):
            response_data = unmarshal_json_response(errors.ErrorResponseData, http_res)
            raise errors.ErrorResponse(response_data, http_res)
        if utils.match_response(http_res, ["500", "503"], "application/json"):
            response_data = unmarshal_json_response(errors.ErrorResponseData, http_res)
            raise errors.ErrorResponse(response_data, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)

        raise errors.SDKError("Unexpected response received", http_res)

    async def section_permissions_modification_async(
        self,
        *,
        document_id: str,
        section_id: str,
        resource_permissions_modification: Union[
            models.ResourcePermissionsModification,
            models.ResourcePermissionsModificationTypedDict,
        ],
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ):
        r"""Modify permissions on a given section of a document

        Assign and/or revoke permissions on a section. If any modification in a request fails, all modifications on that request fail. <br /><br /> _To modify an existing permission, the existing permission must first be  explicitly revoked. Then, the new permission needs to be assigned. This  can be done in a single request by sending `toAssign` and `toRevoke` in  the request body._


        :param document_id: The unique identifier of the document
        :param section_id: The unique identifier of the section
        :param resource_permissions_modification: Details about the section permissions modification.
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.SectionPermissionsModificationRequest(
            document_id=document_id,
            section_id=section_id,
            resource_permissions_modification=utils.get_pydantic_model(
                resource_permissions_modification,
                models.ResourcePermissionsModification,
            ),
        )

        req = self._build_request_async(
            method="POST",
            path="/documents/{documentId}/sections/{sectionId}/permissions/modification",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request.resource_permissions_modification,
                False,
                False,
                "json",
                models.ResourcePermissionsModification,
            ),
            allow_empty_value=None,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="sectionPermissionsModification",
                oauth2_scopes=["file:write"],
                security_source=self.sdk_configuration.security,
            ),
            request=req,
            error_status_codes=[
                "400",
                "401",
                "403",
                "404",
                "409",
                "429",
                "4XX",
                "500",
                "503",
                "5XX",
            ],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "204", "*"):
            return
        if utils.match_response(
            http_res, ["400", "401", "403", "404", "409", "429"], "application/json"
        ):
            response_data = unmarshal_json_response(errors.ErrorResponseData, http_res)
            raise errors.ErrorResponse(response_data, http_res)
        if utils.match_response(http_res, ["500", "503"], "application/json"):
            response_data = unmarshal_json_response(errors.ErrorResponseData, http_res)
            raise errors.ErrorResponse(response_data, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.SDKError("API error occurred", http_res, http_res_text)

        raise errors.SDKError("Unexpected response received", http_res)
