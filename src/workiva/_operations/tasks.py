"""Platform API â€” tasks namespace.

Auto-generated by codegen. Do not edit manually.
"""

from __future__ import annotations

from typing import Any, Literal, Optional

import httpx

from workiva._constants import _API
from workiva._operations._base import BaseNamespace
from workiva._pagination import (
    extract_next_link,
    paginate_all,
    paginate_all_async,
)
from workiva.models.platform import (
    Task,
    TaskApprovalStep,
    TaskLocation,
    TasksListResult,
    TaskUser,
)

__all__ = ["Tasks"]


class Tasks(BaseNamespace):
    """Tasks operations."""

    _api: _API = _API.PLATFORM

    def get_tasks(
        self,
        *,
        filter_: Optional[str] = None,
        order_by: Optional[str] = None,
        maxpagesize: Optional[int] = 1000,
        timeout: Optional[float] = None,
    ) -> TasksListResult:
        """Retrieve a list of tasks

        > Returns a paginated list of [tasks](ref:tasks#task). Currently this
        endpoint returns general tasks
        (such as those created as part of editing documents, sheets, and
        presentations) and tasks that have been associated  with a
        Sustainability Program.
        It does not return tasks created as part of a process.

        Args:
            filter_: The properties to filter the results by.
            order_by: One or more comma-separated expressions to indicate the order in which to sort the results.
            maxpagesize: The maximum number of results to retrieve
            timeout: Override the default request timeout (seconds).

        Returns:
            TasksListResult

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 429, 500, 503).
        """

        def _fetch(_cursor: str | None) -> httpx.Response:
            return self._client.request(
                "GET",
                self._api,
                "/tasks",
                query_params={
                    "$filter": filter_,
                    "$orderBy": order_by,
                    "$maxpagesize": maxpagesize,
                    "$next": _cursor,
                },
                timeout=timeout,
            )

        _body_result = paginate_all(_fetch, extract_next_link, "data")
        return TasksListResult.model_validate(_body_result)

    async def get_tasks_async(
        self,
        *,
        filter_: Optional[str] = None,
        order_by: Optional[str] = None,
        maxpagesize: Optional[int] = 1000,
        timeout: Optional[float] = None,
    ) -> TasksListResult:
        """Retrieve a list of tasks (async)

        > Returns a paginated list of [tasks](ref:tasks#task). Currently this
        endpoint returns general tasks
        (such as those created as part of editing documents, sheets, and
        presentations) and tasks that have been associated  with a
        Sustainability Program.
        It does not return tasks created as part of a process.

        Args:
            filter_: The properties to filter the results by.
            order_by: One or more comma-separated expressions to indicate the order in which to sort the results.
            maxpagesize: The maximum number of results to retrieve
            timeout: Override the default request timeout (seconds).

        Returns:
            TasksListResult

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 429, 500, 503).
        """

        async def _fetch(_cursor: str | None) -> httpx.Response:
            return await self._client.request_async(
                "GET",
                self._api,
                "/tasks",
                query_params={
                    "$filter": filter_,
                    "$orderBy": order_by,
                    "$maxpagesize": maxpagesize,
                    "$next": _cursor,
                },
                timeout=timeout,
            )

        _body_result = await paginate_all_async(_fetch, extract_next_link, "data")
        return TasksListResult.model_validate(_body_result)

    def create_task(
        self,
        *,
        title: str,
        approval_steps: Optional[list[TaskApprovalStep]] = None,
        assignees: Optional[list[TaskUser]] = None,
        description: Optional[str] = None,
        due_date: Optional[str] = None,
        location: Optional[TaskLocation] = None,
        notifications_disabled: Optional[bool] = None,
        status: Optional[str] = None,
        timeout: Optional[float] = None,
    ) -> Task:
        """Create a new task

                Creates a new [task](ref:tasks#task) given its properties.

                Args:
                    title: The title of the task.
                    approval_steps: The approval process for the task where applicable.
                    assignees: A list of assignees for the task.
                    description: The task description.
                    due_date: An ISO 8601 datetime indicating a deadline for the task to be completed. Will be converted to UTC if another time zone is included.
                    location:
                    notifications_disabled: Suspend notifications during create/updates. Automated and manual reminders will still be sent. The default value is false.
                    status: > The status for the task. The default value is Created. The status of the task will be updated automatically as it
        > progresses through the multiple steps of the approval process.

                    timeout: Override the default request timeout (seconds).

                Returns:
                    Task

                Raises:
                    WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 429, 500, 503).
        """
        _body: dict[str, Any] = {}
        if title is not None:
            _body["title"] = title
        if approval_steps is not None:
            _body["approvalSteps"] = approval_steps
        if assignees is not None:
            _body["assignees"] = assignees
        if description is not None:
            _body["description"] = description
        if due_date is not None:
            _body["dueDate"] = due_date
        if location is not None:
            _body["location"] = location
        if notifications_disabled is not None:
            _body["notificationsDisabled"] = notifications_disabled
        if status is not None:
            _body["status"] = status
        response = self._client.request(
            "POST",
            self._api,
            "/tasks",
            json_body=_body or None,
            timeout=timeout,
        )
        return Task.model_validate(response.json())

    async def create_task_async(
        self,
        *,
        title: str,
        approval_steps: Optional[list[TaskApprovalStep]] = None,
        assignees: Optional[list[TaskUser]] = None,
        description: Optional[str] = None,
        due_date: Optional[str] = None,
        location: Optional[TaskLocation] = None,
        notifications_disabled: Optional[bool] = None,
        status: Optional[str] = None,
        timeout: Optional[float] = None,
    ) -> Task:
        """Create a new task (async)

                Creates a new [task](ref:tasks#task) given its properties.

                Args:
                    title: The title of the task.
                    approval_steps: The approval process for the task where applicable.
                    assignees: A list of assignees for the task.
                    description: The task description.
                    due_date: An ISO 8601 datetime indicating a deadline for the task to be completed. Will be converted to UTC if another time zone is included.
                    location:
                    notifications_disabled: Suspend notifications during create/updates. Automated and manual reminders will still be sent. The default value is false.
                    status: > The status for the task. The default value is Created. The status of the task will be updated automatically as it
        > progresses through the multiple steps of the approval process.

                    timeout: Override the default request timeout (seconds).

                Returns:
                    Task

                Raises:
                    WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 429, 500, 503).
        """
        _body: dict[str, Any] = {}
        if title is not None:
            _body["title"] = title
        if approval_steps is not None:
            _body["approvalSteps"] = approval_steps
        if assignees is not None:
            _body["assignees"] = assignees
        if description is not None:
            _body["description"] = description
        if due_date is not None:
            _body["dueDate"] = due_date
        if location is not None:
            _body["location"] = location
        if notifications_disabled is not None:
            _body["notificationsDisabled"] = notifications_disabled
        if status is not None:
            _body["status"] = status
        response = await self._client.request_async(
            "POST",
            self._api,
            "/tasks",
            json_body=_body or None,
            timeout=timeout,
        )
        return Task.model_validate(response.json())

    def delete_task_by_id(
        self,
        *,
        task_id: str,
        timeout: Optional[float] = None,
    ) -> httpx.Response:
        """Delete a single task

        Deletes a [task](ref:tasks#task) given its ID

        Args:
            task_id: The unique identifier of the task
            timeout: Override the default request timeout (seconds).

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 429, 500, 503).
        """
        return self._client.request(
            "DELETE",
            self._api,
            "/tasks/{taskId}",
            path_params={
                "taskId": task_id,
            },
            timeout=timeout,
        )

    async def delete_task_by_id_async(
        self,
        *,
        task_id: str,
        timeout: Optional[float] = None,
    ) -> httpx.Response:
        """Delete a single task (async)

        Deletes a [task](ref:tasks#task) given its ID

        Args:
            task_id: The unique identifier of the task
            timeout: Override the default request timeout (seconds).

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 429, 500, 503).
        """
        return await self._client.request_async(
            "DELETE",
            self._api,
            "/tasks/{taskId}",
            path_params={
                "taskId": task_id,
            },
            timeout=timeout,
        )

    def get_task_by_id(
        self,
        *,
        task_id: str,
        timeout: Optional[float] = None,
    ) -> Task:
        """Retrieve a single task

        Retrieves a [task](ref:tasks#task) given its ID

        Args:
            task_id: The unique identifier of the task
            timeout: Override the default request timeout (seconds).

        Returns:
            Task

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 429, 500, 503).
        """
        response = self._client.request(
            "GET",
            self._api,
            "/tasks/{taskId}",
            path_params={
                "taskId": task_id,
            },
            timeout=timeout,
        )
        return Task.model_validate(response.json())

    async def get_task_by_id_async(
        self,
        *,
        task_id: str,
        timeout: Optional[float] = None,
    ) -> Task:
        """Retrieve a single task (async)

        Retrieves a [task](ref:tasks#task) given its ID

        Args:
            task_id: The unique identifier of the task
            timeout: Override the default request timeout (seconds).

        Returns:
            Task

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 429, 500, 503).
        """
        response = await self._client.request_async(
            "GET",
            self._api,
            "/tasks/{taskId}",
            path_params={
                "taskId": task_id,
            },
            timeout=timeout,
        )
        return Task.model_validate(response.json())

    def partially_update_task_by_id(
        self,
        *,
        task_id: str,
        body: list[Any],
        timeout: Optional[float] = None,
    ) -> Task:
        """Partially update a single task

        Partially updates the properties of a [task](ref:tasks#task).
        Please note: Tasks are automatically restarted when the following
        properties are updated:
        - `assignees`
        - `approvalSteps`: If any `participants` who have already approved are
        updated, the task will be restarted.
        - `location`
        ### Options
        |Path|PATCH Operations Supported|
        |---|---|
        |`/approvalSteps`|`replace`|
        |`/assignees`|`replace`|
        |`/description`|`replace`|
        |`/dueDate`|`replace`|
        |`/location`|`replace`|
        |`/owner`|`replace`|
        |`/title`|`replace`|

        Args:
            task_id: The unique identifier of the task
            body: Request body.
            timeout: Override the default request timeout (seconds).

        Returns:
            Task

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 429, 500, 503).
        """
        response = self._client.request(
            "PATCH",
            self._api,
            "/tasks/{taskId}",
            path_params={
                "taskId": task_id,
            },
            json_body=body,
            timeout=timeout,
        )
        return Task.model_validate(response.json())

    async def partially_update_task_by_id_async(
        self,
        *,
        task_id: str,
        body: list[Any],
        timeout: Optional[float] = None,
    ) -> Task:
        """Partially update a single task (async)

        Partially updates the properties of a [task](ref:tasks#task).
        Please note: Tasks are automatically restarted when the following
        properties are updated:
        - `assignees`
        - `approvalSteps`: If any `participants` who have already approved are
        updated, the task will be restarted.
        - `location`
        ### Options
        |Path|PATCH Operations Supported|
        |---|---|
        |`/approvalSteps`|`replace`|
        |`/assignees`|`replace`|
        |`/description`|`replace`|
        |`/dueDate`|`replace`|
        |`/location`|`replace`|
        |`/owner`|`replace`|
        |`/title`|`replace`|

        Args:
            task_id: The unique identifier of the task
            body: Request body.
            timeout: Override the default request timeout (seconds).

        Returns:
            Task

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 429, 500, 503).
        """
        response = await self._client.request_async(
            "PATCH",
            self._api,
            "/tasks/{taskId}",
            path_params={
                "taskId": task_id,
            },
            json_body=body,
            timeout=timeout,
        )
        return Task.model_validate(response.json())

    def submit_task_action(
        self,
        *,
        task_id: str,
        action: Literal["SUBMIT", "APPROVE", "REJECT", "CANCEL", "RESTART", "SKIP"],
        comment: Optional[str] = None,
        timeout: Optional[float] = None,
    ) -> Task:
        """Initiate a task action submission

        This endpoint enables submitting actions on a [task](ref:tasks#task).
        For tasks with multiple approval steps, it's the only way to advance a
        task through the approval process.

        Args:
            task_id: The unique identifier of the task
            action:
            comment: An optional comment to accompany the action.
            timeout: Override the default request timeout (seconds).

        Returns:
            Task

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 429, 500, 503).
        """
        _body: dict[str, Any] = {}
        if action is not None:
            _body["action"] = action
        if comment is not None:
            _body["comment"] = comment
        response = self._client.request(
            "POST",
            self._api,
            "/tasks/{taskId}/actionSubmission",
            path_params={
                "taskId": task_id,
            },
            json_body=_body or None,
            timeout=timeout,
        )
        return Task.model_validate(response.json())

    async def submit_task_action_async(
        self,
        *,
        task_id: str,
        action: Literal["SUBMIT", "APPROVE", "REJECT", "CANCEL", "RESTART", "SKIP"],
        comment: Optional[str] = None,
        timeout: Optional[float] = None,
    ) -> Task:
        """Initiate a task action submission (async)

        This endpoint enables submitting actions on a [task](ref:tasks#task).
        For tasks with multiple approval steps, it's the only way to advance a
        task through the approval process.

        Args:
            task_id: The unique identifier of the task
            action:
            comment: An optional comment to accompany the action.
            timeout: Override the default request timeout (seconds).

        Returns:
            Task

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 429, 500, 503).
        """
        _body: dict[str, Any] = {}
        if action is not None:
            _body["action"] = action
        if comment is not None:
            _body["comment"] = comment
        response = await self._client.request_async(
            "POST",
            self._api,
            "/tasks/{taskId}/actionSubmission",
            path_params={
                "taskId": task_id,
            },
            json_body=_body or None,
            timeout=timeout,
        )
        return Task.model_validate(response.json())
