"""Wdata API â€” tag_management namespace.

Auto-generated by codegen. Do not edit manually.
"""

from __future__ import annotations

from typing import Any, Optional

import httpx

from workiva._constants import _API
from workiva._operations._base import BaseNamespace
from workiva.models.wdata import (
    TagDto,
)


class TagManagement(BaseNamespace):
    """TagManagement operations."""

    _api: _API = _API.WDATA

    def list_tags(
        self,
        *,
        cursor: Optional[str] = None,
        limit: Optional[int] = 1000,
        offset: Optional[int] = None,
        timeout: Optional[float] = None,
    ) -> httpx.Response:
        """Retrieve a list of tags

        Returns a paged list of all tags associated with the workspace of the
        request.
        """
        return self._client.request(
            "GET",
            self._api,
            "/api/v1/tag",
            query_params={
                "cursor": cursor,
                "limit": limit,
                "offset": offset,
            },
            timeout=timeout,
        )

    async def list_tags_async(
        self,
        *,
        cursor: Optional[str] = None,
        limit: Optional[int] = 1000,
        offset: Optional[int] = None,
        timeout: Optional[float] = None,
    ) -> httpx.Response:
        """Retrieve a list of tags (async)

        Returns a paged list of all tags associated with the workspace of the
        request.
        """
        return await self._client.request_async(
            "GET",
            self._api,
            "/api/v1/tag",
            query_params={
                "cursor": cursor,
                "limit": limit,
                "offset": offset,
            },
            timeout=timeout,
        )

    def create_tag(
        self,
        *,
        body: TagDto,
        timeout: Optional[float] = None,
    ) -> httpx.Response:
        """Create a new tag

        Creates a tag. If another tag already has the same key, returns a 409.
        There is a limit of 300 values for a tag.
        """
        return self._client.request(
            "POST",
            self._api,
            "/api/v1/tag",
            json_body=body,
            timeout=timeout,
        )

    async def create_tag_async(
        self,
        *,
        body: TagDto,
        timeout: Optional[float] = None,
    ) -> httpx.Response:
        """Create a new tag (async)

        Creates a tag. If another tag already has the same key, returns a 409.
        There is a limit of 300 values for a tag.
        """
        return await self._client.request_async(
            "POST",
            self._api,
            "/api/v1/tag",
            json_body=body,
            timeout=timeout,
        )

    def delete_tag(
        self,
        *,
        tag_id: str,
        timeout: Optional[float] = None,
    ) -> httpx.Response:
        """Delete a single tag

        Deletes the tag with the provided ID. If no such tag is found, this is a
        no-op.
        """
        return self._client.request(
            "DELETE",
            self._api,
            "/api/v1/tag/{tagId}",
            path_params={
                "tagId": tag_id,
            },
            timeout=timeout,
        )

    async def delete_tag_async(
        self,
        *,
        tag_id: str,
        timeout: Optional[float] = None,
    ) -> httpx.Response:
        """Delete a single tag (async)

        Deletes the tag with the provided ID. If no such tag is found, this is a
        no-op.
        """
        return await self._client.request_async(
            "DELETE",
            self._api,
            "/api/v1/tag/{tagId}",
            path_params={
                "tagId": tag_id,
            },
            timeout=timeout,
        )

    def update_tag(
        self,
        *,
        tag_id: str,
        body: TagDto,
        timeout: Optional[float] = None,
    ) -> httpx.Response:
        """Update a single tag

        Updates the tag that matches the provided ID with the details provided
        in the body.
        Ignores the provided key, as keys are immutable once set.
        There is a limit of 300 values for a tag.
        """
        return self._client.request(
            "PUT",
            self._api,
            "/api/v1/tag/{tagId}",
            path_params={
                "tagId": tag_id,
            },
            json_body=body,
            timeout=timeout,
        )

    async def update_tag_async(
        self,
        *,
        tag_id: str,
        body: TagDto,
        timeout: Optional[float] = None,
    ) -> httpx.Response:
        """Update a single tag (async)

        Updates the tag that matches the provided ID with the details provided
        in the body.
        Ignores the provided key, as keys are immutable once set.
        There is a limit of 300 values for a tag.
        """
        return await self._client.request_async(
            "PUT",
            self._api,
            "/api/v1/tag/{tagId}",
            path_params={
                "tagId": tag_id,
            },
            json_body=body,
            timeout=timeout,
        )
