"""Wdata API — wdata namespace.

Auto-generated by codegen. Do not edit manually.
"""

from __future__ import annotations

from typing import Any, Literal, Optional

import httpx

from workiva._constants import _API
from workiva._operations._base import BaseNamespace
from workiva._pagination import (
    extract_wdata_cursor,
    paginate_all,
    paginate_all_async,
)
from workiva.models.wdata import (
    BaseResponseCollectionFolderableDto,
    BaseResponseConnectionDto,
    BaseResponseConnectionRunDto,
    BaseResponseDescribeQueryResponseDto,
    BaseResponseFileMetaDto,
    BaseResponseFolderDto,
    BaseResponseGlobalParameterDto,
    BaseResponseImportInfoDto,
    BaseResponseLong,
    BaseResponseMapStringString,
    BaseResponsePivotViewDto,
    BaseResponseQueryColumnDataDto,
    BaseResponseQueryDto,
    BaseResponseQueryResultDto,
    BaseResponseRefreshBatchDto,
    BaseResponseSelectListDto,
    BaseResponseSharedTableDto,
    BaseResponseSpreadsheetInfoDto,
    BaseResponseString,
    BaseResponseTableDto,
    BaseResponseTagDto,
    BaseResponseTokenDto,
    BaseResponseValidateFilesDto,
    BaseResponseValidateTablesDto,
    DatetimeDto,
    ExportFileDto,
    ExportQueryResultDto,
    FolderableDto,
    FolderDto,
    GlobalParameterDto,
    ImportDto,
    ImportFromSpreadsheetDto,
    PagedResponseConnectionDto,
    PagedResponseFileMetaDto,
    PagedResponseFolderableDto,
    PagedResponseFolderDto,
    PagedResponseGlobalParameterDto,
    PagedResponseImportErrorDto,
    PagedResponsePivotViewDto,
    PagedResponseQueryDto,
    PagedResponseQueryResultDto,
    PagedResponseSelectListDto,
    PagedResponseSharedTableDto,
    PagedResponseTableDto,
    PagedResponseTagDto,
    PivotViewDto,
    QueryDto,
    QueryResultDto,
    QueryTextDto,
    RefreshConnectionDto,
    SelectListDto,
    SharedTableDto,
    StartValidateFilesDto,
    TableDto,
    TagDto,
    TokenDto,
)

__all__ = ["Wdata"]


class Wdata(BaseNamespace):
    """Wdata operations."""

    _api: _API = _API.WDATA

    def delete_workspace(
        self,
        *,
        timeout: Optional[float] = None,
    ) -> BaseResponseString:
        """Delete a single workspace

        Deletes all information in the workspace of the request. <b>This is a
        final operation and can't be undone</b>. Any state left in the workspace
        due to an error is in an indeterminate state and shouldn't be trusted.
        Some non-private information may be kept for auditing and metric
        purposes.

        Returns:
            BaseResponseString

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 423, 429, 500).
        """
        response = self._client.request(
            "DELETE",
            self._api,
            "/api/v1/admin/account",
            timeout=timeout,
        )
        return BaseResponseString.model_validate(response.json())

    async def delete_workspace_async(
        self,
        *,
        timeout: Optional[float] = None,
    ) -> BaseResponseString:
        """Delete a single workspace (async)

        Deletes all information in the workspace of the request. <b>This is a
        final operation and can't be undone</b>. Any state left in the workspace
        due to an error is in an indeterminate state and shouldn't be trusted.
        Some non-private information may be kept for auditing and metric
        purposes.

        Returns:
            BaseResponseString

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 423, 429, 500).
        """
        response = await self._client.request_async(
            "DELETE",
            self._api,
            "/api/v1/admin/account",
            timeout=timeout,
        )
        return BaseResponseString.model_validate(response.json())

    def export_workspace(
        self,
        *,
        timeout: Optional[float] = None,
    ) -> BaseResponseTokenDto:
        """Export a single workspace

        Creates a file representing the entirety of the requested workspace and
        returns a
        token. Use the [`Download a single file endpoint`](ref:wdata-
        downloadfile) to
        exchange the token for the file.

        Returns:
            BaseResponseTokenDto

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 423, 429, 500).
        """
        response = self._client.request(
            "GET",
            self._api,
            "/api/v1/admin/export",
            timeout=timeout,
        )
        return BaseResponseTokenDto.model_validate(response.json())

    async def export_workspace_async(
        self,
        *,
        timeout: Optional[float] = None,
    ) -> BaseResponseTokenDto:
        """Export a single workspace (async)

        Creates a file representing the entirety of the requested workspace and
        returns a
        token. Use the [`Download a single file endpoint`](ref:wdata-
        downloadfile) to
        exchange the token for the file.

        Returns:
            BaseResponseTokenDto

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 423, 429, 500).
        """
        response = await self._client.request_async(
            "GET",
            self._api,
            "/api/v1/admin/export",
            timeout=timeout,
        )
        return BaseResponseTokenDto.model_validate(response.json())

    def import_data(
        self,
        *,
        wipe: Optional[bool] = True,
        body: Optional[dict[str, Any]] = None,
        timeout: Optional[float] = None,
    ) -> BaseResponseString:
        """Import data

        By default, deletes all information in the workspace of the request.
        <b>This is a final
        operation and can't be undone.</b>  Any state left in the workspace due
        to an error is
        in an indeterminate state and shouldn't be trusted. Some non-private
        information may be
        kept for auditing and metric purposes. After the delete, it then imports
        the tables, tags,
        and queries in the provided cb file into the workspace. <br><br>
        This is an asynchronous operation. Returns a 201 when the file is
        correctly decoded and
        its tables, queries, and tags are saved. Files continue to import after
        this call
        completes.

        Args:
            wipe:
            body: Request body.
            timeout: Override the default request timeout (seconds).

        Returns:
            BaseResponseString

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 423, 429, 500).

        Note:
            This operation uses multipart/form-data. Pass ``body`` as a dict
            mapping field names to values. For file fields use a tuple::

                body = {
                    "file": ("filename.csv", open("filename.csv", "rb")),
                    "field": "value",
                }
        """
        response = self._client.request(
            "POST",
            self._api,
            "/api/v1/admin/import",
            query_params={
                "wipe": wipe,
            },
            files=body,
            timeout=timeout,
        )
        return BaseResponseString.model_validate(response.json())

    async def import_data_async(
        self,
        *,
        wipe: Optional[bool] = True,
        body: Optional[dict[str, Any]] = None,
        timeout: Optional[float] = None,
    ) -> BaseResponseString:
        """Import data (async)

        By default, deletes all information in the workspace of the request.
        <b>This is a final
        operation and can't be undone.</b>  Any state left in the workspace due
        to an error is
        in an indeterminate state and shouldn't be trusted. Some non-private
        information may be
        kept for auditing and metric purposes. After the delete, it then imports
        the tables, tags,
        and queries in the provided cb file into the workspace. <br><br>
        This is an asynchronous operation. Returns a 201 when the file is
        correctly decoded and
        its tables, queries, and tags are saved. Files continue to import after
        this call
        completes.

        Args:
            wipe:
            body: Request body.
            timeout: Override the default request timeout (seconds).

        Returns:
            BaseResponseString

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 423, 429, 500).

        Note:
            This operation uses multipart/form-data. Pass ``body`` as a dict
            mapping field names to values. For file fields use a tuple::

                body = {
                    "file": ("filename.csv", open("filename.csv", "rb")),
                    "field": "value",
                }
        """
        response = await self._client.request_async(
            "POST",
            self._api,
            "/api/v1/admin/import",
            query_params={
                "wipe": wipe,
            },
            files=body,
            timeout=timeout,
        )
        return BaseResponseString.model_validate(response.json())

    def find_workspace_files_by_size(
        self,
        *,
        limit: Optional[int] = None,
        offset: Optional[int] = None,
        timeout: Optional[float] = None,
    ) -> PagedResponseFileMetaDto:
        """Retrieve workspace files by size

        Returns a paged collection of the file meta associated with the
        workspace of the request,
        ordered by size.

        Args:
            limit: The number of file meta objects to return, from 1 to 1000; by default, 1000
            offset: The item to start with on the page, greater than or equal to 0; by default, 0
            timeout: Override the default request timeout (seconds).

        Returns:
            PagedResponseFileMetaDto

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 423, 429, 500).
        """

        def _fetch(_cursor: str | None) -> httpx.Response:
            return self._client.request(
                "GET",
                self._api,
                "/api/v1/admin/usage/filesBySize",
                query_params={
                    "limit": limit,
                    "offset": offset,
                    "cursor": _cursor,
                },
                timeout=timeout,
            )

        _body = paginate_all(_fetch, extract_wdata_cursor, "body")
        return PagedResponseFileMetaDto.model_validate(_body)

    async def find_workspace_files_by_size_async(
        self,
        *,
        limit: Optional[int] = None,
        offset: Optional[int] = None,
        timeout: Optional[float] = None,
    ) -> PagedResponseFileMetaDto:
        """Retrieve workspace files by size (async)

        Returns a paged collection of the file meta associated with the
        workspace of the request,
        ordered by size.

        Args:
            limit: The number of file meta objects to return, from 1 to 1000; by default, 1000
            offset: The item to start with on the page, greater than or equal to 0; by default, 0
            timeout: Override the default request timeout (seconds).

        Returns:
            PagedResponseFileMetaDto

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 423, 429, 500).
        """

        async def _fetch(_cursor: str | None) -> httpx.Response:
            return await self._client.request_async(
                "GET",
                self._api,
                "/api/v1/admin/usage/filesBySize",
                query_params={
                    "limit": limit,
                    "offset": offset,
                    "cursor": _cursor,
                },
                timeout=timeout,
            )

        _body = await paginate_all_async(_fetch, extract_wdata_cursor, "body")
        return PagedResponseFileMetaDto.model_validate(_body)

    def get_workspace_query_usage(
        self,
        *,
        start_date: Optional[str] = "1970-01-01",
        stop_date: Optional[str] = "9999-01-01",
        timeout: Optional[float] = None,
    ) -> BaseResponseLong:
        """Retrieve workspace query usage

        Returns a Long that represents the number of bytes queried by the
        workspace of the
        request since the start time provided.

        Args:
            start_date: The earliest date of usage to consider
            stop_date: The end date of usage to consider
            timeout: Override the default request timeout (seconds).

        Returns:
            BaseResponseLong

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 423, 429, 500).
        """
        response = self._client.request(
            "GET",
            self._api,
            "/api/v1/admin/usage/query",
            query_params={
                "startDate": start_date,
                "stopDate": stop_date,
            },
            timeout=timeout,
        )
        return BaseResponseLong.model_validate(response.json())

    async def get_workspace_query_usage_async(
        self,
        *,
        start_date: Optional[str] = "1970-01-01",
        stop_date: Optional[str] = "9999-01-01",
        timeout: Optional[float] = None,
    ) -> BaseResponseLong:
        """Retrieve workspace query usage (async)

        Returns a Long that represents the number of bytes queried by the
        workspace of the
        request since the start time provided.

        Args:
            start_date: The earliest date of usage to consider
            stop_date: The end date of usage to consider
            timeout: Override the default request timeout (seconds).

        Returns:
            BaseResponseLong

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 423, 429, 500).
        """
        response = await self._client.request_async(
            "GET",
            self._api,
            "/api/v1/admin/usage/query",
            query_params={
                "startDate": start_date,
                "stopDate": stop_date,
            },
            timeout=timeout,
        )
        return BaseResponseLong.model_validate(response.json())

    def get_workspace_upload_usage(
        self,
        *,
        start_date: Optional[str] = "1970-01-01",
        stop_date: Optional[str] = "9999-01-01",
        timeout: Optional[float] = None,
    ) -> BaseResponseLong:
        """Retrieve workspace upload usage

        Returns a Long that represents the number of bytes uploaded by the
        workspace associated with this request from the start time provided to
        now.

        Args:
            start_date: The starting point to begin considering usage
            stop_date: The ending point when considering usage
            timeout: Override the default request timeout (seconds).

        Returns:
            BaseResponseLong

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 423, 429, 500).
        """
        response = self._client.request(
            "GET",
            self._api,
            "/api/v1/admin/usage/upload",
            query_params={
                "startDate": start_date,
                "stopDate": stop_date,
            },
            timeout=timeout,
        )
        return BaseResponseLong.model_validate(response.json())

    async def get_workspace_upload_usage_async(
        self,
        *,
        start_date: Optional[str] = "1970-01-01",
        stop_date: Optional[str] = "9999-01-01",
        timeout: Optional[float] = None,
    ) -> BaseResponseLong:
        """Retrieve workspace upload usage (async)

        Returns a Long that represents the number of bytes uploaded by the
        workspace associated with this request from the start time provided to
        now.

        Args:
            start_date: The starting point to begin considering usage
            stop_date: The ending point when considering usage
            timeout: Override the default request timeout (seconds).

        Returns:
            BaseResponseLong

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 423, 429, 500).
        """
        response = await self._client.request_async(
            "GET",
            self._api,
            "/api/v1/admin/usage/upload",
            query_params={
                "startDate": start_date,
                "stopDate": stop_date,
            },
            timeout=timeout,
        )
        return BaseResponseLong.model_validate(response.json())

    def validate_files(
        self,
        *,
        body: StartValidateFilesDto,
        timeout: Optional[float] = None,
    ) -> BaseResponseValidateFilesDto:
        """Validate files

        Validates files associated with the provided table ID. Validation
        repairs any files in
        an inconsistent state, and deletes those without enough state to
        recover. All files
        deleted or repaired are returned.

        Returns:
            BaseResponseValidateFilesDto

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 423, 429, 500).
        """
        response = self._client.request(
            "POST",
            self._api,
            "/api/v1/admin/validation/files",
            json_body=body,
            timeout=timeout,
        )
        return BaseResponseValidateFilesDto.model_validate(response.json())

    async def validate_files_async(
        self,
        *,
        body: StartValidateFilesDto,
        timeout: Optional[float] = None,
    ) -> BaseResponseValidateFilesDto:
        """Validate files (async)

        Validates files associated with the provided table ID. Validation
        repairs any files in
        an inconsistent state, and deletes those without enough state to
        recover. All files
        deleted or repaired are returned.

        Returns:
            BaseResponseValidateFilesDto

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 423, 429, 500).
        """
        response = await self._client.request_async(
            "POST",
            self._api,
            "/api/v1/admin/validation/files",
            json_body=body,
            timeout=timeout,
        )
        return BaseResponseValidateFilesDto.model_validate(response.json())

    def validate_tables(
        self,
        *,
        timeout: Optional[float] = None,
    ) -> BaseResponseValidateTablesDto:
        """Validate tables

        Validates the tables in the workspace associated with the request.
        Validation returns an entity that indicates the tables deleted due to
        bad state, and those with enough state and repaired.

        Returns:
            BaseResponseValidateTablesDto

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 423, 429, 500).
        """
        response = self._client.request(
            "POST",
            self._api,
            "/api/v1/admin/validation/tables",
            timeout=timeout,
        )
        return BaseResponseValidateTablesDto.model_validate(response.json())

    async def validate_tables_async(
        self,
        *,
        timeout: Optional[float] = None,
    ) -> BaseResponseValidateTablesDto:
        """Validate tables (async)

        Validates the tables in the workspace associated with the request.
        Validation returns an entity that indicates the tables deleted due to
        bad state, and those with enough state and repaired.

        Returns:
            BaseResponseValidateTablesDto

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 423, 429, 500).
        """
        response = await self._client.request_async(
            "POST",
            self._api,
            "/api/v1/admin/validation/tables",
            timeout=timeout,
        )
        return BaseResponseValidateTablesDto.model_validate(response.json())

    def list_connections(
        self,
        *,
        source_type: Optional[
            Literal[
                "document",
                "document_chart",
                "document_embedded_table",
                "esg_program",
                "presentation",
                "presentation_chart",
                "presentation_embedded_table",
                "report",
                "spreadsheet",
                "spreadsheet_section",
                "wdata_query",
                "wdata_table",
                "wdata_table_dataset",
            ]
        ] = None,
        destination_type: Optional[
            Literal[
                "document",
                "document_chart",
                "document_embedded_table",
                "presentation",
                "presentation_chart",
                "presentation_embedded_table",
                "report",
                "spreadsheet",
                "spreadsheet_section",
                "wdata_query",
                "wdata_table",
                "wdata_table_dataset",
            ]
        ] = None,
        source_id: Optional[str] = None,
        destination_id: Optional[str] = None,
        limit: Optional[int] = None,
        offset: Optional[int] = None,
        timeout: Optional[float] = None,
    ) -> PagedResponseConnectionDto:
        """List connections

        A pageable endpoint to list data connections between features of the
        Workiva platform. When filtering by source or destination, the
        corresponding ID is required.

        Args:
            source_type: The type of file or item the connection pulls data from
            destination_type: The type of file or item the connection sends data to
            source_id: The ID of the file or item the connection pulls data from
            destination_id: The ID of the file or item the connection sends data to
            limit: The number of connections to return, from 1 to 1000; by default, 1000
            offset: The item to start with on the page, greater than or equal to 0; by default, 0
            timeout: Override the default request timeout (seconds).

        Returns:
            PagedResponseConnectionDto

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 423, 429, 500).
        """

        def _fetch(_cursor: str | None) -> httpx.Response:
            return self._client.request(
                "GET",
                self._api,
                "/api/v1/connections",
                query_params={
                    "sourceType": source_type,
                    "destinationType": destination_type,
                    "sourceId": source_id,
                    "destinationId": destination_id,
                    "limit": limit,
                    "offset": offset,
                    "cursor": _cursor,
                },
                timeout=timeout,
            )

        _body = paginate_all(_fetch, extract_wdata_cursor, "body")
        return PagedResponseConnectionDto.model_validate(_body)

    async def list_connections_async(
        self,
        *,
        source_type: Optional[
            Literal[
                "document",
                "document_chart",
                "document_embedded_table",
                "esg_program",
                "presentation",
                "presentation_chart",
                "presentation_embedded_table",
                "report",
                "spreadsheet",
                "spreadsheet_section",
                "wdata_query",
                "wdata_table",
                "wdata_table_dataset",
            ]
        ] = None,
        destination_type: Optional[
            Literal[
                "document",
                "document_chart",
                "document_embedded_table",
                "presentation",
                "presentation_chart",
                "presentation_embedded_table",
                "report",
                "spreadsheet",
                "spreadsheet_section",
                "wdata_query",
                "wdata_table",
                "wdata_table_dataset",
            ]
        ] = None,
        source_id: Optional[str] = None,
        destination_id: Optional[str] = None,
        limit: Optional[int] = None,
        offset: Optional[int] = None,
        timeout: Optional[float] = None,
    ) -> PagedResponseConnectionDto:
        """List connections (async)

        A pageable endpoint to list data connections between features of the
        Workiva platform. When filtering by source or destination, the
        corresponding ID is required.

        Args:
            source_type: The type of file or item the connection pulls data from
            destination_type: The type of file or item the connection sends data to
            source_id: The ID of the file or item the connection pulls data from
            destination_id: The ID of the file or item the connection sends data to
            limit: The number of connections to return, from 1 to 1000; by default, 1000
            offset: The item to start with on the page, greater than or equal to 0; by default, 0
            timeout: Override the default request timeout (seconds).

        Returns:
            PagedResponseConnectionDto

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 423, 429, 500).
        """

        async def _fetch(_cursor: str | None) -> httpx.Response:
            return await self._client.request_async(
                "GET",
                self._api,
                "/api/v1/connections",
                query_params={
                    "sourceType": source_type,
                    "destinationType": destination_type,
                    "sourceId": source_id,
                    "destinationId": destination_id,
                    "limit": limit,
                    "offset": offset,
                    "cursor": _cursor,
                },
                timeout=timeout,
            )

        _body = await paginate_all_async(_fetch, extract_wdata_cursor, "body")
        return PagedResponseConnectionDto.model_validate(_body)

    def refresh_batch(
        self,
        *,
        body: list[RefreshConnectionDto],
        cancel_unwritables: Optional[bool] = None,
        timeout: Optional[float] = None,
    ) -> BaseResponseRefreshBatchDto:
        """Refresh batch of connections

        Refreshes multiple incoming connections within the same spreadsheet,
        based on ID. When connecting to multiple spreadsheets, tables or other
        destinations, use the [`singular refresh connection`](ref:wdata-
        refreshconnection) instead.
         `usePreviousDestinationParameters` and  `usePreviousSourceParameters`
        will use the exact parameters of your previous run; any new parameters
        you’ve provided will be ignored. This endpoint only works for outgoing
        connections if they are all connected to the same workbook. This
        endpoint has a limit of 100 refreshes per request.

        Args:
            cancel_unwritables: Allow individual connections in the batch to be canceled if they have a destination that is unwritable. This will NOT cancel the entire batch.
            body: Request body.
            timeout: Override the default request timeout (seconds).

        Returns:
            BaseResponseRefreshBatchDto

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 423, 429, 500).
        """
        response = self._client.request(
            "POST",
            self._api,
            "/api/v1/connections/batch/refresh",
            query_params={
                "cancelUnwritables": cancel_unwritables,
            },
            json_body=body,
            timeout=timeout,
        )
        return BaseResponseRefreshBatchDto.model_validate(response.json())

    async def refresh_batch_async(
        self,
        *,
        body: list[RefreshConnectionDto],
        cancel_unwritables: Optional[bool] = None,
        timeout: Optional[float] = None,
    ) -> BaseResponseRefreshBatchDto:
        """Refresh batch of connections (async)

        Refreshes multiple incoming connections within the same spreadsheet,
        based on ID. When connecting to multiple spreadsheets, tables or other
        destinations, use the [`singular refresh connection`](ref:wdata-
        refreshconnection) instead.
         `usePreviousDestinationParameters` and  `usePreviousSourceParameters`
        will use the exact parameters of your previous run; any new parameters
        you’ve provided will be ignored. This endpoint only works for outgoing
        connections if they are all connected to the same workbook. This
        endpoint has a limit of 100 refreshes per request.

        Args:
            cancel_unwritables: Allow individual connections in the batch to be canceled if they have a destination that is unwritable. This will NOT cancel the entire batch.
            body: Request body.
            timeout: Override the default request timeout (seconds).

        Returns:
            BaseResponseRefreshBatchDto

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 423, 429, 500).
        """
        response = await self._client.request_async(
            "POST",
            self._api,
            "/api/v1/connections/batch/refresh",
            query_params={
                "cancelUnwritables": cancel_unwritables,
            },
            json_body=body,
            timeout=timeout,
        )
        return BaseResponseRefreshBatchDto.model_validate(response.json())

    def get_refresh_batch_status(
        self,
        *,
        batch_id: str,
        workspace_id: Optional[str] = None,
        timeout: Optional[float] = None,
    ) -> BaseResponseRefreshBatchDto:
        """Gets the status of a batch refresh

        Returns details about a specific batch refresh, based on its ID.

        Args:
            batch_id: The ID of the batch to return details about
            workspace_id:
            timeout: Override the default request timeout (seconds).

        Returns:
            BaseResponseRefreshBatchDto

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 423, 429, 500).
        """
        response = self._client.request(
            "GET",
            self._api,
            "/api/v1/connections/batch/refresh/{batchId}",
            path_params={
                "batchId": batch_id,
            },
            query_params={
                "workspaceId": workspace_id,
            },
            timeout=timeout,
        )
        return BaseResponseRefreshBatchDto.model_validate(response.json())

    async def get_refresh_batch_status_async(
        self,
        *,
        batch_id: str,
        workspace_id: Optional[str] = None,
        timeout: Optional[float] = None,
    ) -> BaseResponseRefreshBatchDto:
        """Gets the status of a batch refresh (async)

        Returns details about a specific batch refresh, based on its ID.

        Args:
            batch_id: The ID of the batch to return details about
            workspace_id:
            timeout: Override the default request timeout (seconds).

        Returns:
            BaseResponseRefreshBatchDto

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 423, 429, 500).
        """
        response = await self._client.request_async(
            "GET",
            self._api,
            "/api/v1/connections/batch/refresh/{batchId}",
            path_params={
                "batchId": batch_id,
            },
            query_params={
                "workspaceId": workspace_id,
            },
            timeout=timeout,
        )
        return BaseResponseRefreshBatchDto.model_validate(response.json())

    def get_connection(
        self,
        *,
        connection_id: str,
        workspace_id: Optional[str] = None,
        timeout: Optional[float] = None,
    ) -> BaseResponseConnectionDto:
        """Get connection details

        Returns details about a specific connection, based on its ID

        Args:
            connection_id: The ID of the connection to return details about
            workspace_id:
            timeout: Override the default request timeout (seconds).

        Returns:
            BaseResponseConnectionDto

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 423, 429, 500).
        """
        response = self._client.request(
            "GET",
            self._api,
            "/api/v1/connections/{connectionId}",
            path_params={
                "connectionId": connection_id,
            },
            query_params={
                "workspaceId": workspace_id,
            },
            timeout=timeout,
        )
        return BaseResponseConnectionDto.model_validate(response.json())

    async def get_connection_async(
        self,
        *,
        connection_id: str,
        workspace_id: Optional[str] = None,
        timeout: Optional[float] = None,
    ) -> BaseResponseConnectionDto:
        """Get connection details (async)

        Returns details about a specific connection, based on its ID

        Args:
            connection_id: The ID of the connection to return details about
            workspace_id:
            timeout: Override the default request timeout (seconds).

        Returns:
            BaseResponseConnectionDto

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 423, 429, 500).
        """
        response = await self._client.request_async(
            "GET",
            self._api,
            "/api/v1/connections/{connectionId}",
            path_params={
                "connectionId": connection_id,
            },
            query_params={
                "workspaceId": workspace_id,
            },
            timeout=timeout,
        )
        return BaseResponseConnectionDto.model_validate(response.json())

    def refresh_connection(
        self,
        *,
        connection_id: str,
        body: RefreshConnectionDto,
        timeout: Optional[float] = None,
    ) -> BaseResponseConnectionRunDto:
        """Refresh connection

        Refreshes a specific connection, based on its ID

        Args:
            connection_id:
            body: Request body.
            timeout: Override the default request timeout (seconds).

        Returns:
            BaseResponseConnectionRunDto

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 423, 429, 500).
        """
        response = self._client.request(
            "POST",
            self._api,
            "/api/v1/connections/{connectionId}/refresh",
            path_params={
                "connectionId": connection_id,
            },
            json_body=body,
            timeout=timeout,
        )
        return BaseResponseConnectionRunDto.model_validate(response.json())

    async def refresh_connection_async(
        self,
        *,
        connection_id: str,
        body: RefreshConnectionDto,
        timeout: Optional[float] = None,
    ) -> BaseResponseConnectionRunDto:
        """Refresh connection (async)

        Refreshes a specific connection, based on its ID

        Args:
            connection_id:
            body: Request body.
            timeout: Override the default request timeout (seconds).

        Returns:
            BaseResponseConnectionRunDto

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 423, 429, 500).
        """
        response = await self._client.request_async(
            "POST",
            self._api,
            "/api/v1/connections/{connectionId}/refresh",
            path_params={
                "connectionId": connection_id,
            },
            json_body=body,
            timeout=timeout,
        )
        return BaseResponseConnectionRunDto.model_validate(response.json())

    def get_refresh_status(
        self,
        *,
        connection_id: str,
        job_id: Optional[str] = None,
        workspace_id: Optional[str] = None,
        timeout: Optional[float] = None,
    ) -> BaseResponseConnectionRunDto:
        """Get connection refresh status

        Returns details about a specific connection refresh status, based on its
        ID. To retrieve details about a specific refresh, provide its 'jobId'.

        Args:
            connection_id: The ID of the connection to return details about
            job_id: The ID of the job running for a connection
            workspace_id:
            timeout: Override the default request timeout (seconds).

        Returns:
            BaseResponseConnectionRunDto

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 423, 429, 500).
        """
        response = self._client.request(
            "GET",
            self._api,
            "/api/v1/connections/{connectionId}/status",
            path_params={
                "connectionId": connection_id,
            },
            query_params={
                "jobId": job_id,
                "workspaceId": workspace_id,
            },
            timeout=timeout,
        )
        return BaseResponseConnectionRunDto.model_validate(response.json())

    async def get_refresh_status_async(
        self,
        *,
        connection_id: str,
        job_id: Optional[str] = None,
        workspace_id: Optional[str] = None,
        timeout: Optional[float] = None,
    ) -> BaseResponseConnectionRunDto:
        """Get connection refresh status (async)

        Returns details about a specific connection refresh status, based on its
        ID. To retrieve details about a specific refresh, provide its 'jobId'.

        Args:
            connection_id: The ID of the connection to return details about
            job_id: The ID of the job running for a connection
            workspace_id:
            timeout: Override the default request timeout (seconds).

        Returns:
            BaseResponseConnectionRunDto

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 423, 429, 500).
        """
        response = await self._client.request_async(
            "GET",
            self._api,
            "/api/v1/connections/{connectionId}/status",
            path_params={
                "connectionId": connection_id,
            },
            query_params={
                "jobId": job_id,
                "workspaceId": workspace_id,
            },
            timeout=timeout,
        )
        return BaseResponseConnectionRunDto.model_validate(response.json())

    def search(
        self,
        *,
        name: Optional[str] = None,
        description: Optional[str] = None,
        type_: Optional[list[int]] = None,
        limit: Optional[int] = 1000,
        offset: Optional[int] = None,
        timeout: Optional[float] = None,
    ) -> PagedResponseFolderableDto:
        """Search

        Returns a list of all entities that match the provided criteria. Both
        name and
        description are fuzzy matches; they match _any_ entity that contains the
        provided
        string. The type is used to filter results based on the provided type of
        entity.
        The consumer must have READ access on all returned entities.

        Args:
            name: The name to use when fuzzy-matching entities
            description: The description to use when fuzzy-matching entities
            type_: To limit the scope, the type of entity to return in the results
            limit: The number of folders to return, from 1 to 1000; by default, 1000
            offset: The item to start with on the page, greater than or equal to 0; by default, 0
            timeout: Override the default request timeout (seconds).

        Returns:
            PagedResponseFolderableDto

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 423, 429, 500).
        """

        def _fetch(_cursor: str | None) -> httpx.Response:
            return self._client.request(
                "GET",
                self._api,
                "/api/v1/entity",
                query_params={
                    "name": name,
                    "description": description,
                    "type": type_,
                    "limit": limit,
                    "offset": offset,
                    "cursor": _cursor,
                },
                timeout=timeout,
            )

        _body = paginate_all(_fetch, extract_wdata_cursor, "body")
        return PagedResponseFolderableDto.model_validate(_body)

    async def search_async(
        self,
        *,
        name: Optional[str] = None,
        description: Optional[str] = None,
        type_: Optional[list[int]] = None,
        limit: Optional[int] = 1000,
        offset: Optional[int] = None,
        timeout: Optional[float] = None,
    ) -> PagedResponseFolderableDto:
        """Search (async)

        Returns a list of all entities that match the provided criteria. Both
        name and
        description are fuzzy matches; they match _any_ entity that contains the
        provided
        string. The type is used to filter results based on the provided type of
        entity.
        The consumer must have READ access on all returned entities.

        Args:
            name: The name to use when fuzzy-matching entities
            description: The description to use when fuzzy-matching entities
            type_: To limit the scope, the type of entity to return in the results
            limit: The number of folders to return, from 1 to 1000; by default, 1000
            offset: The item to start with on the page, greater than or equal to 0; by default, 0
            timeout: Override the default request timeout (seconds).

        Returns:
            PagedResponseFolderableDto

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 423, 429, 500).
        """

        async def _fetch(_cursor: str | None) -> httpx.Response:
            return await self._client.request_async(
                "GET",
                self._api,
                "/api/v1/entity",
                query_params={
                    "name": name,
                    "description": description,
                    "type": type_,
                    "limit": limit,
                    "offset": offset,
                    "cursor": _cursor,
                },
                timeout=timeout,
            )

        _body = await paginate_all_async(_fetch, extract_wdata_cursor, "body")
        return PagedResponseFolderableDto.model_validate(_body)

    def get_files(
        self,
        *,
        table_id: str,
        limit: Optional[int] = None,
        offset: Optional[int] = None,
        sort_order: Optional[Literal["asc", "desc"]] = None,
        sort_by: Optional[Literal["asc", "desc"]] = None,
        search_text: Optional[str] = None,
        timeout: Optional[float] = None,
    ) -> PagedResponseFileMetaDto:
        """Retrieve a list of files

        Returns a paged list of all files associated with the provided table ID,
        as well
        as metadata associated with each file.

        Args:
            table_id: The unique table identifier associated with this file
            limit: The number of files to return, from 1 to 1000; by default, 1000
            offset: The item to start with on the page, greater than or equal to 0; by default, 0
            sort_order: The sort order for the files being returned
            sort_by: The column to use the sort order on
            search_text: The text to filter the results upon; matching the file name
            timeout: Override the default request timeout (seconds).

        Returns:
            PagedResponseFileMetaDto

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 423, 429, 500).
        """

        def _fetch(_cursor: str | None) -> httpx.Response:
            return self._client.request(
                "GET",
                self._api,
                "/api/v1/file",
                query_params={
                    "tableId": table_id,
                    "limit": limit,
                    "offset": offset,
                    "sortOrder": sort_order,
                    "sortBy": sort_by,
                    "searchText": search_text,
                    "cursor": _cursor,
                },
                timeout=timeout,
            )

        _body = paginate_all(_fetch, extract_wdata_cursor, "body")
        return PagedResponseFileMetaDto.model_validate(_body)

    async def get_files_async(
        self,
        *,
        table_id: str,
        limit: Optional[int] = None,
        offset: Optional[int] = None,
        sort_order: Optional[Literal["asc", "desc"]] = None,
        sort_by: Optional[Literal["asc", "desc"]] = None,
        search_text: Optional[str] = None,
        timeout: Optional[float] = None,
    ) -> PagedResponseFileMetaDto:
        """Retrieve a list of files (async)

        Returns a paged list of all files associated with the provided table ID,
        as well
        as metadata associated with each file.

        Args:
            table_id: The unique table identifier associated with this file
            limit: The number of files to return, from 1 to 1000; by default, 1000
            offset: The item to start with on the page, greater than or equal to 0; by default, 0
            sort_order: The sort order for the files being returned
            sort_by: The column to use the sort order on
            search_text: The text to filter the results upon; matching the file name
            timeout: Override the default request timeout (seconds).

        Returns:
            PagedResponseFileMetaDto

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 423, 429, 500).
        """

        async def _fetch(_cursor: str | None) -> httpx.Response:
            return await self._client.request_async(
                "GET",
                self._api,
                "/api/v1/file",
                query_params={
                    "tableId": table_id,
                    "limit": limit,
                    "offset": offset,
                    "sortOrder": sort_order,
                    "sortBy": sort_by,
                    "searchText": search_text,
                    "cursor": _cursor,
                },
                timeout=timeout,
            )

        _body = await paginate_all_async(_fetch, extract_wdata_cursor, "body")
        return PagedResponseFileMetaDto.model_validate(_body)

    def upload_file(
        self,
        *,
        table_id: str,
        name: Optional[str] = None,
        url: Optional[str] = None,
        source: Optional[str] = None,
        delimiter: Optional[str] = None,
        import_dto: Optional[str] = None,
        body: Optional[dict[str, Any]] = None,
        timeout: Optional[float] = None,
    ) -> BaseResponseFileMetaDto:
        """Upload a single file

                Accepts CSV, TSV, or JSON files, or a ZIP file that contains a single
                CSV, TSV, or
                JSON file. If a ZIP, it must contain a CSV, TSV, or JSON file, and the
                name of the
                CSV, TSV, or JSON file is also used with the imported file. Downloading
                this file
                again downloads the source. Note that all files uploaded must have a
                .csv, .tsv, or .json
                extension. JSON files are expected to have a single JSON record per
                line; a JSON file is
                a series of JSON objects delimited by a newline character.

                Args:
                    table_id: The unique table identifier associated with this file
                    name: No longer in use, here to ensure backwards compatibility
                    url: No longer in use, here to ensure backwards compatibility
                    source: The data source to associate with the file, no more than 255 characters. This
        field is not in use; it only keeps track of the source
                    delimiter: The character to use as a delimiter within the file to separate one field from
        another.  The default is comma
                    import_dto:
                    body: Request body.
                    timeout: Override the default request timeout (seconds).

                Returns:
                    BaseResponseFileMetaDto

                Raises:
                    WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 423, 429, 500).

                Note:
                    This operation uses multipart/form-data. Pass ``body`` as a dict
                    mapping field names to values. For file fields use a tuple::

                        body = {
                            "file": ("filename.csv", open("filename.csv", "rb")),
                            "field": "value",
                        }
        """
        response = self._client.request(
            "POST",
            self._api,
            "/api/v1/file",
            query_params={
                "tableId": table_id,
                "name": name,
                "url": url,
                "source": source,
                "delimiter": delimiter,
                "importDto": import_dto,
            },
            files=body,
            timeout=timeout,
        )
        return BaseResponseFileMetaDto.model_validate(response.json())

    async def upload_file_async(
        self,
        *,
        table_id: str,
        name: Optional[str] = None,
        url: Optional[str] = None,
        source: Optional[str] = None,
        delimiter: Optional[str] = None,
        import_dto: Optional[str] = None,
        body: Optional[dict[str, Any]] = None,
        timeout: Optional[float] = None,
    ) -> BaseResponseFileMetaDto:
        """Upload a single file (async)

                Accepts CSV, TSV, or JSON files, or a ZIP file that contains a single
                CSV, TSV, or
                JSON file. If a ZIP, it must contain a CSV, TSV, or JSON file, and the
                name of the
                CSV, TSV, or JSON file is also used with the imported file. Downloading
                this file
                again downloads the source. Note that all files uploaded must have a
                .csv, .tsv, or .json
                extension. JSON files are expected to have a single JSON record per
                line; a JSON file is
                a series of JSON objects delimited by a newline character.

                Args:
                    table_id: The unique table identifier associated with this file
                    name: No longer in use, here to ensure backwards compatibility
                    url: No longer in use, here to ensure backwards compatibility
                    source: The data source to associate with the file, no more than 255 characters. This
        field is not in use; it only keeps track of the source
                    delimiter: The character to use as a delimiter within the file to separate one field from
        another.  The default is comma
                    import_dto:
                    body: Request body.
                    timeout: Override the default request timeout (seconds).

                Returns:
                    BaseResponseFileMetaDto

                Raises:
                    WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 423, 429, 500).

                Note:
                    This operation uses multipart/form-data. Pass ``body`` as a dict
                    mapping field names to values. For file fields use a tuple::

                        body = {
                            "file": ("filename.csv", open("filename.csv", "rb")),
                            "field": "value",
                        }
        """
        response = await self._client.request_async(
            "POST",
            self._api,
            "/api/v1/file",
            query_params={
                "tableId": table_id,
                "name": name,
                "url": url,
                "source": source,
                "delimiter": delimiter,
                "importDto": import_dto,
            },
            files=body,
            timeout=timeout,
        )
        return BaseResponseFileMetaDto.model_validate(response.json())

    def validate_filename(
        self,
        *,
        table_id: str,
        filename: str,
        timeout: Optional[float] = None,
    ) -> BaseResponseString:
        """Validate whether a file with the filename can be uploaded to the table

        If the filename is valid, this returns 200. If the table already has a
        file with the same name, this returns 409. If the user isn't allowed to
        read the table, or if the table isn't found, this returns 404.

        Args:
            table_id: The ID of the table to upload the file to
            filename: The name of the file to upload
            timeout: Override the default request timeout (seconds).

        Returns:
            BaseResponseString

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 423, 429, 500).
        """
        response = self._client.request(
            "GET",
            self._api,
            "/api/v1/file/validateName",
            query_params={
                "tableId": table_id,
                "filename": filename,
            },
            timeout=timeout,
        )
        return BaseResponseString.model_validate(response.json())

    async def validate_filename_async(
        self,
        *,
        table_id: str,
        filename: str,
        timeout: Optional[float] = None,
    ) -> BaseResponseString:
        """Validate whether a file with the filename can be uploaded to the table (async)

        If the filename is valid, this returns 200. If the table already has a
        file with the same name, this returns 409. If the user isn't allowed to
        read the table, or if the table isn't found, this returns 404.

        Args:
            table_id: The ID of the table to upload the file to
            filename: The name of the file to upload
            timeout: Override the default request timeout (seconds).

        Returns:
            BaseResponseString

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 423, 429, 500).
        """
        response = await self._client.request_async(
            "GET",
            self._api,
            "/api/v1/file/validateName",
            query_params={
                "tableId": table_id,
                "filename": filename,
            },
            timeout=timeout,
        )
        return BaseResponseString.model_validate(response.json())

    def get_file(
        self,
        *,
        file_id: str,
        timeout: Optional[float] = None,
    ) -> BaseResponseFileMetaDto:
        """Retrieve a single file

        Returns the file meta that matches the provided ID, or a 404 if an
        associated file
        can't be found.

        Args:
            file_id: The unique identifier of the file
            timeout: Override the default request timeout (seconds).

        Returns:
            BaseResponseFileMetaDto

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 423, 429, 500).
        """
        response = self._client.request(
            "GET",
            self._api,
            "/api/v1/file/{fileId}",
            path_params={
                "fileId": file_id,
            },
            timeout=timeout,
        )
        return BaseResponseFileMetaDto.model_validate(response.json())

    async def get_file_async(
        self,
        *,
        file_id: str,
        timeout: Optional[float] = None,
    ) -> BaseResponseFileMetaDto:
        """Retrieve a single file (async)

        Returns the file meta that matches the provided ID, or a 404 if an
        associated file
        can't be found.

        Args:
            file_id: The unique identifier of the file
            timeout: Override the default request timeout (seconds).

        Returns:
            BaseResponseFileMetaDto

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 423, 429, 500).
        """
        response = await self._client.request_async(
            "GET",
            self._api,
            "/api/v1/file/{fileId}",
            path_params={
                "fileId": file_id,
            },
            timeout=timeout,
        )
        return BaseResponseFileMetaDto.model_validate(response.json())

    def delete_file(
        self,
        *,
        file_id: str,
        timeout: Optional[float] = None,
    ) -> BaseResponseString:
        """Delete a single file

        Unstages the file with the provided ID. The file must have a STAGED
        status; if the
        file isn't STAGED, returns a 409 status. If the file isn't found, this
        is a no-op.

        Args:
            file_id: The unique identifier of the file
            timeout: Override the default request timeout (seconds).

        Returns:
            BaseResponseString

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 423, 429, 500).
        """
        response = self._client.request(
            "DELETE",
            self._api,
            "/api/v1/file/{fileId}",
            path_params={
                "fileId": file_id,
            },
            timeout=timeout,
        )
        return BaseResponseString.model_validate(response.json())

    async def delete_file_async(
        self,
        *,
        file_id: str,
        timeout: Optional[float] = None,
    ) -> BaseResponseString:
        """Delete a single file (async)

        Unstages the file with the provided ID. The file must have a STAGED
        status; if the
        file isn't STAGED, returns a 409 status. If the file isn't found, this
        is a no-op.

        Args:
            file_id: The unique identifier of the file
            timeout: Override the default request timeout (seconds).

        Returns:
            BaseResponseString

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 423, 429, 500).
        """
        response = await self._client.request_async(
            "DELETE",
            self._api,
            "/api/v1/file/{fileId}",
            path_params={
                "fileId": file_id,
            },
            timeout=timeout,
        )
        return BaseResponseString.model_validate(response.json())

    def download_file_1(
        self,
        *,
        file_id: str,
        timeout: Optional[float] = None,
    ) -> httpx.Response:
        """Download a single file

        Returns a file with the provided ID, which points to a file meta ID.

        Args:
            file_id: The unique identifier of the file
            timeout: Override the default request timeout (seconds).

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 423, 429, 500).
        """
        return self._client.request(
            "GET",
            self._api,
            "/api/v1/file/{fileId}/download",
            path_params={
                "fileId": file_id,
            },
            timeout=timeout,
        )

    async def download_file_1_async(
        self,
        *,
        file_id: str,
        timeout: Optional[float] = None,
    ) -> httpx.Response:
        """Download a single file (async)

        Returns a file with the provided ID, which points to a file meta ID.

        Args:
            file_id: The unique identifier of the file
            timeout: Override the default request timeout (seconds).

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 423, 429, 500).
        """
        return await self._client.request_async(
            "GET",
            self._api,
            "/api/v1/file/{fileId}/download",
            path_params={
                "fileId": file_id,
            },
            timeout=timeout,
        )

    def get_errors(
        self,
        *,
        file_id: str,
        limit: Optional[int] = 50,
        offset: Optional[int] = None,
        timeout: Optional[float] = None,
    ) -> PagedResponseImportErrorDto:
        """Retrieve errors

        Returns a paged list of operation errors during the upload, import, or
        tagging
        processes for the provided file ID, if they exist. This list is
        immutable and may be
        empty if no errors have occurred. If errors exist we recommend fixing
        them and
        reimporting your file

        Args:
            file_id: The unique identifier of the file
            limit: The number of errors to return, from 1 to 50; by default, 50
            offset: The item to start with on the page, greater than or equal to 0; by default, 0
            timeout: Override the default request timeout (seconds).

        Returns:
            PagedResponseImportErrorDto

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 423, 429, 500).
        """

        def _fetch(_cursor: str | None) -> httpx.Response:
            return self._client.request(
                "GET",
                self._api,
                "/api/v1/file/{fileId}/error",
                path_params={
                    "fileId": file_id,
                },
                query_params={
                    "limit": limit,
                    "offset": offset,
                    "cursor": _cursor,
                },
                timeout=timeout,
            )

        _body = paginate_all(_fetch, extract_wdata_cursor, "body")
        return PagedResponseImportErrorDto.model_validate(_body)

    async def get_errors_async(
        self,
        *,
        file_id: str,
        limit: Optional[int] = 50,
        offset: Optional[int] = None,
        timeout: Optional[float] = None,
    ) -> PagedResponseImportErrorDto:
        """Retrieve errors (async)

        Returns a paged list of operation errors during the upload, import, or
        tagging
        processes for the provided file ID, if they exist. This list is
        immutable and may be
        empty if no errors have occurred. If errors exist we recommend fixing
        them and
        reimporting your file

        Args:
            file_id: The unique identifier of the file
            limit: The number of errors to return, from 1 to 50; by default, 50
            offset: The item to start with on the page, greater than or equal to 0; by default, 0
            timeout: Override the default request timeout (seconds).

        Returns:
            PagedResponseImportErrorDto

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 423, 429, 500).
        """

        async def _fetch(_cursor: str | None) -> httpx.Response:
            return await self._client.request_async(
                "GET",
                self._api,
                "/api/v1/file/{fileId}/error",
                path_params={
                    "fileId": file_id,
                },
                query_params={
                    "limit": limit,
                    "offset": offset,
                    "cursor": _cursor,
                },
                timeout=timeout,
            )

        _body = await paginate_all_async(_fetch, extract_wdata_cursor, "body")
        return PagedResponseImportErrorDto.model_validate(_body)

    def export_file_to_spreadsheets(
        self,
        *,
        file_id: str,
        body: ExportFileDto,
        timeout: Optional[float] = None,
    ) -> BaseResponseSpreadsheetInfoDto:
        """Export a file to spreadsheets

        Exports the file ID identified in the path to the spreadsheet identified
        by the
        provided URL. If the URL string is empty, creates and returns a new
        spreadsheet and
        its sheet IDs.

        Args:
            file_id: The unique identifier of the file
            body: Request body.
            timeout: Override the default request timeout (seconds).

        Returns:
            BaseResponseSpreadsheetInfoDto

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 423, 429, 500).
        """
        response = self._client.request(
            "POST",
            self._api,
            "/api/v1/file/{fileId}/export",
            path_params={
                "fileId": file_id,
            },
            json_body=body,
            timeout=timeout,
        )
        return BaseResponseSpreadsheetInfoDto.model_validate(response.json())

    async def export_file_to_spreadsheets_async(
        self,
        *,
        file_id: str,
        body: ExportFileDto,
        timeout: Optional[float] = None,
    ) -> BaseResponseSpreadsheetInfoDto:
        """Export a file to spreadsheets (async)

        Exports the file ID identified in the path to the spreadsheet identified
        by the
        provided URL. If the URL string is empty, creates and returns a new
        spreadsheet and
        its sheet IDs.

        Args:
            file_id: The unique identifier of the file
            body: Request body.
            timeout: Override the default request timeout (seconds).

        Returns:
            BaseResponseSpreadsheetInfoDto

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 423, 429, 500).
        """
        response = await self._client.request_async(
            "POST",
            self._api,
            "/api/v1/file/{fileId}/export",
            path_params={
                "fileId": file_id,
            },
            json_body=body,
            timeout=timeout,
        )
        return BaseResponseSpreadsheetInfoDto.model_validate(response.json())

    def list_folders(
        self,
        *,
        limit: Optional[int] = 1000,
        offset: Optional[int] = None,
        timeout: Optional[float] = None,
    ) -> PagedResponseFolderDto:
        """Retrieve a list of folders

        Returns a paged list of all folders associated with the workspace.

        Args:
            limit: The number of folders to return, from 1 to 1000; by default, 1000
            offset: The item to start with on the page, greater than or equal to 0; by default, 0
            timeout: Override the default request timeout (seconds).

        Returns:
            PagedResponseFolderDto

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 423, 429, 500).
        """

        def _fetch(_cursor: str | None) -> httpx.Response:
            return self._client.request(
                "GET",
                self._api,
                "/api/v1/folder",
                query_params={
                    "limit": limit,
                    "offset": offset,
                    "cursor": _cursor,
                },
                timeout=timeout,
            )

        _body = paginate_all(_fetch, extract_wdata_cursor, "body")
        return PagedResponseFolderDto.model_validate(_body)

    async def list_folders_async(
        self,
        *,
        limit: Optional[int] = 1000,
        offset: Optional[int] = None,
        timeout: Optional[float] = None,
    ) -> PagedResponseFolderDto:
        """Retrieve a list of folders (async)

        Returns a paged list of all folders associated with the workspace.

        Args:
            limit: The number of folders to return, from 1 to 1000; by default, 1000
            offset: The item to start with on the page, greater than or equal to 0; by default, 0
            timeout: Override the default request timeout (seconds).

        Returns:
            PagedResponseFolderDto

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 423, 429, 500).
        """

        async def _fetch(_cursor: str | None) -> httpx.Response:
            return await self._client.request_async(
                "GET",
                self._api,
                "/api/v1/folder",
                query_params={
                    "limit": limit,
                    "offset": offset,
                    "cursor": _cursor,
                },
                timeout=timeout,
            )

        _body = await paginate_all_async(_fetch, extract_wdata_cursor, "body")
        return PagedResponseFolderDto.model_validate(_body)

    def create_folder(
        self,
        *,
        body: FolderDto,
        timeout: Optional[float] = None,
    ) -> BaseResponseFolderDto:
        """Create a new folder

        Creates a folder using the provided information and returns the folder
        meta.

        Returns:
            BaseResponseFolderDto

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 423, 429, 500).
        """
        response = self._client.request(
            "POST",
            self._api,
            "/api/v1/folder",
            json_body=body,
            timeout=timeout,
        )
        return BaseResponseFolderDto.model_validate(response.json())

    async def create_folder_async(
        self,
        *,
        body: FolderDto,
        timeout: Optional[float] = None,
    ) -> BaseResponseFolderDto:
        """Create a new folder (async)

        Creates a folder using the provided information and returns the folder
        meta.

        Returns:
            BaseResponseFolderDto

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 423, 429, 500).
        """
        response = await self._client.request_async(
            "POST",
            self._api,
            "/api/v1/folder",
            json_body=body,
            timeout=timeout,
        )
        return BaseResponseFolderDto.model_validate(response.json())

    def get_folder(
        self,
        *,
        folder_id: str,
        timeout: Optional[float] = None,
    ) -> BaseResponseFolderDto:
        """Retrieve a single folder

        Returns a folder with the provided ID, or a 404 if no matching folder is
        found.

        Args:
            folder_id: The unique identifier of the folder
            timeout: Override the default request timeout (seconds).

        Returns:
            BaseResponseFolderDto

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 423, 429, 500).
        """
        response = self._client.request(
            "GET",
            self._api,
            "/api/v1/folder/{folderId}",
            path_params={
                "folderId": folder_id,
            },
            timeout=timeout,
        )
        return BaseResponseFolderDto.model_validate(response.json())

    async def get_folder_async(
        self,
        *,
        folder_id: str,
        timeout: Optional[float] = None,
    ) -> BaseResponseFolderDto:
        """Retrieve a single folder (async)

        Returns a folder with the provided ID, or a 404 if no matching folder is
        found.

        Args:
            folder_id: The unique identifier of the folder
            timeout: Override the default request timeout (seconds).

        Returns:
            BaseResponseFolderDto

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 423, 429, 500).
        """
        response = await self._client.request_async(
            "GET",
            self._api,
            "/api/v1/folder/{folderId}",
            path_params={
                "folderId": folder_id,
            },
            timeout=timeout,
        )
        return BaseResponseFolderDto.model_validate(response.json())

    def delete_folder(
        self,
        *,
        folder_id: str,
        timeout: Optional[float] = None,
    ) -> BaseResponseString:
        """Delete a single folder

        Deletes the folder with the provided ID.  If the folder is not found,
        this is a
        no-op. <b>All files and sub-folders are also recursively deleted.</b>

        Args:
            folder_id: The unique identifier of the folder
            timeout: Override the default request timeout (seconds).

        Returns:
            BaseResponseString

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 423, 429, 500).
        """
        response = self._client.request(
            "DELETE",
            self._api,
            "/api/v1/folder/{folderId}",
            path_params={
                "folderId": folder_id,
            },
            timeout=timeout,
        )
        return BaseResponseString.model_validate(response.json())

    async def delete_folder_async(
        self,
        *,
        folder_id: str,
        timeout: Optional[float] = None,
    ) -> BaseResponseString:
        """Delete a single folder (async)

        Deletes the folder with the provided ID.  If the folder is not found,
        this is a
        no-op. <b>All files and sub-folders are also recursively deleted.</b>

        Args:
            folder_id: The unique identifier of the folder
            timeout: Override the default request timeout (seconds).

        Returns:
            BaseResponseString

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 423, 429, 500).
        """
        response = await self._client.request_async(
            "DELETE",
            self._api,
            "/api/v1/folder/{folderId}",
            path_params={
                "folderId": folder_id,
            },
            timeout=timeout,
        )
        return BaseResponseString.model_validate(response.json())

    def update_folder(
        self,
        *,
        folder_id: str,
        body: FolderDto,
        timeout: Optional[float] = None,
    ) -> BaseResponseFolderDto:
        """Update a single folder

        Updates the folder that matches the provided ID with the details
        provided in the
        body.

        Args:
            folder_id: The unique identifier of the folder
            body: Request body.
            timeout: Override the default request timeout (seconds).

        Returns:
            BaseResponseFolderDto

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 423, 429, 500).
        """
        response = self._client.request(
            "PUT",
            self._api,
            "/api/v1/folder/{folderId}",
            path_params={
                "folderId": folder_id,
            },
            json_body=body,
            timeout=timeout,
        )
        return BaseResponseFolderDto.model_validate(response.json())

    async def update_folder_async(
        self,
        *,
        folder_id: str,
        body: FolderDto,
        timeout: Optional[float] = None,
    ) -> BaseResponseFolderDto:
        """Update a single folder (async)

        Updates the folder that matches the provided ID with the details
        provided in the
        body.

        Args:
            folder_id: The unique identifier of the folder
            body: Request body.
            timeout: Override the default request timeout (seconds).

        Returns:
            BaseResponseFolderDto

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 423, 429, 500).
        """
        response = await self._client.request_async(
            "PUT",
            self._api,
            "/api/v1/folder/{folderId}",
            path_params={
                "folderId": folder_id,
            },
            json_body=body,
            timeout=timeout,
        )
        return BaseResponseFolderDto.model_validate(response.json())

    def list_children(
        self,
        *,
        folder_id: str,
        limit: Optional[int] = 1000,
        offset: Optional[int] = None,
        timeout: Optional[float] = None,
    ) -> PagedResponseFolderableDto:
        """Retrieve list of folder contents

        Returns a paged list of all children whose parent ID matches the
        provided folder
        ID.  If the folder ID in the path is the literal 'null' value, returns a
        list of
        all entities with no parent.

        Args:
            folder_id: The unique identifier of the folder
            limit: The number of folders to return, from 1 to 1000; by default, 1000
            offset: The item to start with on the page, greater than or equal to 0; by default, 0
            timeout: Override the default request timeout (seconds).

        Returns:
            PagedResponseFolderableDto

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 423, 429, 500).
        """

        def _fetch(_cursor: str | None) -> httpx.Response:
            return self._client.request(
                "GET",
                self._api,
                "/api/v1/folder/{folderId}/children",
                path_params={
                    "folderId": folder_id,
                },
                query_params={
                    "limit": limit,
                    "offset": offset,
                    "cursor": _cursor,
                },
                timeout=timeout,
            )

        _body = paginate_all(_fetch, extract_wdata_cursor, "body")
        return PagedResponseFolderableDto.model_validate(_body)

    async def list_children_async(
        self,
        *,
        folder_id: str,
        limit: Optional[int] = 1000,
        offset: Optional[int] = None,
        timeout: Optional[float] = None,
    ) -> PagedResponseFolderableDto:
        """Retrieve list of folder contents (async)

        Returns a paged list of all children whose parent ID matches the
        provided folder
        ID.  If the folder ID in the path is the literal 'null' value, returns a
        list of
        all entities with no parent.

        Args:
            folder_id: The unique identifier of the folder
            limit: The number of folders to return, from 1 to 1000; by default, 1000
            offset: The item to start with on the page, greater than or equal to 0; by default, 0
            timeout: Override the default request timeout (seconds).

        Returns:
            PagedResponseFolderableDto

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 423, 429, 500).
        """

        async def _fetch(_cursor: str | None) -> httpx.Response:
            return await self._client.request_async(
                "GET",
                self._api,
                "/api/v1/folder/{folderId}/children",
                path_params={
                    "folderId": folder_id,
                },
                query_params={
                    "limit": limit,
                    "offset": offset,
                    "cursor": _cursor,
                },
                timeout=timeout,
            )

        _body = await paginate_all_async(_fetch, extract_wdata_cursor, "body")
        return PagedResponseFolderableDto.model_validate(_body)

    def set_children(
        self,
        *,
        folder_id: str,
        body: list[FolderableDto],
        timeout: Optional[float] = None,
    ) -> BaseResponseCollectionFolderableDto:
        """Move content into a folder

        Sets the children of a folder using the entities' types and IDs provided
        in the
        body. If the entities previously resided under a folder, including the
        root,
        they move to the folder with the provided ID. If the provided ID is
        'null',
        the entities move to the root folder.

        Args:
            folder_id: The unique identifier of the folder
            body: Request body.
            timeout: Override the default request timeout (seconds).

        Returns:
            BaseResponseCollectionFolderableDto

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 423, 429, 500).
        """
        response = self._client.request(
            "POST",
            self._api,
            "/api/v1/folder/{folderId}/children",
            path_params={
                "folderId": folder_id,
            },
            json_body=body,
            timeout=timeout,
        )
        return BaseResponseCollectionFolderableDto.model_validate(response.json())

    async def set_children_async(
        self,
        *,
        folder_id: str,
        body: list[FolderableDto],
        timeout: Optional[float] = None,
    ) -> BaseResponseCollectionFolderableDto:
        """Move content into a folder (async)

        Sets the children of a folder using the entities' types and IDs provided
        in the
        body. If the entities previously resided under a folder, including the
        root,
        they move to the folder with the provided ID. If the provided ID is
        'null',
        the entities move to the root folder.

        Args:
            folder_id: The unique identifier of the folder
            body: Request body.
            timeout: Override the default request timeout (seconds).

        Returns:
            BaseResponseCollectionFolderableDto

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 423, 429, 500).
        """
        response = await self._client.request_async(
            "POST",
            self._api,
            "/api/v1/folder/{folderId}/children",
            path_params={
                "folderId": folder_id,
            },
            json_body=body,
            timeout=timeout,
        )
        return BaseResponseCollectionFolderableDto.model_validate(response.json())

    def list_parameters(
        self,
        *,
        limit: Optional[int] = 1000,
        offset: Optional[int] = None,
        timeout: Optional[float] = None,
    ) -> PagedResponseGlobalParameterDto:
        """Get Parameters

                Returns a list of all parameters associated with the workspace.  By
                default, these
                parameters are ordered by their names in ascending order.

                Args:
                    limit: The number of parameters to return, must be between 1 and 1000, will default
        to 1000
                    offset: The item to start with on the page, must be greater than or equal to 0, will default to 0
                    timeout: Override the default request timeout (seconds).

                Returns:
                    PagedResponseGlobalParameterDto

                Raises:
                    WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 423, 429, 500).
        """

        def _fetch(_cursor: str | None) -> httpx.Response:
            return self._client.request(
                "GET",
                self._api,
                "/api/v1/parameter",
                query_params={
                    "limit": limit,
                    "offset": offset,
                    "cursor": _cursor,
                },
                timeout=timeout,
            )

        _body = paginate_all(_fetch, extract_wdata_cursor, "body")
        return PagedResponseGlobalParameterDto.model_validate(_body)

    async def list_parameters_async(
        self,
        *,
        limit: Optional[int] = 1000,
        offset: Optional[int] = None,
        timeout: Optional[float] = None,
    ) -> PagedResponseGlobalParameterDto:
        """Get Parameters (async)

                Returns a list of all parameters associated with the workspace.  By
                default, these
                parameters are ordered by their names in ascending order.

                Args:
                    limit: The number of parameters to return, must be between 1 and 1000, will default
        to 1000
                    offset: The item to start with on the page, must be greater than or equal to 0, will default to 0
                    timeout: Override the default request timeout (seconds).

                Returns:
                    PagedResponseGlobalParameterDto

                Raises:
                    WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 423, 429, 500).
        """

        async def _fetch(_cursor: str | None) -> httpx.Response:
            return await self._client.request_async(
                "GET",
                self._api,
                "/api/v1/parameter",
                query_params={
                    "limit": limit,
                    "offset": offset,
                    "cursor": _cursor,
                },
                timeout=timeout,
            )

        _body = await paginate_all_async(_fetch, extract_wdata_cursor, "body")
        return PagedResponseGlobalParameterDto.model_validate(_body)

    def create_parameter(
        self,
        *,
        body: GlobalParameterDto,
        timeout: Optional[float] = None,
    ) -> BaseResponseGlobalParameterDto:
        """Create parameter

        Creates a parameter.  If there is a parameter with the same ID, a 409 is
        returned.

        Returns:
            BaseResponseGlobalParameterDto

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 423, 429, 500).
        """
        response = self._client.request(
            "POST",
            self._api,
            "/api/v1/parameter",
            json_body=body,
            timeout=timeout,
        )
        return BaseResponseGlobalParameterDto.model_validate(response.json())

    async def create_parameter_async(
        self,
        *,
        body: GlobalParameterDto,
        timeout: Optional[float] = None,
    ) -> BaseResponseGlobalParameterDto:
        """Create parameter (async)

        Creates a parameter.  If there is a parameter with the same ID, a 409 is
        returned.

        Returns:
            BaseResponseGlobalParameterDto

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 423, 429, 500).
        """
        response = await self._client.request_async(
            "POST",
            self._api,
            "/api/v1/parameter",
            json_body=body,
            timeout=timeout,
        )
        return BaseResponseGlobalParameterDto.model_validate(response.json())

    def get_parameter(
        self,
        *,
        parameter_id: str,
        timeout: Optional[float] = None,
    ) -> BaseResponseGlobalParameterDto:
        """Get Parameter

        Returns a parameter matching the provided parameter ID.  If no matching
        entity can be found, a 404 status is returned.

        Args:
            parameter_id: The unique identifier of the parameter
            timeout: Override the default request timeout (seconds).

        Returns:
            BaseResponseGlobalParameterDto

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 423, 429, 500).
        """
        response = self._client.request(
            "GET",
            self._api,
            "/api/v1/parameter/{parameterId}",
            path_params={
                "parameterId": parameter_id,
            },
            timeout=timeout,
        )
        return BaseResponseGlobalParameterDto.model_validate(response.json())

    async def get_parameter_async(
        self,
        *,
        parameter_id: str,
        timeout: Optional[float] = None,
    ) -> BaseResponseGlobalParameterDto:
        """Get Parameter (async)

        Returns a parameter matching the provided parameter ID.  If no matching
        entity can be found, a 404 status is returned.

        Args:
            parameter_id: The unique identifier of the parameter
            timeout: Override the default request timeout (seconds).

        Returns:
            BaseResponseGlobalParameterDto

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 423, 429, 500).
        """
        response = await self._client.request_async(
            "GET",
            self._api,
            "/api/v1/parameter/{parameterId}",
            path_params={
                "parameterId": parameter_id,
            },
            timeout=timeout,
        )
        return BaseResponseGlobalParameterDto.model_validate(response.json())

    def delete_parameter(
        self,
        *,
        parameter_id: str,
        timeout: Optional[float] = None,
    ) -> BaseResponseString:
        """Delete Parameter

        Deletes the parameter with the provided parameter ID.  If the parameter
        is not found, this is a no-op.

        Args:
            parameter_id: The unique identifier of the parameter
            timeout: Override the default request timeout (seconds).

        Returns:
            BaseResponseString

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 423, 429, 500).
        """
        response = self._client.request(
            "DELETE",
            self._api,
            "/api/v1/parameter/{parameterId}",
            path_params={
                "parameterId": parameter_id,
            },
            timeout=timeout,
        )
        return BaseResponseString.model_validate(response.json())

    async def delete_parameter_async(
        self,
        *,
        parameter_id: str,
        timeout: Optional[float] = None,
    ) -> BaseResponseString:
        """Delete Parameter (async)

        Deletes the parameter with the provided parameter ID.  If the parameter
        is not found, this is a no-op.

        Args:
            parameter_id: The unique identifier of the parameter
            timeout: Override the default request timeout (seconds).

        Returns:
            BaseResponseString

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 423, 429, 500).
        """
        response = await self._client.request_async(
            "DELETE",
            self._api,
            "/api/v1/parameter/{parameterId}",
            path_params={
                "parameterId": parameter_id,
            },
            timeout=timeout,
        )
        return BaseResponseString.model_validate(response.json())

    def update_parameter(
        self,
        *,
        parameter_id: str,
        body: GlobalParameterDto,
        timeout: Optional[float] = None,
    ) -> BaseResponseGlobalParameterDto:
        """Update Parameter

        Updates the parameter matching the provided ID in the provided payload.

        Args:
            parameter_id: The unique identifier of the parameter
            body: Request body.
            timeout: Override the default request timeout (seconds).

        Returns:
            BaseResponseGlobalParameterDto

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 423, 429, 500).
        """
        response = self._client.request(
            "PUT",
            self._api,
            "/api/v1/parameter/{parameterId}",
            path_params={
                "parameterId": parameter_id,
            },
            json_body=body,
            timeout=timeout,
        )
        return BaseResponseGlobalParameterDto.model_validate(response.json())

    async def update_parameter_async(
        self,
        *,
        parameter_id: str,
        body: GlobalParameterDto,
        timeout: Optional[float] = None,
    ) -> BaseResponseGlobalParameterDto:
        """Update Parameter (async)

        Updates the parameter matching the provided ID in the provided payload.

        Args:
            parameter_id: The unique identifier of the parameter
            body: Request body.
            timeout: Override the default request timeout (seconds).

        Returns:
            BaseResponseGlobalParameterDto

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 423, 429, 500).
        """
        response = await self._client.request_async(
            "PUT",
            self._api,
            "/api/v1/parameter/{parameterId}",
            path_params={
                "parameterId": parameter_id,
            },
            json_body=body,
            timeout=timeout,
        )
        return BaseResponseGlobalParameterDto.model_validate(response.json())

    def list_pivot_views(
        self,
        *,
        query_id: str,
        limit: Optional[int] = 1000,
        offset: Optional[int] = None,
        timeout: Optional[float] = None,
    ) -> PagedResponsePivotViewDto:
        """Retrieve a list of pivot views

        Returns a paged list of views in the workspace of the request. If
        queryId is provided, the results are limited to only views associated
        with the query ID.

        Args:
            query_id: The unique query identifier to filter the views
            limit: The number of views to return, from 1 to 1000; by default, 1000
            offset: The item to start with on the page, greater than or equal to 0; by default, 0
            timeout: Override the default request timeout (seconds).

        Returns:
            PagedResponsePivotViewDto

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 423, 429, 500).
        """

        def _fetch(_cursor: str | None) -> httpx.Response:
            return self._client.request(
                "GET",
                self._api,
                "/api/v1/pivotview",
                query_params={
                    "queryId": query_id,
                    "limit": limit,
                    "offset": offset,
                    "cursor": _cursor,
                },
                timeout=timeout,
            )

        _body = paginate_all(_fetch, extract_wdata_cursor, "body")
        return PagedResponsePivotViewDto.model_validate(_body)

    async def list_pivot_views_async(
        self,
        *,
        query_id: str,
        limit: Optional[int] = 1000,
        offset: Optional[int] = None,
        timeout: Optional[float] = None,
    ) -> PagedResponsePivotViewDto:
        """Retrieve a list of pivot views (async)

        Returns a paged list of views in the workspace of the request. If
        queryId is provided, the results are limited to only views associated
        with the query ID.

        Args:
            query_id: The unique query identifier to filter the views
            limit: The number of views to return, from 1 to 1000; by default, 1000
            offset: The item to start with on the page, greater than or equal to 0; by default, 0
            timeout: Override the default request timeout (seconds).

        Returns:
            PagedResponsePivotViewDto

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 423, 429, 500).
        """

        async def _fetch(_cursor: str | None) -> httpx.Response:
            return await self._client.request_async(
                "GET",
                self._api,
                "/api/v1/pivotview",
                query_params={
                    "queryId": query_id,
                    "limit": limit,
                    "offset": offset,
                    "cursor": _cursor,
                },
                timeout=timeout,
            )

        _body = await paginate_all_async(_fetch, extract_wdata_cursor, "body")
        return PagedResponsePivotViewDto.model_validate(_body)

    def create_pivot_view(
        self,
        *,
        body: PivotViewDto,
        timeout: Optional[float] = None,
    ) -> BaseResponsePivotViewDto:
        """Create a new pivot view

        Creates a view from the provided information. Currently, persists the
        provided
        `additionalMetadata` field, which can store an arbitrary JSON definition
        of a pivot
        table view. This pivot table must be associated with a query, and can
        optionally be
        associated with a query result. When a query is deleted, its associated
        views are
        also deleted.

        Returns:
            BaseResponsePivotViewDto

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 423, 429, 500).
        """
        response = self._client.request(
            "POST",
            self._api,
            "/api/v1/pivotview",
            json_body=body,
            timeout=timeout,
        )
        return BaseResponsePivotViewDto.model_validate(response.json())

    async def create_pivot_view_async(
        self,
        *,
        body: PivotViewDto,
        timeout: Optional[float] = None,
    ) -> BaseResponsePivotViewDto:
        """Create a new pivot view (async)

        Creates a view from the provided information. Currently, persists the
        provided
        `additionalMetadata` field, which can store an arbitrary JSON definition
        of a pivot
        table view. This pivot table must be associated with a query, and can
        optionally be
        associated with a query result. When a query is deleted, its associated
        views are
        also deleted.

        Returns:
            BaseResponsePivotViewDto

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 423, 429, 500).
        """
        response = await self._client.request_async(
            "POST",
            self._api,
            "/api/v1/pivotview",
            json_body=body,
            timeout=timeout,
        )
        return BaseResponsePivotViewDto.model_validate(response.json())

    def get_pivot_view(
        self,
        *,
        pivot_view_id: str,
        timeout: Optional[float] = None,
    ) -> BaseResponsePivotViewDto:
        """Retrieve a single pivot view

        Returns a view with the provided ID, or a 404 if no view matches the ID.

        Args:
            pivot_view_id: The unique identifier of the pivot view
            timeout: Override the default request timeout (seconds).

        Returns:
            BaseResponsePivotViewDto

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 423, 429, 500).
        """
        response = self._client.request(
            "GET",
            self._api,
            "/api/v1/pivotview/{pivotViewId}",
            path_params={
                "pivotViewId": pivot_view_id,
            },
            timeout=timeout,
        )
        return BaseResponsePivotViewDto.model_validate(response.json())

    async def get_pivot_view_async(
        self,
        *,
        pivot_view_id: str,
        timeout: Optional[float] = None,
    ) -> BaseResponsePivotViewDto:
        """Retrieve a single pivot view (async)

        Returns a view with the provided ID, or a 404 if no view matches the ID.

        Args:
            pivot_view_id: The unique identifier of the pivot view
            timeout: Override the default request timeout (seconds).

        Returns:
            BaseResponsePivotViewDto

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 423, 429, 500).
        """
        response = await self._client.request_async(
            "GET",
            self._api,
            "/api/v1/pivotview/{pivotViewId}",
            path_params={
                "pivotViewId": pivot_view_id,
            },
            timeout=timeout,
        )
        return BaseResponsePivotViewDto.model_validate(response.json())

    def delete_pivot_view(
        self,
        *,
        pivot_view_id: str,
        timeout: Optional[float] = None,
    ) -> BaseResponseString:
        """Delete a single pivot view

        Deletes a view that matches the provided ID.  This is an administrative
        method and
        should be assumed a hard-delete, given no capability to restore a
        deleted view is
        available.  A no-op if no such view exists.

        Args:
            pivot_view_id: The unique identifier of the pivot view
            timeout: Override the default request timeout (seconds).

        Returns:
            BaseResponseString

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 423, 429, 500).
        """
        response = self._client.request(
            "DELETE",
            self._api,
            "/api/v1/pivotview/{pivotViewId}",
            path_params={
                "pivotViewId": pivot_view_id,
            },
            timeout=timeout,
        )
        return BaseResponseString.model_validate(response.json())

    async def delete_pivot_view_async(
        self,
        *,
        pivot_view_id: str,
        timeout: Optional[float] = None,
    ) -> BaseResponseString:
        """Delete a single pivot view (async)

        Deletes a view that matches the provided ID.  This is an administrative
        method and
        should be assumed a hard-delete, given no capability to restore a
        deleted view is
        available.  A no-op if no such view exists.

        Args:
            pivot_view_id: The unique identifier of the pivot view
            timeout: Override the default request timeout (seconds).

        Returns:
            BaseResponseString

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 423, 429, 500).
        """
        response = await self._client.request_async(
            "DELETE",
            self._api,
            "/api/v1/pivotview/{pivotViewId}",
            path_params={
                "pivotViewId": pivot_view_id,
            },
            timeout=timeout,
        )
        return BaseResponseString.model_validate(response.json())

    def update_pivot_view(
        self,
        *,
        pivot_view_id: str,
        body: PivotViewDto,
        timeout: Optional[float] = None,
    ) -> BaseResponsePivotViewDto:
        """Update a single pivot view

        Updates the view that matches the provided ID with the details provided
        in the
        body. The associated query can't be updated, so providing the query ID
        has no effect.

        Args:
            pivot_view_id: The unique identifier of the pivot view
            body: Request body.
            timeout: Override the default request timeout (seconds).

        Returns:
            BaseResponsePivotViewDto

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 423, 429, 500).
        """
        response = self._client.request(
            "PUT",
            self._api,
            "/api/v1/pivotview/{pivotViewId}",
            path_params={
                "pivotViewId": pivot_view_id,
            },
            json_body=body,
            timeout=timeout,
        )
        return BaseResponsePivotViewDto.model_validate(response.json())

    async def update_pivot_view_async(
        self,
        *,
        pivot_view_id: str,
        body: PivotViewDto,
        timeout: Optional[float] = None,
    ) -> BaseResponsePivotViewDto:
        """Update a single pivot view (async)

        Updates the view that matches the provided ID with the details provided
        in the
        body. The associated query can't be updated, so providing the query ID
        has no effect.

        Args:
            pivot_view_id: The unique identifier of the pivot view
            body: Request body.
            timeout: Override the default request timeout (seconds).

        Returns:
            BaseResponsePivotViewDto

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 423, 429, 500).
        """
        response = await self._client.request_async(
            "PUT",
            self._api,
            "/api/v1/pivotview/{pivotViewId}",
            path_params={
                "pivotViewId": pivot_view_id,
            },
            json_body=body,
            timeout=timeout,
        )
        return BaseResponsePivotViewDto.model_validate(response.json())

    def list_queries(
        self,
        *,
        limit: Optional[int] = 1000,
        offset: Optional[int] = None,
        ids: Optional[list[str]] = None,
        timeout: Optional[float] = None,
    ) -> PagedResponseQueryDto:
        """Retrieve list of queries

        Returns a list of all non-temporary queries associated with the
        workspace. By default, these queries are ordered by their names, in
        ascending order.

        Args:
            limit: The number of queries to return, from 1 to 1000; by default, 1000
            offset: The item to start with on the page, greater than or equal to 0; by default, 0
            ids: A list of ids to filter the returned list by
            timeout: Override the default request timeout (seconds).

        Returns:
            PagedResponseQueryDto

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 423, 429, 500).
        """

        def _fetch(_cursor: str | None) -> httpx.Response:
            return self._client.request(
                "GET",
                self._api,
                "/api/v1/query",
                query_params={
                    "limit": limit,
                    "offset": offset,
                    "ids": ids,
                    "cursor": _cursor,
                },
                timeout=timeout,
            )

        _body = paginate_all(_fetch, extract_wdata_cursor, "body")
        return PagedResponseQueryDto.model_validate(_body)

    async def list_queries_async(
        self,
        *,
        limit: Optional[int] = 1000,
        offset: Optional[int] = None,
        ids: Optional[list[str]] = None,
        timeout: Optional[float] = None,
    ) -> PagedResponseQueryDto:
        """Retrieve list of queries (async)

        Returns a list of all non-temporary queries associated with the
        workspace. By default, these queries are ordered by their names, in
        ascending order.

        Args:
            limit: The number of queries to return, from 1 to 1000; by default, 1000
            offset: The item to start with on the page, greater than or equal to 0; by default, 0
            ids: A list of ids to filter the returned list by
            timeout: Override the default request timeout (seconds).

        Returns:
            PagedResponseQueryDto

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 423, 429, 500).
        """

        async def _fetch(_cursor: str | None) -> httpx.Response:
            return await self._client.request_async(
                "GET",
                self._api,
                "/api/v1/query",
                query_params={
                    "limit": limit,
                    "offset": offset,
                    "ids": ids,
                    "cursor": _cursor,
                },
                timeout=timeout,
            )

        _body = await paginate_all_async(_fetch, extract_wdata_cursor, "body")
        return PagedResponseQueryDto.model_validate(_body)

    def create_query(
        self,
        *,
        body: QueryDto,
        timeout: Optional[float] = None,
    ) -> BaseResponseQueryDto:
        """Create a new query

        Creates a query object and validates full permissions to ensure the
        requestor has
        access to all data sources being queried. This endpoint _doesn't_
        execute the query;
        to execute, call the POST /queryresult method.

        Returns:
            BaseResponseQueryDto

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 423, 429, 500).
        """
        response = self._client.request(
            "POST",
            self._api,
            "/api/v1/query",
            json_body=body,
            timeout=timeout,
        )
        return BaseResponseQueryDto.model_validate(response.json())

    async def create_query_async(
        self,
        *,
        body: QueryDto,
        timeout: Optional[float] = None,
    ) -> BaseResponseQueryDto:
        """Create a new query (async)

        Creates a query object and validates full permissions to ensure the
        requestor has
        access to all data sources being queried. This endpoint _doesn't_
        execute the query;
        to execute, call the POST /queryresult method.

        Returns:
            BaseResponseQueryDto

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 423, 429, 500).
        """
        response = await self._client.request_async(
            "POST",
            self._api,
            "/api/v1/query",
            json_body=body,
            timeout=timeout,
        )
        return BaseResponseQueryDto.model_validate(response.json())

    def get_query_column_data(
        self,
        *,
        body: QueryTextDto,
        timeout: Optional[float] = None,
    ) -> BaseResponseQueryColumnDataDto:
        """Retrieve query column data

        Returns a QueryColumnDataDto representing the column data for the given
        query text.
        If the query isn't valid, returns a 400.

        Returns:
            BaseResponseQueryColumnDataDto

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 423, 429, 500).
        """
        response = self._client.request(
            "POST",
            self._api,
            "/api/v1/query/data",
            json_body=body,
            timeout=timeout,
        )
        return BaseResponseQueryColumnDataDto.model_validate(response.json())

    async def get_query_column_data_async(
        self,
        *,
        body: QueryTextDto,
        timeout: Optional[float] = None,
    ) -> BaseResponseQueryColumnDataDto:
        """Retrieve query column data (async)

        Returns a QueryColumnDataDto representing the column data for the given
        query text.
        If the query isn't valid, returns a 400.

        Returns:
            BaseResponseQueryColumnDataDto

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 423, 429, 500).
        """
        response = await self._client.request_async(
            "POST",
            self._api,
            "/api/v1/query/data",
            json_body=body,
            timeout=timeout,
        )
        return BaseResponseQueryColumnDataDto.model_validate(response.json())

    def is_query_valid(
        self,
        *,
        body: QueryDto,
        timeout: Optional[float] = None,
    ) -> BaseResponseQueryDto:
        """Parses the query to determine if it is valid

        Returns the provided QueryDto

        Returns:
            BaseResponseQueryDto

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 423, 429, 500).
        """
        response = self._client.request(
            "POST",
            self._api,
            "/api/v1/query/validation",
            json_body=body,
            timeout=timeout,
        )
        return BaseResponseQueryDto.model_validate(response.json())

    async def is_query_valid_async(
        self,
        *,
        body: QueryDto,
        timeout: Optional[float] = None,
    ) -> BaseResponseQueryDto:
        """Parses the query to determine if it is valid (async)

        Returns the provided QueryDto

        Returns:
            BaseResponseQueryDto

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 423, 429, 500).
        """
        response = await self._client.request_async(
            "POST",
            self._api,
            "/api/v1/query/validation",
            json_body=body,
            timeout=timeout,
        )
        return BaseResponseQueryDto.model_validate(response.json())

    def get_query(
        self,
        *,
        query_id: str,
        timeout: Optional[float] = None,
    ) -> BaseResponseQueryDto:
        """Retrieve a single query

        Returns a query that matches the provided ID, or a 404 if no matching
        query is found.

        Args:
            query_id: The unique identifier of the query
            timeout: Override the default request timeout (seconds).

        Returns:
            BaseResponseQueryDto

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 423, 429, 500).
        """
        response = self._client.request(
            "GET",
            self._api,
            "/api/v1/query/{queryId}",
            path_params={
                "queryId": query_id,
            },
            timeout=timeout,
        )
        return BaseResponseQueryDto.model_validate(response.json())

    async def get_query_async(
        self,
        *,
        query_id: str,
        timeout: Optional[float] = None,
    ) -> BaseResponseQueryDto:
        """Retrieve a single query (async)

        Returns a query that matches the provided ID, or a 404 if no matching
        query is found.

        Args:
            query_id: The unique identifier of the query
            timeout: Override the default request timeout (seconds).

        Returns:
            BaseResponseQueryDto

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 423, 429, 500).
        """
        response = await self._client.request_async(
            "GET",
            self._api,
            "/api/v1/query/{queryId}",
            path_params={
                "queryId": query_id,
            },
            timeout=timeout,
        )
        return BaseResponseQueryDto.model_validate(response.json())

    def delete_query(
        self,
        *,
        query_id: str,
        timeout: Optional[float] = None,
    ) -> BaseResponseString:
        """Delete a single query

        Deletes the query that matches the provided ID. If no such query is
        found, this is
        a no-op.

        Args:
            query_id: The unique identifier of the query
            timeout: Override the default request timeout (seconds).

        Returns:
            BaseResponseString

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 423, 429, 500).
        """
        response = self._client.request(
            "DELETE",
            self._api,
            "/api/v1/query/{queryId}",
            path_params={
                "queryId": query_id,
            },
            timeout=timeout,
        )
        return BaseResponseString.model_validate(response.json())

    async def delete_query_async(
        self,
        *,
        query_id: str,
        timeout: Optional[float] = None,
    ) -> BaseResponseString:
        """Delete a single query (async)

        Deletes the query that matches the provided ID. If no such query is
        found, this is
        a no-op.

        Args:
            query_id: The unique identifier of the query
            timeout: Override the default request timeout (seconds).

        Returns:
            BaseResponseString

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 423, 429, 500).
        """
        response = await self._client.request_async(
            "DELETE",
            self._api,
            "/api/v1/query/{queryId}",
            path_params={
                "queryId": query_id,
            },
            timeout=timeout,
        )
        return BaseResponseString.model_validate(response.json())

    def update_query(
        self,
        *,
        query_id: str,
        body: QueryDto,
        timeout: Optional[float] = None,
    ) -> BaseResponseQueryDto:
        """Update a single query

        Updates the query that matches the provided ID with the details provided
        in the
        body.

        Args:
            query_id: The unique identifier of the query
            body: Request body.
            timeout: Override the default request timeout (seconds).

        Returns:
            BaseResponseQueryDto

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 423, 429, 500).
        """
        response = self._client.request(
            "PUT",
            self._api,
            "/api/v1/query/{queryId}",
            path_params={
                "queryId": query_id,
            },
            json_body=body,
            timeout=timeout,
        )
        return BaseResponseQueryDto.model_validate(response.json())

    async def update_query_async(
        self,
        *,
        query_id: str,
        body: QueryDto,
        timeout: Optional[float] = None,
    ) -> BaseResponseQueryDto:
        """Update a single query (async)

        Updates the query that matches the provided ID with the details provided
        in the
        body.

        Args:
            query_id: The unique identifier of the query
            body: Request body.
            timeout: Override the default request timeout (seconds).

        Returns:
            BaseResponseQueryDto

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 423, 429, 500).
        """
        response = await self._client.request_async(
            "PUT",
            self._api,
            "/api/v1/query/{queryId}",
            path_params={
                "queryId": query_id,
            },
            json_body=body,
            timeout=timeout,
        )
        return BaseResponseQueryDto.model_validate(response.json())

    def get_dependencies(
        self,
        *,
        query_id: str,
        limit: Optional[int] = 1000,
        offset: Optional[int] = None,
        timeout: Optional[float] = None,
    ) -> PagedResponseTableDto:
        """Retrieve dependencies

        Returns an unordered collection of all tables the matching query uses as
        datasources, including any shared tables outside of this OAuth token's
        workspace. The endpoint verifies the user has read permissions on the
        query, but _not_ on the tables returned.

        Args:
            query_id: The unique identifier of the query
            limit: The number of dependencies to return, from 1 to 1000; by default, 1000
            offset: The item to start with on the page, greater than or equal to 0; by default, 0
            timeout: Override the default request timeout (seconds).

        Returns:
            PagedResponseTableDto

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 423, 429, 500).
        """

        def _fetch(_cursor: str | None) -> httpx.Response:
            return self._client.request(
                "GET",
                self._api,
                "/api/v1/query/{queryId}/dependencies",
                path_params={
                    "queryId": query_id,
                },
                query_params={
                    "limit": limit,
                    "offset": offset,
                    "cursor": _cursor,
                },
                timeout=timeout,
            )

        _body = paginate_all(_fetch, extract_wdata_cursor, "body")
        return PagedResponseTableDto.model_validate(_body)

    async def get_dependencies_async(
        self,
        *,
        query_id: str,
        limit: Optional[int] = 1000,
        offset: Optional[int] = None,
        timeout: Optional[float] = None,
    ) -> PagedResponseTableDto:
        """Retrieve dependencies (async)

        Returns an unordered collection of all tables the matching query uses as
        datasources, including any shared tables outside of this OAuth token's
        workspace. The endpoint verifies the user has read permissions on the
        query, but _not_ on the tables returned.

        Args:
            query_id: The unique identifier of the query
            limit: The number of dependencies to return, from 1 to 1000; by default, 1000
            offset: The item to start with on the page, greater than or equal to 0; by default, 0
            timeout: Override the default request timeout (seconds).

        Returns:
            PagedResponseTableDto

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 423, 429, 500).
        """

        async def _fetch(_cursor: str | None) -> httpx.Response:
            return await self._client.request_async(
                "GET",
                self._api,
                "/api/v1/query/{queryId}/dependencies",
                path_params={
                    "queryId": query_id,
                },
                query_params={
                    "limit": limit,
                    "offset": offset,
                    "cursor": _cursor,
                },
                timeout=timeout,
            )

        _body = await paginate_all_async(_fetch, extract_wdata_cursor, "body")
        return PagedResponseTableDto.model_validate(_body)

    def get_tables_dependent_on_query(
        self,
        *,
        query_id: str,
        limit: Optional[int] = 1000,
        offset: Optional[int] = None,
        timeout: Optional[float] = None,
    ) -> PagedResponseTableDto:
        """Retrieve a list of dependents

        Returns a list of all tables that use the query with provided ID as a
        datasource.

        Args:
            query_id: The unique identifier of the query
            limit: The number of folders to return, from 1 to 1000; by default, 1000
            offset: The item to start with on the page, greater than or equal to 0; by default, 0
            timeout: Override the default request timeout (seconds).

        Returns:
            PagedResponseTableDto

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 423, 429, 500).
        """

        def _fetch(_cursor: str | None) -> httpx.Response:
            return self._client.request(
                "GET",
                self._api,
                "/api/v1/query/{queryId}/dependents",
                path_params={
                    "queryId": query_id,
                },
                query_params={
                    "limit": limit,
                    "offset": offset,
                    "cursor": _cursor,
                },
                timeout=timeout,
            )

        _body = paginate_all(_fetch, extract_wdata_cursor, "body")
        return PagedResponseTableDto.model_validate(_body)

    async def get_tables_dependent_on_query_async(
        self,
        *,
        query_id: str,
        limit: Optional[int] = 1000,
        offset: Optional[int] = None,
        timeout: Optional[float] = None,
    ) -> PagedResponseTableDto:
        """Retrieve a list of dependents (async)

        Returns a list of all tables that use the query with provided ID as a
        datasource.

        Args:
            query_id: The unique identifier of the query
            limit: The number of folders to return, from 1 to 1000; by default, 1000
            offset: The item to start with on the page, greater than or equal to 0; by default, 0
            timeout: Override the default request timeout (seconds).

        Returns:
            PagedResponseTableDto

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 423, 429, 500).
        """

        async def _fetch(_cursor: str | None) -> httpx.Response:
            return await self._client.request_async(
                "GET",
                self._api,
                "/api/v1/query/{queryId}/dependents",
                path_params={
                    "queryId": query_id,
                },
                query_params={
                    "limit": limit,
                    "offset": offset,
                    "cursor": _cursor,
                },
                timeout=timeout,
            )

        _body = await paginate_all_async(_fetch, extract_wdata_cursor, "body")
        return PagedResponseTableDto.model_validate(_body)

    def describe_query(
        self,
        *,
        query_id: str,
        timeout: Optional[float] = None,
    ) -> BaseResponseDescribeQueryResponseDto:
        """List the output columns of a query

        List the output columns of a query, including the column name (or
        alias), catalog, schema,
        table, type, type size in bytes, and a boolean indicating if the column
        is aliased.

        Args:
            query_id: The unique identifier of the query
            timeout: Override the default request timeout (seconds).

        Returns:
            BaseResponseDescribeQueryResponseDto

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 423, 429, 500).
        """
        response = self._client.request(
            "POST",
            self._api,
            "/api/v1/query/{queryId}/describe",
            path_params={
                "queryId": query_id,
            },
            timeout=timeout,
        )
        return BaseResponseDescribeQueryResponseDto.model_validate(response.json())

    async def describe_query_async(
        self,
        *,
        query_id: str,
        timeout: Optional[float] = None,
    ) -> BaseResponseDescribeQueryResponseDto:
        """List the output columns of a query (async)

        List the output columns of a query, including the column name (or
        alias), catalog, schema,
        table, type, type size in bytes, and a boolean indicating if the column
        is aliased.

        Args:
            query_id: The unique identifier of the query
            timeout: Override the default request timeout (seconds).

        Returns:
            BaseResponseDescribeQueryResponseDto

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 423, 429, 500).
        """
        response = await self._client.request_async(
            "POST",
            self._api,
            "/api/v1/query/{queryId}/describe",
            path_params={
                "queryId": query_id,
            },
            timeout=timeout,
        )
        return BaseResponseDescribeQueryResponseDto.model_validate(response.json())

    def list_query_results(
        self,
        *,
        query_id: str,
        user_specific: Optional[bool] = False,
        limit: Optional[str] = None,
        offset: Optional[int] = 0,
        timeout: Optional[float] = None,
    ) -> PagedResponseQueryResultDto:
        """Retrieve a list of query results

        Returns a paged list of query results that match the provided query ID,
        or an empty
        list if no matching query is found.

        Args:
            query_id: The unique identifier of the query
            user_specific: Limit results to those created by the current user
            limit: The number of query results to return, from 1 to 1000; by default, 1000
            offset: The item to start with on the page, greater than or equal to 0; by default, 0
            timeout: Override the default request timeout (seconds).

        Returns:
            PagedResponseQueryResultDto

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 423, 429, 500).
        """

        def _fetch(_cursor: str | None) -> httpx.Response:
            return self._client.request(
                "GET",
                self._api,
                "/api/v1/queryresult",
                query_params={
                    "queryId": query_id,
                    "userSpecific": user_specific,
                    "limit": limit,
                    "offset": offset,
                    "cursor": _cursor,
                },
                timeout=timeout,
            )

        _body = paginate_all(_fetch, extract_wdata_cursor, "body")
        return PagedResponseQueryResultDto.model_validate(_body)

    async def list_query_results_async(
        self,
        *,
        query_id: str,
        user_specific: Optional[bool] = False,
        limit: Optional[str] = None,
        offset: Optional[int] = 0,
        timeout: Optional[float] = None,
    ) -> PagedResponseQueryResultDto:
        """Retrieve a list of query results (async)

        Returns a paged list of query results that match the provided query ID,
        or an empty
        list if no matching query is found.

        Args:
            query_id: The unique identifier of the query
            user_specific: Limit results to those created by the current user
            limit: The number of query results to return, from 1 to 1000; by default, 1000
            offset: The item to start with on the page, greater than or equal to 0; by default, 0
            timeout: Override the default request timeout (seconds).

        Returns:
            PagedResponseQueryResultDto

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 423, 429, 500).
        """

        async def _fetch(_cursor: str | None) -> httpx.Response:
            return await self._client.request_async(
                "GET",
                self._api,
                "/api/v1/queryresult",
                query_params={
                    "queryId": query_id,
                    "userSpecific": user_specific,
                    "limit": limit,
                    "offset": offset,
                    "cursor": _cursor,
                },
                timeout=timeout,
            )

        _body = await paginate_all_async(_fetch, extract_wdata_cursor, "body")
        return PagedResponseQueryResultDto.model_validate(_body)

    def run_query(
        self,
        *,
        body: QueryResultDto,
        timeout: Optional[float] = None,
    ) -> BaseResponseQueryResultDto:
        """Execute a query

        Runs a query and immediately returns a query result entity, which has an
        ID that
        can be used to poll the status from the GET /queryresult method. A
        status of
        COMPLETED or ERROR indicates the query has completed.

        Returns:
            BaseResponseQueryResultDto

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 423, 429, 500).
        """
        response = self._client.request(
            "POST",
            self._api,
            "/api/v1/queryresult",
            json_body=body,
            timeout=timeout,
        )
        return BaseResponseQueryResultDto.model_validate(response.json())

    async def run_query_async(
        self,
        *,
        body: QueryResultDto,
        timeout: Optional[float] = None,
    ) -> BaseResponseQueryResultDto:
        """Execute a query (async)

        Runs a query and immediately returns a query result entity, which has an
        ID that
        can be used to poll the status from the GET /queryresult method. A
        status of
        COMPLETED or ERROR indicates the query has completed.

        Returns:
            BaseResponseQueryResultDto

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 423, 429, 500).
        """
        response = await self._client.request_async(
            "POST",
            self._api,
            "/api/v1/queryresult",
            json_body=body,
            timeout=timeout,
        )
        return BaseResponseQueryResultDto.model_validate(response.json())

    def get_query_result(
        self,
        *,
        query_result_id: str,
        timeout: Optional[float] = None,
    ) -> BaseResponseQueryResultDto:
        """Retrieve a single query result

        Returns a single query result that matches the provided ID, or a 404 if
        no such
        query result is found.

        Args:
            query_result_id: The unique identifier of the query result
            timeout: Override the default request timeout (seconds).

        Returns:
            BaseResponseQueryResultDto

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 423, 429, 500).
        """
        response = self._client.request(
            "GET",
            self._api,
            "/api/v1/queryresult/{queryResultId}",
            path_params={
                "queryResultId": query_result_id,
            },
            timeout=timeout,
        )
        return BaseResponseQueryResultDto.model_validate(response.json())

    async def get_query_result_async(
        self,
        *,
        query_result_id: str,
        timeout: Optional[float] = None,
    ) -> BaseResponseQueryResultDto:
        """Retrieve a single query result (async)

        Returns a single query result that matches the provided ID, or a 404 if
        no such
        query result is found.

        Args:
            query_result_id: The unique identifier of the query result
            timeout: Override the default request timeout (seconds).

        Returns:
            BaseResponseQueryResultDto

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 423, 429, 500).
        """
        response = await self._client.request_async(
            "GET",
            self._api,
            "/api/v1/queryresult/{queryResultId}",
            path_params={
                "queryResultId": query_result_id,
            },
            timeout=timeout,
        )
        return BaseResponseQueryResultDto.model_validate(response.json())

    def cancel_query(
        self,
        *,
        query_result_id: str,
        timeout: Optional[float] = None,
    ) -> BaseResponseQueryResultDto:
        """Cancel a running query

        Cancels a running query based on the provided result ID, and returns a
        cancelled
        result unless the query's already in a COMPLETED state.

        Args:
            query_result_id: The unique identifier of the query result
            timeout: Override the default request timeout (seconds).

        Returns:
            BaseResponseQueryResultDto

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 423, 429, 500).
        """
        response = self._client.request(
            "DELETE",
            self._api,
            "/api/v1/queryresult/{queryResultId}",
            path_params={
                "queryResultId": query_result_id,
            },
            timeout=timeout,
        )
        return BaseResponseQueryResultDto.model_validate(response.json())

    async def cancel_query_async(
        self,
        *,
        query_result_id: str,
        timeout: Optional[float] = None,
    ) -> BaseResponseQueryResultDto:
        """Cancel a running query (async)

        Cancels a running query based on the provided result ID, and returns a
        cancelled
        result unless the query's already in a COMPLETED state.

        Args:
            query_result_id: The unique identifier of the query result
            timeout: Override the default request timeout (seconds).

        Returns:
            BaseResponseQueryResultDto

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 423, 429, 500).
        """
        response = await self._client.request_async(
            "DELETE",
            self._api,
            "/api/v1/queryresult/{queryResultId}",
            path_params={
                "queryResultId": query_result_id,
            },
            timeout=timeout,
        )
        return BaseResponseQueryResultDto.model_validate(response.json())

    def download_query_result(
        self,
        *,
        query_result_id: str,
        timeout: Optional[float] = None,
    ) -> httpx.Response:
        """Download a query result

        Uses the Token Management API to create a token with the query result
        ID, which it
        then uses to download a CSV file of the query results.

        Args:
            query_result_id: The unique identifier of the query result
            timeout: Override the default request timeout (seconds).

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 423, 429, 500).
        """
        return self._client.request(
            "GET",
            self._api,
            "/api/v1/queryresult/{queryResultId}/download",
            path_params={
                "queryResultId": query_result_id,
            },
            timeout=timeout,
        )

    async def download_query_result_async(
        self,
        *,
        query_result_id: str,
        timeout: Optional[float] = None,
    ) -> httpx.Response:
        """Download a query result (async)

        Uses the Token Management API to create a token with the query result
        ID, which it
        then uses to download a CSV file of the query results.

        Args:
            query_result_id: The unique identifier of the query result
            timeout: Override the default request timeout (seconds).

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 423, 429, 500).
        """
        return await self._client.request_async(
            "GET",
            self._api,
            "/api/v1/queryresult/{queryResultId}/download",
            path_params={
                "queryResultId": query_result_id,
            },
            timeout=timeout,
        )

    def export_query_result_to_spreadsheets(
        self,
        *,
        query_result_id: str,
        body: ExportQueryResultDto,
        timeout: Optional[float] = None,
    ) -> BaseResponseString:
        """Export query result to spreadsheets

        Exports a query result with the provided ID to Spreadsheets. To
        determine where to
        export the results, the request body should include a URL copied and
        pasted from the
        Spreadsheets UI. Returns a 404 if no matching query result is found.

        Args:
            query_result_id: The unique identifier of the query result
            body: Request body.
            timeout: Override the default request timeout (seconds).

        Returns:
            BaseResponseString

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 423, 429, 500).
        """
        response = self._client.request(
            "POST",
            self._api,
            "/api/v1/queryresult/{queryResultId}/export",
            path_params={
                "queryResultId": query_result_id,
            },
            json_body=body,
            timeout=timeout,
        )
        return BaseResponseString.model_validate(response.json())

    async def export_query_result_to_spreadsheets_async(
        self,
        *,
        query_result_id: str,
        body: ExportQueryResultDto,
        timeout: Optional[float] = None,
    ) -> BaseResponseString:
        """Export query result to spreadsheets (async)

        Exports a query result with the provided ID to Spreadsheets. To
        determine where to
        export the results, the request body should include a URL copied and
        pasted from the
        Spreadsheets UI. Returns a 404 if no matching query result is found.

        Args:
            query_result_id: The unique identifier of the query result
            body: Request body.
            timeout: Override the default request timeout (seconds).

        Returns:
            BaseResponseString

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 423, 429, 500).
        """
        response = await self._client.request_async(
            "POST",
            self._api,
            "/api/v1/queryresult/{queryResultId}/export",
            path_params={
                "queryResultId": query_result_id,
            },
            json_body=body,
            timeout=timeout,
        )
        return BaseResponseString.model_validate(response.json())

    def list_select_lists(
        self,
        *,
        limit: Optional[int] = None,
        offset: Optional[int] = None,
        timeout: Optional[float] = None,
    ) -> PagedResponseSelectListDto:
        """Retrieve a list of select lists

        Returns a list of select lists associated with the workspace.

        Args:
            limit: The number of select lists to return, from 1 to 1000; by default, 1000
            offset: The item to start with on the page, greater than or equal to 0; by default, 0
            timeout: Override the default request timeout (seconds).

        Returns:
            PagedResponseSelectListDto

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 423, 429, 500).
        """

        def _fetch(_cursor: str | None) -> httpx.Response:
            return self._client.request(
                "GET",
                self._api,
                "/api/v1/selectlist",
                query_params={
                    "limit": limit,
                    "offset": offset,
                    "cursor": _cursor,
                },
                timeout=timeout,
            )

        _body = paginate_all(_fetch, extract_wdata_cursor, "body")
        return PagedResponseSelectListDto.model_validate(_body)

    async def list_select_lists_async(
        self,
        *,
        limit: Optional[int] = None,
        offset: Optional[int] = None,
        timeout: Optional[float] = None,
    ) -> PagedResponseSelectListDto:
        """Retrieve a list of select lists (async)

        Returns a list of select lists associated with the workspace.

        Args:
            limit: The number of select lists to return, from 1 to 1000; by default, 1000
            offset: The item to start with on the page, greater than or equal to 0; by default, 0
            timeout: Override the default request timeout (seconds).

        Returns:
            PagedResponseSelectListDto

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 423, 429, 500).
        """

        async def _fetch(_cursor: str | None) -> httpx.Response:
            return await self._client.request_async(
                "GET",
                self._api,
                "/api/v1/selectlist",
                query_params={
                    "limit": limit,
                    "offset": offset,
                    "cursor": _cursor,
                },
                timeout=timeout,
            )

        _body = await paginate_all_async(_fetch, extract_wdata_cursor, "body")
        return PagedResponseSelectListDto.model_validate(_body)

    def create_select_list(
        self,
        *,
        body: SelectListDto,
        timeout: Optional[float] = None,
    ) -> BaseResponseSelectListDto:
        """Create a new select list

        Creates a select list using the provided information and returns the
        select list meta.

        Returns:
            BaseResponseSelectListDto

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 423, 429, 500).
        """
        response = self._client.request(
            "POST",
            self._api,
            "/api/v1/selectlist",
            json_body=body,
            timeout=timeout,
        )
        return BaseResponseSelectListDto.model_validate(response.json())

    async def create_select_list_async(
        self,
        *,
        body: SelectListDto,
        timeout: Optional[float] = None,
    ) -> BaseResponseSelectListDto:
        """Create a new select list (async)

        Creates a select list using the provided information and returns the
        select list meta.

        Returns:
            BaseResponseSelectListDto

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 423, 429, 500).
        """
        response = await self._client.request_async(
            "POST",
            self._api,
            "/api/v1/selectlist",
            json_body=body,
            timeout=timeout,
        )
        return BaseResponseSelectListDto.model_validate(response.json())

    def get_select_list(
        self,
        *,
        select_list_id: str,
        timeout: Optional[float] = None,
    ) -> BaseResponseSelectListDto:
        """Retrieve a single select list

        Returns a select list that matches the provided ID, or a 404 if no
        matching select
        list is found.

        Args:
            select_list_id: The unique identifier of the select list
            timeout: Override the default request timeout (seconds).

        Returns:
            BaseResponseSelectListDto

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 423, 429, 500).
        """
        response = self._client.request(
            "GET",
            self._api,
            "/api/v1/selectlist/{selectListId}",
            path_params={
                "selectListId": select_list_id,
            },
            timeout=timeout,
        )
        return BaseResponseSelectListDto.model_validate(response.json())

    async def get_select_list_async(
        self,
        *,
        select_list_id: str,
        timeout: Optional[float] = None,
    ) -> BaseResponseSelectListDto:
        """Retrieve a single select list (async)

        Returns a select list that matches the provided ID, or a 404 if no
        matching select
        list is found.

        Args:
            select_list_id: The unique identifier of the select list
            timeout: Override the default request timeout (seconds).

        Returns:
            BaseResponseSelectListDto

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 423, 429, 500).
        """
        response = await self._client.request_async(
            "GET",
            self._api,
            "/api/v1/selectlist/{selectListId}",
            path_params={
                "selectListId": select_list_id,
            },
            timeout=timeout,
        )
        return BaseResponseSelectListDto.model_validate(response.json())

    def delete(
        self,
        *,
        select_list_id: str,
        timeout: Optional[float] = None,
    ) -> BaseResponseString:
        """Delete a single select list

        Deletes a select list with the provided ID. If no such select list
        exists, this is
        a no-op.

        Args:
            select_list_id: The unique identifier of the select list
            timeout: Override the default request timeout (seconds).

        Returns:
            BaseResponseString

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 423, 429, 500).
        """
        response = self._client.request(
            "DELETE",
            self._api,
            "/api/v1/selectlist/{selectListId}",
            path_params={
                "selectListId": select_list_id,
            },
            timeout=timeout,
        )
        return BaseResponseString.model_validate(response.json())

    async def delete_async(
        self,
        *,
        select_list_id: str,
        timeout: Optional[float] = None,
    ) -> BaseResponseString:
        """Delete a single select list (async)

        Deletes a select list with the provided ID. If no such select list
        exists, this is
        a no-op.

        Args:
            select_list_id: The unique identifier of the select list
            timeout: Override the default request timeout (seconds).

        Returns:
            BaseResponseString

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 423, 429, 500).
        """
        response = await self._client.request_async(
            "DELETE",
            self._api,
            "/api/v1/selectlist/{selectListId}",
            path_params={
                "selectListId": select_list_id,
            },
            timeout=timeout,
        )
        return BaseResponseString.model_validate(response.json())

    def update_select_list(
        self,
        *,
        select_list_id: str,
        body: SelectListDto,
        timeout: Optional[float] = None,
    ) -> BaseResponseSelectListDto:
        """Update a single select list

        Updates the select list with the provided ID with the details provided
        in the
        body.

        Args:
            select_list_id: The unique identifier of the select list
            body: Request body.
            timeout: Override the default request timeout (seconds).

        Returns:
            BaseResponseSelectListDto

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 423, 429, 500).
        """
        response = self._client.request(
            "PUT",
            self._api,
            "/api/v1/selectlist/{selectListId}",
            path_params={
                "selectListId": select_list_id,
            },
            json_body=body,
            timeout=timeout,
        )
        return BaseResponseSelectListDto.model_validate(response.json())

    async def update_select_list_async(
        self,
        *,
        select_list_id: str,
        body: SelectListDto,
        timeout: Optional[float] = None,
    ) -> BaseResponseSelectListDto:
        """Update a single select list (async)

        Updates the select list with the provided ID with the details provided
        in the
        body.

        Args:
            select_list_id: The unique identifier of the select list
            body: Request body.
            timeout: Override the default request timeout (seconds).

        Returns:
            BaseResponseSelectListDto

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 423, 429, 500).
        """
        response = await self._client.request_async(
            "PUT",
            self._api,
            "/api/v1/selectlist/{selectListId}",
            path_params={
                "selectListId": select_list_id,
            },
            json_body=body,
            timeout=timeout,
        )
        return BaseResponseSelectListDto.model_validate(response.json())

    def list_shared_tables(
        self,
        *,
        shared_with_me: Optional[bool] = None,
        table_id: Optional[str] = None,
        limit: Optional[int] = 1000,
        offset: Optional[int] = None,
        timeout: Optional[float] = None,
    ) -> PagedResponseSharedTableDto:
        """Retrieve a list of shared tables

                Returns a list of shared tables associated with the workspace of the
                request.

                Args:
                    shared_with_me: If true, returns a list of tables that have been shared _to_ it rather than
        from it. The entities contain both the shared table entity _and_ the table being
        shared. If true, `tableId` is ignored.
                    table_id: The unique table identifier associated with the shared table
                    limit: The number of shared files to return, from 1 to 1000; by default, 1000
                    offset: The item to start with on the page, greater than or equal to 0; by default, 0
                    timeout: Override the default request timeout (seconds).

                Returns:
                    PagedResponseSharedTableDto

                Raises:
                    WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 423, 429, 500).
        """

        def _fetch(_cursor: str | None) -> httpx.Response:
            return self._client.request(
                "GET",
                self._api,
                "/api/v1/sharedtable",
                query_params={
                    "sharedWithMe": shared_with_me,
                    "tableId": table_id,
                    "limit": limit,
                    "offset": offset,
                    "cursor": _cursor,
                },
                timeout=timeout,
            )

        _body = paginate_all(_fetch, extract_wdata_cursor, "body")
        return PagedResponseSharedTableDto.model_validate(_body)

    async def list_shared_tables_async(
        self,
        *,
        shared_with_me: Optional[bool] = None,
        table_id: Optional[str] = None,
        limit: Optional[int] = 1000,
        offset: Optional[int] = None,
        timeout: Optional[float] = None,
    ) -> PagedResponseSharedTableDto:
        """Retrieve a list of shared tables (async)

                Returns a list of shared tables associated with the workspace of the
                request.

                Args:
                    shared_with_me: If true, returns a list of tables that have been shared _to_ it rather than
        from it. The entities contain both the shared table entity _and_ the table being
        shared. If true, `tableId` is ignored.
                    table_id: The unique table identifier associated with the shared table
                    limit: The number of shared files to return, from 1 to 1000; by default, 1000
                    offset: The item to start with on the page, greater than or equal to 0; by default, 0
                    timeout: Override the default request timeout (seconds).

                Returns:
                    PagedResponseSharedTableDto

                Raises:
                    WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 423, 429, 500).
        """

        async def _fetch(_cursor: str | None) -> httpx.Response:
            return await self._client.request_async(
                "GET",
                self._api,
                "/api/v1/sharedtable",
                query_params={
                    "sharedWithMe": shared_with_me,
                    "tableId": table_id,
                    "limit": limit,
                    "offset": offset,
                    "cursor": _cursor,
                },
                timeout=timeout,
            )

        _body = await paginate_all_async(_fetch, extract_wdata_cursor, "body")
        return PagedResponseSharedTableDto.model_validate(_body)

    def create_shared_table(
        self,
        *,
        body: SharedTableDto,
        timeout: Optional[float] = None,
    ) -> BaseResponseSharedTableDto:
        """Create a new shared table

        Creates a shared table instance between the workspace of the request and
        the workspace provided in the body.

        Returns:
            BaseResponseSharedTableDto

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 423, 429, 500).
        """
        response = self._client.request(
            "POST",
            self._api,
            "/api/v1/sharedtable",
            json_body=body,
            timeout=timeout,
        )
        return BaseResponseSharedTableDto.model_validate(response.json())

    async def create_shared_table_async(
        self,
        *,
        body: SharedTableDto,
        timeout: Optional[float] = None,
    ) -> BaseResponseSharedTableDto:
        """Create a new shared table (async)

        Creates a shared table instance between the workspace of the request and
        the workspace provided in the body.

        Returns:
            BaseResponseSharedTableDto

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 423, 429, 500).
        """
        response = await self._client.request_async(
            "POST",
            self._api,
            "/api/v1/sharedtable",
            json_body=body,
            timeout=timeout,
        )
        return BaseResponseSharedTableDto.model_validate(response.json())

    def get_shared_table(
        self,
        *,
        shared_table_id: str,
        shared_with_me: Optional[bool] = None,
        timeout: Optional[float] = None,
    ) -> BaseResponseSharedTableDto:
        """Retrieve a single shared table

        Returns a shared table that matches the provided ID, or a 404 if no
        matching shared table is found.

        Args:
            shared_table_id: The unique identifier of the shared table
            shared_with_me: If true, returns a shared table with the provided ID that has been shared _to_—rather than from—the workspace of the request.
            timeout: Override the default request timeout (seconds).

        Returns:
            BaseResponseSharedTableDto

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 423, 429, 500).
        """
        response = self._client.request(
            "GET",
            self._api,
            "/api/v1/sharedtable/{sharedTableId}",
            path_params={
                "sharedTableId": shared_table_id,
            },
            query_params={
                "sharedWithMe": shared_with_me,
            },
            timeout=timeout,
        )
        return BaseResponseSharedTableDto.model_validate(response.json())

    async def get_shared_table_async(
        self,
        *,
        shared_table_id: str,
        shared_with_me: Optional[bool] = None,
        timeout: Optional[float] = None,
    ) -> BaseResponseSharedTableDto:
        """Retrieve a single shared table (async)

        Returns a shared table that matches the provided ID, or a 404 if no
        matching shared table is found.

        Args:
            shared_table_id: The unique identifier of the shared table
            shared_with_me: If true, returns a shared table with the provided ID that has been shared _to_—rather than from—the workspace of the request.
            timeout: Override the default request timeout (seconds).

        Returns:
            BaseResponseSharedTableDto

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 423, 429, 500).
        """
        response = await self._client.request_async(
            "GET",
            self._api,
            "/api/v1/sharedtable/{sharedTableId}",
            path_params={
                "sharedTableId": shared_table_id,
            },
            query_params={
                "sharedWithMe": shared_with_me,
            },
            timeout=timeout,
        )
        return BaseResponseSharedTableDto.model_validate(response.json())

    def delete_shared_table(
        self,
        *,
        shared_table_id: str,
        timeout: Optional[float] = None,
    ) -> BaseResponseString:
        """Delete a single shared table

        Deletes the linkages between the source and destination of a shared
        table that matches
        the provided ID; the actual table itself is left intact. If no such
        shared table exists,
        this is a no-op.

        Args:
            shared_table_id: The unique identifier of the shared table
            timeout: Override the default request timeout (seconds).

        Returns:
            BaseResponseString

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 423, 429, 500).
        """
        response = self._client.request(
            "DELETE",
            self._api,
            "/api/v1/sharedtable/{sharedTableId}",
            path_params={
                "sharedTableId": shared_table_id,
            },
            timeout=timeout,
        )
        return BaseResponseString.model_validate(response.json())

    async def delete_shared_table_async(
        self,
        *,
        shared_table_id: str,
        timeout: Optional[float] = None,
    ) -> BaseResponseString:
        """Delete a single shared table (async)

        Deletes the linkages between the source and destination of a shared
        table that matches
        the provided ID; the actual table itself is left intact. If no such
        shared table exists,
        this is a no-op.

        Args:
            shared_table_id: The unique identifier of the shared table
            timeout: Override the default request timeout (seconds).

        Returns:
            BaseResponseString

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 423, 429, 500).
        """
        response = await self._client.request_async(
            "DELETE",
            self._api,
            "/api/v1/sharedtable/{sharedTableId}",
            path_params={
                "sharedTableId": shared_table_id,
            },
            timeout=timeout,
        )
        return BaseResponseString.model_validate(response.json())

    def get_tables(
        self,
        *,
        include_shared: Optional[bool] = False,
        limit: Optional[int] = 1000,
        offset: Optional[int] = None,
        timeout: Optional[float] = None,
    ) -> PagedResponseTableDto:
        """Retrieve a list of tables

        Returns all tables available in the workspace.

        Args:
            include_shared: If true, returns all tables shared with the workspace associated with the request. If false, returns only tables the workspace owns.
            limit: the number of folders to return, from 1 to 1000; by default, 1000
            offset: The item to start with on the page, must be greater than or equal to 0, will default to 0
            timeout: Override the default request timeout (seconds).

        Returns:
            PagedResponseTableDto

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 423, 429, 500).
        """

        def _fetch(_cursor: str | None) -> httpx.Response:
            return self._client.request(
                "GET",
                self._api,
                "/api/v1/table",
                query_params={
                    "includeShared": include_shared,
                    "limit": limit,
                    "offset": offset,
                    "cursor": _cursor,
                },
                timeout=timeout,
            )

        _body = paginate_all(_fetch, extract_wdata_cursor, "body")
        return PagedResponseTableDto.model_validate(_body)

    async def get_tables_async(
        self,
        *,
        include_shared: Optional[bool] = False,
        limit: Optional[int] = 1000,
        offset: Optional[int] = None,
        timeout: Optional[float] = None,
    ) -> PagedResponseTableDto:
        """Retrieve a list of tables (async)

        Returns all tables available in the workspace.

        Args:
            include_shared: If true, returns all tables shared with the workspace associated with the request. If false, returns only tables the workspace owns.
            limit: the number of folders to return, from 1 to 1000; by default, 1000
            offset: The item to start with on the page, must be greater than or equal to 0, will default to 0
            timeout: Override the default request timeout (seconds).

        Returns:
            PagedResponseTableDto

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 423, 429, 500).
        """

        async def _fetch(_cursor: str | None) -> httpx.Response:
            return await self._client.request_async(
                "GET",
                self._api,
                "/api/v1/table",
                query_params={
                    "includeShared": include_shared,
                    "limit": limit,
                    "offset": offset,
                    "cursor": _cursor,
                },
                timeout=timeout,
            )

        _body = await paginate_all_async(_fetch, extract_wdata_cursor, "body")
        return PagedResponseTableDto.model_validate(_body)

    def create_table(
        self,
        *,
        body: TableDto,
        timeout: Optional[float] = None,
    ) -> BaseResponseTableDto:
        """Create a new table

        Creates a table in the database with the specified schema. For type,
        specify either a dimension or data table. In the interface, data tables
        appear as fact tables.

        Returns:
            BaseResponseTableDto

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 423, 429, 500).
        """
        response = self._client.request(
            "POST",
            self._api,
            "/api/v1/table",
            json_body=body,
            timeout=timeout,
        )
        return BaseResponseTableDto.model_validate(response.json())

    async def create_table_async(
        self,
        *,
        body: TableDto,
        timeout: Optional[float] = None,
    ) -> BaseResponseTableDto:
        """Create a new table (async)

        Creates a table in the database with the specified schema. For type,
        specify either a dimension or data table. In the interface, data tables
        appear as fact tables.

        Returns:
            BaseResponseTableDto

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 423, 429, 500).
        """
        response = await self._client.request_async(
            "POST",
            self._api,
            "/api/v1/table",
            json_body=body,
            timeout=timeout,
        )
        return BaseResponseTableDto.model_validate(response.json())

    def get_table(
        self,
        *,
        table_id: str,
        timeout: Optional[float] = None,
    ) -> BaseResponseTableDto:
        """Retrieve a single table

        Returns a table with the provided ID, or a 404 if no such table is
        found.

        Args:
            table_id: The unique identifier of the table
            timeout: Override the default request timeout (seconds).

        Returns:
            BaseResponseTableDto

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 423, 429, 500).
        """
        response = self._client.request(
            "GET",
            self._api,
            "/api/v1/table/{tableId}",
            path_params={
                "tableId": table_id,
            },
            timeout=timeout,
        )
        return BaseResponseTableDto.model_validate(response.json())

    async def get_table_async(
        self,
        *,
        table_id: str,
        timeout: Optional[float] = None,
    ) -> BaseResponseTableDto:
        """Retrieve a single table (async)

        Returns a table with the provided ID, or a 404 if no such table is
        found.

        Args:
            table_id: The unique identifier of the table
            timeout: Override the default request timeout (seconds).

        Returns:
            BaseResponseTableDto

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 423, 429, 500).
        """
        response = await self._client.request_async(
            "GET",
            self._api,
            "/api/v1/table/{tableId}",
            path_params={
                "tableId": table_id,
            },
            timeout=timeout,
        )
        return BaseResponseTableDto.model_validate(response.json())

    def delete_table(
        self,
        *,
        table_id: str,
        timeout: Optional[float] = None,
    ) -> BaseResponseString:
        """Delete a single table

        Soft-deletes the table with the provided ID.

        Args:
            table_id: The unique identifier of the table
            timeout: Override the default request timeout (seconds).

        Returns:
            BaseResponseString

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 423, 429, 500).
        """
        response = self._client.request(
            "DELETE",
            self._api,
            "/api/v1/table/{tableId}",
            path_params={
                "tableId": table_id,
            },
            timeout=timeout,
        )
        return BaseResponseString.model_validate(response.json())

    async def delete_table_async(
        self,
        *,
        table_id: str,
        timeout: Optional[float] = None,
    ) -> BaseResponseString:
        """Delete a single table (async)

        Soft-deletes the table with the provided ID.

        Args:
            table_id: The unique identifier of the table
            timeout: Override the default request timeout (seconds).

        Returns:
            BaseResponseString

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 423, 429, 500).
        """
        response = await self._client.request_async(
            "DELETE",
            self._api,
            "/api/v1/table/{tableId}",
            path_params={
                "tableId": table_id,
            },
            timeout=timeout,
        )
        return BaseResponseString.model_validate(response.json())

    def update_table(
        self,
        *,
        table_id: str,
        body: TableDto,
        timeout: Optional[float] = None,
    ) -> BaseResponseTableDto:
        """Update a single table

        Updates an existing table with the provided information. Include all
        user-defined
        table columns with the request. For type, specify either a dimension or
        data table.
        In the interface, data tables appear as fact tables.
        * If the table has no imported
        data, user-defined columns not included with the request are deleted,
        and columns are
        sorted according to their order in the request.
        * If the table has imported data,
        any columns with names not already in the table are considered new. This
        equality
        check is case-insensitive. Any new columns appear after other user-
        defined columns,
        but before any meta columns, which start with `_`.

        Args:
            table_id: The unique identifier of the table
            body: Request body.
            timeout: Override the default request timeout (seconds).

        Returns:
            BaseResponseTableDto

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 423, 429, 500).
        """
        response = self._client.request(
            "PUT",
            self._api,
            "/api/v1/table/{tableId}",
            path_params={
                "tableId": table_id,
            },
            json_body=body,
            timeout=timeout,
        )
        return BaseResponseTableDto.model_validate(response.json())

    async def update_table_async(
        self,
        *,
        table_id: str,
        body: TableDto,
        timeout: Optional[float] = None,
    ) -> BaseResponseTableDto:
        """Update a single table (async)

        Updates an existing table with the provided information. Include all
        user-defined
        table columns with the request. For type, specify either a dimension or
        data table.
        In the interface, data tables appear as fact tables.
        * If the table has no imported
        data, user-defined columns not included with the request are deleted,
        and columns are
        sorted according to their order in the request.
        * If the table has imported data,
        any columns with names not already in the table are considered new. This
        equality
        check is case-insensitive. Any new columns appear after other user-
        defined columns,
        but before any meta columns, which start with `_`.

        Args:
            table_id: The unique identifier of the table
            body: Request body.
            timeout: Override the default request timeout (seconds).

        Returns:
            BaseResponseTableDto

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 423, 429, 500).
        """
        response = await self._client.request_async(
            "PUT",
            self._api,
            "/api/v1/table/{tableId}",
            path_params={
                "tableId": table_id,
            },
            json_body=body,
            timeout=timeout,
        )
        return BaseResponseTableDto.model_validate(response.json())

    def get_dependents(
        self,
        *,
        table_id: str,
        limit: Optional[int] = 1000,
        offset: Optional[int] = None,
        timeout: Optional[float] = None,
    ) -> PagedResponseQueryDto:
        """Retrieve a list of dependents

        Returns a list of all queries that use the table with provided ID as a
        datasource.
        If a shared table, this may include queries outside of the current OAuth
        context.
        Permission is checked only for the table ID provided, _not_ on the
        returned list of
        queries.

        Args:
            table_id: The unique identifier of the table
            limit: The number of folders to return, from 1 to 1000; by default, 1000
            offset: The item to start with on the page, greater than or equal to 0; by default, 0
            timeout: Override the default request timeout (seconds).

        Returns:
            PagedResponseQueryDto

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 423, 429, 500).
        """

        def _fetch(_cursor: str | None) -> httpx.Response:
            return self._client.request(
                "GET",
                self._api,
                "/api/v1/table/{tableId}/dependents",
                path_params={
                    "tableId": table_id,
                },
                query_params={
                    "limit": limit,
                    "offset": offset,
                    "cursor": _cursor,
                },
                timeout=timeout,
            )

        _body = paginate_all(_fetch, extract_wdata_cursor, "body")
        return PagedResponseQueryDto.model_validate(_body)

    async def get_dependents_async(
        self,
        *,
        table_id: str,
        limit: Optional[int] = 1000,
        offset: Optional[int] = None,
        timeout: Optional[float] = None,
    ) -> PagedResponseQueryDto:
        """Retrieve a list of dependents (async)

        Returns a list of all queries that use the table with provided ID as a
        datasource.
        If a shared table, this may include queries outside of the current OAuth
        context.
        Permission is checked only for the table ID provided, _not_ on the
        returned list of
        queries.

        Args:
            table_id: The unique identifier of the table
            limit: The number of folders to return, from 1 to 1000; by default, 1000
            offset: The item to start with on the page, greater than or equal to 0; by default, 0
            timeout: Override the default request timeout (seconds).

        Returns:
            PagedResponseQueryDto

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 423, 429, 500).
        """

        async def _fetch(_cursor: str | None) -> httpx.Response:
            return await self._client.request_async(
                "GET",
                self._api,
                "/api/v1/table/{tableId}/dependents",
                path_params={
                    "tableId": table_id,
                },
                query_params={
                    "limit": limit,
                    "offset": offset,
                    "cursor": _cursor,
                },
                timeout=timeout,
            )

        _body = await paginate_all_async(_fetch, extract_wdata_cursor, "body")
        return PagedResponseQueryDto.model_validate(_body)

    def import_file(
        self,
        *,
        table_id: str,
        body: ImportDto,
        timeout: Optional[float] = None,
    ) -> BaseResponseFileMetaDto:
        """Import a single file

        Imports the provided file into the associated table, and immediately
        returns a
        file meta object with an ID that can be used to poll the file controller
        for status.

        Args:
            table_id: The unique identifier of the table
            body: Request body.
            timeout: Override the default request timeout (seconds).

        Returns:
            BaseResponseFileMetaDto

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 423, 429, 500).
        """
        response = self._client.request(
            "POST",
            self._api,
            "/api/v1/table/{tableId}/import",
            path_params={
                "tableId": table_id,
            },
            json_body=body,
            timeout=timeout,
        )
        return BaseResponseFileMetaDto.model_validate(response.json())

    async def import_file_async(
        self,
        *,
        table_id: str,
        body: ImportDto,
        timeout: Optional[float] = None,
    ) -> BaseResponseFileMetaDto:
        """Import a single file (async)

        Imports the provided file into the associated table, and immediately
        returns a
        file meta object with an ID that can be used to poll the file controller
        for status.

        Args:
            table_id: The unique identifier of the table
            body: Request body.
            timeout: Override the default request timeout (seconds).

        Returns:
            BaseResponseFileMetaDto

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 423, 429, 500).
        """
        response = await self._client.request_async(
            "POST",
            self._api,
            "/api/v1/table/{tableId}/import",
            path_params={
                "tableId": table_id,
            },
            json_body=body,
            timeout=timeout,
        )
        return BaseResponseFileMetaDto.model_validate(response.json())

    def unimport_file(
        self,
        *,
        table_id: str,
        file_id: str,
        force: Optional[str] = "false",
        timeout: Optional[float] = None,
    ) -> BaseResponseFileMetaDto:
        """Unimport a single file

        Unimports the provided file from the provided table. Returns a 409 if
        the file is
        not in an imported state, or a 404 if the file can't be found.

        Args:
            table_id: The unique identifier of the table
            file_id: The unique identifier of the file
            force: If true, unimports and deletes file from the table
            timeout: Override the default request timeout (seconds).

        Returns:
            BaseResponseFileMetaDto

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 423, 429, 500).
        """
        response = self._client.request(
            "DELETE",
            self._api,
            "/api/v1/table/{tableId}/import/{fileId}",
            path_params={
                "tableId": table_id,
                "fileId": file_id,
            },
            query_params={
                "force": force,
            },
            timeout=timeout,
        )
        return BaseResponseFileMetaDto.model_validate(response.json())

    async def unimport_file_async(
        self,
        *,
        table_id: str,
        file_id: str,
        force: Optional[str] = "false",
        timeout: Optional[float] = None,
    ) -> BaseResponseFileMetaDto:
        """Unimport a single file (async)

        Unimports the provided file from the provided table. Returns a 409 if
        the file is
        not in an imported state, or a 404 if the file can't be found.

        Args:
            table_id: The unique identifier of the table
            file_id: The unique identifier of the file
            force: If true, unimports and deletes file from the table
            timeout: Override the default request timeout (seconds).

        Returns:
            BaseResponseFileMetaDto

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 423, 429, 500).
        """
        response = await self._client.request_async(
            "DELETE",
            self._api,
            "/api/v1/table/{tableId}/import/{fileId}",
            path_params={
                "tableId": table_id,
                "fileId": file_id,
            },
            query_params={
                "force": force,
            },
            timeout=timeout,
        )
        return BaseResponseFileMetaDto.model_validate(response.json())

    def get_import_info(
        self,
        *,
        table_id: str,
        timeout: Optional[float] = None,
    ) -> BaseResponseImportInfoDto:
        """Retrieve import information

        Returns information around imported files for a table.

        Args:
            table_id: The unique identifier of the table
            timeout: Override the default request timeout (seconds).

        Returns:
            BaseResponseImportInfoDto

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 423, 429, 500).
        """
        response = self._client.request(
            "GET",
            self._api,
            "/api/v1/table/{tableId}/importInfo",
            path_params={
                "tableId": table_id,
            },
            timeout=timeout,
        )
        return BaseResponseImportInfoDto.model_validate(response.json())

    async def get_import_info_async(
        self,
        *,
        table_id: str,
        timeout: Optional[float] = None,
    ) -> BaseResponseImportInfoDto:
        """Retrieve import information (async)

        Returns information around imported files for a table.

        Args:
            table_id: The unique identifier of the table
            timeout: Override the default request timeout (seconds).

        Returns:
            BaseResponseImportInfoDto

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 423, 429, 500).
        """
        response = await self._client.request_async(
            "GET",
            self._api,
            "/api/v1/table/{tableId}/importInfo",
            path_params={
                "tableId": table_id,
            },
            timeout=timeout,
        )
        return BaseResponseImportInfoDto.model_validate(response.json())

    def import_from_spreadsheets(
        self,
        *,
        table_id: str,
        body: ImportFromSpreadsheetDto,
        timeout: Optional[float] = None,
    ) -> BaseResponseFileMetaDto:
        """Import from spreadsheets

        Imports spreadsheet data and immediately returns a file meta result.
        This DTO has
        an ID, which can be used to poll on status via the file controller.

        Args:
            table_id: The unique identifier of the table
            body: Request body.
            timeout: Override the default request timeout (seconds).

        Returns:
            BaseResponseFileMetaDto

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 423, 429, 500).
        """
        response = self._client.request(
            "POST",
            self._api,
            "/api/v1/table/{tableId}/spreadsheet/import",
            path_params={
                "tableId": table_id,
            },
            json_body=body,
            timeout=timeout,
        )
        return BaseResponseFileMetaDto.model_validate(response.json())

    async def import_from_spreadsheets_async(
        self,
        *,
        table_id: str,
        body: ImportFromSpreadsheetDto,
        timeout: Optional[float] = None,
    ) -> BaseResponseFileMetaDto:
        """Import from spreadsheets (async)

        Imports spreadsheet data and immediately returns a file meta result.
        This DTO has
        an ID, which can be used to poll on status via the file controller.

        Args:
            table_id: The unique identifier of the table
            body: Request body.
            timeout: Override the default request timeout (seconds).

        Returns:
            BaseResponseFileMetaDto

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 423, 429, 500).
        """
        response = await self._client.request_async(
            "POST",
            self._api,
            "/api/v1/table/{tableId}/spreadsheet/import",
            path_params={
                "tableId": table_id,
            },
            json_body=body,
            timeout=timeout,
        )
        return BaseResponseFileMetaDto.model_validate(response.json())

    def list_tags(
        self,
        *,
        limit: Optional[int] = 1000,
        offset: Optional[int] = None,
        timeout: Optional[float] = None,
    ) -> PagedResponseTagDto:
        """Retrieve a list of tags

        Returns a paged list of all tags associated with the workspace of the
        request.

        Args:
            limit: The number of tags to return, from 1 to 1000; by default, 1000
            offset: The item to start with on the page, greater than or equal to 0; by default, 0
            timeout: Override the default request timeout (seconds).

        Returns:
            PagedResponseTagDto

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 423, 429, 500).
        """

        def _fetch(_cursor: str | None) -> httpx.Response:
            return self._client.request(
                "GET",
                self._api,
                "/api/v1/tag",
                query_params={
                    "limit": limit,
                    "offset": offset,
                    "cursor": _cursor,
                },
                timeout=timeout,
            )

        _body = paginate_all(_fetch, extract_wdata_cursor, "body")
        return PagedResponseTagDto.model_validate(_body)

    async def list_tags_async(
        self,
        *,
        limit: Optional[int] = 1000,
        offset: Optional[int] = None,
        timeout: Optional[float] = None,
    ) -> PagedResponseTagDto:
        """Retrieve a list of tags (async)

        Returns a paged list of all tags associated with the workspace of the
        request.

        Args:
            limit: The number of tags to return, from 1 to 1000; by default, 1000
            offset: The item to start with on the page, greater than or equal to 0; by default, 0
            timeout: Override the default request timeout (seconds).

        Returns:
            PagedResponseTagDto

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 423, 429, 500).
        """

        async def _fetch(_cursor: str | None) -> httpx.Response:
            return await self._client.request_async(
                "GET",
                self._api,
                "/api/v1/tag",
                query_params={
                    "limit": limit,
                    "offset": offset,
                    "cursor": _cursor,
                },
                timeout=timeout,
            )

        _body = await paginate_all_async(_fetch, extract_wdata_cursor, "body")
        return PagedResponseTagDto.model_validate(_body)

    def create_tag(
        self,
        *,
        body: TagDto,
        timeout: Optional[float] = None,
    ) -> BaseResponseTagDto:
        """Create a new tag

        Creates a tag. If another tag already has the same key, returns a 409.
        There is a limit of 300 values for a tag.

        Returns:
            BaseResponseTagDto

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 423, 429, 500).
        """
        response = self._client.request(
            "POST",
            self._api,
            "/api/v1/tag",
            json_body=body,
            timeout=timeout,
        )
        return BaseResponseTagDto.model_validate(response.json())

    async def create_tag_async(
        self,
        *,
        body: TagDto,
        timeout: Optional[float] = None,
    ) -> BaseResponseTagDto:
        """Create a new tag (async)

        Creates a tag. If another tag already has the same key, returns a 409.
        There is a limit of 300 values for a tag.

        Returns:
            BaseResponseTagDto

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 423, 429, 500).
        """
        response = await self._client.request_async(
            "POST",
            self._api,
            "/api/v1/tag",
            json_body=body,
            timeout=timeout,
        )
        return BaseResponseTagDto.model_validate(response.json())

    def delete_tag(
        self,
        *,
        tag_id: str,
        timeout: Optional[float] = None,
    ) -> BaseResponseString:
        """Delete a single tag

        Deletes the tag with the provided ID. If no such tag is found, this is a
        no-op.

        Args:
            tag_id: The unique identifier of the tag
            timeout: Override the default request timeout (seconds).

        Returns:
            BaseResponseString

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 423, 429, 500).
        """
        response = self._client.request(
            "DELETE",
            self._api,
            "/api/v1/tag/{tagId}",
            path_params={
                "tagId": tag_id,
            },
            timeout=timeout,
        )
        return BaseResponseString.model_validate(response.json())

    async def delete_tag_async(
        self,
        *,
        tag_id: str,
        timeout: Optional[float] = None,
    ) -> BaseResponseString:
        """Delete a single tag (async)

        Deletes the tag with the provided ID. If no such tag is found, this is a
        no-op.

        Args:
            tag_id: The unique identifier of the tag
            timeout: Override the default request timeout (seconds).

        Returns:
            BaseResponseString

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 423, 429, 500).
        """
        response = await self._client.request_async(
            "DELETE",
            self._api,
            "/api/v1/tag/{tagId}",
            path_params={
                "tagId": tag_id,
            },
            timeout=timeout,
        )
        return BaseResponseString.model_validate(response.json())

    def update_tag(
        self,
        *,
        tag_id: str,
        body: TagDto,
        timeout: Optional[float] = None,
    ) -> BaseResponseTagDto:
        """Update a single tag

        Updates the tag that matches the provided ID with the details provided
        in the body.
        Ignores the provided key, as keys are immutable once set.
        There is a limit of 300 values for a tag.

        Args:
            tag_id: The unique identifier of the tag
            body: Request body.
            timeout: Override the default request timeout (seconds).

        Returns:
            BaseResponseTagDto

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 423, 429, 500).
        """
        response = self._client.request(
            "PUT",
            self._api,
            "/api/v1/tag/{tagId}",
            path_params={
                "tagId": tag_id,
            },
            json_body=body,
            timeout=timeout,
        )
        return BaseResponseTagDto.model_validate(response.json())

    async def update_tag_async(
        self,
        *,
        tag_id: str,
        body: TagDto,
        timeout: Optional[float] = None,
    ) -> BaseResponseTagDto:
        """Update a single tag (async)

        Updates the tag that matches the provided ID with the details provided
        in the body.
        Ignores the provided key, as keys are immutable once set.
        There is a limit of 300 values for a tag.

        Args:
            tag_id: The unique identifier of the tag
            body: Request body.
            timeout: Override the default request timeout (seconds).

        Returns:
            BaseResponseTagDto

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 423, 429, 500).
        """
        response = await self._client.request_async(
            "PUT",
            self._api,
            "/api/v1/tag/{tagId}",
            path_params={
                "tagId": tag_id,
            },
            json_body=body,
            timeout=timeout,
        )
        return BaseResponseTagDto.model_validate(response.json())

    def create_token(
        self,
        *,
        body: TokenDto,
        timeout: Optional[float] = None,
    ) -> BaseResponseTokenDto:
        """Create a new token

        Creates a temporary token—valid for only a short period of time—to
        download a table
        dataset file or query result, given its ID.

        Returns:
            BaseResponseTokenDto

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 423, 429, 500).
        """
        response = self._client.request(
            "POST",
            self._api,
            "/api/v1/token",
            json_body=body,
            timeout=timeout,
        )
        return BaseResponseTokenDto.model_validate(response.json())

    async def create_token_async(
        self,
        *,
        body: TokenDto,
        timeout: Optional[float] = None,
    ) -> BaseResponseTokenDto:
        """Create a new token (async)

        Creates a temporary token—valid for only a short period of time—to
        download a table
        dataset file or query result, given its ID.

        Returns:
            BaseResponseTokenDto

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 423, 429, 500).
        """
        response = await self._client.request_async(
            "POST",
            self._api,
            "/api/v1/token",
            json_body=body,
            timeout=timeout,
        )
        return BaseResponseTokenDto.model_validate(response.json())

    def download_file(
        self,
        *,
        token_id: str,
        filename: Optional[str] = None,
        timeout: Optional[float] = None,
    ) -> httpx.Response:
        """Download a single file

        Downloads a table dataset or query result as a file, given its token
        from the [`Create a new token endpoint`](ref:wdata-createtoken). If no
        matching entity is found, returns a 404.

        Args:
            token_id: The unique identifier of the token
            filename: A filename for the download; if included, the default filename is overridden
            timeout: Override the default request timeout (seconds).

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 423, 429, 500).
        """
        return self._client.request(
            "GET",
            self._api,
            "/api/v1/token/{tokenId}",
            path_params={
                "tokenId": token_id,
            },
            query_params={
                "filename": filename,
            },
            timeout=timeout,
        )

    async def download_file_async(
        self,
        *,
        token_id: str,
        filename: Optional[str] = None,
        timeout: Optional[float] = None,
    ) -> httpx.Response:
        """Download a single file (async)

        Downloads a table dataset or query result as a file, given its token
        from the [`Create a new token endpoint`](ref:wdata-createtoken). If no
        matching entity is found, returns a 404.

        Args:
            token_id: The unique identifier of the token
            filename: A filename for the download; if included, the default filename is overridden
            timeout: Override the default request timeout (seconds).

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 423, 429, 500).
        """
        return await self._client.request_async(
            "GET",
            self._api,
            "/api/v1/token/{tokenId}",
            path_params={
                "tokenId": token_id,
            },
            query_params={
                "filename": filename,
            },
            timeout=timeout,
        )

    def parse_date(
        self,
        *,
        body: DatetimeDto,
        timeout: Optional[float] = None,
    ) -> BaseResponseString:
        """Parse a date

        Provides a simple endpoint to check whether a given date candidate
        parses with
        the provided format string.  Both the date candidate and format strings
        are required.
        Returns a 200 if the date parses, or a 400 with a message if not. If the
        date parses,
        the provided format can be provided as column metadata, and the imported
        values parse
        correctly. The format string is java DateTimeFormatter style e.g.
        dateFormat =
        "MM/dd/yyyy" and candidate = "07/28/1987"

        Returns:
            BaseResponseString

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 423, 429, 500).
        """
        response = self._client.request(
            "POST",
            self._api,
            "/api/v1/util/datetime",
            json_body=body,
            timeout=timeout,
        )
        return BaseResponseString.model_validate(response.json())

    async def parse_date_async(
        self,
        *,
        body: DatetimeDto,
        timeout: Optional[float] = None,
    ) -> BaseResponseString:
        """Parse a date (async)

        Provides a simple endpoint to check whether a given date candidate
        parses with
        the provided format string.  Both the date candidate and format strings
        are required.
        Returns a 200 if the date parses, or a 400 with a message if not. If the
        date parses,
        the provided format can be provided as column metadata, and the imported
        values parse
        correctly. The format string is java DateTimeFormatter style e.g.
        dateFormat =
        "MM/dd/yyyy" and candidate = "07/28/1987"

        Returns:
            BaseResponseString

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 423, 429, 500).
        """
        response = await self._client.request_async(
            "POST",
            self._api,
            "/api/v1/util/datetime",
            json_body=body,
            timeout=timeout,
        )
        return BaseResponseString.model_validate(response.json())

    def health_check(
        self,
        *,
        timeout: Optional[float] = None,
    ) -> BaseResponseMapStringString:
        """Health check

        Returns the status of the API WSGI servers

        Returns:
            BaseResponseMapStringString

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 423, 429, 500).
        """
        response = self._client.request(
            "GET",
            self._api,
            "/health",
            timeout=timeout,
        )
        return BaseResponseMapStringString.model_validate(response.json())

    async def health_check_async(
        self,
        *,
        timeout: Optional[float] = None,
    ) -> BaseResponseMapStringString:
        """Health check (async)

        Returns the status of the API WSGI servers

        Returns:
            BaseResponseMapStringString

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 423, 429, 500).
        """
        response = await self._client.request_async(
            "GET",
            self._api,
            "/health",
            timeout=timeout,
        )
        return BaseResponseMapStringString.model_validate(response.json())
