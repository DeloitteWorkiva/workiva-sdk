"""Wdata API — wdata namespace.

Auto-generated by codegen. Do not edit manually.
"""

from __future__ import annotations

from typing import Any, Literal, Optional

import httpx

from workiva._constants import _API
from workiva._operations._base import BaseNamespace
from workiva._pagination import (
    extract_wdata_cursor,
    paginate_all,
    paginate_all_async,
)
from workiva.models.wdata import (
    BaseResponseCollectionFolderableDto,
    BaseResponseConnectionDto,
    BaseResponseConnectionRunDto,
    BaseResponseDescribeQueryResponseDto,
    BaseResponseFileMetaDto,
    BaseResponseFolderDto,
    BaseResponseGlobalParameterDto,
    BaseResponseImportInfoDto,
    BaseResponseLong,
    BaseResponseMapStringString,
    BaseResponsePivotViewDto,
    BaseResponseQueryColumnDataDto,
    BaseResponseQueryDto,
    BaseResponseQueryResultDto,
    BaseResponseRefreshBatchDto,
    BaseResponseSelectListDto,
    BaseResponseSharedTableDto,
    BaseResponseSpreadsheetInfoDto,
    BaseResponseString,
    BaseResponseTableDto,
    BaseResponseTagDto,
    BaseResponseTokenDto,
    BaseResponseValidateFilesDto,
    BaseResponseValidateTablesDto,
    FolderableDto,
    HierarchyMetadata,
    PagedResponseConnectionDto,
    PagedResponseFileMetaDto,
    PagedResponseFolderableDto,
    PagedResponseFolderDto,
    PagedResponseGlobalParameterDto,
    PagedResponseImportErrorDto,
    PagedResponsePivotViewDto,
    PagedResponseQueryDto,
    PagedResponseQueryResultDto,
    PagedResponseSelectListDto,
    PagedResponseSharedTableDto,
    PagedResponseTableDto,
    PagedResponseTagDto,
    PivotDefinitionDto,
    QueryDto,
    QueryParameterDto,
    RefreshConnectionDto,
    TableSchema,
    UniqueConstraintDto,
)

__all__ = ["Wdata"]


class Wdata(BaseNamespace):
    """Wdata operations."""

    _api: _API = _API.WDATA

    def delete_workspace(
        self,
        *,
        timeout: Optional[float] = None,
    ) -> BaseResponseString:
        """Delete a single workspace

        Deletes all information in the workspace of the request. <b>This is a
        final operation and can't be undone</b>. Any state left in the workspace
        due to an error is in an indeterminate state and shouldn't be trusted.
        Some non-private information may be kept for auditing and metric
        purposes.

        Returns:
            BaseResponseString

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 423, 429, 500).
        """
        response = self._client.request(
            "DELETE",
            self._api,
            "/api/v1/admin/account",
            timeout=timeout,
        )
        return BaseResponseString.model_validate(response.json())

    async def delete_workspace_async(
        self,
        *,
        timeout: Optional[float] = None,
    ) -> BaseResponseString:
        """Delete a single workspace (async)

        Deletes all information in the workspace of the request. <b>This is a
        final operation and can't be undone</b>. Any state left in the workspace
        due to an error is in an indeterminate state and shouldn't be trusted.
        Some non-private information may be kept for auditing and metric
        purposes.

        Returns:
            BaseResponseString

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 423, 429, 500).
        """
        response = await self._client.request_async(
            "DELETE",
            self._api,
            "/api/v1/admin/account",
            timeout=timeout,
        )
        return BaseResponseString.model_validate(response.json())

    def export_workspace(
        self,
        *,
        timeout: Optional[float] = None,
    ) -> BaseResponseTokenDto:
        """Export a single workspace

        Creates a file representing the entirety of the requested workspace and
        returns a
        token. Use the [`Download a single file endpoint`](ref:wdata-
        downloadfile) to
        exchange the token for the file.

        Returns:
            BaseResponseTokenDto

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 423, 429, 500).
        """
        response = self._client.request(
            "GET",
            self._api,
            "/api/v1/admin/export",
            timeout=timeout,
        )
        return BaseResponseTokenDto.model_validate(response.json())

    async def export_workspace_async(
        self,
        *,
        timeout: Optional[float] = None,
    ) -> BaseResponseTokenDto:
        """Export a single workspace (async)

        Creates a file representing the entirety of the requested workspace and
        returns a
        token. Use the [`Download a single file endpoint`](ref:wdata-
        downloadfile) to
        exchange the token for the file.

        Returns:
            BaseResponseTokenDto

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 423, 429, 500).
        """
        response = await self._client.request_async(
            "GET",
            self._api,
            "/api/v1/admin/export",
            timeout=timeout,
        )
        return BaseResponseTokenDto.model_validate(response.json())

    def import_data(
        self,
        *,
        wipe: Optional[bool] = True,
        body: Optional[dict[str, Any]] = None,
        timeout: Optional[float] = None,
    ) -> BaseResponseString:
        """Import data

        By default, deletes all information in the workspace of the request.
        <b>This is a final
        operation and can't be undone.</b>  Any state left in the workspace due
        to an error is
        in an indeterminate state and shouldn't be trusted. Some non-private
        information may be
        kept for auditing and metric purposes. After the delete, it then imports
        the tables, tags,
        and queries in the provided cb file into the workspace. <br><br>
        This is an asynchronous operation. Returns a 201 when the file is
        correctly decoded and
        its tables, queries, and tags are saved. Files continue to import after
        this call
        completes.

        Args:
            wipe:
            body: Request body.
            timeout: Override the default request timeout (seconds).

        Returns:
            BaseResponseString

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 423, 429, 500).

        Note:
            This operation uses multipart/form-data. Pass ``body`` as a dict
            mapping field names to values. For file fields use a tuple::

                body = {
                    "file": ("filename.csv", open("filename.csv", "rb")),
                    "field": "value",
                }
        """
        response = self._client.request(
            "POST",
            self._api,
            "/api/v1/admin/import",
            query_params={
                "wipe": wipe,
            },
            files=body,
            timeout=timeout,
        )
        return BaseResponseString.model_validate(response.json())

    async def import_data_async(
        self,
        *,
        wipe: Optional[bool] = True,
        body: Optional[dict[str, Any]] = None,
        timeout: Optional[float] = None,
    ) -> BaseResponseString:
        """Import data (async)

        By default, deletes all information in the workspace of the request.
        <b>This is a final
        operation and can't be undone.</b>  Any state left in the workspace due
        to an error is
        in an indeterminate state and shouldn't be trusted. Some non-private
        information may be
        kept for auditing and metric purposes. After the delete, it then imports
        the tables, tags,
        and queries in the provided cb file into the workspace. <br><br>
        This is an asynchronous operation. Returns a 201 when the file is
        correctly decoded and
        its tables, queries, and tags are saved. Files continue to import after
        this call
        completes.

        Args:
            wipe:
            body: Request body.
            timeout: Override the default request timeout (seconds).

        Returns:
            BaseResponseString

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 423, 429, 500).

        Note:
            This operation uses multipart/form-data. Pass ``body`` as a dict
            mapping field names to values. For file fields use a tuple::

                body = {
                    "file": ("filename.csv", open("filename.csv", "rb")),
                    "field": "value",
                }
        """
        response = await self._client.request_async(
            "POST",
            self._api,
            "/api/v1/admin/import",
            query_params={
                "wipe": wipe,
            },
            files=body,
            timeout=timeout,
        )
        return BaseResponseString.model_validate(response.json())

    def find_workspace_files_by_size(
        self,
        *,
        limit: Optional[int] = None,
        offset: Optional[int] = None,
        timeout: Optional[float] = None,
    ) -> PagedResponseFileMetaDto:
        """Retrieve workspace files by size

        Returns a paged collection of the file meta associated with the
        workspace of the request,
        ordered by size.

        Args:
            limit: The number of file meta objects to return, from 1 to 1000; by default, 1000
            offset: The item to start with on the page, greater than or equal to 0; by default, 0
            timeout: Override the default request timeout (seconds).

        Returns:
            PagedResponseFileMetaDto

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 423, 429, 500).
        """

        def _fetch(_cursor: str | None) -> httpx.Response:
            return self._client.request(
                "GET",
                self._api,
                "/api/v1/admin/usage/filesBySize",
                query_params={
                    "limit": limit,
                    "offset": offset,
                    "cursor": _cursor,
                },
                timeout=timeout,
            )

        _body_result = paginate_all(_fetch, extract_wdata_cursor, "body")
        return PagedResponseFileMetaDto.model_validate(_body_result)

    async def find_workspace_files_by_size_async(
        self,
        *,
        limit: Optional[int] = None,
        offset: Optional[int] = None,
        timeout: Optional[float] = None,
    ) -> PagedResponseFileMetaDto:
        """Retrieve workspace files by size (async)

        Returns a paged collection of the file meta associated with the
        workspace of the request,
        ordered by size.

        Args:
            limit: The number of file meta objects to return, from 1 to 1000; by default, 1000
            offset: The item to start with on the page, greater than or equal to 0; by default, 0
            timeout: Override the default request timeout (seconds).

        Returns:
            PagedResponseFileMetaDto

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 423, 429, 500).
        """

        async def _fetch(_cursor: str | None) -> httpx.Response:
            return await self._client.request_async(
                "GET",
                self._api,
                "/api/v1/admin/usage/filesBySize",
                query_params={
                    "limit": limit,
                    "offset": offset,
                    "cursor": _cursor,
                },
                timeout=timeout,
            )

        _body_result = await paginate_all_async(_fetch, extract_wdata_cursor, "body")
        return PagedResponseFileMetaDto.model_validate(_body_result)

    def get_workspace_query_usage(
        self,
        *,
        start_date: Optional[str] = "1970-01-01",
        stop_date: Optional[str] = "9999-01-01",
        timeout: Optional[float] = None,
    ) -> BaseResponseLong:
        """Retrieve workspace query usage

        Returns a Long that represents the number of bytes queried by the
        workspace of the
        request since the start time provided.

        Args:
            start_date: The earliest date of usage to consider
            stop_date: The end date of usage to consider
            timeout: Override the default request timeout (seconds).

        Returns:
            BaseResponseLong

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 423, 429, 500).
        """
        response = self._client.request(
            "GET",
            self._api,
            "/api/v1/admin/usage/query",
            query_params={
                "startDate": start_date,
                "stopDate": stop_date,
            },
            timeout=timeout,
        )
        return BaseResponseLong.model_validate(response.json())

    async def get_workspace_query_usage_async(
        self,
        *,
        start_date: Optional[str] = "1970-01-01",
        stop_date: Optional[str] = "9999-01-01",
        timeout: Optional[float] = None,
    ) -> BaseResponseLong:
        """Retrieve workspace query usage (async)

        Returns a Long that represents the number of bytes queried by the
        workspace of the
        request since the start time provided.

        Args:
            start_date: The earliest date of usage to consider
            stop_date: The end date of usage to consider
            timeout: Override the default request timeout (seconds).

        Returns:
            BaseResponseLong

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 423, 429, 500).
        """
        response = await self._client.request_async(
            "GET",
            self._api,
            "/api/v1/admin/usage/query",
            query_params={
                "startDate": start_date,
                "stopDate": stop_date,
            },
            timeout=timeout,
        )
        return BaseResponseLong.model_validate(response.json())

    def get_workspace_upload_usage(
        self,
        *,
        start_date: Optional[str] = "1970-01-01",
        stop_date: Optional[str] = "9999-01-01",
        timeout: Optional[float] = None,
    ) -> BaseResponseLong:
        """Retrieve workspace upload usage

        Returns a Long that represents the number of bytes uploaded by the
        workspace associated with this request from the start time provided to
        now.

        Args:
            start_date: The starting point to begin considering usage
            stop_date: The ending point when considering usage
            timeout: Override the default request timeout (seconds).

        Returns:
            BaseResponseLong

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 423, 429, 500).
        """
        response = self._client.request(
            "GET",
            self._api,
            "/api/v1/admin/usage/upload",
            query_params={
                "startDate": start_date,
                "stopDate": stop_date,
            },
            timeout=timeout,
        )
        return BaseResponseLong.model_validate(response.json())

    async def get_workspace_upload_usage_async(
        self,
        *,
        start_date: Optional[str] = "1970-01-01",
        stop_date: Optional[str] = "9999-01-01",
        timeout: Optional[float] = None,
    ) -> BaseResponseLong:
        """Retrieve workspace upload usage (async)

        Returns a Long that represents the number of bytes uploaded by the
        workspace associated with this request from the start time provided to
        now.

        Args:
            start_date: The starting point to begin considering usage
            stop_date: The ending point when considering usage
            timeout: Override the default request timeout (seconds).

        Returns:
            BaseResponseLong

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 423, 429, 500).
        """
        response = await self._client.request_async(
            "GET",
            self._api,
            "/api/v1/admin/usage/upload",
            query_params={
                "startDate": start_date,
                "stopDate": stop_date,
            },
            timeout=timeout,
        )
        return BaseResponseLong.model_validate(response.json())

    def validate_files(
        self,
        *,
        table_id: str,
        timeout: Optional[float] = None,
    ) -> BaseResponseValidateFilesDto:
        """Validate files

        Validates files associated with the provided table ID. Validation
        repairs any files in
        an inconsistent state, and deletes those without enough state to
        recover. All files
        deleted or repaired are returned.

        Args:
            table_id: The unique identifier for the table.
            timeout: Override the default request timeout (seconds).

        Returns:
            BaseResponseValidateFilesDto

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 423, 429, 500).
        """
        _body: dict[str, Any] = {}
        if table_id is not None:
            _body["tableId"] = table_id
        response = self._client.request(
            "POST",
            self._api,
            "/api/v1/admin/validation/files",
            json_body=_body or None,
            timeout=timeout,
        )
        return BaseResponseValidateFilesDto.model_validate(response.json())

    async def validate_files_async(
        self,
        *,
        table_id: str,
        timeout: Optional[float] = None,
    ) -> BaseResponseValidateFilesDto:
        """Validate files (async)

        Validates files associated with the provided table ID. Validation
        repairs any files in
        an inconsistent state, and deletes those without enough state to
        recover. All files
        deleted or repaired are returned.

        Args:
            table_id: The unique identifier for the table.
            timeout: Override the default request timeout (seconds).

        Returns:
            BaseResponseValidateFilesDto

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 423, 429, 500).
        """
        _body: dict[str, Any] = {}
        if table_id is not None:
            _body["tableId"] = table_id
        response = await self._client.request_async(
            "POST",
            self._api,
            "/api/v1/admin/validation/files",
            json_body=_body or None,
            timeout=timeout,
        )
        return BaseResponseValidateFilesDto.model_validate(response.json())

    def validate_tables(
        self,
        *,
        timeout: Optional[float] = None,
    ) -> BaseResponseValidateTablesDto:
        """Validate tables

        Validates the tables in the workspace associated with the request.
        Validation returns an entity that indicates the tables deleted due to
        bad state, and those with enough state and repaired.

        Returns:
            BaseResponseValidateTablesDto

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 423, 429, 500).
        """
        response = self._client.request(
            "POST",
            self._api,
            "/api/v1/admin/validation/tables",
            timeout=timeout,
        )
        return BaseResponseValidateTablesDto.model_validate(response.json())

    async def validate_tables_async(
        self,
        *,
        timeout: Optional[float] = None,
    ) -> BaseResponseValidateTablesDto:
        """Validate tables (async)

        Validates the tables in the workspace associated with the request.
        Validation returns an entity that indicates the tables deleted due to
        bad state, and those with enough state and repaired.

        Returns:
            BaseResponseValidateTablesDto

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 423, 429, 500).
        """
        response = await self._client.request_async(
            "POST",
            self._api,
            "/api/v1/admin/validation/tables",
            timeout=timeout,
        )
        return BaseResponseValidateTablesDto.model_validate(response.json())

    def list_connections(
        self,
        *,
        source_type: Optional[
            Literal[
                "document",
                "document_chart",
                "document_embedded_table",
                "esg_program",
                "presentation",
                "presentation_chart",
                "presentation_embedded_table",
                "report",
                "spreadsheet",
                "spreadsheet_section",
                "wdata_query",
                "wdata_table",
                "wdata_table_dataset",
            ]
        ] = None,
        destination_type: Optional[
            Literal[
                "document",
                "document_chart",
                "document_embedded_table",
                "presentation",
                "presentation_chart",
                "presentation_embedded_table",
                "report",
                "spreadsheet",
                "spreadsheet_section",
                "wdata_query",
                "wdata_table",
                "wdata_table_dataset",
            ]
        ] = None,
        source_id: Optional[str] = None,
        destination_id: Optional[str] = None,
        limit: Optional[int] = None,
        offset: Optional[int] = None,
        timeout: Optional[float] = None,
    ) -> PagedResponseConnectionDto:
        """List connections

        A pageable endpoint to list data connections between features of the
        Workiva platform. When filtering by source or destination, the
        corresponding ID is required.

        Args:
            source_type: The type of file or item the connection pulls data from
            destination_type: The type of file or item the connection sends data to
            source_id: The ID of the file or item the connection pulls data from
            destination_id: The ID of the file or item the connection sends data to
            limit: The number of connections to return, from 1 to 1000; by default, 1000
            offset: The item to start with on the page, greater than or equal to 0; by default, 0
            timeout: Override the default request timeout (seconds).

        Returns:
            PagedResponseConnectionDto

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 423, 429, 500).
        """

        def _fetch(_cursor: str | None) -> httpx.Response:
            return self._client.request(
                "GET",
                self._api,
                "/api/v1/connections",
                query_params={
                    "sourceType": source_type,
                    "destinationType": destination_type,
                    "sourceId": source_id,
                    "destinationId": destination_id,
                    "limit": limit,
                    "offset": offset,
                    "cursor": _cursor,
                },
                timeout=timeout,
            )

        _body_result = paginate_all(_fetch, extract_wdata_cursor, "body")
        return PagedResponseConnectionDto.model_validate(_body_result)

    async def list_connections_async(
        self,
        *,
        source_type: Optional[
            Literal[
                "document",
                "document_chart",
                "document_embedded_table",
                "esg_program",
                "presentation",
                "presentation_chart",
                "presentation_embedded_table",
                "report",
                "spreadsheet",
                "spreadsheet_section",
                "wdata_query",
                "wdata_table",
                "wdata_table_dataset",
            ]
        ] = None,
        destination_type: Optional[
            Literal[
                "document",
                "document_chart",
                "document_embedded_table",
                "presentation",
                "presentation_chart",
                "presentation_embedded_table",
                "report",
                "spreadsheet",
                "spreadsheet_section",
                "wdata_query",
                "wdata_table",
                "wdata_table_dataset",
            ]
        ] = None,
        source_id: Optional[str] = None,
        destination_id: Optional[str] = None,
        limit: Optional[int] = None,
        offset: Optional[int] = None,
        timeout: Optional[float] = None,
    ) -> PagedResponseConnectionDto:
        """List connections (async)

        A pageable endpoint to list data connections between features of the
        Workiva platform. When filtering by source or destination, the
        corresponding ID is required.

        Args:
            source_type: The type of file or item the connection pulls data from
            destination_type: The type of file or item the connection sends data to
            source_id: The ID of the file or item the connection pulls data from
            destination_id: The ID of the file or item the connection sends data to
            limit: The number of connections to return, from 1 to 1000; by default, 1000
            offset: The item to start with on the page, greater than or equal to 0; by default, 0
            timeout: Override the default request timeout (seconds).

        Returns:
            PagedResponseConnectionDto

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 423, 429, 500).
        """

        async def _fetch(_cursor: str | None) -> httpx.Response:
            return await self._client.request_async(
                "GET",
                self._api,
                "/api/v1/connections",
                query_params={
                    "sourceType": source_type,
                    "destinationType": destination_type,
                    "sourceId": source_id,
                    "destinationId": destination_id,
                    "limit": limit,
                    "offset": offset,
                    "cursor": _cursor,
                },
                timeout=timeout,
            )

        _body_result = await paginate_all_async(_fetch, extract_wdata_cursor, "body")
        return PagedResponseConnectionDto.model_validate(_body_result)

    def refresh_batch(
        self,
        *,
        body: list[RefreshConnectionDto],
        cancel_unwritables: Optional[bool] = None,
        timeout: Optional[float] = None,
    ) -> BaseResponseRefreshBatchDto:
        """Refresh batch of connections

        Refreshes multiple incoming connections within the same spreadsheet,
        based on ID. When connecting to multiple spreadsheets, tables or other
        destinations, use the [`singular refresh connection`](ref:wdata-
        refreshconnection) instead.
         `usePreviousDestinationParameters` and  `usePreviousSourceParameters`
        will use the exact parameters of your previous run; any new parameters
        you’ve provided will be ignored. This endpoint only works for outgoing
        connections if they are all connected to the same workbook. This
        endpoint has a limit of 100 refreshes per request.

        Args:
            cancel_unwritables: Allow individual connections in the batch to be canceled if they have a destination that is unwritable. This will NOT cancel the entire batch.
            body: Request body.
            timeout: Override the default request timeout (seconds).

        Returns:
            BaseResponseRefreshBatchDto

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 423, 429, 500).
        """
        response = self._client.request(
            "POST",
            self._api,
            "/api/v1/connections/batch/refresh",
            query_params={
                "cancelUnwritables": cancel_unwritables,
            },
            json_body=body,
            timeout=timeout,
        )
        return BaseResponseRefreshBatchDto.model_validate(response.json())

    async def refresh_batch_async(
        self,
        *,
        body: list[RefreshConnectionDto],
        cancel_unwritables: Optional[bool] = None,
        timeout: Optional[float] = None,
    ) -> BaseResponseRefreshBatchDto:
        """Refresh batch of connections (async)

        Refreshes multiple incoming connections within the same spreadsheet,
        based on ID. When connecting to multiple spreadsheets, tables or other
        destinations, use the [`singular refresh connection`](ref:wdata-
        refreshconnection) instead.
         `usePreviousDestinationParameters` and  `usePreviousSourceParameters`
        will use the exact parameters of your previous run; any new parameters
        you’ve provided will be ignored. This endpoint only works for outgoing
        connections if they are all connected to the same workbook. This
        endpoint has a limit of 100 refreshes per request.

        Args:
            cancel_unwritables: Allow individual connections in the batch to be canceled if they have a destination that is unwritable. This will NOT cancel the entire batch.
            body: Request body.
            timeout: Override the default request timeout (seconds).

        Returns:
            BaseResponseRefreshBatchDto

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 423, 429, 500).
        """
        response = await self._client.request_async(
            "POST",
            self._api,
            "/api/v1/connections/batch/refresh",
            query_params={
                "cancelUnwritables": cancel_unwritables,
            },
            json_body=body,
            timeout=timeout,
        )
        return BaseResponseRefreshBatchDto.model_validate(response.json())

    def get_refresh_batch_status(
        self,
        *,
        batch_id: str,
        workspace_id: Optional[str] = None,
        timeout: Optional[float] = None,
    ) -> BaseResponseRefreshBatchDto:
        """Gets the status of a batch refresh

        Returns details about a specific batch refresh, based on its ID.

        Args:
            batch_id: The ID of the batch to return details about
            workspace_id:
            timeout: Override the default request timeout (seconds).

        Returns:
            BaseResponseRefreshBatchDto

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 423, 429, 500).
        """
        response = self._client.request(
            "GET",
            self._api,
            "/api/v1/connections/batch/refresh/{batchId}",
            path_params={
                "batchId": batch_id,
            },
            query_params={
                "workspaceId": workspace_id,
            },
            timeout=timeout,
        )
        return BaseResponseRefreshBatchDto.model_validate(response.json())

    async def get_refresh_batch_status_async(
        self,
        *,
        batch_id: str,
        workspace_id: Optional[str] = None,
        timeout: Optional[float] = None,
    ) -> BaseResponseRefreshBatchDto:
        """Gets the status of a batch refresh (async)

        Returns details about a specific batch refresh, based on its ID.

        Args:
            batch_id: The ID of the batch to return details about
            workspace_id:
            timeout: Override the default request timeout (seconds).

        Returns:
            BaseResponseRefreshBatchDto

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 423, 429, 500).
        """
        response = await self._client.request_async(
            "GET",
            self._api,
            "/api/v1/connections/batch/refresh/{batchId}",
            path_params={
                "batchId": batch_id,
            },
            query_params={
                "workspaceId": workspace_id,
            },
            timeout=timeout,
        )
        return BaseResponseRefreshBatchDto.model_validate(response.json())

    def get_connection(
        self,
        *,
        connection_id: str,
        workspace_id: Optional[str] = None,
        timeout: Optional[float] = None,
    ) -> BaseResponseConnectionDto:
        """Get connection details

        Returns details about a specific connection, based on its ID

        Args:
            connection_id: The ID of the connection to return details about
            workspace_id:
            timeout: Override the default request timeout (seconds).

        Returns:
            BaseResponseConnectionDto

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 423, 429, 500).
        """
        response = self._client.request(
            "GET",
            self._api,
            "/api/v1/connections/{connectionId}",
            path_params={
                "connectionId": connection_id,
            },
            query_params={
                "workspaceId": workspace_id,
            },
            timeout=timeout,
        )
        return BaseResponseConnectionDto.model_validate(response.json())

    async def get_connection_async(
        self,
        *,
        connection_id: str,
        workspace_id: Optional[str] = None,
        timeout: Optional[float] = None,
    ) -> BaseResponseConnectionDto:
        """Get connection details (async)

        Returns details about a specific connection, based on its ID

        Args:
            connection_id: The ID of the connection to return details about
            workspace_id:
            timeout: Override the default request timeout (seconds).

        Returns:
            BaseResponseConnectionDto

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 423, 429, 500).
        """
        response = await self._client.request_async(
            "GET",
            self._api,
            "/api/v1/connections/{connectionId}",
            path_params={
                "connectionId": connection_id,
            },
            query_params={
                "workspaceId": workspace_id,
            },
            timeout=timeout,
        )
        return BaseResponseConnectionDto.model_validate(response.json())

    def refresh_connection(
        self,
        *,
        connection_id: str,
        connection_id_: Optional[str] = None,
        destination_parameters: Optional[dict[str, Any]] = None,
        source_parameters: Optional[dict[str, Any]] = None,
        use_previous_destination_parameters: Optional[bool] = None,
        use_previous_source_parameters: Optional[bool] = None,
        workspace_id: Optional[str] = None,
        timeout: Optional[float] = None,
    ) -> BaseResponseConnectionRunDto:
        """Refresh connection

        Refreshes a specific connection, based on its ID

        Args:
            connection_id:
            connection_id_: The unique ID of the connection
            destination_parameters: Parameters to send to the destination, on refresh
            source_parameters: Parameters to send to the source, on refresh
            use_previous_destination_parameters: Use the destination parameters from the previous run. This overrides any specified destination parameters. Ignored by "Refresh batch of connections" endpoint
            use_previous_source_parameters: Use the source parameters from the previous run. This overrides any specified source parameters. Ignored by "Refresh batch of connections" endpoint
            workspace_id: The workspace ID of the connection
            timeout: Override the default request timeout (seconds).

        Returns:
            BaseResponseConnectionRunDto

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 423, 429, 500).
        """
        _body: dict[str, Any] = {}
        if connection_id_ is not None:
            _body["connectionId"] = connection_id_
        if destination_parameters is not None:
            _body["destinationParameters"] = destination_parameters
        if source_parameters is not None:
            _body["sourceParameters"] = source_parameters
        if use_previous_destination_parameters is not None:
            _body["usePreviousDestinationParameters"] = use_previous_destination_parameters
        if use_previous_source_parameters is not None:
            _body["usePreviousSourceParameters"] = use_previous_source_parameters
        if workspace_id is not None:
            _body["workspaceId"] = workspace_id
        response = self._client.request(
            "POST",
            self._api,
            "/api/v1/connections/{connectionId}/refresh",
            path_params={
                "connectionId": connection_id,
            },
            json_body=_body or None,
            timeout=timeout,
        )
        return BaseResponseConnectionRunDto.model_validate(response.json())

    async def refresh_connection_async(
        self,
        *,
        connection_id: str,
        connection_id_: Optional[str] = None,
        destination_parameters: Optional[dict[str, Any]] = None,
        source_parameters: Optional[dict[str, Any]] = None,
        use_previous_destination_parameters: Optional[bool] = None,
        use_previous_source_parameters: Optional[bool] = None,
        workspace_id: Optional[str] = None,
        timeout: Optional[float] = None,
    ) -> BaseResponseConnectionRunDto:
        """Refresh connection (async)

        Refreshes a specific connection, based on its ID

        Args:
            connection_id:
            connection_id_: The unique ID of the connection
            destination_parameters: Parameters to send to the destination, on refresh
            source_parameters: Parameters to send to the source, on refresh
            use_previous_destination_parameters: Use the destination parameters from the previous run. This overrides any specified destination parameters. Ignored by "Refresh batch of connections" endpoint
            use_previous_source_parameters: Use the source parameters from the previous run. This overrides any specified source parameters. Ignored by "Refresh batch of connections" endpoint
            workspace_id: The workspace ID of the connection
            timeout: Override the default request timeout (seconds).

        Returns:
            BaseResponseConnectionRunDto

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 423, 429, 500).
        """
        _body: dict[str, Any] = {}
        if connection_id_ is not None:
            _body["connectionId"] = connection_id_
        if destination_parameters is not None:
            _body["destinationParameters"] = destination_parameters
        if source_parameters is not None:
            _body["sourceParameters"] = source_parameters
        if use_previous_destination_parameters is not None:
            _body["usePreviousDestinationParameters"] = use_previous_destination_parameters
        if use_previous_source_parameters is not None:
            _body["usePreviousSourceParameters"] = use_previous_source_parameters
        if workspace_id is not None:
            _body["workspaceId"] = workspace_id
        response = await self._client.request_async(
            "POST",
            self._api,
            "/api/v1/connections/{connectionId}/refresh",
            path_params={
                "connectionId": connection_id,
            },
            json_body=_body or None,
            timeout=timeout,
        )
        return BaseResponseConnectionRunDto.model_validate(response.json())

    def get_refresh_status(
        self,
        *,
        connection_id: str,
        job_id: Optional[str] = None,
        workspace_id: Optional[str] = None,
        timeout: Optional[float] = None,
    ) -> BaseResponseConnectionRunDto:
        """Get connection refresh status

        Returns details about a specific connection refresh status, based on its
        ID. To retrieve details about a specific refresh, provide its 'jobId'.

        Args:
            connection_id: The ID of the connection to return details about
            job_id: The ID of the job running for a connection
            workspace_id:
            timeout: Override the default request timeout (seconds).

        Returns:
            BaseResponseConnectionRunDto

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 423, 429, 500).
        """
        response = self._client.request(
            "GET",
            self._api,
            "/api/v1/connections/{connectionId}/status",
            path_params={
                "connectionId": connection_id,
            },
            query_params={
                "jobId": job_id,
                "workspaceId": workspace_id,
            },
            timeout=timeout,
        )
        return BaseResponseConnectionRunDto.model_validate(response.json())

    async def get_refresh_status_async(
        self,
        *,
        connection_id: str,
        job_id: Optional[str] = None,
        workspace_id: Optional[str] = None,
        timeout: Optional[float] = None,
    ) -> BaseResponseConnectionRunDto:
        """Get connection refresh status (async)

        Returns details about a specific connection refresh status, based on its
        ID. To retrieve details about a specific refresh, provide its 'jobId'.

        Args:
            connection_id: The ID of the connection to return details about
            job_id: The ID of the job running for a connection
            workspace_id:
            timeout: Override the default request timeout (seconds).

        Returns:
            BaseResponseConnectionRunDto

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 423, 429, 500).
        """
        response = await self._client.request_async(
            "GET",
            self._api,
            "/api/v1/connections/{connectionId}/status",
            path_params={
                "connectionId": connection_id,
            },
            query_params={
                "jobId": job_id,
                "workspaceId": workspace_id,
            },
            timeout=timeout,
        )
        return BaseResponseConnectionRunDto.model_validate(response.json())

    def search(
        self,
        *,
        name: Optional[str] = None,
        description: Optional[str] = None,
        type_: Optional[list[int]] = None,
        limit: Optional[int] = 1000,
        offset: Optional[int] = None,
        timeout: Optional[float] = None,
    ) -> PagedResponseFolderableDto:
        """Search

        Returns a list of all entities that match the provided criteria. Both
        name and
        description are fuzzy matches; they match _any_ entity that contains the
        provided
        string. The type is used to filter results based on the provided type of
        entity.
        The consumer must have READ access on all returned entities.

        Args:
            name: The name to use when fuzzy-matching entities
            description: The description to use when fuzzy-matching entities
            type_: To limit the scope, the type of entity to return in the results
            limit: The number of folders to return, from 1 to 1000; by default, 1000
            offset: The item to start with on the page, greater than or equal to 0; by default, 0
            timeout: Override the default request timeout (seconds).

        Returns:
            PagedResponseFolderableDto

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 423, 429, 500).
        """

        def _fetch(_cursor: str | None) -> httpx.Response:
            return self._client.request(
                "GET",
                self._api,
                "/api/v1/entity",
                query_params={
                    "name": name,
                    "description": description,
                    "type": type_,
                    "limit": limit,
                    "offset": offset,
                    "cursor": _cursor,
                },
                timeout=timeout,
            )

        _body_result = paginate_all(_fetch, extract_wdata_cursor, "body")
        return PagedResponseFolderableDto.model_validate(_body_result)

    async def search_async(
        self,
        *,
        name: Optional[str] = None,
        description: Optional[str] = None,
        type_: Optional[list[int]] = None,
        limit: Optional[int] = 1000,
        offset: Optional[int] = None,
        timeout: Optional[float] = None,
    ) -> PagedResponseFolderableDto:
        """Search (async)

        Returns a list of all entities that match the provided criteria. Both
        name and
        description are fuzzy matches; they match _any_ entity that contains the
        provided
        string. The type is used to filter results based on the provided type of
        entity.
        The consumer must have READ access on all returned entities.

        Args:
            name: The name to use when fuzzy-matching entities
            description: The description to use when fuzzy-matching entities
            type_: To limit the scope, the type of entity to return in the results
            limit: The number of folders to return, from 1 to 1000; by default, 1000
            offset: The item to start with on the page, greater than or equal to 0; by default, 0
            timeout: Override the default request timeout (seconds).

        Returns:
            PagedResponseFolderableDto

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 423, 429, 500).
        """

        async def _fetch(_cursor: str | None) -> httpx.Response:
            return await self._client.request_async(
                "GET",
                self._api,
                "/api/v1/entity",
                query_params={
                    "name": name,
                    "description": description,
                    "type": type_,
                    "limit": limit,
                    "offset": offset,
                    "cursor": _cursor,
                },
                timeout=timeout,
            )

        _body_result = await paginate_all_async(_fetch, extract_wdata_cursor, "body")
        return PagedResponseFolderableDto.model_validate(_body_result)

    def get_files(
        self,
        *,
        table_id: str,
        limit: Optional[int] = None,
        offset: Optional[int] = None,
        sort_order: Optional[Literal["asc", "desc"]] = None,
        sort_by: Optional[Literal["asc", "desc"]] = None,
        search_text: Optional[str] = None,
        timeout: Optional[float] = None,
    ) -> PagedResponseFileMetaDto:
        """Retrieve a list of files

        Returns a paged list of all files associated with the provided table ID,
        as well
        as metadata associated with each file.

        Args:
            table_id: The unique table identifier associated with this file
            limit: The number of files to return, from 1 to 1000; by default, 1000
            offset: The item to start with on the page, greater than or equal to 0; by default, 0
            sort_order: The sort order for the files being returned
            sort_by: The column to use the sort order on
            search_text: The text to filter the results upon; matching the file name
            timeout: Override the default request timeout (seconds).

        Returns:
            PagedResponseFileMetaDto

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 423, 429, 500).
        """

        def _fetch(_cursor: str | None) -> httpx.Response:
            return self._client.request(
                "GET",
                self._api,
                "/api/v1/file",
                query_params={
                    "tableId": table_id,
                    "limit": limit,
                    "offset": offset,
                    "sortOrder": sort_order,
                    "sortBy": sort_by,
                    "searchText": search_text,
                    "cursor": _cursor,
                },
                timeout=timeout,
            )

        _body_result = paginate_all(_fetch, extract_wdata_cursor, "body")
        return PagedResponseFileMetaDto.model_validate(_body_result)

    async def get_files_async(
        self,
        *,
        table_id: str,
        limit: Optional[int] = None,
        offset: Optional[int] = None,
        sort_order: Optional[Literal["asc", "desc"]] = None,
        sort_by: Optional[Literal["asc", "desc"]] = None,
        search_text: Optional[str] = None,
        timeout: Optional[float] = None,
    ) -> PagedResponseFileMetaDto:
        """Retrieve a list of files (async)

        Returns a paged list of all files associated with the provided table ID,
        as well
        as metadata associated with each file.

        Args:
            table_id: The unique table identifier associated with this file
            limit: The number of files to return, from 1 to 1000; by default, 1000
            offset: The item to start with on the page, greater than or equal to 0; by default, 0
            sort_order: The sort order for the files being returned
            sort_by: The column to use the sort order on
            search_text: The text to filter the results upon; matching the file name
            timeout: Override the default request timeout (seconds).

        Returns:
            PagedResponseFileMetaDto

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 423, 429, 500).
        """

        async def _fetch(_cursor: str | None) -> httpx.Response:
            return await self._client.request_async(
                "GET",
                self._api,
                "/api/v1/file",
                query_params={
                    "tableId": table_id,
                    "limit": limit,
                    "offset": offset,
                    "sortOrder": sort_order,
                    "sortBy": sort_by,
                    "searchText": search_text,
                    "cursor": _cursor,
                },
                timeout=timeout,
            )

        _body_result = await paginate_all_async(_fetch, extract_wdata_cursor, "body")
        return PagedResponseFileMetaDto.model_validate(_body_result)

    def upload_file(
        self,
        *,
        table_id: str,
        name: Optional[str] = None,
        url: Optional[str] = None,
        source: Optional[str] = None,
        delimiter: Optional[str] = None,
        import_dto: Optional[str] = None,
        body: Optional[dict[str, Any]] = None,
        timeout: Optional[float] = None,
    ) -> BaseResponseFileMetaDto:
        """Upload a single file

                Accepts CSV, TSV, or JSON files, or a ZIP file that contains a single
                CSV, TSV, or
                JSON file. If a ZIP, it must contain a CSV, TSV, or JSON file, and the
                name of the
                CSV, TSV, or JSON file is also used with the imported file. Downloading
                this file
                again downloads the source. Note that all files uploaded must have a
                .csv, .tsv, or .json
                extension. JSON files are expected to have a single JSON record per
                line; a JSON file is
                a series of JSON objects delimited by a newline character.

                Args:
                    table_id: The unique table identifier associated with this file
                    name: No longer in use, here to ensure backwards compatibility
                    url: No longer in use, here to ensure backwards compatibility
                    source: The data source to associate with the file, no more than 255 characters. This
        field is not in use; it only keeps track of the source
                    delimiter: The character to use as a delimiter within the file to separate one field from
        another.  The default is comma
                    import_dto:
                    body: Request body.
                    timeout: Override the default request timeout (seconds).

                Returns:
                    BaseResponseFileMetaDto

                Raises:
                    WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 423, 429, 500).

                Note:
                    This operation uses multipart/form-data. Pass ``body`` as a dict
                    mapping field names to values. For file fields use a tuple::

                        body = {
                            "file": ("filename.csv", open("filename.csv", "rb")),
                            "field": "value",
                        }
        """
        response = self._client.request(
            "POST",
            self._api,
            "/api/v1/file",
            query_params={
                "tableId": table_id,
                "name": name,
                "url": url,
                "source": source,
                "delimiter": delimiter,
                "importDto": import_dto,
            },
            files=body,
            timeout=timeout,
        )
        return BaseResponseFileMetaDto.model_validate(response.json())

    async def upload_file_async(
        self,
        *,
        table_id: str,
        name: Optional[str] = None,
        url: Optional[str] = None,
        source: Optional[str] = None,
        delimiter: Optional[str] = None,
        import_dto: Optional[str] = None,
        body: Optional[dict[str, Any]] = None,
        timeout: Optional[float] = None,
    ) -> BaseResponseFileMetaDto:
        """Upload a single file (async)

                Accepts CSV, TSV, or JSON files, or a ZIP file that contains a single
                CSV, TSV, or
                JSON file. If a ZIP, it must contain a CSV, TSV, or JSON file, and the
                name of the
                CSV, TSV, or JSON file is also used with the imported file. Downloading
                this file
                again downloads the source. Note that all files uploaded must have a
                .csv, .tsv, or .json
                extension. JSON files are expected to have a single JSON record per
                line; a JSON file is
                a series of JSON objects delimited by a newline character.

                Args:
                    table_id: The unique table identifier associated with this file
                    name: No longer in use, here to ensure backwards compatibility
                    url: No longer in use, here to ensure backwards compatibility
                    source: The data source to associate with the file, no more than 255 characters. This
        field is not in use; it only keeps track of the source
                    delimiter: The character to use as a delimiter within the file to separate one field from
        another.  The default is comma
                    import_dto:
                    body: Request body.
                    timeout: Override the default request timeout (seconds).

                Returns:
                    BaseResponseFileMetaDto

                Raises:
                    WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 423, 429, 500).

                Note:
                    This operation uses multipart/form-data. Pass ``body`` as a dict
                    mapping field names to values. For file fields use a tuple::

                        body = {
                            "file": ("filename.csv", open("filename.csv", "rb")),
                            "field": "value",
                        }
        """
        response = await self._client.request_async(
            "POST",
            self._api,
            "/api/v1/file",
            query_params={
                "tableId": table_id,
                "name": name,
                "url": url,
                "source": source,
                "delimiter": delimiter,
                "importDto": import_dto,
            },
            files=body,
            timeout=timeout,
        )
        return BaseResponseFileMetaDto.model_validate(response.json())

    def validate_filename(
        self,
        *,
        table_id: str,
        filename: str,
        timeout: Optional[float] = None,
    ) -> BaseResponseString:
        """Validate whether a file with the filename can be uploaded to the table

        If the filename is valid, this returns 200. If the table already has a
        file with the same name, this returns 409. If the user isn't allowed to
        read the table, or if the table isn't found, this returns 404.

        Args:
            table_id: The ID of the table to upload the file to
            filename: The name of the file to upload
            timeout: Override the default request timeout (seconds).

        Returns:
            BaseResponseString

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 423, 429, 500).
        """
        response = self._client.request(
            "GET",
            self._api,
            "/api/v1/file/validateName",
            query_params={
                "tableId": table_id,
                "filename": filename,
            },
            timeout=timeout,
        )
        return BaseResponseString.model_validate(response.json())

    async def validate_filename_async(
        self,
        *,
        table_id: str,
        filename: str,
        timeout: Optional[float] = None,
    ) -> BaseResponseString:
        """Validate whether a file with the filename can be uploaded to the table (async)

        If the filename is valid, this returns 200. If the table already has a
        file with the same name, this returns 409. If the user isn't allowed to
        read the table, or if the table isn't found, this returns 404.

        Args:
            table_id: The ID of the table to upload the file to
            filename: The name of the file to upload
            timeout: Override the default request timeout (seconds).

        Returns:
            BaseResponseString

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 423, 429, 500).
        """
        response = await self._client.request_async(
            "GET",
            self._api,
            "/api/v1/file/validateName",
            query_params={
                "tableId": table_id,
                "filename": filename,
            },
            timeout=timeout,
        )
        return BaseResponseString.model_validate(response.json())

    def delete_file(
        self,
        *,
        file_id: str,
        timeout: Optional[float] = None,
    ) -> BaseResponseString:
        """Delete a single file

        Unstages the file with the provided ID. The file must have a STAGED
        status; if the
        file isn't STAGED, returns a 409 status. If the file isn't found, this
        is a no-op.

        Args:
            file_id: The unique identifier of the file
            timeout: Override the default request timeout (seconds).

        Returns:
            BaseResponseString

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 423, 429, 500).
        """
        response = self._client.request(
            "DELETE",
            self._api,
            "/api/v1/file/{fileId}",
            path_params={
                "fileId": file_id,
            },
            timeout=timeout,
        )
        return BaseResponseString.model_validate(response.json())

    async def delete_file_async(
        self,
        *,
        file_id: str,
        timeout: Optional[float] = None,
    ) -> BaseResponseString:
        """Delete a single file (async)

        Unstages the file with the provided ID. The file must have a STAGED
        status; if the
        file isn't STAGED, returns a 409 status. If the file isn't found, this
        is a no-op.

        Args:
            file_id: The unique identifier of the file
            timeout: Override the default request timeout (seconds).

        Returns:
            BaseResponseString

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 423, 429, 500).
        """
        response = await self._client.request_async(
            "DELETE",
            self._api,
            "/api/v1/file/{fileId}",
            path_params={
                "fileId": file_id,
            },
            timeout=timeout,
        )
        return BaseResponseString.model_validate(response.json())

    def get_file(
        self,
        *,
        file_id: str,
        timeout: Optional[float] = None,
    ) -> BaseResponseFileMetaDto:
        """Retrieve a single file

        Returns the file meta that matches the provided ID, or a 404 if an
        associated file
        can't be found.

        Args:
            file_id: The unique identifier of the file
            timeout: Override the default request timeout (seconds).

        Returns:
            BaseResponseFileMetaDto

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 423, 429, 500).
        """
        response = self._client.request(
            "GET",
            self._api,
            "/api/v1/file/{fileId}",
            path_params={
                "fileId": file_id,
            },
            timeout=timeout,
        )
        return BaseResponseFileMetaDto.model_validate(response.json())

    async def get_file_async(
        self,
        *,
        file_id: str,
        timeout: Optional[float] = None,
    ) -> BaseResponseFileMetaDto:
        """Retrieve a single file (async)

        Returns the file meta that matches the provided ID, or a 404 if an
        associated file
        can't be found.

        Args:
            file_id: The unique identifier of the file
            timeout: Override the default request timeout (seconds).

        Returns:
            BaseResponseFileMetaDto

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 423, 429, 500).
        """
        response = await self._client.request_async(
            "GET",
            self._api,
            "/api/v1/file/{fileId}",
            path_params={
                "fileId": file_id,
            },
            timeout=timeout,
        )
        return BaseResponseFileMetaDto.model_validate(response.json())

    def download_file_1(
        self,
        *,
        file_id: str,
        timeout: Optional[float] = None,
    ) -> httpx.Response:
        """Download a single file

        Returns a file with the provided ID, which points to a file meta ID.

        Args:
            file_id: The unique identifier of the file
            timeout: Override the default request timeout (seconds).

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 423, 429, 500).
        """
        return self._client.request(
            "GET",
            self._api,
            "/api/v1/file/{fileId}/download",
            path_params={
                "fileId": file_id,
            },
            timeout=timeout,
        )

    async def download_file_1_async(
        self,
        *,
        file_id: str,
        timeout: Optional[float] = None,
    ) -> httpx.Response:
        """Download a single file (async)

        Returns a file with the provided ID, which points to a file meta ID.

        Args:
            file_id: The unique identifier of the file
            timeout: Override the default request timeout (seconds).

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 423, 429, 500).
        """
        return await self._client.request_async(
            "GET",
            self._api,
            "/api/v1/file/{fileId}/download",
            path_params={
                "fileId": file_id,
            },
            timeout=timeout,
        )

    def get_errors(
        self,
        *,
        file_id: str,
        limit: Optional[int] = 50,
        offset: Optional[int] = None,
        timeout: Optional[float] = None,
    ) -> PagedResponseImportErrorDto:
        """Retrieve errors

        Returns a paged list of operation errors during the upload, import, or
        tagging
        processes for the provided file ID, if they exist. This list is
        immutable and may be
        empty if no errors have occurred. If errors exist we recommend fixing
        them and
        reimporting your file

        Args:
            file_id: The unique identifier of the file
            limit: The number of errors to return, from 1 to 50; by default, 50
            offset: The item to start with on the page, greater than or equal to 0; by default, 0
            timeout: Override the default request timeout (seconds).

        Returns:
            PagedResponseImportErrorDto

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 423, 429, 500).
        """

        def _fetch(_cursor: str | None) -> httpx.Response:
            return self._client.request(
                "GET",
                self._api,
                "/api/v1/file/{fileId}/error",
                path_params={
                    "fileId": file_id,
                },
                query_params={
                    "limit": limit,
                    "offset": offset,
                    "cursor": _cursor,
                },
                timeout=timeout,
            )

        _body_result = paginate_all(_fetch, extract_wdata_cursor, "body")
        return PagedResponseImportErrorDto.model_validate(_body_result)

    async def get_errors_async(
        self,
        *,
        file_id: str,
        limit: Optional[int] = 50,
        offset: Optional[int] = None,
        timeout: Optional[float] = None,
    ) -> PagedResponseImportErrorDto:
        """Retrieve errors (async)

        Returns a paged list of operation errors during the upload, import, or
        tagging
        processes for the provided file ID, if they exist. This list is
        immutable and may be
        empty if no errors have occurred. If errors exist we recommend fixing
        them and
        reimporting your file

        Args:
            file_id: The unique identifier of the file
            limit: The number of errors to return, from 1 to 50; by default, 50
            offset: The item to start with on the page, greater than or equal to 0; by default, 0
            timeout: Override the default request timeout (seconds).

        Returns:
            PagedResponseImportErrorDto

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 423, 429, 500).
        """

        async def _fetch(_cursor: str | None) -> httpx.Response:
            return await self._client.request_async(
                "GET",
                self._api,
                "/api/v1/file/{fileId}/error",
                path_params={
                    "fileId": file_id,
                },
                query_params={
                    "limit": limit,
                    "offset": offset,
                    "cursor": _cursor,
                },
                timeout=timeout,
            )

        _body_result = await paginate_all_async(_fetch, extract_wdata_cursor, "body")
        return PagedResponseImportErrorDto.model_validate(_body_result)

    def export_file_to_spreadsheets(
        self,
        *,
        file_id: str,
        url: Optional[str] = None,
        timeout: Optional[float] = None,
    ) -> BaseResponseSpreadsheetInfoDto:
        """Export a file to spreadsheets

        Exports the file ID identified in the path to the spreadsheet identified
        by the
        provided URL. If the URL string is empty, creates and returns a new
        spreadsheet and
        its sheet IDs.

        Args:
            file_id: The unique identifier of the file
            url: URL of the spreadsheet to export to, if present. If not present, a new spreadsheet will be created.
            timeout: Override the default request timeout (seconds).

        Returns:
            BaseResponseSpreadsheetInfoDto

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 423, 429, 500).
        """
        _body: dict[str, Any] = {}
        if url is not None:
            _body["url"] = url
        response = self._client.request(
            "POST",
            self._api,
            "/api/v1/file/{fileId}/export",
            path_params={
                "fileId": file_id,
            },
            json_body=_body or None,
            timeout=timeout,
        )
        return BaseResponseSpreadsheetInfoDto.model_validate(response.json())

    async def export_file_to_spreadsheets_async(
        self,
        *,
        file_id: str,
        url: Optional[str] = None,
        timeout: Optional[float] = None,
    ) -> BaseResponseSpreadsheetInfoDto:
        """Export a file to spreadsheets (async)

        Exports the file ID identified in the path to the spreadsheet identified
        by the
        provided URL. If the URL string is empty, creates and returns a new
        spreadsheet and
        its sheet IDs.

        Args:
            file_id: The unique identifier of the file
            url: URL of the spreadsheet to export to, if present. If not present, a new spreadsheet will be created.
            timeout: Override the default request timeout (seconds).

        Returns:
            BaseResponseSpreadsheetInfoDto

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 423, 429, 500).
        """
        _body: dict[str, Any] = {}
        if url is not None:
            _body["url"] = url
        response = await self._client.request_async(
            "POST",
            self._api,
            "/api/v1/file/{fileId}/export",
            path_params={
                "fileId": file_id,
            },
            json_body=_body or None,
            timeout=timeout,
        )
        return BaseResponseSpreadsheetInfoDto.model_validate(response.json())

    def list_folders(
        self,
        *,
        limit: Optional[int] = 1000,
        offset: Optional[int] = None,
        timeout: Optional[float] = None,
    ) -> PagedResponseFolderDto:
        """Retrieve a list of folders

        Returns a paged list of all folders associated with the workspace.

        Args:
            limit: The number of folders to return, from 1 to 1000; by default, 1000
            offset: The item to start with on the page, greater than or equal to 0; by default, 0
            timeout: Override the default request timeout (seconds).

        Returns:
            PagedResponseFolderDto

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 423, 429, 500).
        """

        def _fetch(_cursor: str | None) -> httpx.Response:
            return self._client.request(
                "GET",
                self._api,
                "/api/v1/folder",
                query_params={
                    "limit": limit,
                    "offset": offset,
                    "cursor": _cursor,
                },
                timeout=timeout,
            )

        _body_result = paginate_all(_fetch, extract_wdata_cursor, "body")
        return PagedResponseFolderDto.model_validate(_body_result)

    async def list_folders_async(
        self,
        *,
        limit: Optional[int] = 1000,
        offset: Optional[int] = None,
        timeout: Optional[float] = None,
    ) -> PagedResponseFolderDto:
        """Retrieve a list of folders (async)

        Returns a paged list of all folders associated with the workspace.

        Args:
            limit: The number of folders to return, from 1 to 1000; by default, 1000
            offset: The item to start with on the page, greater than or equal to 0; by default, 0
            timeout: Override the default request timeout (seconds).

        Returns:
            PagedResponseFolderDto

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 423, 429, 500).
        """

        async def _fetch(_cursor: str | None) -> httpx.Response:
            return await self._client.request_async(
                "GET",
                self._api,
                "/api/v1/folder",
                query_params={
                    "limit": limit,
                    "offset": offset,
                    "cursor": _cursor,
                },
                timeout=timeout,
            )

        _body_result = await paginate_all_async(_fetch, extract_wdata_cursor, "body")
        return PagedResponseFolderDto.model_validate(_body_result)

    def create_folder(
        self,
        *,
        name: str,
        description: Optional[str] = None,
        timeout: Optional[float] = None,
    ) -> BaseResponseFolderDto:
        """Create a new folder

        Creates a folder using the provided information and returns the folder
        meta.

        Args:
            name: The name of the folder
            description: A description of the folder
            timeout: Override the default request timeout (seconds).

        Returns:
            BaseResponseFolderDto

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 423, 429, 500).
        """
        _body: dict[str, Any] = {}
        if name is not None:
            _body["name"] = name
        if description is not None:
            _body["description"] = description
        response = self._client.request(
            "POST",
            self._api,
            "/api/v1/folder",
            json_body=_body or None,
            timeout=timeout,
        )
        return BaseResponseFolderDto.model_validate(response.json())

    async def create_folder_async(
        self,
        *,
        name: str,
        description: Optional[str] = None,
        timeout: Optional[float] = None,
    ) -> BaseResponseFolderDto:
        """Create a new folder (async)

        Creates a folder using the provided information and returns the folder
        meta.

        Args:
            name: The name of the folder
            description: A description of the folder
            timeout: Override the default request timeout (seconds).

        Returns:
            BaseResponseFolderDto

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 423, 429, 500).
        """
        _body: dict[str, Any] = {}
        if name is not None:
            _body["name"] = name
        if description is not None:
            _body["description"] = description
        response = await self._client.request_async(
            "POST",
            self._api,
            "/api/v1/folder",
            json_body=_body or None,
            timeout=timeout,
        )
        return BaseResponseFolderDto.model_validate(response.json())

    def delete_folder(
        self,
        *,
        folder_id: str,
        timeout: Optional[float] = None,
    ) -> BaseResponseString:
        """Delete a single folder

        Deletes the folder with the provided ID.  If the folder is not found,
        this is a
        no-op. <b>All files and sub-folders are also recursively deleted.</b>

        Args:
            folder_id: The unique identifier of the folder
            timeout: Override the default request timeout (seconds).

        Returns:
            BaseResponseString

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 423, 429, 500).
        """
        response = self._client.request(
            "DELETE",
            self._api,
            "/api/v1/folder/{folderId}",
            path_params={
                "folderId": folder_id,
            },
            timeout=timeout,
        )
        return BaseResponseString.model_validate(response.json())

    async def delete_folder_async(
        self,
        *,
        folder_id: str,
        timeout: Optional[float] = None,
    ) -> BaseResponseString:
        """Delete a single folder (async)

        Deletes the folder with the provided ID.  If the folder is not found,
        this is a
        no-op. <b>All files and sub-folders are also recursively deleted.</b>

        Args:
            folder_id: The unique identifier of the folder
            timeout: Override the default request timeout (seconds).

        Returns:
            BaseResponseString

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 423, 429, 500).
        """
        response = await self._client.request_async(
            "DELETE",
            self._api,
            "/api/v1/folder/{folderId}",
            path_params={
                "folderId": folder_id,
            },
            timeout=timeout,
        )
        return BaseResponseString.model_validate(response.json())

    def get_folder(
        self,
        *,
        folder_id: str,
        timeout: Optional[float] = None,
    ) -> BaseResponseFolderDto:
        """Retrieve a single folder

        Returns a folder with the provided ID, or a 404 if no matching folder is
        found.

        Args:
            folder_id: The unique identifier of the folder
            timeout: Override the default request timeout (seconds).

        Returns:
            BaseResponseFolderDto

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 423, 429, 500).
        """
        response = self._client.request(
            "GET",
            self._api,
            "/api/v1/folder/{folderId}",
            path_params={
                "folderId": folder_id,
            },
            timeout=timeout,
        )
        return BaseResponseFolderDto.model_validate(response.json())

    async def get_folder_async(
        self,
        *,
        folder_id: str,
        timeout: Optional[float] = None,
    ) -> BaseResponseFolderDto:
        """Retrieve a single folder (async)

        Returns a folder with the provided ID, or a 404 if no matching folder is
        found.

        Args:
            folder_id: The unique identifier of the folder
            timeout: Override the default request timeout (seconds).

        Returns:
            BaseResponseFolderDto

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 423, 429, 500).
        """
        response = await self._client.request_async(
            "GET",
            self._api,
            "/api/v1/folder/{folderId}",
            path_params={
                "folderId": folder_id,
            },
            timeout=timeout,
        )
        return BaseResponseFolderDto.model_validate(response.json())

    def update_folder(
        self,
        *,
        folder_id: str,
        name: str,
        description: Optional[str] = None,
        timeout: Optional[float] = None,
    ) -> BaseResponseFolderDto:
        """Update a single folder

        Updates the folder that matches the provided ID with the details
        provided in the
        body.

        Args:
            folder_id: The unique identifier of the folder
            name: The name of the folder
            description: A description of the folder
            timeout: Override the default request timeout (seconds).

        Returns:
            BaseResponseFolderDto

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 423, 429, 500).
        """
        _body: dict[str, Any] = {}
        if name is not None:
            _body["name"] = name
        if description is not None:
            _body["description"] = description
        response = self._client.request(
            "PUT",
            self._api,
            "/api/v1/folder/{folderId}",
            path_params={
                "folderId": folder_id,
            },
            json_body=_body or None,
            timeout=timeout,
        )
        return BaseResponseFolderDto.model_validate(response.json())

    async def update_folder_async(
        self,
        *,
        folder_id: str,
        name: str,
        description: Optional[str] = None,
        timeout: Optional[float] = None,
    ) -> BaseResponseFolderDto:
        """Update a single folder (async)

        Updates the folder that matches the provided ID with the details
        provided in the
        body.

        Args:
            folder_id: The unique identifier of the folder
            name: The name of the folder
            description: A description of the folder
            timeout: Override the default request timeout (seconds).

        Returns:
            BaseResponseFolderDto

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 423, 429, 500).
        """
        _body: dict[str, Any] = {}
        if name is not None:
            _body["name"] = name
        if description is not None:
            _body["description"] = description
        response = await self._client.request_async(
            "PUT",
            self._api,
            "/api/v1/folder/{folderId}",
            path_params={
                "folderId": folder_id,
            },
            json_body=_body or None,
            timeout=timeout,
        )
        return BaseResponseFolderDto.model_validate(response.json())

    def list_children(
        self,
        *,
        folder_id: str,
        limit: Optional[int] = 1000,
        offset: Optional[int] = None,
        timeout: Optional[float] = None,
    ) -> PagedResponseFolderableDto:
        """Retrieve list of folder contents

        Returns a paged list of all children whose parent ID matches the
        provided folder
        ID.  If the folder ID in the path is the literal 'null' value, returns a
        list of
        all entities with no parent.

        Args:
            folder_id: The unique identifier of the folder
            limit: The number of folders to return, from 1 to 1000; by default, 1000
            offset: The item to start with on the page, greater than or equal to 0; by default, 0
            timeout: Override the default request timeout (seconds).

        Returns:
            PagedResponseFolderableDto

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 423, 429, 500).
        """

        def _fetch(_cursor: str | None) -> httpx.Response:
            return self._client.request(
                "GET",
                self._api,
                "/api/v1/folder/{folderId}/children",
                path_params={
                    "folderId": folder_id,
                },
                query_params={
                    "limit": limit,
                    "offset": offset,
                    "cursor": _cursor,
                },
                timeout=timeout,
            )

        _body_result = paginate_all(_fetch, extract_wdata_cursor, "body")
        return PagedResponseFolderableDto.model_validate(_body_result)

    async def list_children_async(
        self,
        *,
        folder_id: str,
        limit: Optional[int] = 1000,
        offset: Optional[int] = None,
        timeout: Optional[float] = None,
    ) -> PagedResponseFolderableDto:
        """Retrieve list of folder contents (async)

        Returns a paged list of all children whose parent ID matches the
        provided folder
        ID.  If the folder ID in the path is the literal 'null' value, returns a
        list of
        all entities with no parent.

        Args:
            folder_id: The unique identifier of the folder
            limit: The number of folders to return, from 1 to 1000; by default, 1000
            offset: The item to start with on the page, greater than or equal to 0; by default, 0
            timeout: Override the default request timeout (seconds).

        Returns:
            PagedResponseFolderableDto

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 423, 429, 500).
        """

        async def _fetch(_cursor: str | None) -> httpx.Response:
            return await self._client.request_async(
                "GET",
                self._api,
                "/api/v1/folder/{folderId}/children",
                path_params={
                    "folderId": folder_id,
                },
                query_params={
                    "limit": limit,
                    "offset": offset,
                    "cursor": _cursor,
                },
                timeout=timeout,
            )

        _body_result = await paginate_all_async(_fetch, extract_wdata_cursor, "body")
        return PagedResponseFolderableDto.model_validate(_body_result)

    def set_children(
        self,
        *,
        folder_id: str,
        body: list[FolderableDto],
        timeout: Optional[float] = None,
    ) -> BaseResponseCollectionFolderableDto:
        """Move content into a folder

        Sets the children of a folder using the entities' types and IDs provided
        in the
        body. If the entities previously resided under a folder, including the
        root,
        they move to the folder with the provided ID. If the provided ID is
        'null',
        the entities move to the root folder.

        Args:
            folder_id: The unique identifier of the folder
            body: Request body.
            timeout: Override the default request timeout (seconds).

        Returns:
            BaseResponseCollectionFolderableDto

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 423, 429, 500).
        """
        response = self._client.request(
            "POST",
            self._api,
            "/api/v1/folder/{folderId}/children",
            path_params={
                "folderId": folder_id,
            },
            json_body=body,
            timeout=timeout,
        )
        return BaseResponseCollectionFolderableDto.model_validate(response.json())

    async def set_children_async(
        self,
        *,
        folder_id: str,
        body: list[FolderableDto],
        timeout: Optional[float] = None,
    ) -> BaseResponseCollectionFolderableDto:
        """Move content into a folder (async)

        Sets the children of a folder using the entities' types and IDs provided
        in the
        body. If the entities previously resided under a folder, including the
        root,
        they move to the folder with the provided ID. If the provided ID is
        'null',
        the entities move to the root folder.

        Args:
            folder_id: The unique identifier of the folder
            body: Request body.
            timeout: Override the default request timeout (seconds).

        Returns:
            BaseResponseCollectionFolderableDto

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 423, 429, 500).
        """
        response = await self._client.request_async(
            "POST",
            self._api,
            "/api/v1/folder/{folderId}/children",
            path_params={
                "folderId": folder_id,
            },
            json_body=body,
            timeout=timeout,
        )
        return BaseResponseCollectionFolderableDto.model_validate(response.json())

    def list_parameters(
        self,
        *,
        limit: Optional[int] = 1000,
        offset: Optional[int] = None,
        timeout: Optional[float] = None,
    ) -> PagedResponseGlobalParameterDto:
        """Get Parameters

                Returns a list of all parameters associated with the workspace.  By
                default, these
                parameters are ordered by their names in ascending order.

                Args:
                    limit: The number of parameters to return, must be between 1 and 1000, will default
        to 1000
                    offset: The item to start with on the page, must be greater than or equal to 0, will default to 0
                    timeout: Override the default request timeout (seconds).

                Returns:
                    PagedResponseGlobalParameterDto

                Raises:
                    WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 423, 429, 500).
        """

        def _fetch(_cursor: str | None) -> httpx.Response:
            return self._client.request(
                "GET",
                self._api,
                "/api/v1/parameter",
                query_params={
                    "limit": limit,
                    "offset": offset,
                    "cursor": _cursor,
                },
                timeout=timeout,
            )

        _body_result = paginate_all(_fetch, extract_wdata_cursor, "body")
        return PagedResponseGlobalParameterDto.model_validate(_body_result)

    async def list_parameters_async(
        self,
        *,
        limit: Optional[int] = 1000,
        offset: Optional[int] = None,
        timeout: Optional[float] = None,
    ) -> PagedResponseGlobalParameterDto:
        """Get Parameters (async)

                Returns a list of all parameters associated with the workspace.  By
                default, these
                parameters are ordered by their names in ascending order.

                Args:
                    limit: The number of parameters to return, must be between 1 and 1000, will default
        to 1000
                    offset: The item to start with on the page, must be greater than or equal to 0, will default to 0
                    timeout: Override the default request timeout (seconds).

                Returns:
                    PagedResponseGlobalParameterDto

                Raises:
                    WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 423, 429, 500).
        """

        async def _fetch(_cursor: str | None) -> httpx.Response:
            return await self._client.request_async(
                "GET",
                self._api,
                "/api/v1/parameter",
                query_params={
                    "limit": limit,
                    "offset": offset,
                    "cursor": _cursor,
                },
                timeout=timeout,
            )

        _body_result = await paginate_all_async(_fetch, extract_wdata_cursor, "body")
        return PagedResponseGlobalParameterDto.model_validate(_body_result)

    def create_parameter(
        self,
        *,
        mode: Literal["scalar", "singleSelect", "multiSelect"],
        name: str,
        type_: Literal[
            "string",
            "bytes",
            "integer",
            "float",
            "boolean",
            "timestamp",
            "date",
            "time",
            "datetime",
            "global_parameter",
            "nested_query_parameter",
        ],
        description: Optional[str] = None,
        label: Optional[str] = None,
        overridable: Optional[bool] = None,
        select_list_id: Optional[str] = None,
        value: Optional[dict[str, Any]] = None,
        timeout: Optional[float] = None,
    ) -> BaseResponseGlobalParameterDto:
        """Create parameter

                Creates a parameter.  If there is a parameter with the same ID, a 409 is
                returned.

                Args:
                    mode: The mode of the parameter
                    name: The name of the parameter
                    type_: The type of the parameter
                    description: The description of the parameter
                    label: The label for the query parameter
                    overridable: Denotes if this parameter can be overridden later in the process, either when the
        query is created or executed.  The default is true; it can be overridden.
                    select_list_id: If mode is select, this must be populated and is a reference to a select list from
        which choices will be derived.
                    value: The default value of the parameter
                    timeout: Override the default request timeout (seconds).

                Returns:
                    BaseResponseGlobalParameterDto

                Raises:
                    WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 423, 429, 500).
        """
        _body: dict[str, Any] = {}
        if mode is not None:
            _body["mode"] = mode
        if name is not None:
            _body["name"] = name
        if type_ is not None:
            _body["type"] = type_
        if description is not None:
            _body["description"] = description
        if label is not None:
            _body["label"] = label
        if overridable is not None:
            _body["overridable"] = overridable
        if select_list_id is not None:
            _body["selectListId"] = select_list_id
        if value is not None:
            _body["value"] = value
        response = self._client.request(
            "POST",
            self._api,
            "/api/v1/parameter",
            json_body=_body or None,
            timeout=timeout,
        )
        return BaseResponseGlobalParameterDto.model_validate(response.json())

    async def create_parameter_async(
        self,
        *,
        mode: Literal["scalar", "singleSelect", "multiSelect"],
        name: str,
        type_: Literal[
            "string",
            "bytes",
            "integer",
            "float",
            "boolean",
            "timestamp",
            "date",
            "time",
            "datetime",
            "global_parameter",
            "nested_query_parameter",
        ],
        description: Optional[str] = None,
        label: Optional[str] = None,
        overridable: Optional[bool] = None,
        select_list_id: Optional[str] = None,
        value: Optional[dict[str, Any]] = None,
        timeout: Optional[float] = None,
    ) -> BaseResponseGlobalParameterDto:
        """Create parameter (async)

                Creates a parameter.  If there is a parameter with the same ID, a 409 is
                returned.

                Args:
                    mode: The mode of the parameter
                    name: The name of the parameter
                    type_: The type of the parameter
                    description: The description of the parameter
                    label: The label for the query parameter
                    overridable: Denotes if this parameter can be overridden later in the process, either when the
        query is created or executed.  The default is true; it can be overridden.
                    select_list_id: If mode is select, this must be populated and is a reference to a select list from
        which choices will be derived.
                    value: The default value of the parameter
                    timeout: Override the default request timeout (seconds).

                Returns:
                    BaseResponseGlobalParameterDto

                Raises:
                    WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 423, 429, 500).
        """
        _body: dict[str, Any] = {}
        if mode is not None:
            _body["mode"] = mode
        if name is not None:
            _body["name"] = name
        if type_ is not None:
            _body["type"] = type_
        if description is not None:
            _body["description"] = description
        if label is not None:
            _body["label"] = label
        if overridable is not None:
            _body["overridable"] = overridable
        if select_list_id is not None:
            _body["selectListId"] = select_list_id
        if value is not None:
            _body["value"] = value
        response = await self._client.request_async(
            "POST",
            self._api,
            "/api/v1/parameter",
            json_body=_body or None,
            timeout=timeout,
        )
        return BaseResponseGlobalParameterDto.model_validate(response.json())

    def delete_parameter(
        self,
        *,
        parameter_id: str,
        timeout: Optional[float] = None,
    ) -> BaseResponseString:
        """Delete Parameter

        Deletes the parameter with the provided parameter ID.  If the parameter
        is not found, this is a no-op.

        Args:
            parameter_id: The unique identifier of the parameter
            timeout: Override the default request timeout (seconds).

        Returns:
            BaseResponseString

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 423, 429, 500).
        """
        response = self._client.request(
            "DELETE",
            self._api,
            "/api/v1/parameter/{parameterId}",
            path_params={
                "parameterId": parameter_id,
            },
            timeout=timeout,
        )
        return BaseResponseString.model_validate(response.json())

    async def delete_parameter_async(
        self,
        *,
        parameter_id: str,
        timeout: Optional[float] = None,
    ) -> BaseResponseString:
        """Delete Parameter (async)

        Deletes the parameter with the provided parameter ID.  If the parameter
        is not found, this is a no-op.

        Args:
            parameter_id: The unique identifier of the parameter
            timeout: Override the default request timeout (seconds).

        Returns:
            BaseResponseString

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 423, 429, 500).
        """
        response = await self._client.request_async(
            "DELETE",
            self._api,
            "/api/v1/parameter/{parameterId}",
            path_params={
                "parameterId": parameter_id,
            },
            timeout=timeout,
        )
        return BaseResponseString.model_validate(response.json())

    def get_parameter(
        self,
        *,
        parameter_id: str,
        timeout: Optional[float] = None,
    ) -> BaseResponseGlobalParameterDto:
        """Get Parameter

        Returns a parameter matching the provided parameter ID.  If no matching
        entity can be found, a 404 status is returned.

        Args:
            parameter_id: The unique identifier of the parameter
            timeout: Override the default request timeout (seconds).

        Returns:
            BaseResponseGlobalParameterDto

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 423, 429, 500).
        """
        response = self._client.request(
            "GET",
            self._api,
            "/api/v1/parameter/{parameterId}",
            path_params={
                "parameterId": parameter_id,
            },
            timeout=timeout,
        )
        return BaseResponseGlobalParameterDto.model_validate(response.json())

    async def get_parameter_async(
        self,
        *,
        parameter_id: str,
        timeout: Optional[float] = None,
    ) -> BaseResponseGlobalParameterDto:
        """Get Parameter (async)

        Returns a parameter matching the provided parameter ID.  If no matching
        entity can be found, a 404 status is returned.

        Args:
            parameter_id: The unique identifier of the parameter
            timeout: Override the default request timeout (seconds).

        Returns:
            BaseResponseGlobalParameterDto

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 423, 429, 500).
        """
        response = await self._client.request_async(
            "GET",
            self._api,
            "/api/v1/parameter/{parameterId}",
            path_params={
                "parameterId": parameter_id,
            },
            timeout=timeout,
        )
        return BaseResponseGlobalParameterDto.model_validate(response.json())

    def update_parameter(
        self,
        *,
        parameter_id: str,
        mode: Literal["scalar", "singleSelect", "multiSelect"],
        name: str,
        type_: Literal[
            "string",
            "bytes",
            "integer",
            "float",
            "boolean",
            "timestamp",
            "date",
            "time",
            "datetime",
            "global_parameter",
            "nested_query_parameter",
        ],
        description: Optional[str] = None,
        label: Optional[str] = None,
        overridable: Optional[bool] = None,
        select_list_id: Optional[str] = None,
        value: Optional[dict[str, Any]] = None,
        timeout: Optional[float] = None,
    ) -> BaseResponseGlobalParameterDto:
        """Update Parameter

                Updates the parameter matching the provided ID in the provided payload.

                Args:
                    parameter_id: The unique identifier of the parameter
                    mode: The mode of the parameter
                    name: The name of the parameter
                    type_: The type of the parameter
                    description: The description of the parameter
                    label: The label for the query parameter
                    overridable: Denotes if this parameter can be overridden later in the process, either when the
        query is created or executed.  The default is true; it can be overridden.
                    select_list_id: If mode is select, this must be populated and is a reference to a select list from
        which choices will be derived.
                    value: The default value of the parameter
                    timeout: Override the default request timeout (seconds).

                Returns:
                    BaseResponseGlobalParameterDto

                Raises:
                    WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 423, 429, 500).
        """
        _body: dict[str, Any] = {}
        if mode is not None:
            _body["mode"] = mode
        if name is not None:
            _body["name"] = name
        if type_ is not None:
            _body["type"] = type_
        if description is not None:
            _body["description"] = description
        if label is not None:
            _body["label"] = label
        if overridable is not None:
            _body["overridable"] = overridable
        if select_list_id is not None:
            _body["selectListId"] = select_list_id
        if value is not None:
            _body["value"] = value
        response = self._client.request(
            "PUT",
            self._api,
            "/api/v1/parameter/{parameterId}",
            path_params={
                "parameterId": parameter_id,
            },
            json_body=_body or None,
            timeout=timeout,
        )
        return BaseResponseGlobalParameterDto.model_validate(response.json())

    async def update_parameter_async(
        self,
        *,
        parameter_id: str,
        mode: Literal["scalar", "singleSelect", "multiSelect"],
        name: str,
        type_: Literal[
            "string",
            "bytes",
            "integer",
            "float",
            "boolean",
            "timestamp",
            "date",
            "time",
            "datetime",
            "global_parameter",
            "nested_query_parameter",
        ],
        description: Optional[str] = None,
        label: Optional[str] = None,
        overridable: Optional[bool] = None,
        select_list_id: Optional[str] = None,
        value: Optional[dict[str, Any]] = None,
        timeout: Optional[float] = None,
    ) -> BaseResponseGlobalParameterDto:
        """Update Parameter (async)

                Updates the parameter matching the provided ID in the provided payload.

                Args:
                    parameter_id: The unique identifier of the parameter
                    mode: The mode of the parameter
                    name: The name of the parameter
                    type_: The type of the parameter
                    description: The description of the parameter
                    label: The label for the query parameter
                    overridable: Denotes if this parameter can be overridden later in the process, either when the
        query is created or executed.  The default is true; it can be overridden.
                    select_list_id: If mode is select, this must be populated and is a reference to a select list from
        which choices will be derived.
                    value: The default value of the parameter
                    timeout: Override the default request timeout (seconds).

                Returns:
                    BaseResponseGlobalParameterDto

                Raises:
                    WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 423, 429, 500).
        """
        _body: dict[str, Any] = {}
        if mode is not None:
            _body["mode"] = mode
        if name is not None:
            _body["name"] = name
        if type_ is not None:
            _body["type"] = type_
        if description is not None:
            _body["description"] = description
        if label is not None:
            _body["label"] = label
        if overridable is not None:
            _body["overridable"] = overridable
        if select_list_id is not None:
            _body["selectListId"] = select_list_id
        if value is not None:
            _body["value"] = value
        response = await self._client.request_async(
            "PUT",
            self._api,
            "/api/v1/parameter/{parameterId}",
            path_params={
                "parameterId": parameter_id,
            },
            json_body=_body or None,
            timeout=timeout,
        )
        return BaseResponseGlobalParameterDto.model_validate(response.json())

    def list_pivot_views(
        self,
        *,
        query_id: str,
        limit: Optional[int] = 1000,
        offset: Optional[int] = None,
        timeout: Optional[float] = None,
    ) -> PagedResponsePivotViewDto:
        """Retrieve a list of pivot views

        Returns a paged list of views in the workspace of the request. If
        queryId is provided, the results are limited to only views associated
        with the query ID.

        Args:
            query_id: The unique query identifier to filter the views
            limit: The number of views to return, from 1 to 1000; by default, 1000
            offset: The item to start with on the page, greater than or equal to 0; by default, 0
            timeout: Override the default request timeout (seconds).

        Returns:
            PagedResponsePivotViewDto

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 423, 429, 500).
        """

        def _fetch(_cursor: str | None) -> httpx.Response:
            return self._client.request(
                "GET",
                self._api,
                "/api/v1/pivotview",
                query_params={
                    "queryId": query_id,
                    "limit": limit,
                    "offset": offset,
                    "cursor": _cursor,
                },
                timeout=timeout,
            )

        _body_result = paginate_all(_fetch, extract_wdata_cursor, "body")
        return PagedResponsePivotViewDto.model_validate(_body_result)

    async def list_pivot_views_async(
        self,
        *,
        query_id: str,
        limit: Optional[int] = 1000,
        offset: Optional[int] = None,
        timeout: Optional[float] = None,
    ) -> PagedResponsePivotViewDto:
        """Retrieve a list of pivot views (async)

        Returns a paged list of views in the workspace of the request. If
        queryId is provided, the results are limited to only views associated
        with the query ID.

        Args:
            query_id: The unique query identifier to filter the views
            limit: The number of views to return, from 1 to 1000; by default, 1000
            offset: The item to start with on the page, greater than or equal to 0; by default, 0
            timeout: Override the default request timeout (seconds).

        Returns:
            PagedResponsePivotViewDto

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 423, 429, 500).
        """

        async def _fetch(_cursor: str | None) -> httpx.Response:
            return await self._client.request_async(
                "GET",
                self._api,
                "/api/v1/pivotview",
                query_params={
                    "queryId": query_id,
                    "limit": limit,
                    "offset": offset,
                    "cursor": _cursor,
                },
                timeout=timeout,
            )

        _body_result = await paginate_all_async(_fetch, extract_wdata_cursor, "body")
        return PagedResponsePivotViewDto.model_validate(_body_result)

    def create_pivot_view(
        self,
        *,
        name: str,
        query_id: str,
        additional_meta: Optional[dict[str, Any]] = None,
        description: Optional[str] = None,
        query_result_id: Optional[str] = None,
        timeout: Optional[float] = None,
    ) -> BaseResponsePivotViewDto:
        """Create a new pivot view

                Creates a view from the provided information. Currently, persists the
                provided
                `additionalMetadata` field, which can store an arbitrary JSON definition
                of a pivot
                table view. This pivot table must be associated with a query, and can
                optionally be
                associated with a query result. When a query is deleted, its associated
                views are
                also deleted.

                Args:
                    name: Name of the pivot view. The maximum size is 255 characters.
                    query_id: The query to associate with this pivot view. This value is required and cannot be
        updated after the pivot is created. Any attempt to update the query ID is ignored.
                    additional_meta: User-defined metadata to attach to the pivot view. This is any arbitrary JSON object and is not required.
                    description: The description of the pivot view
                    query_result_id: An optional query result id to associate with this pivot view. If associated, saving a pivot view will cause an existence check on the related query result.  This value is not required. The query id on the query result must match this pivot's query ID.
                    timeout: Override the default request timeout (seconds).

                Returns:
                    BaseResponsePivotViewDto

                Raises:
                    WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 423, 429, 500).
        """
        _body: dict[str, Any] = {}
        if name is not None:
            _body["name"] = name
        if query_id is not None:
            _body["queryId"] = query_id
        if additional_meta is not None:
            _body["additionalMeta"] = additional_meta
        if description is not None:
            _body["description"] = description
        if query_result_id is not None:
            _body["queryResultId"] = query_result_id
        response = self._client.request(
            "POST",
            self._api,
            "/api/v1/pivotview",
            json_body=_body or None,
            timeout=timeout,
        )
        return BaseResponsePivotViewDto.model_validate(response.json())

    async def create_pivot_view_async(
        self,
        *,
        name: str,
        query_id: str,
        additional_meta: Optional[dict[str, Any]] = None,
        description: Optional[str] = None,
        query_result_id: Optional[str] = None,
        timeout: Optional[float] = None,
    ) -> BaseResponsePivotViewDto:
        """Create a new pivot view (async)

                Creates a view from the provided information. Currently, persists the
                provided
                `additionalMetadata` field, which can store an arbitrary JSON definition
                of a pivot
                table view. This pivot table must be associated with a query, and can
                optionally be
                associated with a query result. When a query is deleted, its associated
                views are
                also deleted.

                Args:
                    name: Name of the pivot view. The maximum size is 255 characters.
                    query_id: The query to associate with this pivot view. This value is required and cannot be
        updated after the pivot is created. Any attempt to update the query ID is ignored.
                    additional_meta: User-defined metadata to attach to the pivot view. This is any arbitrary JSON object and is not required.
                    description: The description of the pivot view
                    query_result_id: An optional query result id to associate with this pivot view. If associated, saving a pivot view will cause an existence check on the related query result.  This value is not required. The query id on the query result must match this pivot's query ID.
                    timeout: Override the default request timeout (seconds).

                Returns:
                    BaseResponsePivotViewDto

                Raises:
                    WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 423, 429, 500).
        """
        _body: dict[str, Any] = {}
        if name is not None:
            _body["name"] = name
        if query_id is not None:
            _body["queryId"] = query_id
        if additional_meta is not None:
            _body["additionalMeta"] = additional_meta
        if description is not None:
            _body["description"] = description
        if query_result_id is not None:
            _body["queryResultId"] = query_result_id
        response = await self._client.request_async(
            "POST",
            self._api,
            "/api/v1/pivotview",
            json_body=_body or None,
            timeout=timeout,
        )
        return BaseResponsePivotViewDto.model_validate(response.json())

    def delete_pivot_view(
        self,
        *,
        pivot_view_id: str,
        timeout: Optional[float] = None,
    ) -> BaseResponseString:
        """Delete a single pivot view

        Deletes a view that matches the provided ID.  This is an administrative
        method and
        should be assumed a hard-delete, given no capability to restore a
        deleted view is
        available.  A no-op if no such view exists.

        Args:
            pivot_view_id: The unique identifier of the pivot view
            timeout: Override the default request timeout (seconds).

        Returns:
            BaseResponseString

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 423, 429, 500).
        """
        response = self._client.request(
            "DELETE",
            self._api,
            "/api/v1/pivotview/{pivotViewId}",
            path_params={
                "pivotViewId": pivot_view_id,
            },
            timeout=timeout,
        )
        return BaseResponseString.model_validate(response.json())

    async def delete_pivot_view_async(
        self,
        *,
        pivot_view_id: str,
        timeout: Optional[float] = None,
    ) -> BaseResponseString:
        """Delete a single pivot view (async)

        Deletes a view that matches the provided ID.  This is an administrative
        method and
        should be assumed a hard-delete, given no capability to restore a
        deleted view is
        available.  A no-op if no such view exists.

        Args:
            pivot_view_id: The unique identifier of the pivot view
            timeout: Override the default request timeout (seconds).

        Returns:
            BaseResponseString

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 423, 429, 500).
        """
        response = await self._client.request_async(
            "DELETE",
            self._api,
            "/api/v1/pivotview/{pivotViewId}",
            path_params={
                "pivotViewId": pivot_view_id,
            },
            timeout=timeout,
        )
        return BaseResponseString.model_validate(response.json())

    def get_pivot_view(
        self,
        *,
        pivot_view_id: str,
        timeout: Optional[float] = None,
    ) -> BaseResponsePivotViewDto:
        """Retrieve a single pivot view

        Returns a view with the provided ID, or a 404 if no view matches the ID.

        Args:
            pivot_view_id: The unique identifier of the pivot view
            timeout: Override the default request timeout (seconds).

        Returns:
            BaseResponsePivotViewDto

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 423, 429, 500).
        """
        response = self._client.request(
            "GET",
            self._api,
            "/api/v1/pivotview/{pivotViewId}",
            path_params={
                "pivotViewId": pivot_view_id,
            },
            timeout=timeout,
        )
        return BaseResponsePivotViewDto.model_validate(response.json())

    async def get_pivot_view_async(
        self,
        *,
        pivot_view_id: str,
        timeout: Optional[float] = None,
    ) -> BaseResponsePivotViewDto:
        """Retrieve a single pivot view (async)

        Returns a view with the provided ID, or a 404 if no view matches the ID.

        Args:
            pivot_view_id: The unique identifier of the pivot view
            timeout: Override the default request timeout (seconds).

        Returns:
            BaseResponsePivotViewDto

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 423, 429, 500).
        """
        response = await self._client.request_async(
            "GET",
            self._api,
            "/api/v1/pivotview/{pivotViewId}",
            path_params={
                "pivotViewId": pivot_view_id,
            },
            timeout=timeout,
        )
        return BaseResponsePivotViewDto.model_validate(response.json())

    def update_pivot_view(
        self,
        *,
        pivot_view_id: str,
        name: str,
        query_id: str,
        additional_meta: Optional[dict[str, Any]] = None,
        description: Optional[str] = None,
        query_result_id: Optional[str] = None,
        timeout: Optional[float] = None,
    ) -> BaseResponsePivotViewDto:
        """Update a single pivot view

                Updates the view that matches the provided ID with the details provided
                in the
                body. The associated query can't be updated, so providing the query ID
                has no effect.

                Args:
                    pivot_view_id: The unique identifier of the pivot view
                    name: Name of the pivot view. The maximum size is 255 characters.
                    query_id: The query to associate with this pivot view. This value is required and cannot be
        updated after the pivot is created. Any attempt to update the query ID is ignored.
                    additional_meta: User-defined metadata to attach to the pivot view. This is any arbitrary JSON object and is not required.
                    description: The description of the pivot view
                    query_result_id: An optional query result id to associate with this pivot view. If associated, saving a pivot view will cause an existence check on the related query result.  This value is not required. The query id on the query result must match this pivot's query ID.
                    timeout: Override the default request timeout (seconds).

                Returns:
                    BaseResponsePivotViewDto

                Raises:
                    WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 423, 429, 500).
        """
        _body: dict[str, Any] = {}
        if name is not None:
            _body["name"] = name
        if query_id is not None:
            _body["queryId"] = query_id
        if additional_meta is not None:
            _body["additionalMeta"] = additional_meta
        if description is not None:
            _body["description"] = description
        if query_result_id is not None:
            _body["queryResultId"] = query_result_id
        response = self._client.request(
            "PUT",
            self._api,
            "/api/v1/pivotview/{pivotViewId}",
            path_params={
                "pivotViewId": pivot_view_id,
            },
            json_body=_body or None,
            timeout=timeout,
        )
        return BaseResponsePivotViewDto.model_validate(response.json())

    async def update_pivot_view_async(
        self,
        *,
        pivot_view_id: str,
        name: str,
        query_id: str,
        additional_meta: Optional[dict[str, Any]] = None,
        description: Optional[str] = None,
        query_result_id: Optional[str] = None,
        timeout: Optional[float] = None,
    ) -> BaseResponsePivotViewDto:
        """Update a single pivot view (async)

                Updates the view that matches the provided ID with the details provided
                in the
                body. The associated query can't be updated, so providing the query ID
                has no effect.

                Args:
                    pivot_view_id: The unique identifier of the pivot view
                    name: Name of the pivot view. The maximum size is 255 characters.
                    query_id: The query to associate with this pivot view. This value is required and cannot be
        updated after the pivot is created. Any attempt to update the query ID is ignored.
                    additional_meta: User-defined metadata to attach to the pivot view. This is any arbitrary JSON object and is not required.
                    description: The description of the pivot view
                    query_result_id: An optional query result id to associate with this pivot view. If associated, saving a pivot view will cause an existence check on the related query result.  This value is not required. The query id on the query result must match this pivot's query ID.
                    timeout: Override the default request timeout (seconds).

                Returns:
                    BaseResponsePivotViewDto

                Raises:
                    WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 423, 429, 500).
        """
        _body: dict[str, Any] = {}
        if name is not None:
            _body["name"] = name
        if query_id is not None:
            _body["queryId"] = query_id
        if additional_meta is not None:
            _body["additionalMeta"] = additional_meta
        if description is not None:
            _body["description"] = description
        if query_result_id is not None:
            _body["queryResultId"] = query_result_id
        response = await self._client.request_async(
            "PUT",
            self._api,
            "/api/v1/pivotview/{pivotViewId}",
            path_params={
                "pivotViewId": pivot_view_id,
            },
            json_body=_body or None,
            timeout=timeout,
        )
        return BaseResponsePivotViewDto.model_validate(response.json())

    def list_queries(
        self,
        *,
        limit: Optional[int] = 1000,
        offset: Optional[int] = None,
        ids: Optional[list[str]] = None,
        timeout: Optional[float] = None,
    ) -> PagedResponseQueryDto:
        """Retrieve list of queries

        Returns a list of all non-temporary queries associated with the
        workspace. By default, these queries are ordered by their names, in
        ascending order.

        Args:
            limit: The number of queries to return, from 1 to 1000; by default, 1000
            offset: The item to start with on the page, greater than or equal to 0; by default, 0
            ids: A list of ids to filter the returned list by
            timeout: Override the default request timeout (seconds).

        Returns:
            PagedResponseQueryDto

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 423, 429, 500).
        """

        def _fetch(_cursor: str | None) -> httpx.Response:
            return self._client.request(
                "GET",
                self._api,
                "/api/v1/query",
                query_params={
                    "limit": limit,
                    "offset": offset,
                    "ids": ids,
                    "cursor": _cursor,
                },
                timeout=timeout,
            )

        _body_result = paginate_all(_fetch, extract_wdata_cursor, "body")
        return PagedResponseQueryDto.model_validate(_body_result)

    async def list_queries_async(
        self,
        *,
        limit: Optional[int] = 1000,
        offset: Optional[int] = None,
        ids: Optional[list[str]] = None,
        timeout: Optional[float] = None,
    ) -> PagedResponseQueryDto:
        """Retrieve list of queries (async)

        Returns a list of all non-temporary queries associated with the
        workspace. By default, these queries are ordered by their names, in
        ascending order.

        Args:
            limit: The number of queries to return, from 1 to 1000; by default, 1000
            offset: The item to start with on the page, greater than or equal to 0; by default, 0
            ids: A list of ids to filter the returned list by
            timeout: Override the default request timeout (seconds).

        Returns:
            PagedResponseQueryDto

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 423, 429, 500).
        """

        async def _fetch(_cursor: str | None) -> httpx.Response:
            return await self._client.request_async(
                "GET",
                self._api,
                "/api/v1/query",
                query_params={
                    "limit": limit,
                    "offset": offset,
                    "ids": ids,
                    "cursor": _cursor,
                },
                timeout=timeout,
            )

        _body_result = await paginate_all_async(_fetch, extract_wdata_cursor, "body")
        return PagedResponseQueryDto.model_validate(_body_result)

    def create_query(
        self,
        *,
        name: str,
        query_text: str,
        definition: Optional[PivotDefinitionDto] = None,
        description: Optional[str] = None,
        history_revision: Optional[int] = None,
        is_shared: Optional[bool] = None,
        parameters: Optional[list[QueryParameterDto]] = None,
        primary_query_result_id: Optional[str] = None,
        temporary: Optional[bool] = None,
        timeout: Optional[float] = None,
    ) -> BaseResponseQueryDto:
        """Create a new query

        Creates a query object and validates full permissions to ensure the
        requestor has
        access to all data sources being queried. This endpoint _doesn't_
        execute the query;
        to execute, call the POST /queryresult method.

        Args:
            name: The name of the query
            query_text: Max size is 30000 characters.  Is required.  Must be a valid DML statement.
            definition: The pivot view's definition
            description: The description of the query
            history_revision: Historical revision number of this entity
            is_shared: Whether or not this query is being shared.
            parameters: The query parameters
            primary_query_result_id: The identifier of the primary query result
            temporary: Denotes if this query is meant to be temporary.  Default is false.
            timeout: Override the default request timeout (seconds).

        Returns:
            BaseResponseQueryDto

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 423, 429, 500).
        """
        _body: dict[str, Any] = {}
        if name is not None:
            _body["name"] = name
        if query_text is not None:
            _body["queryText"] = query_text
        if definition is not None:
            _body["definition"] = definition
        if description is not None:
            _body["description"] = description
        if history_revision is not None:
            _body["historyRevision"] = history_revision
        if is_shared is not None:
            _body["isShared"] = is_shared
        if parameters is not None:
            _body["parameters"] = parameters
        if primary_query_result_id is not None:
            _body["primaryQueryResultId"] = primary_query_result_id
        if temporary is not None:
            _body["temporary"] = temporary
        response = self._client.request(
            "POST",
            self._api,
            "/api/v1/query",
            json_body=_body or None,
            timeout=timeout,
        )
        return BaseResponseQueryDto.model_validate(response.json())

    async def create_query_async(
        self,
        *,
        name: str,
        query_text: str,
        definition: Optional[PivotDefinitionDto] = None,
        description: Optional[str] = None,
        history_revision: Optional[int] = None,
        is_shared: Optional[bool] = None,
        parameters: Optional[list[QueryParameterDto]] = None,
        primary_query_result_id: Optional[str] = None,
        temporary: Optional[bool] = None,
        timeout: Optional[float] = None,
    ) -> BaseResponseQueryDto:
        """Create a new query (async)

        Creates a query object and validates full permissions to ensure the
        requestor has
        access to all data sources being queried. This endpoint _doesn't_
        execute the query;
        to execute, call the POST /queryresult method.

        Args:
            name: The name of the query
            query_text: Max size is 30000 characters.  Is required.  Must be a valid DML statement.
            definition: The pivot view's definition
            description: The description of the query
            history_revision: Historical revision number of this entity
            is_shared: Whether or not this query is being shared.
            parameters: The query parameters
            primary_query_result_id: The identifier of the primary query result
            temporary: Denotes if this query is meant to be temporary.  Default is false.
            timeout: Override the default request timeout (seconds).

        Returns:
            BaseResponseQueryDto

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 423, 429, 500).
        """
        _body: dict[str, Any] = {}
        if name is not None:
            _body["name"] = name
        if query_text is not None:
            _body["queryText"] = query_text
        if definition is not None:
            _body["definition"] = definition
        if description is not None:
            _body["description"] = description
        if history_revision is not None:
            _body["historyRevision"] = history_revision
        if is_shared is not None:
            _body["isShared"] = is_shared
        if parameters is not None:
            _body["parameters"] = parameters
        if primary_query_result_id is not None:
            _body["primaryQueryResultId"] = primary_query_result_id
        if temporary is not None:
            _body["temporary"] = temporary
        response = await self._client.request_async(
            "POST",
            self._api,
            "/api/v1/query",
            json_body=_body or None,
            timeout=timeout,
        )
        return BaseResponseQueryDto.model_validate(response.json())

    def get_query_column_data(
        self,
        *,
        query_text: str,
        timeout: Optional[float] = None,
    ) -> BaseResponseQueryColumnDataDto:
        """Retrieve query column data

        Returns a QueryColumnDataDto representing the column data for the given
        query text.
        If the query isn't valid, returns a 400.

        Args:
            query_text: queryText to be parsed, if present and valid.
            timeout: Override the default request timeout (seconds).

        Returns:
            BaseResponseQueryColumnDataDto

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 423, 429, 500).
        """
        _body: dict[str, Any] = {}
        if query_text is not None:
            _body["queryText"] = query_text
        response = self._client.request(
            "POST",
            self._api,
            "/api/v1/query/data",
            json_body=_body or None,
            timeout=timeout,
        )
        return BaseResponseQueryColumnDataDto.model_validate(response.json())

    async def get_query_column_data_async(
        self,
        *,
        query_text: str,
        timeout: Optional[float] = None,
    ) -> BaseResponseQueryColumnDataDto:
        """Retrieve query column data (async)

        Returns a QueryColumnDataDto representing the column data for the given
        query text.
        If the query isn't valid, returns a 400.

        Args:
            query_text: queryText to be parsed, if present and valid.
            timeout: Override the default request timeout (seconds).

        Returns:
            BaseResponseQueryColumnDataDto

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 423, 429, 500).
        """
        _body: dict[str, Any] = {}
        if query_text is not None:
            _body["queryText"] = query_text
        response = await self._client.request_async(
            "POST",
            self._api,
            "/api/v1/query/data",
            json_body=_body or None,
            timeout=timeout,
        )
        return BaseResponseQueryColumnDataDto.model_validate(response.json())

    def is_query_valid(
        self,
        *,
        name: str,
        query_text: str,
        definition: Optional[PivotDefinitionDto] = None,
        description: Optional[str] = None,
        history_revision: Optional[int] = None,
        is_shared: Optional[bool] = None,
        parameters: Optional[list[QueryParameterDto]] = None,
        primary_query_result_id: Optional[str] = None,
        temporary: Optional[bool] = None,
        timeout: Optional[float] = None,
    ) -> BaseResponseQueryDto:
        """Parses the query to determine if it is valid

        Returns the provided QueryDto

        Args:
            name: The name of the query
            query_text: Max size is 30000 characters.  Is required.  Must be a valid DML statement.
            definition: The pivot view's definition
            description: The description of the query
            history_revision: Historical revision number of this entity
            is_shared: Whether or not this query is being shared.
            parameters: The query parameters
            primary_query_result_id: The identifier of the primary query result
            temporary: Denotes if this query is meant to be temporary.  Default is false.
            timeout: Override the default request timeout (seconds).

        Returns:
            BaseResponseQueryDto

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 423, 429, 500).
        """
        _body: dict[str, Any] = {}
        if name is not None:
            _body["name"] = name
        if query_text is not None:
            _body["queryText"] = query_text
        if definition is not None:
            _body["definition"] = definition
        if description is not None:
            _body["description"] = description
        if history_revision is not None:
            _body["historyRevision"] = history_revision
        if is_shared is not None:
            _body["isShared"] = is_shared
        if parameters is not None:
            _body["parameters"] = parameters
        if primary_query_result_id is not None:
            _body["primaryQueryResultId"] = primary_query_result_id
        if temporary is not None:
            _body["temporary"] = temporary
        response = self._client.request(
            "POST",
            self._api,
            "/api/v1/query/validation",
            json_body=_body or None,
            timeout=timeout,
        )
        return BaseResponseQueryDto.model_validate(response.json())

    async def is_query_valid_async(
        self,
        *,
        name: str,
        query_text: str,
        definition: Optional[PivotDefinitionDto] = None,
        description: Optional[str] = None,
        history_revision: Optional[int] = None,
        is_shared: Optional[bool] = None,
        parameters: Optional[list[QueryParameterDto]] = None,
        primary_query_result_id: Optional[str] = None,
        temporary: Optional[bool] = None,
        timeout: Optional[float] = None,
    ) -> BaseResponseQueryDto:
        """Parses the query to determine if it is valid (async)

        Returns the provided QueryDto

        Args:
            name: The name of the query
            query_text: Max size is 30000 characters.  Is required.  Must be a valid DML statement.
            definition: The pivot view's definition
            description: The description of the query
            history_revision: Historical revision number of this entity
            is_shared: Whether or not this query is being shared.
            parameters: The query parameters
            primary_query_result_id: The identifier of the primary query result
            temporary: Denotes if this query is meant to be temporary.  Default is false.
            timeout: Override the default request timeout (seconds).

        Returns:
            BaseResponseQueryDto

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 423, 429, 500).
        """
        _body: dict[str, Any] = {}
        if name is not None:
            _body["name"] = name
        if query_text is not None:
            _body["queryText"] = query_text
        if definition is not None:
            _body["definition"] = definition
        if description is not None:
            _body["description"] = description
        if history_revision is not None:
            _body["historyRevision"] = history_revision
        if is_shared is not None:
            _body["isShared"] = is_shared
        if parameters is not None:
            _body["parameters"] = parameters
        if primary_query_result_id is not None:
            _body["primaryQueryResultId"] = primary_query_result_id
        if temporary is not None:
            _body["temporary"] = temporary
        response = await self._client.request_async(
            "POST",
            self._api,
            "/api/v1/query/validation",
            json_body=_body or None,
            timeout=timeout,
        )
        return BaseResponseQueryDto.model_validate(response.json())

    def delete_query(
        self,
        *,
        query_id: str,
        timeout: Optional[float] = None,
    ) -> BaseResponseString:
        """Delete a single query

        Deletes the query that matches the provided ID. If no such query is
        found, this is
        a no-op.

        Args:
            query_id: The unique identifier of the query
            timeout: Override the default request timeout (seconds).

        Returns:
            BaseResponseString

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 423, 429, 500).
        """
        response = self._client.request(
            "DELETE",
            self._api,
            "/api/v1/query/{queryId}",
            path_params={
                "queryId": query_id,
            },
            timeout=timeout,
        )
        return BaseResponseString.model_validate(response.json())

    async def delete_query_async(
        self,
        *,
        query_id: str,
        timeout: Optional[float] = None,
    ) -> BaseResponseString:
        """Delete a single query (async)

        Deletes the query that matches the provided ID. If no such query is
        found, this is
        a no-op.

        Args:
            query_id: The unique identifier of the query
            timeout: Override the default request timeout (seconds).

        Returns:
            BaseResponseString

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 423, 429, 500).
        """
        response = await self._client.request_async(
            "DELETE",
            self._api,
            "/api/v1/query/{queryId}",
            path_params={
                "queryId": query_id,
            },
            timeout=timeout,
        )
        return BaseResponseString.model_validate(response.json())

    def get_query(
        self,
        *,
        query_id: str,
        timeout: Optional[float] = None,
    ) -> BaseResponseQueryDto:
        """Retrieve a single query

        Returns a query that matches the provided ID, or a 404 if no matching
        query is found.

        Args:
            query_id: The unique identifier of the query
            timeout: Override the default request timeout (seconds).

        Returns:
            BaseResponseQueryDto

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 423, 429, 500).
        """
        response = self._client.request(
            "GET",
            self._api,
            "/api/v1/query/{queryId}",
            path_params={
                "queryId": query_id,
            },
            timeout=timeout,
        )
        return BaseResponseQueryDto.model_validate(response.json())

    async def get_query_async(
        self,
        *,
        query_id: str,
        timeout: Optional[float] = None,
    ) -> BaseResponseQueryDto:
        """Retrieve a single query (async)

        Returns a query that matches the provided ID, or a 404 if no matching
        query is found.

        Args:
            query_id: The unique identifier of the query
            timeout: Override the default request timeout (seconds).

        Returns:
            BaseResponseQueryDto

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 423, 429, 500).
        """
        response = await self._client.request_async(
            "GET",
            self._api,
            "/api/v1/query/{queryId}",
            path_params={
                "queryId": query_id,
            },
            timeout=timeout,
        )
        return BaseResponseQueryDto.model_validate(response.json())

    def update_query(
        self,
        *,
        query_id: str,
        name: str,
        query_text: str,
        definition: Optional[PivotDefinitionDto] = None,
        description: Optional[str] = None,
        history_revision: Optional[int] = None,
        is_shared: Optional[bool] = None,
        parameters: Optional[list[QueryParameterDto]] = None,
        primary_query_result_id: Optional[str] = None,
        temporary: Optional[bool] = None,
        timeout: Optional[float] = None,
    ) -> BaseResponseQueryDto:
        """Update a single query

        Updates the query that matches the provided ID with the details provided
        in the
        body.

        Args:
            query_id: The unique identifier of the query
            name: The name of the query
            query_text: Max size is 30000 characters.  Is required.  Must be a valid DML statement.
            definition: The pivot view's definition
            description: The description of the query
            history_revision: Historical revision number of this entity
            is_shared: Whether or not this query is being shared.
            parameters: The query parameters
            primary_query_result_id: The identifier of the primary query result
            temporary: Denotes if this query is meant to be temporary.  Default is false.
            timeout: Override the default request timeout (seconds).

        Returns:
            BaseResponseQueryDto

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 423, 429, 500).
        """
        _body: dict[str, Any] = {}
        if name is not None:
            _body["name"] = name
        if query_text is not None:
            _body["queryText"] = query_text
        if definition is not None:
            _body["definition"] = definition
        if description is not None:
            _body["description"] = description
        if history_revision is not None:
            _body["historyRevision"] = history_revision
        if is_shared is not None:
            _body["isShared"] = is_shared
        if parameters is not None:
            _body["parameters"] = parameters
        if primary_query_result_id is not None:
            _body["primaryQueryResultId"] = primary_query_result_id
        if temporary is not None:
            _body["temporary"] = temporary
        response = self._client.request(
            "PUT",
            self._api,
            "/api/v1/query/{queryId}",
            path_params={
                "queryId": query_id,
            },
            json_body=_body or None,
            timeout=timeout,
        )
        return BaseResponseQueryDto.model_validate(response.json())

    async def update_query_async(
        self,
        *,
        query_id: str,
        name: str,
        query_text: str,
        definition: Optional[PivotDefinitionDto] = None,
        description: Optional[str] = None,
        history_revision: Optional[int] = None,
        is_shared: Optional[bool] = None,
        parameters: Optional[list[QueryParameterDto]] = None,
        primary_query_result_id: Optional[str] = None,
        temporary: Optional[bool] = None,
        timeout: Optional[float] = None,
    ) -> BaseResponseQueryDto:
        """Update a single query (async)

        Updates the query that matches the provided ID with the details provided
        in the
        body.

        Args:
            query_id: The unique identifier of the query
            name: The name of the query
            query_text: Max size is 30000 characters.  Is required.  Must be a valid DML statement.
            definition: The pivot view's definition
            description: The description of the query
            history_revision: Historical revision number of this entity
            is_shared: Whether or not this query is being shared.
            parameters: The query parameters
            primary_query_result_id: The identifier of the primary query result
            temporary: Denotes if this query is meant to be temporary.  Default is false.
            timeout: Override the default request timeout (seconds).

        Returns:
            BaseResponseQueryDto

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 423, 429, 500).
        """
        _body: dict[str, Any] = {}
        if name is not None:
            _body["name"] = name
        if query_text is not None:
            _body["queryText"] = query_text
        if definition is not None:
            _body["definition"] = definition
        if description is not None:
            _body["description"] = description
        if history_revision is not None:
            _body["historyRevision"] = history_revision
        if is_shared is not None:
            _body["isShared"] = is_shared
        if parameters is not None:
            _body["parameters"] = parameters
        if primary_query_result_id is not None:
            _body["primaryQueryResultId"] = primary_query_result_id
        if temporary is not None:
            _body["temporary"] = temporary
        response = await self._client.request_async(
            "PUT",
            self._api,
            "/api/v1/query/{queryId}",
            path_params={
                "queryId": query_id,
            },
            json_body=_body or None,
            timeout=timeout,
        )
        return BaseResponseQueryDto.model_validate(response.json())

    def get_dependencies(
        self,
        *,
        query_id: str,
        limit: Optional[int] = 1000,
        offset: Optional[int] = None,
        timeout: Optional[float] = None,
    ) -> PagedResponseTableDto:
        """Retrieve dependencies

        Returns an unordered collection of all tables the matching query uses as
        datasources, including any shared tables outside of this OAuth token's
        workspace. The endpoint verifies the user has read permissions on the
        query, but _not_ on the tables returned.

        Args:
            query_id: The unique identifier of the query
            limit: The number of dependencies to return, from 1 to 1000; by default, 1000
            offset: The item to start with on the page, greater than or equal to 0; by default, 0
            timeout: Override the default request timeout (seconds).

        Returns:
            PagedResponseTableDto

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 423, 429, 500).
        """

        def _fetch(_cursor: str | None) -> httpx.Response:
            return self._client.request(
                "GET",
                self._api,
                "/api/v1/query/{queryId}/dependencies",
                path_params={
                    "queryId": query_id,
                },
                query_params={
                    "limit": limit,
                    "offset": offset,
                    "cursor": _cursor,
                },
                timeout=timeout,
            )

        _body_result = paginate_all(_fetch, extract_wdata_cursor, "body")
        return PagedResponseTableDto.model_validate(_body_result)

    async def get_dependencies_async(
        self,
        *,
        query_id: str,
        limit: Optional[int] = 1000,
        offset: Optional[int] = None,
        timeout: Optional[float] = None,
    ) -> PagedResponseTableDto:
        """Retrieve dependencies (async)

        Returns an unordered collection of all tables the matching query uses as
        datasources, including any shared tables outside of this OAuth token's
        workspace. The endpoint verifies the user has read permissions on the
        query, but _not_ on the tables returned.

        Args:
            query_id: The unique identifier of the query
            limit: The number of dependencies to return, from 1 to 1000; by default, 1000
            offset: The item to start with on the page, greater than or equal to 0; by default, 0
            timeout: Override the default request timeout (seconds).

        Returns:
            PagedResponseTableDto

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 423, 429, 500).
        """

        async def _fetch(_cursor: str | None) -> httpx.Response:
            return await self._client.request_async(
                "GET",
                self._api,
                "/api/v1/query/{queryId}/dependencies",
                path_params={
                    "queryId": query_id,
                },
                query_params={
                    "limit": limit,
                    "offset": offset,
                    "cursor": _cursor,
                },
                timeout=timeout,
            )

        _body_result = await paginate_all_async(_fetch, extract_wdata_cursor, "body")
        return PagedResponseTableDto.model_validate(_body_result)

    def get_tables_dependent_on_query(
        self,
        *,
        query_id: str,
        limit: Optional[int] = 1000,
        offset: Optional[int] = None,
        timeout: Optional[float] = None,
    ) -> PagedResponseTableDto:
        """Retrieve a list of dependents

        Returns a list of all tables that use the query with provided ID as a
        datasource.

        Args:
            query_id: The unique identifier of the query
            limit: The number of folders to return, from 1 to 1000; by default, 1000
            offset: The item to start with on the page, greater than or equal to 0; by default, 0
            timeout: Override the default request timeout (seconds).

        Returns:
            PagedResponseTableDto

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 423, 429, 500).
        """

        def _fetch(_cursor: str | None) -> httpx.Response:
            return self._client.request(
                "GET",
                self._api,
                "/api/v1/query/{queryId}/dependents",
                path_params={
                    "queryId": query_id,
                },
                query_params={
                    "limit": limit,
                    "offset": offset,
                    "cursor": _cursor,
                },
                timeout=timeout,
            )

        _body_result = paginate_all(_fetch, extract_wdata_cursor, "body")
        return PagedResponseTableDto.model_validate(_body_result)

    async def get_tables_dependent_on_query_async(
        self,
        *,
        query_id: str,
        limit: Optional[int] = 1000,
        offset: Optional[int] = None,
        timeout: Optional[float] = None,
    ) -> PagedResponseTableDto:
        """Retrieve a list of dependents (async)

        Returns a list of all tables that use the query with provided ID as a
        datasource.

        Args:
            query_id: The unique identifier of the query
            limit: The number of folders to return, from 1 to 1000; by default, 1000
            offset: The item to start with on the page, greater than or equal to 0; by default, 0
            timeout: Override the default request timeout (seconds).

        Returns:
            PagedResponseTableDto

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 423, 429, 500).
        """

        async def _fetch(_cursor: str | None) -> httpx.Response:
            return await self._client.request_async(
                "GET",
                self._api,
                "/api/v1/query/{queryId}/dependents",
                path_params={
                    "queryId": query_id,
                },
                query_params={
                    "limit": limit,
                    "offset": offset,
                    "cursor": _cursor,
                },
                timeout=timeout,
            )

        _body_result = await paginate_all_async(_fetch, extract_wdata_cursor, "body")
        return PagedResponseTableDto.model_validate(_body_result)

    def describe_query(
        self,
        *,
        query_id: str,
        timeout: Optional[float] = None,
    ) -> BaseResponseDescribeQueryResponseDto:
        """List the output columns of a query

        List the output columns of a query, including the column name (or
        alias), catalog, schema,
        table, type, type size in bytes, and a boolean indicating if the column
        is aliased.

        Args:
            query_id: The unique identifier of the query
            timeout: Override the default request timeout (seconds).

        Returns:
            BaseResponseDescribeQueryResponseDto

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 423, 429, 500).
        """
        response = self._client.request(
            "POST",
            self._api,
            "/api/v1/query/{queryId}/describe",
            path_params={
                "queryId": query_id,
            },
            timeout=timeout,
        )
        return BaseResponseDescribeQueryResponseDto.model_validate(response.json())

    async def describe_query_async(
        self,
        *,
        query_id: str,
        timeout: Optional[float] = None,
    ) -> BaseResponseDescribeQueryResponseDto:
        """List the output columns of a query (async)

        List the output columns of a query, including the column name (or
        alias), catalog, schema,
        table, type, type size in bytes, and a boolean indicating if the column
        is aliased.

        Args:
            query_id: The unique identifier of the query
            timeout: Override the default request timeout (seconds).

        Returns:
            BaseResponseDescribeQueryResponseDto

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 423, 429, 500).
        """
        response = await self._client.request_async(
            "POST",
            self._api,
            "/api/v1/query/{queryId}/describe",
            path_params={
                "queryId": query_id,
            },
            timeout=timeout,
        )
        return BaseResponseDescribeQueryResponseDto.model_validate(response.json())

    def list_query_results(
        self,
        *,
        query_id: str,
        user_specific: Optional[bool] = False,
        limit: Optional[str] = None,
        offset: Optional[int] = 0,
        timeout: Optional[float] = None,
    ) -> PagedResponseQueryResultDto:
        """Retrieve a list of query results

        Returns a paged list of query results that match the provided query ID,
        or an empty
        list if no matching query is found.

        Args:
            query_id: The unique identifier of the query
            user_specific: Limit results to those created by the current user
            limit: The number of query results to return, from 1 to 1000; by default, 1000
            offset: The item to start with on the page, greater than or equal to 0; by default, 0
            timeout: Override the default request timeout (seconds).

        Returns:
            PagedResponseQueryResultDto

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 423, 429, 500).
        """

        def _fetch(_cursor: str | None) -> httpx.Response:
            return self._client.request(
                "GET",
                self._api,
                "/api/v1/queryresult",
                query_params={
                    "queryId": query_id,
                    "userSpecific": user_specific,
                    "limit": limit,
                    "offset": offset,
                    "cursor": _cursor,
                },
                timeout=timeout,
            )

        _body_result = paginate_all(_fetch, extract_wdata_cursor, "body")
        return PagedResponseQueryResultDto.model_validate(_body_result)

    async def list_query_results_async(
        self,
        *,
        query_id: str,
        user_specific: Optional[bool] = False,
        limit: Optional[str] = None,
        offset: Optional[int] = 0,
        timeout: Optional[float] = None,
    ) -> PagedResponseQueryResultDto:
        """Retrieve a list of query results (async)

        Returns a paged list of query results that match the provided query ID,
        or an empty
        list if no matching query is found.

        Args:
            query_id: The unique identifier of the query
            user_specific: Limit results to those created by the current user
            limit: The number of query results to return, from 1 to 1000; by default, 1000
            offset: The item to start with on the page, greater than or equal to 0; by default, 0
            timeout: Override the default request timeout (seconds).

        Returns:
            PagedResponseQueryResultDto

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 423, 429, 500).
        """

        async def _fetch(_cursor: str | None) -> httpx.Response:
            return await self._client.request_async(
                "GET",
                self._api,
                "/api/v1/queryresult",
                query_params={
                    "queryId": query_id,
                    "userSpecific": user_specific,
                    "limit": limit,
                    "offset": offset,
                    "cursor": _cursor,
                },
                timeout=timeout,
            )

        _body_result = await paginate_all_async(_fetch, extract_wdata_cursor, "body")
        return PagedResponseQueryResultDto.model_validate(_body_result)

    def run_query(
        self,
        *,
        query_id: str,
        is_explain: Optional[bool] = None,
        parameters: Optional[dict[str, Any]] = None,
        query_dto: Optional[QueryDto] = None,
        timeout: Optional[float] = None,
    ) -> BaseResponseQueryResultDto:
        """Execute a query

        Runs a query and immediately returns a query result entity, which has an
        ID that
        can be used to poll the status from the GET /queryresult method. A
        status of
        COMPLETED or ERROR indicates the query has completed.

        Args:
            query_id: The identifier of the original query
            is_explain: Determines if this query is to be explained and not executed
            parameters: The query parameter map
            query_dto: Associated queryDto
            timeout: Override the default request timeout (seconds).

        Returns:
            BaseResponseQueryResultDto

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 423, 429, 500).
        """
        _body: dict[str, Any] = {}
        if query_id is not None:
            _body["queryId"] = query_id
        if is_explain is not None:
            _body["isExplain"] = is_explain
        if parameters is not None:
            _body["parameters"] = parameters
        if query_dto is not None:
            _body["queryDto"] = query_dto
        response = self._client.request(
            "POST",
            self._api,
            "/api/v1/queryresult",
            json_body=_body or None,
            timeout=timeout,
        )
        return BaseResponseQueryResultDto.model_validate(response.json())

    async def run_query_async(
        self,
        *,
        query_id: str,
        is_explain: Optional[bool] = None,
        parameters: Optional[dict[str, Any]] = None,
        query_dto: Optional[QueryDto] = None,
        timeout: Optional[float] = None,
    ) -> BaseResponseQueryResultDto:
        """Execute a query (async)

        Runs a query and immediately returns a query result entity, which has an
        ID that
        can be used to poll the status from the GET /queryresult method. A
        status of
        COMPLETED or ERROR indicates the query has completed.

        Args:
            query_id: The identifier of the original query
            is_explain: Determines if this query is to be explained and not executed
            parameters: The query parameter map
            query_dto: Associated queryDto
            timeout: Override the default request timeout (seconds).

        Returns:
            BaseResponseQueryResultDto

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 423, 429, 500).
        """
        _body: dict[str, Any] = {}
        if query_id is not None:
            _body["queryId"] = query_id
        if is_explain is not None:
            _body["isExplain"] = is_explain
        if parameters is not None:
            _body["parameters"] = parameters
        if query_dto is not None:
            _body["queryDto"] = query_dto
        response = await self._client.request_async(
            "POST",
            self._api,
            "/api/v1/queryresult",
            json_body=_body or None,
            timeout=timeout,
        )
        return BaseResponseQueryResultDto.model_validate(response.json())

    def cancel_query(
        self,
        *,
        query_result_id: str,
        timeout: Optional[float] = None,
    ) -> BaseResponseQueryResultDto:
        """Cancel a running query

        Cancels a running query based on the provided result ID, and returns a
        cancelled
        result unless the query's already in a COMPLETED state.

        Args:
            query_result_id: The unique identifier of the query result
            timeout: Override the default request timeout (seconds).

        Returns:
            BaseResponseQueryResultDto

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 423, 429, 500).
        """
        response = self._client.request(
            "DELETE",
            self._api,
            "/api/v1/queryresult/{queryResultId}",
            path_params={
                "queryResultId": query_result_id,
            },
            timeout=timeout,
        )
        return BaseResponseQueryResultDto.model_validate(response.json())

    async def cancel_query_async(
        self,
        *,
        query_result_id: str,
        timeout: Optional[float] = None,
    ) -> BaseResponseQueryResultDto:
        """Cancel a running query (async)

        Cancels a running query based on the provided result ID, and returns a
        cancelled
        result unless the query's already in a COMPLETED state.

        Args:
            query_result_id: The unique identifier of the query result
            timeout: Override the default request timeout (seconds).

        Returns:
            BaseResponseQueryResultDto

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 423, 429, 500).
        """
        response = await self._client.request_async(
            "DELETE",
            self._api,
            "/api/v1/queryresult/{queryResultId}",
            path_params={
                "queryResultId": query_result_id,
            },
            timeout=timeout,
        )
        return BaseResponseQueryResultDto.model_validate(response.json())

    def get_query_result(
        self,
        *,
        query_result_id: str,
        timeout: Optional[float] = None,
    ) -> BaseResponseQueryResultDto:
        """Retrieve a single query result

        Returns a single query result that matches the provided ID, or a 404 if
        no such
        query result is found.

        Args:
            query_result_id: The unique identifier of the query result
            timeout: Override the default request timeout (seconds).

        Returns:
            BaseResponseQueryResultDto

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 423, 429, 500).
        """
        response = self._client.request(
            "GET",
            self._api,
            "/api/v1/queryresult/{queryResultId}",
            path_params={
                "queryResultId": query_result_id,
            },
            timeout=timeout,
        )
        return BaseResponseQueryResultDto.model_validate(response.json())

    async def get_query_result_async(
        self,
        *,
        query_result_id: str,
        timeout: Optional[float] = None,
    ) -> BaseResponseQueryResultDto:
        """Retrieve a single query result (async)

        Returns a single query result that matches the provided ID, or a 404 if
        no such
        query result is found.

        Args:
            query_result_id: The unique identifier of the query result
            timeout: Override the default request timeout (seconds).

        Returns:
            BaseResponseQueryResultDto

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 423, 429, 500).
        """
        response = await self._client.request_async(
            "GET",
            self._api,
            "/api/v1/queryresult/{queryResultId}",
            path_params={
                "queryResultId": query_result_id,
            },
            timeout=timeout,
        )
        return BaseResponseQueryResultDto.model_validate(response.json())

    def download_query_result(
        self,
        *,
        query_result_id: str,
        timeout: Optional[float] = None,
    ) -> httpx.Response:
        """Download a query result

        Uses the Token Management API to create a token with the query result
        ID, which it
        then uses to download a CSV file of the query results.

        Args:
            query_result_id: The unique identifier of the query result
            timeout: Override the default request timeout (seconds).

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 423, 429, 500).
        """
        return self._client.request(
            "GET",
            self._api,
            "/api/v1/queryresult/{queryResultId}/download",
            path_params={
                "queryResultId": query_result_id,
            },
            timeout=timeout,
        )

    async def download_query_result_async(
        self,
        *,
        query_result_id: str,
        timeout: Optional[float] = None,
    ) -> httpx.Response:
        """Download a query result (async)

        Uses the Token Management API to create a token with the query result
        ID, which it
        then uses to download a CSV file of the query results.

        Args:
            query_result_id: The unique identifier of the query result
            timeout: Override the default request timeout (seconds).

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 423, 429, 500).
        """
        return await self._client.request_async(
            "GET",
            self._api,
            "/api/v1/queryresult/{queryResultId}/download",
            path_params={
                "queryResultId": query_result_id,
            },
            timeout=timeout,
        )

    def export_query_result_to_spreadsheets(
        self,
        *,
        query_result_id: str,
        export_as_dataset: Optional[bool] = None,
        url: Optional[str] = None,
        use_flat_key: Optional[bool] = None,
        timeout: Optional[float] = None,
    ) -> BaseResponseString:
        """Export query result to spreadsheets

        Exports a query result with the provided ID to Spreadsheets. To
        determine where to
        export the results, the request body should include a URL copied and
        pasted from the
        Spreadsheets UI. Returns a 404 if no matching query result is found.

        Args:
            query_result_id: The unique identifier of the query result
            export_as_dataset: If set to true, the data will be exported as a connected dataset to spreadsheets.
            url: URL of the spreadsheet to export to, if present. If not present, a new spreadsheet will be created.
            use_flat_key: Export flat query results in the context of crosstab queries; Ignored unless true.
            timeout: Override the default request timeout (seconds).

        Returns:
            BaseResponseString

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 423, 429, 500).
        """
        _body: dict[str, Any] = {}
        if export_as_dataset is not None:
            _body["exportAsDataset"] = export_as_dataset
        if url is not None:
            _body["url"] = url
        if use_flat_key is not None:
            _body["useFlatKey"] = use_flat_key
        response = self._client.request(
            "POST",
            self._api,
            "/api/v1/queryresult/{queryResultId}/export",
            path_params={
                "queryResultId": query_result_id,
            },
            json_body=_body or None,
            timeout=timeout,
        )
        return BaseResponseString.model_validate(response.json())

    async def export_query_result_to_spreadsheets_async(
        self,
        *,
        query_result_id: str,
        export_as_dataset: Optional[bool] = None,
        url: Optional[str] = None,
        use_flat_key: Optional[bool] = None,
        timeout: Optional[float] = None,
    ) -> BaseResponseString:
        """Export query result to spreadsheets (async)

        Exports a query result with the provided ID to Spreadsheets. To
        determine where to
        export the results, the request body should include a URL copied and
        pasted from the
        Spreadsheets UI. Returns a 404 if no matching query result is found.

        Args:
            query_result_id: The unique identifier of the query result
            export_as_dataset: If set to true, the data will be exported as a connected dataset to spreadsheets.
            url: URL of the spreadsheet to export to, if present. If not present, a new spreadsheet will be created.
            use_flat_key: Export flat query results in the context of crosstab queries; Ignored unless true.
            timeout: Override the default request timeout (seconds).

        Returns:
            BaseResponseString

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 423, 429, 500).
        """
        _body: dict[str, Any] = {}
        if export_as_dataset is not None:
            _body["exportAsDataset"] = export_as_dataset
        if url is not None:
            _body["url"] = url
        if use_flat_key is not None:
            _body["useFlatKey"] = use_flat_key
        response = await self._client.request_async(
            "POST",
            self._api,
            "/api/v1/queryresult/{queryResultId}/export",
            path_params={
                "queryResultId": query_result_id,
            },
            json_body=_body or None,
            timeout=timeout,
        )
        return BaseResponseString.model_validate(response.json())

    def list_select_lists(
        self,
        *,
        limit: Optional[int] = None,
        offset: Optional[int] = None,
        timeout: Optional[float] = None,
    ) -> PagedResponseSelectListDto:
        """Retrieve a list of select lists

        Returns a list of select lists associated with the workspace.

        Args:
            limit: The number of select lists to return, from 1 to 1000; by default, 1000
            offset: The item to start with on the page, greater than or equal to 0; by default, 0
            timeout: Override the default request timeout (seconds).

        Returns:
            PagedResponseSelectListDto

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 423, 429, 500).
        """

        def _fetch(_cursor: str | None) -> httpx.Response:
            return self._client.request(
                "GET",
                self._api,
                "/api/v1/selectlist",
                query_params={
                    "limit": limit,
                    "offset": offset,
                    "cursor": _cursor,
                },
                timeout=timeout,
            )

        _body_result = paginate_all(_fetch, extract_wdata_cursor, "body")
        return PagedResponseSelectListDto.model_validate(_body_result)

    async def list_select_lists_async(
        self,
        *,
        limit: Optional[int] = None,
        offset: Optional[int] = None,
        timeout: Optional[float] = None,
    ) -> PagedResponseSelectListDto:
        """Retrieve a list of select lists (async)

        Returns a list of select lists associated with the workspace.

        Args:
            limit: The number of select lists to return, from 1 to 1000; by default, 1000
            offset: The item to start with on the page, greater than or equal to 0; by default, 0
            timeout: Override the default request timeout (seconds).

        Returns:
            PagedResponseSelectListDto

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 423, 429, 500).
        """

        async def _fetch(_cursor: str | None) -> httpx.Response:
            return await self._client.request_async(
                "GET",
                self._api,
                "/api/v1/selectlist",
                query_params={
                    "limit": limit,
                    "offset": offset,
                    "cursor": _cursor,
                },
                timeout=timeout,
            )

        _body_result = await paginate_all_async(_fetch, extract_wdata_cursor, "body")
        return PagedResponseSelectListDto.model_validate(_body_result)

    def create_select_list(
        self,
        *,
        name: str,
        value_type: Literal[
            "string",
            "bytes",
            "integer",
            "float",
            "boolean",
            "timestamp",
            "date",
            "time",
            "datetime",
            "global_parameter",
            "nested_query_parameter",
        ],
        values: list[dict[str, Any]],
        description: Optional[str] = None,
        type_: Optional[Literal["static"]] = None,
        timeout: Optional[float] = None,
    ) -> BaseResponseSelectListDto:
        """Create a new select list

                Creates a select list using the provided information and returns the
                select list meta.

                Args:
                    name: Name of this select list. Max length: 100
                    value_type: Defines the type of the items in the list.
                    values: List of possible values for the list. These values will be validated against the valueType provided.
                    description: Description of this select list. Max length: 1024
                    type_: Defines the type of the select list. Currently supported types include 'static'.
        More types may be added in the future. Defaults to 'static' if not provided.
                    timeout: Override the default request timeout (seconds).

                Returns:
                    BaseResponseSelectListDto

                Raises:
                    WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 423, 429, 500).
        """
        _body: dict[str, Any] = {}
        if name is not None:
            _body["name"] = name
        if value_type is not None:
            _body["valueType"] = value_type
        if values is not None:
            _body["values"] = values
        if description is not None:
            _body["description"] = description
        if type_ is not None:
            _body["type"] = type_
        response = self._client.request(
            "POST",
            self._api,
            "/api/v1/selectlist",
            json_body=_body or None,
            timeout=timeout,
        )
        return BaseResponseSelectListDto.model_validate(response.json())

    async def create_select_list_async(
        self,
        *,
        name: str,
        value_type: Literal[
            "string",
            "bytes",
            "integer",
            "float",
            "boolean",
            "timestamp",
            "date",
            "time",
            "datetime",
            "global_parameter",
            "nested_query_parameter",
        ],
        values: list[dict[str, Any]],
        description: Optional[str] = None,
        type_: Optional[Literal["static"]] = None,
        timeout: Optional[float] = None,
    ) -> BaseResponseSelectListDto:
        """Create a new select list (async)

                Creates a select list using the provided information and returns the
                select list meta.

                Args:
                    name: Name of this select list. Max length: 100
                    value_type: Defines the type of the items in the list.
                    values: List of possible values for the list. These values will be validated against the valueType provided.
                    description: Description of this select list. Max length: 1024
                    type_: Defines the type of the select list. Currently supported types include 'static'.
        More types may be added in the future. Defaults to 'static' if not provided.
                    timeout: Override the default request timeout (seconds).

                Returns:
                    BaseResponseSelectListDto

                Raises:
                    WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 423, 429, 500).
        """
        _body: dict[str, Any] = {}
        if name is not None:
            _body["name"] = name
        if value_type is not None:
            _body["valueType"] = value_type
        if values is not None:
            _body["values"] = values
        if description is not None:
            _body["description"] = description
        if type_ is not None:
            _body["type"] = type_
        response = await self._client.request_async(
            "POST",
            self._api,
            "/api/v1/selectlist",
            json_body=_body or None,
            timeout=timeout,
        )
        return BaseResponseSelectListDto.model_validate(response.json())

    def delete(
        self,
        *,
        select_list_id: str,
        timeout: Optional[float] = None,
    ) -> BaseResponseString:
        """Delete a single select list

        Deletes a select list with the provided ID. If no such select list
        exists, this is
        a no-op.

        Args:
            select_list_id: The unique identifier of the select list
            timeout: Override the default request timeout (seconds).

        Returns:
            BaseResponseString

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 423, 429, 500).
        """
        response = self._client.request(
            "DELETE",
            self._api,
            "/api/v1/selectlist/{selectListId}",
            path_params={
                "selectListId": select_list_id,
            },
            timeout=timeout,
        )
        return BaseResponseString.model_validate(response.json())

    async def delete_async(
        self,
        *,
        select_list_id: str,
        timeout: Optional[float] = None,
    ) -> BaseResponseString:
        """Delete a single select list (async)

        Deletes a select list with the provided ID. If no such select list
        exists, this is
        a no-op.

        Args:
            select_list_id: The unique identifier of the select list
            timeout: Override the default request timeout (seconds).

        Returns:
            BaseResponseString

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 423, 429, 500).
        """
        response = await self._client.request_async(
            "DELETE",
            self._api,
            "/api/v1/selectlist/{selectListId}",
            path_params={
                "selectListId": select_list_id,
            },
            timeout=timeout,
        )
        return BaseResponseString.model_validate(response.json())

    def get_select_list(
        self,
        *,
        select_list_id: str,
        timeout: Optional[float] = None,
    ) -> BaseResponseSelectListDto:
        """Retrieve a single select list

        Returns a select list that matches the provided ID, or a 404 if no
        matching select
        list is found.

        Args:
            select_list_id: The unique identifier of the select list
            timeout: Override the default request timeout (seconds).

        Returns:
            BaseResponseSelectListDto

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 423, 429, 500).
        """
        response = self._client.request(
            "GET",
            self._api,
            "/api/v1/selectlist/{selectListId}",
            path_params={
                "selectListId": select_list_id,
            },
            timeout=timeout,
        )
        return BaseResponseSelectListDto.model_validate(response.json())

    async def get_select_list_async(
        self,
        *,
        select_list_id: str,
        timeout: Optional[float] = None,
    ) -> BaseResponseSelectListDto:
        """Retrieve a single select list (async)

        Returns a select list that matches the provided ID, or a 404 if no
        matching select
        list is found.

        Args:
            select_list_id: The unique identifier of the select list
            timeout: Override the default request timeout (seconds).

        Returns:
            BaseResponseSelectListDto

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 423, 429, 500).
        """
        response = await self._client.request_async(
            "GET",
            self._api,
            "/api/v1/selectlist/{selectListId}",
            path_params={
                "selectListId": select_list_id,
            },
            timeout=timeout,
        )
        return BaseResponseSelectListDto.model_validate(response.json())

    def update_select_list(
        self,
        *,
        select_list_id: str,
        name: str,
        value_type: Literal[
            "string",
            "bytes",
            "integer",
            "float",
            "boolean",
            "timestamp",
            "date",
            "time",
            "datetime",
            "global_parameter",
            "nested_query_parameter",
        ],
        values: list[dict[str, Any]],
        description: Optional[str] = None,
        type_: Optional[Literal["static"]] = None,
        timeout: Optional[float] = None,
    ) -> BaseResponseSelectListDto:
        """Update a single select list

                Updates the select list with the provided ID with the details provided
                in the
                body.

                Args:
                    select_list_id: The unique identifier of the select list
                    name: Name of this select list. Max length: 100
                    value_type: Defines the type of the items in the list.
                    values: List of possible values for the list. These values will be validated against the valueType provided.
                    description: Description of this select list. Max length: 1024
                    type_: Defines the type of the select list. Currently supported types include 'static'.
        More types may be added in the future. Defaults to 'static' if not provided.
                    timeout: Override the default request timeout (seconds).

                Returns:
                    BaseResponseSelectListDto

                Raises:
                    WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 423, 429, 500).
        """
        _body: dict[str, Any] = {}
        if name is not None:
            _body["name"] = name
        if value_type is not None:
            _body["valueType"] = value_type
        if values is not None:
            _body["values"] = values
        if description is not None:
            _body["description"] = description
        if type_ is not None:
            _body["type"] = type_
        response = self._client.request(
            "PUT",
            self._api,
            "/api/v1/selectlist/{selectListId}",
            path_params={
                "selectListId": select_list_id,
            },
            json_body=_body or None,
            timeout=timeout,
        )
        return BaseResponseSelectListDto.model_validate(response.json())

    async def update_select_list_async(
        self,
        *,
        select_list_id: str,
        name: str,
        value_type: Literal[
            "string",
            "bytes",
            "integer",
            "float",
            "boolean",
            "timestamp",
            "date",
            "time",
            "datetime",
            "global_parameter",
            "nested_query_parameter",
        ],
        values: list[dict[str, Any]],
        description: Optional[str] = None,
        type_: Optional[Literal["static"]] = None,
        timeout: Optional[float] = None,
    ) -> BaseResponseSelectListDto:
        """Update a single select list (async)

                Updates the select list with the provided ID with the details provided
                in the
                body.

                Args:
                    select_list_id: The unique identifier of the select list
                    name: Name of this select list. Max length: 100
                    value_type: Defines the type of the items in the list.
                    values: List of possible values for the list. These values will be validated against the valueType provided.
                    description: Description of this select list. Max length: 1024
                    type_: Defines the type of the select list. Currently supported types include 'static'.
        More types may be added in the future. Defaults to 'static' if not provided.
                    timeout: Override the default request timeout (seconds).

                Returns:
                    BaseResponseSelectListDto

                Raises:
                    WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 423, 429, 500).
        """
        _body: dict[str, Any] = {}
        if name is not None:
            _body["name"] = name
        if value_type is not None:
            _body["valueType"] = value_type
        if values is not None:
            _body["values"] = values
        if description is not None:
            _body["description"] = description
        if type_ is not None:
            _body["type"] = type_
        response = await self._client.request_async(
            "PUT",
            self._api,
            "/api/v1/selectlist/{selectListId}",
            path_params={
                "selectListId": select_list_id,
            },
            json_body=_body or None,
            timeout=timeout,
        )
        return BaseResponseSelectListDto.model_validate(response.json())

    def list_shared_tables(
        self,
        *,
        shared_with_me: Optional[bool] = None,
        table_id: Optional[str] = None,
        limit: Optional[int] = 1000,
        offset: Optional[int] = None,
        timeout: Optional[float] = None,
    ) -> PagedResponseSharedTableDto:
        """Retrieve a list of shared tables

                Returns a list of shared tables associated with the workspace of the
                request.

                Args:
                    shared_with_me: If true, returns a list of tables that have been shared _to_ it rather than
        from it. The entities contain both the shared table entity _and_ the table being
        shared. If true, `tableId` is ignored.
                    table_id: The unique table identifier associated with the shared table
                    limit: The number of shared files to return, from 1 to 1000; by default, 1000
                    offset: The item to start with on the page, greater than or equal to 0; by default, 0
                    timeout: Override the default request timeout (seconds).

                Returns:
                    PagedResponseSharedTableDto

                Raises:
                    WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 423, 429, 500).
        """

        def _fetch(_cursor: str | None) -> httpx.Response:
            return self._client.request(
                "GET",
                self._api,
                "/api/v1/sharedtable",
                query_params={
                    "sharedWithMe": shared_with_me,
                    "tableId": table_id,
                    "limit": limit,
                    "offset": offset,
                    "cursor": _cursor,
                },
                timeout=timeout,
            )

        _body_result = paginate_all(_fetch, extract_wdata_cursor, "body")
        return PagedResponseSharedTableDto.model_validate(_body_result)

    async def list_shared_tables_async(
        self,
        *,
        shared_with_me: Optional[bool] = None,
        table_id: Optional[str] = None,
        limit: Optional[int] = 1000,
        offset: Optional[int] = None,
        timeout: Optional[float] = None,
    ) -> PagedResponseSharedTableDto:
        """Retrieve a list of shared tables (async)

                Returns a list of shared tables associated with the workspace of the
                request.

                Args:
                    shared_with_me: If true, returns a list of tables that have been shared _to_ it rather than
        from it. The entities contain both the shared table entity _and_ the table being
        shared. If true, `tableId` is ignored.
                    table_id: The unique table identifier associated with the shared table
                    limit: The number of shared files to return, from 1 to 1000; by default, 1000
                    offset: The item to start with on the page, greater than or equal to 0; by default, 0
                    timeout: Override the default request timeout (seconds).

                Returns:
                    PagedResponseSharedTableDto

                Raises:
                    WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 423, 429, 500).
        """

        async def _fetch(_cursor: str | None) -> httpx.Response:
            return await self._client.request_async(
                "GET",
                self._api,
                "/api/v1/sharedtable",
                query_params={
                    "sharedWithMe": shared_with_me,
                    "tableId": table_id,
                    "limit": limit,
                    "offset": offset,
                    "cursor": _cursor,
                },
                timeout=timeout,
            )

        _body_result = await paginate_all_async(_fetch, extract_wdata_cursor, "body")
        return PagedResponseSharedTableDto.model_validate(_body_result)

    def create_shared_table(
        self,
        *,
        destination_workspace_id: str,
        source_table_id: str,
        timeout: Optional[float] = None,
    ) -> BaseResponseSharedTableDto:
        """Create a new shared table

        Creates a shared table instance between the workspace of the request and
        the workspace provided in the body.

        Args:
            destination_workspace_id: The id of the workspace being shared to.
            source_table_id: The id of the table being shared.
            timeout: Override the default request timeout (seconds).

        Returns:
            BaseResponseSharedTableDto

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 423, 429, 500).
        """
        _body: dict[str, Any] = {}
        if destination_workspace_id is not None:
            _body["destinationWorkspaceId"] = destination_workspace_id
        if source_table_id is not None:
            _body["sourceTableId"] = source_table_id
        response = self._client.request(
            "POST",
            self._api,
            "/api/v1/sharedtable",
            json_body=_body or None,
            timeout=timeout,
        )
        return BaseResponseSharedTableDto.model_validate(response.json())

    async def create_shared_table_async(
        self,
        *,
        destination_workspace_id: str,
        source_table_id: str,
        timeout: Optional[float] = None,
    ) -> BaseResponseSharedTableDto:
        """Create a new shared table (async)

        Creates a shared table instance between the workspace of the request and
        the workspace provided in the body.

        Args:
            destination_workspace_id: The id of the workspace being shared to.
            source_table_id: The id of the table being shared.
            timeout: Override the default request timeout (seconds).

        Returns:
            BaseResponseSharedTableDto

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 423, 429, 500).
        """
        _body: dict[str, Any] = {}
        if destination_workspace_id is not None:
            _body["destinationWorkspaceId"] = destination_workspace_id
        if source_table_id is not None:
            _body["sourceTableId"] = source_table_id
        response = await self._client.request_async(
            "POST",
            self._api,
            "/api/v1/sharedtable",
            json_body=_body or None,
            timeout=timeout,
        )
        return BaseResponseSharedTableDto.model_validate(response.json())

    def delete_shared_table(
        self,
        *,
        shared_table_id: str,
        timeout: Optional[float] = None,
    ) -> BaseResponseString:
        """Delete a single shared table

        Deletes the linkages between the source and destination of a shared
        table that matches
        the provided ID; the actual table itself is left intact. If no such
        shared table exists,
        this is a no-op.

        Args:
            shared_table_id: The unique identifier of the shared table
            timeout: Override the default request timeout (seconds).

        Returns:
            BaseResponseString

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 423, 429, 500).
        """
        response = self._client.request(
            "DELETE",
            self._api,
            "/api/v1/sharedtable/{sharedTableId}",
            path_params={
                "sharedTableId": shared_table_id,
            },
            timeout=timeout,
        )
        return BaseResponseString.model_validate(response.json())

    async def delete_shared_table_async(
        self,
        *,
        shared_table_id: str,
        timeout: Optional[float] = None,
    ) -> BaseResponseString:
        """Delete a single shared table (async)

        Deletes the linkages between the source and destination of a shared
        table that matches
        the provided ID; the actual table itself is left intact. If no such
        shared table exists,
        this is a no-op.

        Args:
            shared_table_id: The unique identifier of the shared table
            timeout: Override the default request timeout (seconds).

        Returns:
            BaseResponseString

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 423, 429, 500).
        """
        response = await self._client.request_async(
            "DELETE",
            self._api,
            "/api/v1/sharedtable/{sharedTableId}",
            path_params={
                "sharedTableId": shared_table_id,
            },
            timeout=timeout,
        )
        return BaseResponseString.model_validate(response.json())

    def get_shared_table(
        self,
        *,
        shared_table_id: str,
        shared_with_me: Optional[bool] = None,
        timeout: Optional[float] = None,
    ) -> BaseResponseSharedTableDto:
        """Retrieve a single shared table

        Returns a shared table that matches the provided ID, or a 404 if no
        matching shared table is found.

        Args:
            shared_table_id: The unique identifier of the shared table
            shared_with_me: If true, returns a shared table with the provided ID that has been shared _to_—rather than from—the workspace of the request.
            timeout: Override the default request timeout (seconds).

        Returns:
            BaseResponseSharedTableDto

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 423, 429, 500).
        """
        response = self._client.request(
            "GET",
            self._api,
            "/api/v1/sharedtable/{sharedTableId}",
            path_params={
                "sharedTableId": shared_table_id,
            },
            query_params={
                "sharedWithMe": shared_with_me,
            },
            timeout=timeout,
        )
        return BaseResponseSharedTableDto.model_validate(response.json())

    async def get_shared_table_async(
        self,
        *,
        shared_table_id: str,
        shared_with_me: Optional[bool] = None,
        timeout: Optional[float] = None,
    ) -> BaseResponseSharedTableDto:
        """Retrieve a single shared table (async)

        Returns a shared table that matches the provided ID, or a 404 if no
        matching shared table is found.

        Args:
            shared_table_id: The unique identifier of the shared table
            shared_with_me: If true, returns a shared table with the provided ID that has been shared _to_—rather than from—the workspace of the request.
            timeout: Override the default request timeout (seconds).

        Returns:
            BaseResponseSharedTableDto

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 423, 429, 500).
        """
        response = await self._client.request_async(
            "GET",
            self._api,
            "/api/v1/sharedtable/{sharedTableId}",
            path_params={
                "sharedTableId": shared_table_id,
            },
            query_params={
                "sharedWithMe": shared_with_me,
            },
            timeout=timeout,
        )
        return BaseResponseSharedTableDto.model_validate(response.json())

    def get_tables(
        self,
        *,
        include_shared: Optional[bool] = False,
        limit: Optional[int] = 1000,
        offset: Optional[int] = None,
        timeout: Optional[float] = None,
    ) -> PagedResponseTableDto:
        """Retrieve a list of tables

        Returns all tables available in the workspace.

        Args:
            include_shared: If true, returns all tables shared with the workspace associated with the request. If false, returns only tables the workspace owns.
            limit: the number of folders to return, from 1 to 1000; by default, 1000
            offset: The item to start with on the page, must be greater than or equal to 0, will default to 0
            timeout: Override the default request timeout (seconds).

        Returns:
            PagedResponseTableDto

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 423, 429, 500).
        """

        def _fetch(_cursor: str | None) -> httpx.Response:
            return self._client.request(
                "GET",
                self._api,
                "/api/v1/table",
                query_params={
                    "includeShared": include_shared,
                    "limit": limit,
                    "offset": offset,
                    "cursor": _cursor,
                },
                timeout=timeout,
            )

        _body_result = paginate_all(_fetch, extract_wdata_cursor, "body")
        return PagedResponseTableDto.model_validate(_body_result)

    async def get_tables_async(
        self,
        *,
        include_shared: Optional[bool] = False,
        limit: Optional[int] = 1000,
        offset: Optional[int] = None,
        timeout: Optional[float] = None,
    ) -> PagedResponseTableDto:
        """Retrieve a list of tables (async)

        Returns all tables available in the workspace.

        Args:
            include_shared: If true, returns all tables shared with the workspace associated with the request. If false, returns only tables the workspace owns.
            limit: the number of folders to return, from 1 to 1000; by default, 1000
            offset: The item to start with on the page, must be greater than or equal to 0, will default to 0
            timeout: Override the default request timeout (seconds).

        Returns:
            PagedResponseTableDto

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 423, 429, 500).
        """

        async def _fetch(_cursor: str | None) -> httpx.Response:
            return await self._client.request_async(
                "GET",
                self._api,
                "/api/v1/table",
                query_params={
                    "includeShared": include_shared,
                    "limit": limit,
                    "offset": offset,
                    "cursor": _cursor,
                },
                timeout=timeout,
            )

        _body_result = await paginate_all_async(_fetch, extract_wdata_cursor, "body")
        return PagedResponseTableDto.model_validate(_body_result)

    def create_table(
        self,
        *,
        name: str,
        table_schema: TableSchema,
        type_: Literal["data", "lookup", "hierarchy"],
        unique_table_constraints: list[UniqueConstraintDto],
        dataset_updated: Optional[str] = None,
        description: Optional[str] = None,
        hierarchy_metadata: Optional[HierarchyMetadata] = None,
        timeout: Optional[float] = None,
    ) -> BaseResponseTableDto:
        """Create a new table

                Creates a table in the database with the specified schema. For type,
                specify either a dimension or data table. In the interface, data tables
                appear as fact tables.

                Args:
                    name: May be at most 150 characters in length
                    table_schema: The schema to apply
                    type_: The type of table
                    unique_table_constraints: A property indicating the unique constraints on the table.
                    dataset_updated: The last time that the data set for this table was modified.
                    description: May be at most 255 characters in length
                    hierarchy_metadata: For hierarchical tables, this object specifies the parent and child column identifiers.
        Only required for tables of type "hierarchy."

                    timeout: Override the default request timeout (seconds).

                Returns:
                    BaseResponseTableDto

                Raises:
                    WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 423, 429, 500).
        """
        _body: dict[str, Any] = {}
        if name is not None:
            _body["name"] = name
        if table_schema is not None:
            _body["tableSchema"] = table_schema
        if type_ is not None:
            _body["type"] = type_
        if unique_table_constraints is not None:
            _body["uniqueTableConstraints"] = unique_table_constraints
        if dataset_updated is not None:
            _body["datasetUpdated"] = dataset_updated
        if description is not None:
            _body["description"] = description
        if hierarchy_metadata is not None:
            _body["hierarchyMetadata"] = hierarchy_metadata
        response = self._client.request(
            "POST",
            self._api,
            "/api/v1/table",
            json_body=_body or None,
            timeout=timeout,
        )
        return BaseResponseTableDto.model_validate(response.json())

    async def create_table_async(
        self,
        *,
        name: str,
        table_schema: TableSchema,
        type_: Literal["data", "lookup", "hierarchy"],
        unique_table_constraints: list[UniqueConstraintDto],
        dataset_updated: Optional[str] = None,
        description: Optional[str] = None,
        hierarchy_metadata: Optional[HierarchyMetadata] = None,
        timeout: Optional[float] = None,
    ) -> BaseResponseTableDto:
        """Create a new table (async)

                Creates a table in the database with the specified schema. For type,
                specify either a dimension or data table. In the interface, data tables
                appear as fact tables.

                Args:
                    name: May be at most 150 characters in length
                    table_schema: The schema to apply
                    type_: The type of table
                    unique_table_constraints: A property indicating the unique constraints on the table.
                    dataset_updated: The last time that the data set for this table was modified.
                    description: May be at most 255 characters in length
                    hierarchy_metadata: For hierarchical tables, this object specifies the parent and child column identifiers.
        Only required for tables of type "hierarchy."

                    timeout: Override the default request timeout (seconds).

                Returns:
                    BaseResponseTableDto

                Raises:
                    WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 423, 429, 500).
        """
        _body: dict[str, Any] = {}
        if name is not None:
            _body["name"] = name
        if table_schema is not None:
            _body["tableSchema"] = table_schema
        if type_ is not None:
            _body["type"] = type_
        if unique_table_constraints is not None:
            _body["uniqueTableConstraints"] = unique_table_constraints
        if dataset_updated is not None:
            _body["datasetUpdated"] = dataset_updated
        if description is not None:
            _body["description"] = description
        if hierarchy_metadata is not None:
            _body["hierarchyMetadata"] = hierarchy_metadata
        response = await self._client.request_async(
            "POST",
            self._api,
            "/api/v1/table",
            json_body=_body or None,
            timeout=timeout,
        )
        return BaseResponseTableDto.model_validate(response.json())

    def delete_table(
        self,
        *,
        table_id: str,
        timeout: Optional[float] = None,
    ) -> BaseResponseString:
        """Delete a single table

        Soft-deletes the table with the provided ID.

        Args:
            table_id: The unique identifier of the table
            timeout: Override the default request timeout (seconds).

        Returns:
            BaseResponseString

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 423, 429, 500).
        """
        response = self._client.request(
            "DELETE",
            self._api,
            "/api/v1/table/{tableId}",
            path_params={
                "tableId": table_id,
            },
            timeout=timeout,
        )
        return BaseResponseString.model_validate(response.json())

    async def delete_table_async(
        self,
        *,
        table_id: str,
        timeout: Optional[float] = None,
    ) -> BaseResponseString:
        """Delete a single table (async)

        Soft-deletes the table with the provided ID.

        Args:
            table_id: The unique identifier of the table
            timeout: Override the default request timeout (seconds).

        Returns:
            BaseResponseString

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 423, 429, 500).
        """
        response = await self._client.request_async(
            "DELETE",
            self._api,
            "/api/v1/table/{tableId}",
            path_params={
                "tableId": table_id,
            },
            timeout=timeout,
        )
        return BaseResponseString.model_validate(response.json())

    def get_table(
        self,
        *,
        table_id: str,
        timeout: Optional[float] = None,
    ) -> BaseResponseTableDto:
        """Retrieve a single table

        Returns a table with the provided ID, or a 404 if no such table is
        found.

        Args:
            table_id: The unique identifier of the table
            timeout: Override the default request timeout (seconds).

        Returns:
            BaseResponseTableDto

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 423, 429, 500).
        """
        response = self._client.request(
            "GET",
            self._api,
            "/api/v1/table/{tableId}",
            path_params={
                "tableId": table_id,
            },
            timeout=timeout,
        )
        return BaseResponseTableDto.model_validate(response.json())

    async def get_table_async(
        self,
        *,
        table_id: str,
        timeout: Optional[float] = None,
    ) -> BaseResponseTableDto:
        """Retrieve a single table (async)

        Returns a table with the provided ID, or a 404 if no such table is
        found.

        Args:
            table_id: The unique identifier of the table
            timeout: Override the default request timeout (seconds).

        Returns:
            BaseResponseTableDto

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 423, 429, 500).
        """
        response = await self._client.request_async(
            "GET",
            self._api,
            "/api/v1/table/{tableId}",
            path_params={
                "tableId": table_id,
            },
            timeout=timeout,
        )
        return BaseResponseTableDto.model_validate(response.json())

    def update_table(
        self,
        *,
        table_id: str,
        name: str,
        table_schema: TableSchema,
        type_: Literal["data", "lookup", "hierarchy"],
        unique_table_constraints: list[UniqueConstraintDto],
        dataset_updated: Optional[str] = None,
        description: Optional[str] = None,
        hierarchy_metadata: Optional[HierarchyMetadata] = None,
        timeout: Optional[float] = None,
    ) -> BaseResponseTableDto:
        """Update a single table

                Updates an existing table with the provided information. Include all
                user-defined
                table columns with the request. For type, specify either a dimension or
                data table.
                In the interface, data tables appear as fact tables.
                * If the table has no imported
                data, user-defined columns not included with the request are deleted,
                and columns are
                sorted according to their order in the request.
                * If the table has imported data,
                any columns with names not already in the table are considered new. This
                equality
                check is case-insensitive. Any new columns appear after other user-
                defined columns,
                but before any meta columns, which start with `_`.

                Args:
                    table_id: The unique identifier of the table
                    name: May be at most 150 characters in length
                    table_schema: The schema to apply
                    type_: The type of table
                    unique_table_constraints: A property indicating the unique constraints on the table.
                    dataset_updated: The last time that the data set for this table was modified.
                    description: May be at most 255 characters in length
                    hierarchy_metadata: For hierarchical tables, this object specifies the parent and child column identifiers.
        Only required for tables of type "hierarchy."

                    timeout: Override the default request timeout (seconds).

                Returns:
                    BaseResponseTableDto

                Raises:
                    WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 423, 429, 500).
        """
        _body: dict[str, Any] = {}
        if name is not None:
            _body["name"] = name
        if table_schema is not None:
            _body["tableSchema"] = table_schema
        if type_ is not None:
            _body["type"] = type_
        if unique_table_constraints is not None:
            _body["uniqueTableConstraints"] = unique_table_constraints
        if dataset_updated is not None:
            _body["datasetUpdated"] = dataset_updated
        if description is not None:
            _body["description"] = description
        if hierarchy_metadata is not None:
            _body["hierarchyMetadata"] = hierarchy_metadata
        response = self._client.request(
            "PUT",
            self._api,
            "/api/v1/table/{tableId}",
            path_params={
                "tableId": table_id,
            },
            json_body=_body or None,
            timeout=timeout,
        )
        return BaseResponseTableDto.model_validate(response.json())

    async def update_table_async(
        self,
        *,
        table_id: str,
        name: str,
        table_schema: TableSchema,
        type_: Literal["data", "lookup", "hierarchy"],
        unique_table_constraints: list[UniqueConstraintDto],
        dataset_updated: Optional[str] = None,
        description: Optional[str] = None,
        hierarchy_metadata: Optional[HierarchyMetadata] = None,
        timeout: Optional[float] = None,
    ) -> BaseResponseTableDto:
        """Update a single table (async)

                Updates an existing table with the provided information. Include all
                user-defined
                table columns with the request. For type, specify either a dimension or
                data table.
                In the interface, data tables appear as fact tables.
                * If the table has no imported
                data, user-defined columns not included with the request are deleted,
                and columns are
                sorted according to their order in the request.
                * If the table has imported data,
                any columns with names not already in the table are considered new. This
                equality
                check is case-insensitive. Any new columns appear after other user-
                defined columns,
                but before any meta columns, which start with `_`.

                Args:
                    table_id: The unique identifier of the table
                    name: May be at most 150 characters in length
                    table_schema: The schema to apply
                    type_: The type of table
                    unique_table_constraints: A property indicating the unique constraints on the table.
                    dataset_updated: The last time that the data set for this table was modified.
                    description: May be at most 255 characters in length
                    hierarchy_metadata: For hierarchical tables, this object specifies the parent and child column identifiers.
        Only required for tables of type "hierarchy."

                    timeout: Override the default request timeout (seconds).

                Returns:
                    BaseResponseTableDto

                Raises:
                    WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 423, 429, 500).
        """
        _body: dict[str, Any] = {}
        if name is not None:
            _body["name"] = name
        if table_schema is not None:
            _body["tableSchema"] = table_schema
        if type_ is not None:
            _body["type"] = type_
        if unique_table_constraints is not None:
            _body["uniqueTableConstraints"] = unique_table_constraints
        if dataset_updated is not None:
            _body["datasetUpdated"] = dataset_updated
        if description is not None:
            _body["description"] = description
        if hierarchy_metadata is not None:
            _body["hierarchyMetadata"] = hierarchy_metadata
        response = await self._client.request_async(
            "PUT",
            self._api,
            "/api/v1/table/{tableId}",
            path_params={
                "tableId": table_id,
            },
            json_body=_body or None,
            timeout=timeout,
        )
        return BaseResponseTableDto.model_validate(response.json())

    def get_dependents(
        self,
        *,
        table_id: str,
        limit: Optional[int] = 1000,
        offset: Optional[int] = None,
        timeout: Optional[float] = None,
    ) -> PagedResponseQueryDto:
        """Retrieve a list of dependents

        Returns a list of all queries that use the table with provided ID as a
        datasource.
        If a shared table, this may include queries outside of the current OAuth
        context.
        Permission is checked only for the table ID provided, _not_ on the
        returned list of
        queries.

        Args:
            table_id: The unique identifier of the table
            limit: The number of folders to return, from 1 to 1000; by default, 1000
            offset: The item to start with on the page, greater than or equal to 0; by default, 0
            timeout: Override the default request timeout (seconds).

        Returns:
            PagedResponseQueryDto

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 423, 429, 500).
        """

        def _fetch(_cursor: str | None) -> httpx.Response:
            return self._client.request(
                "GET",
                self._api,
                "/api/v1/table/{tableId}/dependents",
                path_params={
                    "tableId": table_id,
                },
                query_params={
                    "limit": limit,
                    "offset": offset,
                    "cursor": _cursor,
                },
                timeout=timeout,
            )

        _body_result = paginate_all(_fetch, extract_wdata_cursor, "body")
        return PagedResponseQueryDto.model_validate(_body_result)

    async def get_dependents_async(
        self,
        *,
        table_id: str,
        limit: Optional[int] = 1000,
        offset: Optional[int] = None,
        timeout: Optional[float] = None,
    ) -> PagedResponseQueryDto:
        """Retrieve a list of dependents (async)

        Returns a list of all queries that use the table with provided ID as a
        datasource.
        If a shared table, this may include queries outside of the current OAuth
        context.
        Permission is checked only for the table ID provided, _not_ on the
        returned list of
        queries.

        Args:
            table_id: The unique identifier of the table
            limit: The number of folders to return, from 1 to 1000; by default, 1000
            offset: The item to start with on the page, greater than or equal to 0; by default, 0
            timeout: Override the default request timeout (seconds).

        Returns:
            PagedResponseQueryDto

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 423, 429, 500).
        """

        async def _fetch(_cursor: str | None) -> httpx.Response:
            return await self._client.request_async(
                "GET",
                self._api,
                "/api/v1/table/{tableId}/dependents",
                path_params={
                    "tableId": table_id,
                },
                query_params={
                    "limit": limit,
                    "offset": offset,
                    "cursor": _cursor,
                },
                timeout=timeout,
            )

        _body_result = await paginate_all_async(_fetch, extract_wdata_cursor, "body")
        return PagedResponseQueryDto.model_validate(_body_result)

    def import_file(
        self,
        *,
        table_id: str,
        file_id: str,
        column_mappings: Optional[dict[str, Any]] = None,
        delimiter: Optional[str] = None,
        metadata: Optional[dict[str, Any]] = None,
        tags: Optional[dict[str, Any]] = None,
        timeout: Optional[float] = None,
    ) -> BaseResponseFileMetaDto:
        """Import a single file

                Imports the provided file into the associated table, and immediately
                returns a
                file meta object with an ID that can be used to poll the file controller
                for status.

                Args:
                    table_id: The unique identifier of the table
                    file_id: id of the file to import to the table
                    column_mappings: a map of import column names to table column ids
                    delimiter: For overriding the file metadata's delimiter. The file delimiter is the character to
        use within the file to separate one field from another. If this value is not set,
        the import will use the file's set delimiter. If this value is set, the file metadata's
        delimiter will be updated on the file object.
                    metadata: For overriding column metadata specifically for this import. The keys in this object
        are column identifiers with the values being metadata objects.
                    tags: an object containing keys and values, which becomes the tag map
                    timeout: Override the default request timeout (seconds).

                Returns:
                    BaseResponseFileMetaDto

                Raises:
                    WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 423, 429, 500).
        """
        _body: dict[str, Any] = {}
        if file_id is not None:
            _body["fileId"] = file_id
        if column_mappings is not None:
            _body["columnMappings"] = column_mappings
        if delimiter is not None:
            _body["delimiter"] = delimiter
        if metadata is not None:
            _body["metadata"] = metadata
        if tags is not None:
            _body["tags"] = tags
        response = self._client.request(
            "POST",
            self._api,
            "/api/v1/table/{tableId}/import",
            path_params={
                "tableId": table_id,
            },
            json_body=_body or None,
            timeout=timeout,
        )
        return BaseResponseFileMetaDto.model_validate(response.json())

    async def import_file_async(
        self,
        *,
        table_id: str,
        file_id: str,
        column_mappings: Optional[dict[str, Any]] = None,
        delimiter: Optional[str] = None,
        metadata: Optional[dict[str, Any]] = None,
        tags: Optional[dict[str, Any]] = None,
        timeout: Optional[float] = None,
    ) -> BaseResponseFileMetaDto:
        """Import a single file (async)

                Imports the provided file into the associated table, and immediately
                returns a
                file meta object with an ID that can be used to poll the file controller
                for status.

                Args:
                    table_id: The unique identifier of the table
                    file_id: id of the file to import to the table
                    column_mappings: a map of import column names to table column ids
                    delimiter: For overriding the file metadata's delimiter. The file delimiter is the character to
        use within the file to separate one field from another. If this value is not set,
        the import will use the file's set delimiter. If this value is set, the file metadata's
        delimiter will be updated on the file object.
                    metadata: For overriding column metadata specifically for this import. The keys in this object
        are column identifiers with the values being metadata objects.
                    tags: an object containing keys and values, which becomes the tag map
                    timeout: Override the default request timeout (seconds).

                Returns:
                    BaseResponseFileMetaDto

                Raises:
                    WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 423, 429, 500).
        """
        _body: dict[str, Any] = {}
        if file_id is not None:
            _body["fileId"] = file_id
        if column_mappings is not None:
            _body["columnMappings"] = column_mappings
        if delimiter is not None:
            _body["delimiter"] = delimiter
        if metadata is not None:
            _body["metadata"] = metadata
        if tags is not None:
            _body["tags"] = tags
        response = await self._client.request_async(
            "POST",
            self._api,
            "/api/v1/table/{tableId}/import",
            path_params={
                "tableId": table_id,
            },
            json_body=_body or None,
            timeout=timeout,
        )
        return BaseResponseFileMetaDto.model_validate(response.json())

    def unimport_file(
        self,
        *,
        table_id: str,
        file_id: str,
        force: Optional[str] = "false",
        timeout: Optional[float] = None,
    ) -> BaseResponseFileMetaDto:
        """Unimport a single file

        Unimports the provided file from the provided table. Returns a 409 if
        the file is
        not in an imported state, or a 404 if the file can't be found.

        Args:
            table_id: The unique identifier of the table
            file_id: The unique identifier of the file
            force: If true, unimports and deletes file from the table
            timeout: Override the default request timeout (seconds).

        Returns:
            BaseResponseFileMetaDto

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 423, 429, 500).
        """
        response = self._client.request(
            "DELETE",
            self._api,
            "/api/v1/table/{tableId}/import/{fileId}",
            path_params={
                "tableId": table_id,
                "fileId": file_id,
            },
            query_params={
                "force": force,
            },
            timeout=timeout,
        )
        return BaseResponseFileMetaDto.model_validate(response.json())

    async def unimport_file_async(
        self,
        *,
        table_id: str,
        file_id: str,
        force: Optional[str] = "false",
        timeout: Optional[float] = None,
    ) -> BaseResponseFileMetaDto:
        """Unimport a single file (async)

        Unimports the provided file from the provided table. Returns a 409 if
        the file is
        not in an imported state, or a 404 if the file can't be found.

        Args:
            table_id: The unique identifier of the table
            file_id: The unique identifier of the file
            force: If true, unimports and deletes file from the table
            timeout: Override the default request timeout (seconds).

        Returns:
            BaseResponseFileMetaDto

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 423, 429, 500).
        """
        response = await self._client.request_async(
            "DELETE",
            self._api,
            "/api/v1/table/{tableId}/import/{fileId}",
            path_params={
                "tableId": table_id,
                "fileId": file_id,
            },
            query_params={
                "force": force,
            },
            timeout=timeout,
        )
        return BaseResponseFileMetaDto.model_validate(response.json())

    def get_import_info(
        self,
        *,
        table_id: str,
        timeout: Optional[float] = None,
    ) -> BaseResponseImportInfoDto:
        """Retrieve import information

        Returns information around imported files for a table.

        Args:
            table_id: The unique identifier of the table
            timeout: Override the default request timeout (seconds).

        Returns:
            BaseResponseImportInfoDto

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 423, 429, 500).
        """
        response = self._client.request(
            "GET",
            self._api,
            "/api/v1/table/{tableId}/importInfo",
            path_params={
                "tableId": table_id,
            },
            timeout=timeout,
        )
        return BaseResponseImportInfoDto.model_validate(response.json())

    async def get_import_info_async(
        self,
        *,
        table_id: str,
        timeout: Optional[float] = None,
    ) -> BaseResponseImportInfoDto:
        """Retrieve import information (async)

        Returns information around imported files for a table.

        Args:
            table_id: The unique identifier of the table
            timeout: Override the default request timeout (seconds).

        Returns:
            BaseResponseImportInfoDto

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 423, 429, 500).
        """
        response = await self._client.request_async(
            "GET",
            self._api,
            "/api/v1/table/{tableId}/importInfo",
            path_params={
                "tableId": table_id,
            },
            timeout=timeout,
        )
        return BaseResponseImportInfoDto.model_validate(response.json())

    def import_from_spreadsheets(
        self,
        *,
        table_id: str,
        name: str,
        url: str,
        file_id: Optional[str] = None,
        tags: Optional[dict[str, Any]] = None,
        timeout: Optional[float] = None,
    ) -> BaseResponseFileMetaDto:
        """Import from spreadsheets

        Imports spreadsheet data and immediately returns a file meta result.
        This DTO has
        an ID, which can be used to poll on status via the file controller.

        Args:
            table_id: The unique identifier of the table
            name:
            url:
            file_id:
            tags:
            timeout: Override the default request timeout (seconds).

        Returns:
            BaseResponseFileMetaDto

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 423, 429, 500).
        """
        _body: dict[str, Any] = {}
        if name is not None:
            _body["name"] = name
        if url is not None:
            _body["url"] = url
        if file_id is not None:
            _body["fileId"] = file_id
        if tags is not None:
            _body["tags"] = tags
        response = self._client.request(
            "POST",
            self._api,
            "/api/v1/table/{tableId}/spreadsheet/import",
            path_params={
                "tableId": table_id,
            },
            json_body=_body or None,
            timeout=timeout,
        )
        return BaseResponseFileMetaDto.model_validate(response.json())

    async def import_from_spreadsheets_async(
        self,
        *,
        table_id: str,
        name: str,
        url: str,
        file_id: Optional[str] = None,
        tags: Optional[dict[str, Any]] = None,
        timeout: Optional[float] = None,
    ) -> BaseResponseFileMetaDto:
        """Import from spreadsheets (async)

        Imports spreadsheet data and immediately returns a file meta result.
        This DTO has
        an ID, which can be used to poll on status via the file controller.

        Args:
            table_id: The unique identifier of the table
            name:
            url:
            file_id:
            tags:
            timeout: Override the default request timeout (seconds).

        Returns:
            BaseResponseFileMetaDto

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 423, 429, 500).
        """
        _body: dict[str, Any] = {}
        if name is not None:
            _body["name"] = name
        if url is not None:
            _body["url"] = url
        if file_id is not None:
            _body["fileId"] = file_id
        if tags is not None:
            _body["tags"] = tags
        response = await self._client.request_async(
            "POST",
            self._api,
            "/api/v1/table/{tableId}/spreadsheet/import",
            path_params={
                "tableId": table_id,
            },
            json_body=_body or None,
            timeout=timeout,
        )
        return BaseResponseFileMetaDto.model_validate(response.json())

    def list_tags(
        self,
        *,
        limit: Optional[int] = 1000,
        offset: Optional[int] = None,
        timeout: Optional[float] = None,
    ) -> PagedResponseTagDto:
        """Retrieve a list of tags

        Returns a paged list of all tags associated with the workspace of the
        request.

        Args:
            limit: The number of tags to return, from 1 to 1000; by default, 1000
            offset: The item to start with on the page, greater than or equal to 0; by default, 0
            timeout: Override the default request timeout (seconds).

        Returns:
            PagedResponseTagDto

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 423, 429, 500).
        """

        def _fetch(_cursor: str | None) -> httpx.Response:
            return self._client.request(
                "GET",
                self._api,
                "/api/v1/tag",
                query_params={
                    "limit": limit,
                    "offset": offset,
                    "cursor": _cursor,
                },
                timeout=timeout,
            )

        _body_result = paginate_all(_fetch, extract_wdata_cursor, "body")
        return PagedResponseTagDto.model_validate(_body_result)

    async def list_tags_async(
        self,
        *,
        limit: Optional[int] = 1000,
        offset: Optional[int] = None,
        timeout: Optional[float] = None,
    ) -> PagedResponseTagDto:
        """Retrieve a list of tags (async)

        Returns a paged list of all tags associated with the workspace of the
        request.

        Args:
            limit: The number of tags to return, from 1 to 1000; by default, 1000
            offset: The item to start with on the page, greater than or equal to 0; by default, 0
            timeout: Override the default request timeout (seconds).

        Returns:
            PagedResponseTagDto

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 423, 429, 500).
        """

        async def _fetch(_cursor: str | None) -> httpx.Response:
            return await self._client.request_async(
                "GET",
                self._api,
                "/api/v1/tag",
                query_params={
                    "limit": limit,
                    "offset": offset,
                    "cursor": _cursor,
                },
                timeout=timeout,
            )

        _body_result = await paginate_all_async(_fetch, extract_wdata_cursor, "body")
        return PagedResponseTagDto.model_validate(_body_result)

    def create_tag(
        self,
        *,
        key: str,
        values: Optional[list[str]] = None,
        timeout: Optional[float] = None,
    ) -> BaseResponseTagDto:
        """Create a new tag

        Creates a tag. If another tag already has the same key, returns a 409.
        There is a limit of 300 values for a tag.

        Args:
            key: Value for the key, maximum 100 characters in length
            values: Set of values for the tag
            timeout: Override the default request timeout (seconds).

        Returns:
            BaseResponseTagDto

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 423, 429, 500).
        """
        _body: dict[str, Any] = {}
        if key is not None:
            _body["key"] = key
        if values is not None:
            _body["values"] = values
        response = self._client.request(
            "POST",
            self._api,
            "/api/v1/tag",
            json_body=_body or None,
            timeout=timeout,
        )
        return BaseResponseTagDto.model_validate(response.json())

    async def create_tag_async(
        self,
        *,
        key: str,
        values: Optional[list[str]] = None,
        timeout: Optional[float] = None,
    ) -> BaseResponseTagDto:
        """Create a new tag (async)

        Creates a tag. If another tag already has the same key, returns a 409.
        There is a limit of 300 values for a tag.

        Args:
            key: Value for the key, maximum 100 characters in length
            values: Set of values for the tag
            timeout: Override the default request timeout (seconds).

        Returns:
            BaseResponseTagDto

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 423, 429, 500).
        """
        _body: dict[str, Any] = {}
        if key is not None:
            _body["key"] = key
        if values is not None:
            _body["values"] = values
        response = await self._client.request_async(
            "POST",
            self._api,
            "/api/v1/tag",
            json_body=_body or None,
            timeout=timeout,
        )
        return BaseResponseTagDto.model_validate(response.json())

    def delete_tag(
        self,
        *,
        tag_id: str,
        timeout: Optional[float] = None,
    ) -> BaseResponseString:
        """Delete a single tag

        Deletes the tag with the provided ID. If no such tag is found, this is a
        no-op.

        Args:
            tag_id: The unique identifier of the tag
            timeout: Override the default request timeout (seconds).

        Returns:
            BaseResponseString

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 423, 429, 500).
        """
        response = self._client.request(
            "DELETE",
            self._api,
            "/api/v1/tag/{tagId}",
            path_params={
                "tagId": tag_id,
            },
            timeout=timeout,
        )
        return BaseResponseString.model_validate(response.json())

    async def delete_tag_async(
        self,
        *,
        tag_id: str,
        timeout: Optional[float] = None,
    ) -> BaseResponseString:
        """Delete a single tag (async)

        Deletes the tag with the provided ID. If no such tag is found, this is a
        no-op.

        Args:
            tag_id: The unique identifier of the tag
            timeout: Override the default request timeout (seconds).

        Returns:
            BaseResponseString

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 423, 429, 500).
        """
        response = await self._client.request_async(
            "DELETE",
            self._api,
            "/api/v1/tag/{tagId}",
            path_params={
                "tagId": tag_id,
            },
            timeout=timeout,
        )
        return BaseResponseString.model_validate(response.json())

    def update_tag(
        self,
        *,
        tag_id: str,
        key: str,
        values: Optional[list[str]] = None,
        timeout: Optional[float] = None,
    ) -> BaseResponseTagDto:
        """Update a single tag

        Updates the tag that matches the provided ID with the details provided
        in the body.
        Ignores the provided key, as keys are immutable once set.
        There is a limit of 300 values for a tag.

        Args:
            tag_id: The unique identifier of the tag
            key: Value for the key, maximum 100 characters in length
            values: Set of values for the tag
            timeout: Override the default request timeout (seconds).

        Returns:
            BaseResponseTagDto

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 423, 429, 500).
        """
        _body: dict[str, Any] = {}
        if key is not None:
            _body["key"] = key
        if values is not None:
            _body["values"] = values
        response = self._client.request(
            "PUT",
            self._api,
            "/api/v1/tag/{tagId}",
            path_params={
                "tagId": tag_id,
            },
            json_body=_body or None,
            timeout=timeout,
        )
        return BaseResponseTagDto.model_validate(response.json())

    async def update_tag_async(
        self,
        *,
        tag_id: str,
        key: str,
        values: Optional[list[str]] = None,
        timeout: Optional[float] = None,
    ) -> BaseResponseTagDto:
        """Update a single tag (async)

        Updates the tag that matches the provided ID with the details provided
        in the body.
        Ignores the provided key, as keys are immutable once set.
        There is a limit of 300 values for a tag.

        Args:
            tag_id: The unique identifier of the tag
            key: Value for the key, maximum 100 characters in length
            values: Set of values for the tag
            timeout: Override the default request timeout (seconds).

        Returns:
            BaseResponseTagDto

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 423, 429, 500).
        """
        _body: dict[str, Any] = {}
        if key is not None:
            _body["key"] = key
        if values is not None:
            _body["values"] = values
        response = await self._client.request_async(
            "PUT",
            self._api,
            "/api/v1/tag/{tagId}",
            path_params={
                "tagId": tag_id,
            },
            json_body=_body or None,
            timeout=timeout,
        )
        return BaseResponseTagDto.model_validate(response.json())

    def create_token(
        self,
        *,
        object_id: str,
        use_flat_key: Optional[bool] = None,
        timeout: Optional[float] = None,
    ) -> BaseResponseTokenDto:
        """Create a new token

        Creates a temporary token—valid for only a short period of time—to
        download a table
        dataset file or query result, given its ID.

        Args:
            object_id: The object's unique identifier
            use_flat_key: Create token using flat query results key; Ignored unless true.
            timeout: Override the default request timeout (seconds).

        Returns:
            BaseResponseTokenDto

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 423, 429, 500).
        """
        _body: dict[str, Any] = {}
        if object_id is not None:
            _body["objectId"] = object_id
        if use_flat_key is not None:
            _body["useFlatKey"] = use_flat_key
        response = self._client.request(
            "POST",
            self._api,
            "/api/v1/token",
            json_body=_body or None,
            timeout=timeout,
        )
        return BaseResponseTokenDto.model_validate(response.json())

    async def create_token_async(
        self,
        *,
        object_id: str,
        use_flat_key: Optional[bool] = None,
        timeout: Optional[float] = None,
    ) -> BaseResponseTokenDto:
        """Create a new token (async)

        Creates a temporary token—valid for only a short period of time—to
        download a table
        dataset file or query result, given its ID.

        Args:
            object_id: The object's unique identifier
            use_flat_key: Create token using flat query results key; Ignored unless true.
            timeout: Override the default request timeout (seconds).

        Returns:
            BaseResponseTokenDto

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 423, 429, 500).
        """
        _body: dict[str, Any] = {}
        if object_id is not None:
            _body["objectId"] = object_id
        if use_flat_key is not None:
            _body["useFlatKey"] = use_flat_key
        response = await self._client.request_async(
            "POST",
            self._api,
            "/api/v1/token",
            json_body=_body or None,
            timeout=timeout,
        )
        return BaseResponseTokenDto.model_validate(response.json())

    def download_file(
        self,
        *,
        token_id: str,
        filename: Optional[str] = None,
        timeout: Optional[float] = None,
    ) -> httpx.Response:
        """Download a single file

        Downloads a table dataset or query result as a file, given its token
        from the [`Create a new token endpoint`](ref:wdata-createtoken). If no
        matching entity is found, returns a 404.

        Args:
            token_id: The unique identifier of the token
            filename: A filename for the download; if included, the default filename is overridden
            timeout: Override the default request timeout (seconds).

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 423, 429, 500).
        """
        return self._client.request(
            "GET",
            self._api,
            "/api/v1/token/{tokenId}",
            path_params={
                "tokenId": token_id,
            },
            query_params={
                "filename": filename,
            },
            timeout=timeout,
        )

    async def download_file_async(
        self,
        *,
        token_id: str,
        filename: Optional[str] = None,
        timeout: Optional[float] = None,
    ) -> httpx.Response:
        """Download a single file (async)

        Downloads a table dataset or query result as a file, given its token
        from the [`Create a new token endpoint`](ref:wdata-createtoken). If no
        matching entity is found, returns a 404.

        Args:
            token_id: The unique identifier of the token
            filename: A filename for the download; if included, the default filename is overridden
            timeout: Override the default request timeout (seconds).

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 423, 429, 500).
        """
        return await self._client.request_async(
            "GET",
            self._api,
            "/api/v1/token/{tokenId}",
            path_params={
                "tokenId": token_id,
            },
            query_params={
                "filename": filename,
            },
            timeout=timeout,
        )

    def parse_date(
        self,
        *,
        candidate: str,
        date_format: str,
        timeout: Optional[float] = None,
    ) -> BaseResponseString:
        """Parse a date

        Provides a simple endpoint to check whether a given date candidate
        parses with
        the provided format string.  Both the date candidate and format strings
        are required.
        Returns a 200 if the date parses, or a 400 with a message if not. If the
        date parses,
        the provided format can be provided as column metadata, and the imported
        values parse
        correctly. The format string is java DateTimeFormatter style e.g.
        dateFormat =
        "MM/dd/yyyy" and candidate = "07/28/1987"

        Args:
            candidate: Candidate to parse with the provided dateformat.
            date_format: The dateformat of the candidate to test.
            timeout: Override the default request timeout (seconds).

        Returns:
            BaseResponseString

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 423, 429, 500).
        """
        _body: dict[str, Any] = {}
        if candidate is not None:
            _body["candidate"] = candidate
        if date_format is not None:
            _body["dateFormat"] = date_format
        response = self._client.request(
            "POST",
            self._api,
            "/api/v1/util/datetime",
            json_body=_body or None,
            timeout=timeout,
        )
        return BaseResponseString.model_validate(response.json())

    async def parse_date_async(
        self,
        *,
        candidate: str,
        date_format: str,
        timeout: Optional[float] = None,
    ) -> BaseResponseString:
        """Parse a date (async)

        Provides a simple endpoint to check whether a given date candidate
        parses with
        the provided format string.  Both the date candidate and format strings
        are required.
        Returns a 200 if the date parses, or a 400 with a message if not. If the
        date parses,
        the provided format can be provided as column metadata, and the imported
        values parse
        correctly. The format string is java DateTimeFormatter style e.g.
        dateFormat =
        "MM/dd/yyyy" and candidate = "07/28/1987"

        Args:
            candidate: Candidate to parse with the provided dateformat.
            date_format: The dateformat of the candidate to test.
            timeout: Override the default request timeout (seconds).

        Returns:
            BaseResponseString

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 423, 429, 500).
        """
        _body: dict[str, Any] = {}
        if candidate is not None:
            _body["candidate"] = candidate
        if date_format is not None:
            _body["dateFormat"] = date_format
        response = await self._client.request_async(
            "POST",
            self._api,
            "/api/v1/util/datetime",
            json_body=_body or None,
            timeout=timeout,
        )
        return BaseResponseString.model_validate(response.json())

    def health_check(
        self,
        *,
        timeout: Optional[float] = None,
    ) -> BaseResponseMapStringString:
        """Health check

        Returns the status of the API WSGI servers

        Returns:
            BaseResponseMapStringString

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 423, 429, 500).
        """
        response = self._client.request(
            "GET",
            self._api,
            "/health",
            timeout=timeout,
        )
        return BaseResponseMapStringString.model_validate(response.json())

    async def health_check_async(
        self,
        *,
        timeout: Optional[float] = None,
    ) -> BaseResponseMapStringString:
        """Health check (async)

        Returns the status of the API WSGI servers

        Returns:
            BaseResponseMapStringString

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 423, 429, 500).
        """
        response = await self._client.request_async(
            "GET",
            self._api,
            "/health",
            timeout=timeout,
        )
        return BaseResponseMapStringString.model_validate(response.json())
