"""Platform API â€” spreadsheets namespace.

Auto-generated by codegen. Do not edit manually.
"""

from __future__ import annotations

from typing import Any, Literal, Optional

import httpx

from workiva._constants import _API
from workiva._operations._base import BaseNamespace
from workiva._pagination import (
    extract_next_link,
    paginate_all,
    paginate_all_async,
)
from workiva.models.platform import (
    DatasetsListResult,
    MilestoneListResult,
    RangeValuesListResult,
    ResourcePermission,
    ResourcePermissionsListResult,
    Sheet,
    SheetDataResult,
    SheetsListResult,
    SheetUpdateApplyBorders,
    SheetUpdateApplyFormats,
    SheetUpdateClearBorders,
    SheetUpdateClearFormats,
    SheetUpdateDeleteColumns,
    SheetUpdateDeleteRows,
    SheetUpdateEditCells,
    SheetUpdateEditRange,
    SheetUpdateHideColumns,
    SheetUpdateHideRows,
    SheetUpdateInsertColumns,
    SheetUpdateInsertRows,
    SheetUpdateMergeRanges,
    SheetUpdateResizeColumns,
    SheetUpdateResizeColumnsToFit,
    SheetUpdateResizeRows,
    SheetUpdateResizeRowsToFit,
    SheetUpdateUnhideColumns,
    SheetUpdateUnhideRows,
    SheetUpdateUnmergeRanges,
    Spreadsheet,
    SpreadsheetsListResult,
    SpreadsheetToCsvOptions,
    SpreadsheetToPdfOptions,
    SpreadsheetToXlsxOptions,
    TableRef,
)

__all__ = ["Spreadsheets"]


class Spreadsheets(BaseNamespace):
    """Spreadsheets operations."""

    _api: _API = _API.PLATFORM

    def get_spreadsheets(
        self,
        *,
        filter_: Optional[str] = None,
        order_by: Optional[str] = None,
        maxpagesize: Optional[int] = 1000,
        timeout: Optional[float] = None,
    ) -> SpreadsheetsListResult:
        """Retrieve a list of spreadsheets

        Returns a paginated list of
        [spreadsheets](ref:spreadsheets#spreadsheet).

        Args:
            filter_: The properties to filter the results by.
            order_by: One or more comma-separated expressions to indicate the order in which to sort the results.
            maxpagesize: The maximum number of results to retrieve
            timeout: Override the default request timeout (seconds).

        Returns:
            SpreadsheetsListResult

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 429, 500, 503).
        """

        def _fetch(_cursor: str | None) -> httpx.Response:
            return self._client.request(
                "GET",
                self._api,
                "/spreadsheets",
                query_params={
                    "$filter": filter_,
                    "$orderBy": order_by,
                    "$maxpagesize": maxpagesize,
                    "$next": _cursor,
                },
                timeout=timeout,
            )

        _body_result = paginate_all(_fetch, extract_next_link, "data")
        return SpreadsheetsListResult.model_validate(_body_result)

    async def get_spreadsheets_async(
        self,
        *,
        filter_: Optional[str] = None,
        order_by: Optional[str] = None,
        maxpagesize: Optional[int] = 1000,
        timeout: Optional[float] = None,
    ) -> SpreadsheetsListResult:
        """Retrieve a list of spreadsheets (async)

        Returns a paginated list of
        [spreadsheets](ref:spreadsheets#spreadsheet).

        Args:
            filter_: The properties to filter the results by.
            order_by: One or more comma-separated expressions to indicate the order in which to sort the results.
            maxpagesize: The maximum number of results to retrieve
            timeout: Override the default request timeout (seconds).

        Returns:
            SpreadsheetsListResult

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 429, 500, 503).
        """

        async def _fetch(_cursor: str | None) -> httpx.Response:
            return await self._client.request_async(
                "GET",
                self._api,
                "/spreadsheets",
                query_params={
                    "$filter": filter_,
                    "$orderBy": order_by,
                    "$maxpagesize": maxpagesize,
                    "$next": _cursor,
                },
                timeout=timeout,
            )

        _body_result = await paginate_all_async(_fetch, extract_next_link, "data")
        return SpreadsheetsListResult.model_validate(_body_result)

    def partially_update_spreadsheet_by_id(
        self,
        *,
        spreadsheet_id: str,
        body: list[Any],
        timeout: Optional[float] = None,
    ) -> httpx.Response:
        """Partially update a single spreadsheet

        Updates the properties of a [spreadsheet](ref:spreadsheets#spreadsheet).

        This is a long running operation. Responses include a `Location` header,
        which indicates where to poll for results. For more details on long-
        running job polling,
        see [Operations endpoint](ref:getoperationbyid).

        ### Options
        | Path                              | PATCH Operations Supported
        |
        |-----------------------------------|-----------------------------------
        -|
        | `/customFields/<custom field id>` | `add`, `remove`, `replace`, `test`
        |
        | `/customFieldGroups`              | `add`, `remove`, `replace`, `test`
        |
        | `/sheetCustomFieldGroups`         | `add`, `remove`, `replace`, `test`
        |
        | `/lock`                           | `replace`
        |

        ### Examples

        #### Add a custom field value

        ```json
        [
          {
            "op": "add",
            "path": "/customFields/com.workiva.gsr.legal_entity",
            "value": "Workiva"
          }
        ]
        ```

        #### Remove a custom field value

        ```json
        [
          {
            "op": "remove",
            "path": "/customFields/com.workiva.gsr.legal_entity"
          }
        ]
        ```

        #### Replace a custom field value

        ```json
        [
          {
            "op": "replace",
            "path": "/customFields/com.workiva.gsr.legal_entity",
            "value": "Workiva, Inc."
          }
        ]
        ```

        #### Verifying customFieldGroup is empty before replacing the list

        ```json
        [
          {
            "op": "test",
            "path": "/customFieldGroups",
            "value": []
          },
          {
            "op": "replace",
            "path": "/customFieldGroups",
            "value": ["gsr.reporting"]
          }
        ]
        ```

        #### Adding a customFieldGroup to the end of a list

        ```json
        [
          {
            "op": "add",
            "path": "/customFieldGroups/-",
            "value": "gsr.reporting"
          }
        ]
        ```

        Args:
            spreadsheet_id: The unique identifier of the spreadsheet
            body: Request body.
            timeout: Override the default request timeout (seconds).

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 429, 500, 503).

        Note:
            This is a long-running operation (HTTP 202). Use
            ``client.wait(response).result()`` to poll until completion.
        """
        return self._client.request(
            "PATCH",
            self._api,
            "/spreadsheets/{spreadsheetId}",
            path_params={
                "spreadsheetId": spreadsheet_id,
            },
            json_body=body,
            timeout=timeout,
        )

    async def partially_update_spreadsheet_by_id_async(
        self,
        *,
        spreadsheet_id: str,
        body: list[Any],
        timeout: Optional[float] = None,
    ) -> httpx.Response:
        """Partially update a single spreadsheet (async)

        Updates the properties of a [spreadsheet](ref:spreadsheets#spreadsheet).

        This is a long running operation. Responses include a `Location` header,
        which indicates where to poll for results. For more details on long-
        running job polling,
        see [Operations endpoint](ref:getoperationbyid).

        ### Options
        | Path                              | PATCH Operations Supported
        |
        |-----------------------------------|-----------------------------------
        -|
        | `/customFields/<custom field id>` | `add`, `remove`, `replace`, `test`
        |
        | `/customFieldGroups`              | `add`, `remove`, `replace`, `test`
        |
        | `/sheetCustomFieldGroups`         | `add`, `remove`, `replace`, `test`
        |
        | `/lock`                           | `replace`
        |

        ### Examples

        #### Add a custom field value

        ```json
        [
          {
            "op": "add",
            "path": "/customFields/com.workiva.gsr.legal_entity",
            "value": "Workiva"
          }
        ]
        ```

        #### Remove a custom field value

        ```json
        [
          {
            "op": "remove",
            "path": "/customFields/com.workiva.gsr.legal_entity"
          }
        ]
        ```

        #### Replace a custom field value

        ```json
        [
          {
            "op": "replace",
            "path": "/customFields/com.workiva.gsr.legal_entity",
            "value": "Workiva, Inc."
          }
        ]
        ```

        #### Verifying customFieldGroup is empty before replacing the list

        ```json
        [
          {
            "op": "test",
            "path": "/customFieldGroups",
            "value": []
          },
          {
            "op": "replace",
            "path": "/customFieldGroups",
            "value": ["gsr.reporting"]
          }
        ]
        ```

        #### Adding a customFieldGroup to the end of a list

        ```json
        [
          {
            "op": "add",
            "path": "/customFieldGroups/-",
            "value": "gsr.reporting"
          }
        ]
        ```

        Args:
            spreadsheet_id: The unique identifier of the spreadsheet
            body: Request body.
            timeout: Override the default request timeout (seconds).

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 429, 500, 503).

        Note:
            This is a long-running operation (HTTP 202). Use
            ``await client.wait(response).result_async()`` to poll until completion.
        """
        return await self._client.request_async(
            "PATCH",
            self._api,
            "/spreadsheets/{spreadsheetId}",
            path_params={
                "spreadsheetId": spreadsheet_id,
            },
            json_body=body,
            timeout=timeout,
        )

    def get_spreadsheet_by_id(
        self,
        *,
        spreadsheet_id: str,
        revision: Optional[str] = None,
        timeout: Optional[float] = None,
    ) -> Spreadsheet:
        """Retrieve a single spreadsheet

        Retrieves a [spreadsheet](ref:spreadsheets#spreadsheet) given its ID.

        Args:
            spreadsheet_id: The unique identifier of the spreadsheet
            revision: Returns resources at a specific revision
            timeout: Override the default request timeout (seconds).

        Returns:
            Spreadsheet

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 429, 500, 503).
        """
        response = self._client.request(
            "GET",
            self._api,
            "/spreadsheets/{spreadsheetId}",
            path_params={
                "spreadsheetId": spreadsheet_id,
            },
            query_params={
                "$revision": revision,
            },
            timeout=timeout,
        )
        return Spreadsheet.model_validate(response.json())

    async def get_spreadsheet_by_id_async(
        self,
        *,
        spreadsheet_id: str,
        revision: Optional[str] = None,
        timeout: Optional[float] = None,
    ) -> Spreadsheet:
        """Retrieve a single spreadsheet (async)

        Retrieves a [spreadsheet](ref:spreadsheets#spreadsheet) given its ID.

        Args:
            spreadsheet_id: The unique identifier of the spreadsheet
            revision: Returns resources at a specific revision
            timeout: Override the default request timeout (seconds).

        Returns:
            Spreadsheet

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 429, 500, 503).
        """
        response = await self._client.request_async(
            "GET",
            self._api,
            "/spreadsheets/{spreadsheetId}",
            path_params={
                "spreadsheetId": spreadsheet_id,
            },
            query_params={
                "$revision": revision,
            },
            timeout=timeout,
        )
        return Spreadsheet.model_validate(response.json())

    def get_datasets(
        self,
        *,
        spreadsheet_id: str,
        timeout: Optional[float] = None,
    ) -> DatasetsListResult:
        """Retrieve a list of datasets

        Returns a list of [datasets](ref:spreadsheets#dataset). <br /><br /> Use
        this endpoint to identify any datasets that exist within a given
        [spreadsheet](ref:spreadsheets#spreadsheet), up to one per
        [sheet](ref:spreadsheets#sheet).

        Args:
            spreadsheet_id: The unique identifier of the spreadsheet
            timeout: Override the default request timeout (seconds).

        Returns:
            DatasetsListResult

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 429, 500, 503).
        """
        response = self._client.request(
            "GET",
            self._api,
            "/spreadsheets/{spreadsheetId}/datasets",
            path_params={
                "spreadsheetId": spreadsheet_id,
            },
            timeout=timeout,
        )
        return DatasetsListResult.model_validate(response.json())

    async def get_datasets_async(
        self,
        *,
        spreadsheet_id: str,
        timeout: Optional[float] = None,
    ) -> DatasetsListResult:
        """Retrieve a list of datasets (async)

        Returns a list of [datasets](ref:spreadsheets#dataset). <br /><br /> Use
        this endpoint to identify any datasets that exist within a given
        [spreadsheet](ref:spreadsheets#spreadsheet), up to one per
        [sheet](ref:spreadsheets#sheet).

        Args:
            spreadsheet_id: The unique identifier of the spreadsheet
            timeout: Override the default request timeout (seconds).

        Returns:
            DatasetsListResult

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 429, 500, 503).
        """
        response = await self._client.request_async(
            "GET",
            self._api,
            "/spreadsheets/{spreadsheetId}/datasets",
            path_params={
                "spreadsheetId": spreadsheet_id,
            },
            timeout=timeout,
        )
        return DatasetsListResult.model_validate(response.json())

    def upsert_datasets(
        self,
        *,
        spreadsheet_id: str,
        body: list[Any],
        timeout: Optional[float] = None,
    ) -> httpx.Response:
        """Bulk upsert of datasets

        Asynchronously upserts an array of [datasets](ref:spreadsheets#dataset)
        to a [spreadsheet](ref:spreadsheets#spreadsheet), given their
        properties. Each [sheet](ref:spreadsheets#sheet) can have only one
        dataset, and its range will always start with `A1`. <br /><br /> Bulk
        upsertion creates or updates datasets in sheets and performs any
        calculations after it completes. When complete, the dataset's range is
        locked through both the UI and endpoints that write values to a sheet.
        To change the values in a dataset, either upsert new values using this
        endpoint again, or delete the dataset. <br /><br /> If any dataset fails
        to upsert, no datasets upsert, and no changes commit. <br /><br /> Each
        dataset in the array requires `sheet` and `values`. Partial upserts are
        not supported. <br /><br /> Values may be strings, numbers, integers, or
        booleans. To indicate an empty cell, provide an empty string.

        Args:
            spreadsheet_id: The unique identifier of the spreadsheet
            body: Request body.
            timeout: Override the default request timeout (seconds).

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 429, 500, 503).

        Note:
            This is a long-running operation (HTTP 202). Use
            ``client.wait(response).result()`` to poll until completion.
        """
        return self._client.request(
            "POST",
            self._api,
            "/spreadsheets/{spreadsheetId}/datasets/bulkUpsert",
            path_params={
                "spreadsheetId": spreadsheet_id,
            },
            json_body=body,
            timeout=timeout,
        )

    async def upsert_datasets_async(
        self,
        *,
        spreadsheet_id: str,
        body: list[Any],
        timeout: Optional[float] = None,
    ) -> httpx.Response:
        """Bulk upsert of datasets (async)

        Asynchronously upserts an array of [datasets](ref:spreadsheets#dataset)
        to a [spreadsheet](ref:spreadsheets#spreadsheet), given their
        properties. Each [sheet](ref:spreadsheets#sheet) can have only one
        dataset, and its range will always start with `A1`. <br /><br /> Bulk
        upsertion creates or updates datasets in sheets and performs any
        calculations after it completes. When complete, the dataset's range is
        locked through both the UI and endpoints that write values to a sheet.
        To change the values in a dataset, either upsert new values using this
        endpoint again, or delete the dataset. <br /><br /> If any dataset fails
        to upsert, no datasets upsert, and no changes commit. <br /><br /> Each
        dataset in the array requires `sheet` and `values`. Partial upserts are
        not supported. <br /><br /> Values may be strings, numbers, integers, or
        booleans. To indicate an empty cell, provide an empty string.

        Args:
            spreadsheet_id: The unique identifier of the spreadsheet
            body: Request body.
            timeout: Override the default request timeout (seconds).

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 429, 500, 503).

        Note:
            This is a long-running operation (HTTP 202). Use
            ``await client.wait(response).result_async()`` to poll until completion.
        """
        return await self._client.request_async(
            "POST",
            self._api,
            "/spreadsheets/{spreadsheetId}/datasets/bulkUpsert",
            path_params={
                "spreadsheetId": spreadsheet_id,
            },
            json_body=body,
            timeout=timeout,
        )

    def spreadsheet_export(
        self,
        *,
        spreadsheet_id: str,
        format_: Literal["pdf", "xlsx", "csv"],
        csv_options: Optional[SpreadsheetToCsvOptions] = None,
        pdf_options: Optional[SpreadsheetToPdfOptions] = None,
        sheets: Optional[list[str]] = None,
        xlsx_options: Optional[SpreadsheetToXlsxOptions] = None,
        timeout: Optional[float] = None,
    ) -> httpx.Response:
        """Initiate a spreadsheet export

                Asynchronously exports a [spreadsheet](ref:spreadsheets#spreadsheet) as
                .XLSX, .PDF, or .CSV.

                Responses include a `Location` header, which indicates where to poll for
                export results. For more details on long-running job polling, see
                [Operations endpoint](ref:getoperationbyid). When the export completes,
                its status will be `completed`, and the response body includes a
                `resourceURL`. To download the exported file, perform a GET on the
                `resourceURL` with the same authentication credentials and flow as the
                export request. For more details, see [Authentication
                documentation](ref:authentication).

                Note: To export to .PDF, the spreadsheet can have no more than 250,000
                cells.

                Args:
                    spreadsheet_id: The unique identifier of the spreadsheet
                    format_: The file format to export the spreadsheet as.
                    csv_options:
                    pdf_options:
                    sheets: The IDs of the sheets within the spreadsheet to export. Omit to export the entire spreadsheet.

        Note: When exporting to .CSV, you can export only the entire spreadsheet or a single sheet. When exporting the entire spreadsheet, the resulting file is a .ZIP of .CSV files, with one .CSV file per sheet.
                    xlsx_options:
                    timeout: Override the default request timeout (seconds).

                Raises:
                    WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 429, 500, 503).

                Note:
                    This is a long-running operation (HTTP 202). Use
                    ``client.wait(response).result()`` to poll until completion.
        """
        _body: dict[str, Any] = {}
        if format_ is not None:
            _body["format"] = format_
        if csv_options is not None:
            _body["csvOptions"] = csv_options
        if pdf_options is not None:
            _body["pdfOptions"] = pdf_options
        if sheets is not None:
            _body["sheets"] = sheets
        if xlsx_options is not None:
            _body["xlsxOptions"] = xlsx_options
        return self._client.request(
            "POST",
            self._api,
            "/spreadsheets/{spreadsheetId}/export",
            path_params={
                "spreadsheetId": spreadsheet_id,
            },
            json_body=_body or None,
            timeout=timeout,
        )

    async def spreadsheet_export_async(
        self,
        *,
        spreadsheet_id: str,
        format_: Literal["pdf", "xlsx", "csv"],
        csv_options: Optional[SpreadsheetToCsvOptions] = None,
        pdf_options: Optional[SpreadsheetToPdfOptions] = None,
        sheets: Optional[list[str]] = None,
        xlsx_options: Optional[SpreadsheetToXlsxOptions] = None,
        timeout: Optional[float] = None,
    ) -> httpx.Response:
        """Initiate a spreadsheet export (async)

                Asynchronously exports a [spreadsheet](ref:spreadsheets#spreadsheet) as
                .XLSX, .PDF, or .CSV.

                Responses include a `Location` header, which indicates where to poll for
                export results. For more details on long-running job polling, see
                [Operations endpoint](ref:getoperationbyid). When the export completes,
                its status will be `completed`, and the response body includes a
                `resourceURL`. To download the exported file, perform a GET on the
                `resourceURL` with the same authentication credentials and flow as the
                export request. For more details, see [Authentication
                documentation](ref:authentication).

                Note: To export to .PDF, the spreadsheet can have no more than 250,000
                cells.

                Args:
                    spreadsheet_id: The unique identifier of the spreadsheet
                    format_: The file format to export the spreadsheet as.
                    csv_options:
                    pdf_options:
                    sheets: The IDs of the sheets within the spreadsheet to export. Omit to export the entire spreadsheet.

        Note: When exporting to .CSV, you can export only the entire spreadsheet or a single sheet. When exporting the entire spreadsheet, the resulting file is a .ZIP of .CSV files, with one .CSV file per sheet.
                    xlsx_options:
                    timeout: Override the default request timeout (seconds).

                Raises:
                    WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 429, 500, 503).

                Note:
                    This is a long-running operation (HTTP 202). Use
                    ``await client.wait(response).result_async()`` to poll until completion.
        """
        _body: dict[str, Any] = {}
        if format_ is not None:
            _body["format"] = format_
        if csv_options is not None:
            _body["csvOptions"] = csv_options
        if pdf_options is not None:
            _body["pdfOptions"] = pdf_options
        if sheets is not None:
            _body["sheets"] = sheets
        if xlsx_options is not None:
            _body["xlsxOptions"] = xlsx_options
        return await self._client.request_async(
            "POST",
            self._api,
            "/spreadsheets/{spreadsheetId}/export",
            path_params={
                "spreadsheetId": spreadsheet_id,
            },
            json_body=_body or None,
            timeout=timeout,
        )

    def spreadsheet_filters_reapplication(
        self,
        *,
        spreadsheet_id: str,
        ignore_non_editable_filters: Optional[bool] = None,
        timeout: Optional[float] = None,
    ) -> httpx.Response:
        """Reapply filters to the spreadsheet

        Performs a [`SpreadsheetFiltersReapplication`](ref:content#spreadsheetfi
        ltersreapplication) on the specified spreadsheet.
        This endpoint is used to refresh the spreadsheet's filters based on the
        latest state or configuration changes.
        The filters are reapplied in the context of the spreadsheet's current
        data state.

        This is a long-running operation. Responses include a `Location` header,
        which indicates where to poll for results.
        For more details on long-running job polling, see [Operations
        endpoint](ref:getoperationbyid).

        Args:
            spreadsheet_id: The unique identifier of the spreadsheet
            ignore_non_editable_filters: Skip filters that cannot be reapplied (due to not having edit permissions, locked sheets, or sheets in input mode) instead of returning an error.
            timeout: Override the default request timeout (seconds).

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 429, 500, 503).

        Note:
            This is a long-running operation (HTTP 202). Use
            ``client.wait(response).result()`` to poll until completion.
        """
        _body: dict[str, Any] = {}
        if ignore_non_editable_filters is not None:
            _body["ignoreNonEditableFilters"] = ignore_non_editable_filters
        return self._client.request(
            "POST",
            self._api,
            "/spreadsheets/{spreadsheetId}/filters/reapplication",
            path_params={
                "spreadsheetId": spreadsheet_id,
            },
            json_body=_body or None,
            timeout=timeout,
        )

    async def spreadsheet_filters_reapplication_async(
        self,
        *,
        spreadsheet_id: str,
        ignore_non_editable_filters: Optional[bool] = None,
        timeout: Optional[float] = None,
    ) -> httpx.Response:
        """Reapply filters to the spreadsheet (async)

        Performs a [`SpreadsheetFiltersReapplication`](ref:content#spreadsheetfi
        ltersreapplication) on the specified spreadsheet.
        This endpoint is used to refresh the spreadsheet's filters based on the
        latest state or configuration changes.
        The filters are reapplied in the context of the spreadsheet's current
        data state.

        This is a long-running operation. Responses include a `Location` header,
        which indicates where to poll for results.
        For more details on long-running job polling, see [Operations
        endpoint](ref:getoperationbyid).

        Args:
            spreadsheet_id: The unique identifier of the spreadsheet
            ignore_non_editable_filters: Skip filters that cannot be reapplied (due to not having edit permissions, locked sheets, or sheets in input mode) instead of returning an error.
            timeout: Override the default request timeout (seconds).

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 429, 500, 503).

        Note:
            This is a long-running operation (HTTP 202). Use
            ``await client.wait(response).result_async()`` to poll until completion.
        """
        _body: dict[str, Any] = {}
        if ignore_non_editable_filters is not None:
            _body["ignoreNonEditableFilters"] = ignore_non_editable_filters
        return await self._client.request_async(
            "POST",
            self._api,
            "/spreadsheets/{spreadsheetId}/filters/reapplication",
            path_params={
                "spreadsheetId": spreadsheet_id,
            },
            json_body=_body or None,
            timeout=timeout,
        )

    def spreadsheet_links_publication(
        self,
        *,
        spreadsheet_id: str,
        publish_type: Literal["ownLinks", "allLinks"],
        timeout: Optional[float] = None,
    ) -> httpx.Response:
        """Initiate publication of links in a spreadsheet

        Publishes the links in a spreadsheet - either all (as document owner) or
        only one's own. Content at the latest spreadsheet revision will be used
        for publish.
        The response also includes a `Location` header, which indicates where to
        poll for operation results. For more details on long-running job
        polling, see [Operations endpoint](ref:getoperationbyid).

        Args:
            spreadsheet_id: The unique identifier of the spreadsheet
            publish_type: Whether or not all links should be published. When "ownLinks" only links one has last edited are published. When "allLinks" all links in document or presentation are published.

            timeout: Override the default request timeout (seconds).

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 429, 500, 503).

        Note:
            This is a long-running operation (HTTP 202). Use
            ``client.wait(response).result()`` to poll until completion.
        """
        _body: dict[str, Any] = {}
        if publish_type is not None:
            _body["publishType"] = publish_type
        return self._client.request(
            "POST",
            self._api,
            "/spreadsheets/{spreadsheetId}/links/publication",
            path_params={
                "spreadsheetId": spreadsheet_id,
            },
            json_body=_body or None,
            timeout=timeout,
        )

    async def spreadsheet_links_publication_async(
        self,
        *,
        spreadsheet_id: str,
        publish_type: Literal["ownLinks", "allLinks"],
        timeout: Optional[float] = None,
    ) -> httpx.Response:
        """Initiate publication of links in a spreadsheet (async)

        Publishes the links in a spreadsheet - either all (as document owner) or
        only one's own. Content at the latest spreadsheet revision will be used
        for publish.
        The response also includes a `Location` header, which indicates where to
        poll for operation results. For more details on long-running job
        polling, see [Operations endpoint](ref:getoperationbyid).

        Args:
            spreadsheet_id: The unique identifier of the spreadsheet
            publish_type: Whether or not all links should be published. When "ownLinks" only links one has last edited are published. When "allLinks" all links in document or presentation are published.

            timeout: Override the default request timeout (seconds).

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 429, 500, 503).

        Note:
            This is a long-running operation (HTTP 202). Use
            ``await client.wait(response).result_async()`` to poll until completion.
        """
        _body: dict[str, Any] = {}
        if publish_type is not None:
            _body["publishType"] = publish_type
        return await self._client.request_async(
            "POST",
            self._api,
            "/spreadsheets/{spreadsheetId}/links/publication",
            path_params={
                "spreadsheetId": spreadsheet_id,
            },
            json_body=_body or None,
            timeout=timeout,
        )

    def get_spreadsheet_milestones(
        self,
        *,
        spreadsheet_id: str,
        timeout: Optional[float] = None,
    ) -> MilestoneListResult:
        """Retrieve a list of milestones for a spreadsheet

        Returns [MilestoneListResult](ref:milestones#milestonelistresult).

        Args:
            spreadsheet_id: The unique identifier of the spreadsheet
            timeout: Override the default request timeout (seconds).

        Returns:
            MilestoneListResult

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 429, 500, 503).
        """

        def _fetch(_cursor: str | None) -> httpx.Response:
            return self._client.request(
                "GET",
                self._api,
                "/spreadsheets/{spreadsheetId}/milestones",
                path_params={
                    "spreadsheetId": spreadsheet_id,
                },
                query_params={
                    "$next": _cursor,
                },
                timeout=timeout,
            )

        _body_result = paginate_all(_fetch, extract_next_link, "data")
        return MilestoneListResult.model_validate(_body_result)

    async def get_spreadsheet_milestones_async(
        self,
        *,
        spreadsheet_id: str,
        timeout: Optional[float] = None,
    ) -> MilestoneListResult:
        """Retrieve a list of milestones for a spreadsheet (async)

        Returns [MilestoneListResult](ref:milestones#milestonelistresult).

        Args:
            spreadsheet_id: The unique identifier of the spreadsheet
            timeout: Override the default request timeout (seconds).

        Returns:
            MilestoneListResult

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 429, 500, 503).
        """

        async def _fetch(_cursor: str | None) -> httpx.Response:
            return await self._client.request_async(
                "GET",
                self._api,
                "/spreadsheets/{spreadsheetId}/milestones",
                path_params={
                    "spreadsheetId": spreadsheet_id,
                },
                query_params={
                    "$next": _cursor,
                },
                timeout=timeout,
            )

        _body_result = await paginate_all_async(_fetch, extract_next_link, "data")
        return MilestoneListResult.model_validate(_body_result)

    def get_spreadsheet_permissions(
        self,
        *,
        spreadsheet_id: str,
        filter_: Optional[str] = None,
        maxpagesize: Optional[int] = 1000,
        timeout: Optional[float] = None,
    ) -> ResourcePermissionsListResult:
        """Retrieve permissions for a spreadsheet

        Retrieves a paginated list of permissions for a given spreadsheet

        Args:
            spreadsheet_id: The unique identifier of the spreadsheet
            filter_: The properties to filter the results by.
            maxpagesize: The maximum number of results to retrieve
            timeout: Override the default request timeout (seconds).

        Returns:
            ResourcePermissionsListResult

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 429, 500, 503).
        """

        def _fetch(_cursor: str | None) -> httpx.Response:
            return self._client.request(
                "GET",
                self._api,
                "/spreadsheets/{spreadsheetId}/permissions",
                path_params={
                    "spreadsheetId": spreadsheet_id,
                },
                query_params={
                    "$filter": filter_,
                    "$maxpagesize": maxpagesize,
                    "$next": _cursor,
                },
                timeout=timeout,
            )

        _body_result = paginate_all(_fetch, extract_next_link, "data")
        return ResourcePermissionsListResult.model_validate(_body_result)

    async def get_spreadsheet_permissions_async(
        self,
        *,
        spreadsheet_id: str,
        filter_: Optional[str] = None,
        maxpagesize: Optional[int] = 1000,
        timeout: Optional[float] = None,
    ) -> ResourcePermissionsListResult:
        """Retrieve permissions for a spreadsheet (async)

        Retrieves a paginated list of permissions for a given spreadsheet

        Args:
            spreadsheet_id: The unique identifier of the spreadsheet
            filter_: The properties to filter the results by.
            maxpagesize: The maximum number of results to retrieve
            timeout: Override the default request timeout (seconds).

        Returns:
            ResourcePermissionsListResult

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 429, 500, 503).
        """

        async def _fetch(_cursor: str | None) -> httpx.Response:
            return await self._client.request_async(
                "GET",
                self._api,
                "/spreadsheets/{spreadsheetId}/permissions",
                path_params={
                    "spreadsheetId": spreadsheet_id,
                },
                query_params={
                    "$filter": filter_,
                    "$maxpagesize": maxpagesize,
                    "$next": _cursor,
                },
                timeout=timeout,
            )

        _body_result = await paginate_all_async(_fetch, extract_next_link, "data")
        return ResourcePermissionsListResult.model_validate(_body_result)

    def spreadsheet_permissions_modification(
        self,
        *,
        spreadsheet_id: str,
        to_assign: Optional[list[ResourcePermission]] = None,
        to_revoke: Optional[list[ResourcePermission]] = None,
        timeout: Optional[float] = None,
    ) -> httpx.Response:
        """Modify permissions on a spreadsheet

        Assign and/or revoke permissions on a spreadsheet. If any modification
        in a request fails, all modifications on that request fail. <br /><br />
        _To modify an existing permission, the existing permission must first be
        explicitly revoked. Then, the new permission needs to be assigned. This
        can be done in a single request by sending `toAssign` and `toRevoke` in
        the request body._

        Args:
            spreadsheet_id: The unique identifier of the spreadsheet
            to_assign: The list of permissions to be assigned to the resource
            to_revoke: The list of permissions to be revoked from the resource
            timeout: Override the default request timeout (seconds).

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 429, 500, 503).
        """
        _body: dict[str, Any] = {}
        if to_assign is not None:
            _body["toAssign"] = to_assign
        if to_revoke is not None:
            _body["toRevoke"] = to_revoke
        return self._client.request(
            "POST",
            self._api,
            "/spreadsheets/{spreadsheetId}/permissions/modification",
            path_params={
                "spreadsheetId": spreadsheet_id,
            },
            json_body=_body or None,
            timeout=timeout,
        )

    async def spreadsheet_permissions_modification_async(
        self,
        *,
        spreadsheet_id: str,
        to_assign: Optional[list[ResourcePermission]] = None,
        to_revoke: Optional[list[ResourcePermission]] = None,
        timeout: Optional[float] = None,
    ) -> httpx.Response:
        """Modify permissions on a spreadsheet (async)

        Assign and/or revoke permissions on a spreadsheet. If any modification
        in a request fails, all modifications on that request fail. <br /><br />
        _To modify an existing permission, the existing permission must first be
        explicitly revoked. Then, the new permission needs to be assigned. This
        can be done in a single request by sending `toAssign` and `toRevoke` in
        the request body._

        Args:
            spreadsheet_id: The unique identifier of the spreadsheet
            to_assign: The list of permissions to be assigned to the resource
            to_revoke: The list of permissions to be revoked from the resource
            timeout: Override the default request timeout (seconds).

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 429, 500, 503).
        """
        _body: dict[str, Any] = {}
        if to_assign is not None:
            _body["toAssign"] = to_assign
        if to_revoke is not None:
            _body["toRevoke"] = to_revoke
        return await self._client.request_async(
            "POST",
            self._api,
            "/spreadsheets/{spreadsheetId}/permissions/modification",
            path_params={
                "spreadsheetId": spreadsheet_id,
            },
            json_body=_body or None,
            timeout=timeout,
        )

    def create_sheet(
        self,
        *,
        spreadsheet_id: str,
        custom_fields: Optional[dict[str, Any]] = None,
        id_: Optional[str] = None,
        index: Optional[int] = None,
        lock: Optional[str] = None,
        name: Optional[str] = None,
        parent: Optional[Sheet] = None,
        table: Optional[TableRef] = None,
        timeout: Optional[float] = None,
    ) -> Sheet:
        """Create a new sheet in a spreadsheet

        Creates a new [sheet](ref:spreadsheets#sheet) in a
        [spreadsheet](ref:spreadsheets#spreadsheet), given its properties. If
        the sheet name provided isn't unique, a number is appended to make it
        unique. By default, creates a top-level sheet in the top-most position.

        Args:
            spreadsheet_id: The unique identifier of the spreadsheet
            custom_fields: A map of ids to values representing Custom Fields on the sheet.

            id_: The unique identifier of the sheet
            index: The integer index of the sheet relative to its parent sheet or to the spreadsheet, if no parent sheet. To position a sheet at the end of its siblings, use the special value -1.
            lock: The type of lock applied to this sheet, if any. Note this property is not tied to revision and will always reflect the sheet's current lock state. When this field is not present on the sheet object, the sheet is not locked.
            name: The name of the sheet
            parent:
            table:
            timeout: Override the default request timeout (seconds).

        Returns:
            Sheet

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 429, 500, 503).
        """
        _body: dict[str, Any] = {}
        if custom_fields is not None:
            _body["customFields"] = custom_fields
        if id_ is not None:
            _body["id"] = id_
        if index is not None:
            _body["index"] = index
        if lock is not None:
            _body["lock"] = lock
        if name is not None:
            _body["name"] = name
        if parent is not None:
            _body["parent"] = parent
        if table is not None:
            _body["table"] = table
        response = self._client.request(
            "POST",
            self._api,
            "/spreadsheets/{spreadsheetId}/sheets",
            path_params={
                "spreadsheetId": spreadsheet_id,
            },
            json_body=_body or None,
            timeout=timeout,
        )
        return Sheet.model_validate(response.json())

    async def create_sheet_async(
        self,
        *,
        spreadsheet_id: str,
        custom_fields: Optional[dict[str, Any]] = None,
        id_: Optional[str] = None,
        index: Optional[int] = None,
        lock: Optional[str] = None,
        name: Optional[str] = None,
        parent: Optional[Sheet] = None,
        table: Optional[TableRef] = None,
        timeout: Optional[float] = None,
    ) -> Sheet:
        """Create a new sheet in a spreadsheet (async)

        Creates a new [sheet](ref:spreadsheets#sheet) in a
        [spreadsheet](ref:spreadsheets#spreadsheet), given its properties. If
        the sheet name provided isn't unique, a number is appended to make it
        unique. By default, creates a top-level sheet in the top-most position.

        Args:
            spreadsheet_id: The unique identifier of the spreadsheet
            custom_fields: A map of ids to values representing Custom Fields on the sheet.

            id_: The unique identifier of the sheet
            index: The integer index of the sheet relative to its parent sheet or to the spreadsheet, if no parent sheet. To position a sheet at the end of its siblings, use the special value -1.
            lock: The type of lock applied to this sheet, if any. Note this property is not tied to revision and will always reflect the sheet's current lock state. When this field is not present on the sheet object, the sheet is not locked.
            name: The name of the sheet
            parent:
            table:
            timeout: Override the default request timeout (seconds).

        Returns:
            Sheet

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 429, 500, 503).
        """
        _body: dict[str, Any] = {}
        if custom_fields is not None:
            _body["customFields"] = custom_fields
        if id_ is not None:
            _body["id"] = id_
        if index is not None:
            _body["index"] = index
        if lock is not None:
            _body["lock"] = lock
        if name is not None:
            _body["name"] = name
        if parent is not None:
            _body["parent"] = parent
        if table is not None:
            _body["table"] = table
        response = await self._client.request_async(
            "POST",
            self._api,
            "/spreadsheets/{spreadsheetId}/sheets",
            path_params={
                "spreadsheetId": spreadsheet_id,
            },
            json_body=_body or None,
            timeout=timeout,
        )
        return Sheet.model_validate(response.json())

    def get_sheets(
        self,
        *,
        spreadsheet_id: str,
        revision: Optional[str] = None,
        maxpagesize: Optional[int] = 1000,
        timeout: Optional[float] = None,
    ) -> SheetsListResult:
        """Retrieve a list of sheets

        Returns a list of [sheets](ref:spreadsheets#sheet).

        Args:
            spreadsheet_id: The unique identifier of the spreadsheet
            revision: Returns resources at a specific revision
            maxpagesize: The maximum number of results to retrieve
            timeout: Override the default request timeout (seconds).

        Returns:
            SheetsListResult

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 429, 500, 503).
        """

        def _fetch(_cursor: str | None) -> httpx.Response:
            return self._client.request(
                "GET",
                self._api,
                "/spreadsheets/{spreadsheetId}/sheets",
                path_params={
                    "spreadsheetId": spreadsheet_id,
                },
                query_params={
                    "$revision": revision,
                    "$maxpagesize": maxpagesize,
                    "$next": _cursor,
                },
                timeout=timeout,
            )

        _body_result = paginate_all(_fetch, extract_next_link, "data")
        return SheetsListResult.model_validate(_body_result)

    async def get_sheets_async(
        self,
        *,
        spreadsheet_id: str,
        revision: Optional[str] = None,
        maxpagesize: Optional[int] = 1000,
        timeout: Optional[float] = None,
    ) -> SheetsListResult:
        """Retrieve a list of sheets (async)

        Returns a list of [sheets](ref:spreadsheets#sheet).

        Args:
            spreadsheet_id: The unique identifier of the spreadsheet
            revision: Returns resources at a specific revision
            maxpagesize: The maximum number of results to retrieve
            timeout: Override the default request timeout (seconds).

        Returns:
            SheetsListResult

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 429, 500, 503).
        """

        async def _fetch(_cursor: str | None) -> httpx.Response:
            return await self._client.request_async(
                "GET",
                self._api,
                "/spreadsheets/{spreadsheetId}/sheets",
                path_params={
                    "spreadsheetId": spreadsheet_id,
                },
                query_params={
                    "$revision": revision,
                    "$maxpagesize": maxpagesize,
                    "$next": _cursor,
                },
                timeout=timeout,
            )

        _body_result = await paginate_all_async(_fetch, extract_next_link, "data")
        return SheetsListResult.model_validate(_body_result)

    def partially_update_sheet_by_id(
        self,
        *,
        spreadsheet_id: str,
        sheet_id: str,
        body: list[Any],
        timeout: Optional[float] = None,
    ) -> httpx.Response:
        """Partially update a single sheet

        Updates the properties of a [sheet](ref:spreadsheets#sheet).

        This is a long running operation. Responses include a `Location` header,
        which indicates where to poll for results. For more details on long-
        running job polling,
        see [Operations endpoint](ref:getoperationbyid).

        ### Options
        | Path                              | PATCH Operations Supported
        |
        |-----------------------------------|-----------------------------------
        -|
        | `/name`                           | `replace`
        |
        | `/index`                          | `replace`
        |
        | `/parent`                         | `replace`
        |
        | `/customFields/<custom field id>` | `add`, `remove`, `replace`, `test`
        |
        | `/lock`                           | `replace`
        |

        ### Examples

        #### Lock an unlocked sheet

        ```json
        [
          {
            "op": "replace",
            "path": "/lock",
            "value": "lock"
          }
        ]
        ```

        #### Unlock a locked sheet

        ```json
        [
          {
            "op": "replace",
            "path": "/lock",
            "value": null
          }
        ]
        ```

        #### Update the name of a sheet

        ```json
        [
          {
            "op": "replace",
            "path": "/name",
            "value": "Q1 Draft"
          }
        ]
        ```

        #### Update the parent of a sheet (preserving its index)

        ```json
        [
          {
            "op": "replace",
            "path": "/parent",
            "value": {
              "id": "242a56d3cc0742c8abad0820bd318b23"
            }
          }
        ]
        ```

        #### Update the parent of a sheet (making it the first child)

        ```json
        [
          {
            "op": "replace",
            "path": "/parent",
            "value": {
              "id": "242a56d3cc0742c8abad0820bd318b23"
            }
          },
          {
            "op": "replace",
            "path": "/index",
            "value": 0
          }
        ]
        ```

        #### Add a custom field value

        ```json
        [
          {
            "op": "add",
            "path": "/customFields/com.workiva.gsr.legal_entity",
            "value": "Workiva"
          }
        ]
        ```

        #### Remove a custom field value

        ```json
        [
          {
            "op": "remove",
            "path": "/customFields/com.workiva.gsr.legal_entity"
          }
        ]
        ```

        #### Replace a custom field value

        ```json
        [
          {
            "op": "replace",
            "path": "/customFields/com.workiva.gsr.legal_entity",
            "value": "Workiva, Inc."
          }
        ]
        ```

        Args:
            spreadsheet_id: The unique identifier of the spreadsheet
            sheet_id: The unique identifier of the sheet
            body: Request body.
            timeout: Override the default request timeout (seconds).

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 429, 500, 503).

        Note:
            This is a long-running operation (HTTP 202). Use
            ``client.wait(response).result()`` to poll until completion.
        """
        return self._client.request(
            "PATCH",
            self._api,
            "/spreadsheets/{spreadsheetId}/sheets/{sheetId}",
            path_params={
                "spreadsheetId": spreadsheet_id,
                "sheetId": sheet_id,
            },
            json_body=body,
            timeout=timeout,
        )

    async def partially_update_sheet_by_id_async(
        self,
        *,
        spreadsheet_id: str,
        sheet_id: str,
        body: list[Any],
        timeout: Optional[float] = None,
    ) -> httpx.Response:
        """Partially update a single sheet (async)

        Updates the properties of a [sheet](ref:spreadsheets#sheet).

        This is a long running operation. Responses include a `Location` header,
        which indicates where to poll for results. For more details on long-
        running job polling,
        see [Operations endpoint](ref:getoperationbyid).

        ### Options
        | Path                              | PATCH Operations Supported
        |
        |-----------------------------------|-----------------------------------
        -|
        | `/name`                           | `replace`
        |
        | `/index`                          | `replace`
        |
        | `/parent`                         | `replace`
        |
        | `/customFields/<custom field id>` | `add`, `remove`, `replace`, `test`
        |
        | `/lock`                           | `replace`
        |

        ### Examples

        #### Lock an unlocked sheet

        ```json
        [
          {
            "op": "replace",
            "path": "/lock",
            "value": "lock"
          }
        ]
        ```

        #### Unlock a locked sheet

        ```json
        [
          {
            "op": "replace",
            "path": "/lock",
            "value": null
          }
        ]
        ```

        #### Update the name of a sheet

        ```json
        [
          {
            "op": "replace",
            "path": "/name",
            "value": "Q1 Draft"
          }
        ]
        ```

        #### Update the parent of a sheet (preserving its index)

        ```json
        [
          {
            "op": "replace",
            "path": "/parent",
            "value": {
              "id": "242a56d3cc0742c8abad0820bd318b23"
            }
          }
        ]
        ```

        #### Update the parent of a sheet (making it the first child)

        ```json
        [
          {
            "op": "replace",
            "path": "/parent",
            "value": {
              "id": "242a56d3cc0742c8abad0820bd318b23"
            }
          },
          {
            "op": "replace",
            "path": "/index",
            "value": 0
          }
        ]
        ```

        #### Add a custom field value

        ```json
        [
          {
            "op": "add",
            "path": "/customFields/com.workiva.gsr.legal_entity",
            "value": "Workiva"
          }
        ]
        ```

        #### Remove a custom field value

        ```json
        [
          {
            "op": "remove",
            "path": "/customFields/com.workiva.gsr.legal_entity"
          }
        ]
        ```

        #### Replace a custom field value

        ```json
        [
          {
            "op": "replace",
            "path": "/customFields/com.workiva.gsr.legal_entity",
            "value": "Workiva, Inc."
          }
        ]
        ```

        Args:
            spreadsheet_id: The unique identifier of the spreadsheet
            sheet_id: The unique identifier of the sheet
            body: Request body.
            timeout: Override the default request timeout (seconds).

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 429, 500, 503).

        Note:
            This is a long-running operation (HTTP 202). Use
            ``await client.wait(response).result_async()`` to poll until completion.
        """
        return await self._client.request_async(
            "PATCH",
            self._api,
            "/spreadsheets/{spreadsheetId}/sheets/{sheetId}",
            path_params={
                "spreadsheetId": spreadsheet_id,
                "sheetId": sheet_id,
            },
            json_body=body,
            timeout=timeout,
        )

    def delete_sheet_by_id(
        self,
        *,
        spreadsheet_id: str,
        sheet_id: str,
        timeout: Optional[float] = None,
    ) -> httpx.Response:
        """Delete a single sheet

        Deletes a [sheet](ref:spreadsheets#sheet) given its ID.

        Args:
            spreadsheet_id: The unique identifier of the spreadsheet
            sheet_id: The unique identifier of the sheet
            timeout: Override the default request timeout (seconds).

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 429, 500, 503).
        """
        return self._client.request(
            "DELETE",
            self._api,
            "/spreadsheets/{spreadsheetId}/sheets/{sheetId}",
            path_params={
                "spreadsheetId": spreadsheet_id,
                "sheetId": sheet_id,
            },
            timeout=timeout,
        )

    async def delete_sheet_by_id_async(
        self,
        *,
        spreadsheet_id: str,
        sheet_id: str,
        timeout: Optional[float] = None,
    ) -> httpx.Response:
        """Delete a single sheet (async)

        Deletes a [sheet](ref:spreadsheets#sheet) given its ID.

        Args:
            spreadsheet_id: The unique identifier of the spreadsheet
            sheet_id: The unique identifier of the sheet
            timeout: Override the default request timeout (seconds).

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 429, 500, 503).
        """
        return await self._client.request_async(
            "DELETE",
            self._api,
            "/spreadsheets/{spreadsheetId}/sheets/{sheetId}",
            path_params={
                "spreadsheetId": spreadsheet_id,
                "sheetId": sheet_id,
            },
            timeout=timeout,
        )

    def get_sheet_by_id(
        self,
        *,
        spreadsheet_id: str,
        sheet_id: str,
        revision: Optional[str] = None,
        timeout: Optional[float] = None,
    ) -> Sheet:
        """Retrieve a single sheet

        Retrieves a [sheet](ref:spreadsheets#sheet) given its ID.

        Args:
            spreadsheet_id: The unique identifier of the spreadsheet
            sheet_id: The unique identifier of the sheet
            revision: Returns resources at a specific revision
            timeout: Override the default request timeout (seconds).

        Returns:
            Sheet

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 429, 500, 503).
        """
        response = self._client.request(
            "GET",
            self._api,
            "/spreadsheets/{spreadsheetId}/sheets/{sheetId}",
            path_params={
                "spreadsheetId": spreadsheet_id,
                "sheetId": sheet_id,
            },
            query_params={
                "$revision": revision,
            },
            timeout=timeout,
        )
        return Sheet.model_validate(response.json())

    async def get_sheet_by_id_async(
        self,
        *,
        spreadsheet_id: str,
        sheet_id: str,
        revision: Optional[str] = None,
        timeout: Optional[float] = None,
    ) -> Sheet:
        """Retrieve a single sheet (async)

        Retrieves a [sheet](ref:spreadsheets#sheet) given its ID.

        Args:
            spreadsheet_id: The unique identifier of the spreadsheet
            sheet_id: The unique identifier of the sheet
            revision: Returns resources at a specific revision
            timeout: Override the default request timeout (seconds).

        Returns:
            Sheet

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 429, 500, 503).
        """
        response = await self._client.request_async(
            "GET",
            self._api,
            "/spreadsheets/{spreadsheetId}/sheets/{sheetId}",
            path_params={
                "spreadsheetId": spreadsheet_id,
                "sheetId": sheet_id,
            },
            query_params={
                "$revision": revision,
            },
            timeout=timeout,
        )
        return Sheet.model_validate(response.json())

    def copy_sheet(
        self,
        *,
        spreadsheet_id: str,
        sheet_id: str,
        spreadsheet: str,
        sheet_index: Optional[int] = None,
        sheet_name: Optional[str] = None,
        sheet_parent: Optional[str] = None,
        timeout: Optional[float] = None,
    ) -> httpx.Response:
        """Copy sheet

        Asynchronously copies a [sheet](ref:spreadsheets#sheet) given details
        about the copy's destination within the same or another spreadsheet.
        Options are specified using a [SheetCopy](ref:spreadsheets#sheetcopy)
        object.

        This endpoint copies a sheet's content, but does not copy labels,
        comments, or tasks. It will copy over most formatting, however it does
        not copy user-defined style guides across spreadsheets. So if the source
        sheet has  formatting that depends on a user-defined style guide, that
        formatting will be lost when copying to a new spreadsheet.

        Unless otherwise specified, the copy appears at the top level of its
        destination spreadsheet, with an index of 0, and with the same name as
        the original sheet.

        Args:
            spreadsheet_id: The unique identifier of the spreadsheet
            sheet_id: The unique identifier of the sheet
            spreadsheet: The unique identifier of the spreadsheet to copy a sheet into
            sheet_index: The integer index of where within the siblings to place the new sheet; 0 by default. To place the sheet at the end of its siblings, use the special value -1.
            sheet_name: The name of the new sheet, if different than the source sheet.
            sheet_parent: The ID of the parent sheet to copy the sheet into. To place the sheet at the top level of the spreadsheet, use the default null.
            timeout: Override the default request timeout (seconds).

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 429, 500, 503).

        Note:
            This is a long-running operation (HTTP 202). Use
            ``client.wait(response).result()`` to poll until completion.
        """
        _body: dict[str, Any] = {}
        if spreadsheet is not None:
            _body["spreadsheet"] = spreadsheet
        if sheet_index is not None:
            _body["sheetIndex"] = sheet_index
        if sheet_name is not None:
            _body["sheetName"] = sheet_name
        if sheet_parent is not None:
            _body["sheetParent"] = sheet_parent
        return self._client.request(
            "POST",
            self._api,
            "/spreadsheets/{spreadsheetId}/sheets/{sheetId}/copy",
            path_params={
                "spreadsheetId": spreadsheet_id,
                "sheetId": sheet_id,
            },
            json_body=_body or None,
            timeout=timeout,
        )

    async def copy_sheet_async(
        self,
        *,
        spreadsheet_id: str,
        sheet_id: str,
        spreadsheet: str,
        sheet_index: Optional[int] = None,
        sheet_name: Optional[str] = None,
        sheet_parent: Optional[str] = None,
        timeout: Optional[float] = None,
    ) -> httpx.Response:
        """Copy sheet (async)

        Asynchronously copies a [sheet](ref:spreadsheets#sheet) given details
        about the copy's destination within the same or another spreadsheet.
        Options are specified using a [SheetCopy](ref:spreadsheets#sheetcopy)
        object.

        This endpoint copies a sheet's content, but does not copy labels,
        comments, or tasks. It will copy over most formatting, however it does
        not copy user-defined style guides across spreadsheets. So if the source
        sheet has  formatting that depends on a user-defined style guide, that
        formatting will be lost when copying to a new spreadsheet.

        Unless otherwise specified, the copy appears at the top level of its
        destination spreadsheet, with an index of 0, and with the same name as
        the original sheet.

        Args:
            spreadsheet_id: The unique identifier of the spreadsheet
            sheet_id: The unique identifier of the sheet
            spreadsheet: The unique identifier of the spreadsheet to copy a sheet into
            sheet_index: The integer index of where within the siblings to place the new sheet; 0 by default. To place the sheet at the end of its siblings, use the special value -1.
            sheet_name: The name of the new sheet, if different than the source sheet.
            sheet_parent: The ID of the parent sheet to copy the sheet into. To place the sheet at the top level of the spreadsheet, use the default null.
            timeout: Override the default request timeout (seconds).

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 429, 500, 503).

        Note:
            This is a long-running operation (HTTP 202). Use
            ``await client.wait(response).result_async()`` to poll until completion.
        """
        _body: dict[str, Any] = {}
        if spreadsheet is not None:
            _body["spreadsheet"] = spreadsheet
        if sheet_index is not None:
            _body["sheetIndex"] = sheet_index
        if sheet_name is not None:
            _body["sheetName"] = sheet_name
        if sheet_parent is not None:
            _body["sheetParent"] = sheet_parent
        return await self._client.request_async(
            "POST",
            self._api,
            "/spreadsheets/{spreadsheetId}/sheets/{sheetId}/copy",
            path_params={
                "spreadsheetId": spreadsheet_id,
                "sheetId": sheet_id,
            },
            json_body=_body or None,
            timeout=timeout,
        )

    def delete_dataset_by_sheet_id(
        self,
        *,
        spreadsheet_id: str,
        sheet_id: str,
        deletevalues: Optional[bool] = False,
        timeout: Optional[float] = None,
    ) -> httpx.Response:
        """Delete a single dataset

        Deletes the [dataset](ref:spreadsheets#dataset) for the specified
        [sheet](ref:spreadsheets#sheet). <br /><br /> When you delete a dataset,
        you can select whether to leave its associated values in place. To
        delete its values, pass `true` for query parameter `$deletevalues`
        (default is `false`).

        Args:
            spreadsheet_id: The unique identifier of the spreadsheet
            sheet_id: The unique identifier of the sheet
            deletevalues: Indicates whether values should be deleted along with the dataset
            timeout: Override the default request timeout (seconds).

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 429, 500, 503).

        Note:
            This is a long-running operation (HTTP 202). Use
            ``client.wait(response).result()`` to poll until completion.
        """
        return self._client.request(
            "DELETE",
            self._api,
            "/spreadsheets/{spreadsheetId}/sheets/{sheetId}/dataset",
            path_params={
                "spreadsheetId": spreadsheet_id,
                "sheetId": sheet_id,
            },
            query_params={
                "$deletevalues": deletevalues,
            },
            timeout=timeout,
        )

    async def delete_dataset_by_sheet_id_async(
        self,
        *,
        spreadsheet_id: str,
        sheet_id: str,
        deletevalues: Optional[bool] = False,
        timeout: Optional[float] = None,
    ) -> httpx.Response:
        """Delete a single dataset (async)

        Deletes the [dataset](ref:spreadsheets#dataset) for the specified
        [sheet](ref:spreadsheets#sheet). <br /><br /> When you delete a dataset,
        you can select whether to leave its associated values in place. To
        delete its values, pass `true` for query parameter `$deletevalues`
        (default is `false`).

        Args:
            spreadsheet_id: The unique identifier of the spreadsheet
            sheet_id: The unique identifier of the sheet
            deletevalues: Indicates whether values should be deleted along with the dataset
            timeout: Override the default request timeout (seconds).

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 429, 500, 503).

        Note:
            This is a long-running operation (HTTP 202). Use
            ``await client.wait(response).result_async()`` to poll until completion.
        """
        return await self._client.request_async(
            "DELETE",
            self._api,
            "/spreadsheets/{spreadsheetId}/sheets/{sheetId}/dataset",
            path_params={
                "spreadsheetId": spreadsheet_id,
                "sheetId": sheet_id,
            },
            query_params={
                "$deletevalues": deletevalues,
            },
            timeout=timeout,
        )

    def get_sheet_permissions(
        self,
        *,
        spreadsheet_id: str,
        sheet_id: str,
        filter_: Optional[str] = None,
        maxpagesize: Optional[int] = 1000,
        timeout: Optional[float] = None,
    ) -> ResourcePermissionsListResult:
        """Retrieve permissions for a sheet in a spreadsheet

        Retrieves a paginated list of permissions for the given sheet in a
        spreadsheet

        Args:
            spreadsheet_id: The unique identifier of the spreadsheet
            sheet_id: The unique identifier of the sheet
            filter_: The properties to filter the results by.
            maxpagesize: The maximum number of results to retrieve
            timeout: Override the default request timeout (seconds).

        Returns:
            ResourcePermissionsListResult

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 429, 500, 503).
        """

        def _fetch(_cursor: str | None) -> httpx.Response:
            return self._client.request(
                "GET",
                self._api,
                "/spreadsheets/{spreadsheetId}/sheets/{sheetId}/permissions",
                path_params={
                    "spreadsheetId": spreadsheet_id,
                    "sheetId": sheet_id,
                },
                query_params={
                    "$filter": filter_,
                    "$maxpagesize": maxpagesize,
                    "$next": _cursor,
                },
                timeout=timeout,
            )

        _body_result = paginate_all(_fetch, extract_next_link, "data")
        return ResourcePermissionsListResult.model_validate(_body_result)

    async def get_sheet_permissions_async(
        self,
        *,
        spreadsheet_id: str,
        sheet_id: str,
        filter_: Optional[str] = None,
        maxpagesize: Optional[int] = 1000,
        timeout: Optional[float] = None,
    ) -> ResourcePermissionsListResult:
        """Retrieve permissions for a sheet in a spreadsheet (async)

        Retrieves a paginated list of permissions for the given sheet in a
        spreadsheet

        Args:
            spreadsheet_id: The unique identifier of the spreadsheet
            sheet_id: The unique identifier of the sheet
            filter_: The properties to filter the results by.
            maxpagesize: The maximum number of results to retrieve
            timeout: Override the default request timeout (seconds).

        Returns:
            ResourcePermissionsListResult

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 429, 500, 503).
        """

        async def _fetch(_cursor: str | None) -> httpx.Response:
            return await self._client.request_async(
                "GET",
                self._api,
                "/spreadsheets/{spreadsheetId}/sheets/{sheetId}/permissions",
                path_params={
                    "spreadsheetId": spreadsheet_id,
                    "sheetId": sheet_id,
                },
                query_params={
                    "$filter": filter_,
                    "$maxpagesize": maxpagesize,
                    "$next": _cursor,
                },
                timeout=timeout,
            )

        _body_result = await paginate_all_async(_fetch, extract_next_link, "data")
        return ResourcePermissionsListResult.model_validate(_body_result)

    def sheet_permissions_modification(
        self,
        *,
        spreadsheet_id: str,
        sheet_id: str,
        to_assign: Optional[list[ResourcePermission]] = None,
        to_revoke: Optional[list[ResourcePermission]] = None,
        timeout: Optional[float] = None,
    ) -> httpx.Response:
        """Modify permissions on a given sheet of a spreadsheet

        Assign and/or revoke permissions on a sheet. If any modification in a
        request fails, all modifications on that request fail. <br /><br /> _To
        modify an existing permission, the existing permission must first be
        explicitly revoked. Then, the new permission needs to be assigned. This
        can be done in a single request by sending `toAssign` and `toRevoke` in
        the request body._

        Args:
            spreadsheet_id: The unique identifier of the spreadsheet
            sheet_id: The unique identifier of the sheet
            to_assign: The list of permissions to be assigned to the resource
            to_revoke: The list of permissions to be revoked from the resource
            timeout: Override the default request timeout (seconds).

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 429, 500, 503).
        """
        _body: dict[str, Any] = {}
        if to_assign is not None:
            _body["toAssign"] = to_assign
        if to_revoke is not None:
            _body["toRevoke"] = to_revoke
        return self._client.request(
            "POST",
            self._api,
            "/spreadsheets/{spreadsheetId}/sheets/{sheetId}/permissions/modification",
            path_params={
                "spreadsheetId": spreadsheet_id,
                "sheetId": sheet_id,
            },
            json_body=_body or None,
            timeout=timeout,
        )

    async def sheet_permissions_modification_async(
        self,
        *,
        spreadsheet_id: str,
        sheet_id: str,
        to_assign: Optional[list[ResourcePermission]] = None,
        to_revoke: Optional[list[ResourcePermission]] = None,
        timeout: Optional[float] = None,
    ) -> httpx.Response:
        """Modify permissions on a given sheet of a spreadsheet (async)

        Assign and/or revoke permissions on a sheet. If any modification in a
        request fails, all modifications on that request fail. <br /><br /> _To
        modify an existing permission, the existing permission must first be
        explicitly revoked. Then, the new permission needs to be assigned. This
        can be done in a single request by sending `toAssign` and `toRevoke` in
        the request body._

        Args:
            spreadsheet_id: The unique identifier of the spreadsheet
            sheet_id: The unique identifier of the sheet
            to_assign: The list of permissions to be assigned to the resource
            to_revoke: The list of permissions to be revoked from the resource
            timeout: Override the default request timeout (seconds).

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 429, 500, 503).
        """
        _body: dict[str, Any] = {}
        if to_assign is not None:
            _body["toAssign"] = to_assign
        if to_revoke is not None:
            _body["toRevoke"] = to_revoke
        return await self._client.request_async(
            "POST",
            self._api,
            "/spreadsheets/{spreadsheetId}/sheets/{sheetId}/permissions/modification",
            path_params={
                "spreadsheetId": spreadsheet_id,
                "sheetId": sheet_id,
            },
            json_body=_body or None,
            timeout=timeout,
        )

    def get_sheet_data(
        self,
        *,
        spreadsheet_id: str,
        sheet_id: str,
        cellrange: Optional[str] = None,
        maxcellsperpage: Optional[int] = 50000,
        fields: Optional[str] = None,
        timeout: Optional[float] = None,
    ) -> SheetDataResult:
        """Retrieve data from a sheet

                Retrieve data from a range in a sheet. Includes the value & formatting
                of cells, visibility of columns and cells, merged ranges, etc.
                Limit the results to particular fields by providing a comma-separated
                list of paths, rooted at the `data` object.
                Example: $fields=cells.calculatedValue,cells.formats.valueFormat <br
                /><br /> Note: This endpoint is rate-limited. You may experience rates
                as low as 600 requests per minute.  This rate is shared across your
                workspace. When you encounter a 429, examine the `Retry-After`  header
                and retry after that many seconds.

                Args:
                    spreadsheet_id: The unique identifier of the spreadsheet
                    sheet_id: The unique identifier of the sheet
                    cellrange: The range to query. If not provided, the entire sheet will be queried.
        A1 style representation of a cell or range. A range my be unbounded in any/all directions by leaving off the corresponding column or row.

                    maxcellsperpage: The maximum number of cells to retrieve. The default is 50000. The maximum allowed value is 50000.
                    fields: A restricted set of fields for a given resource.
                    timeout: Override the default request timeout (seconds).

                Returns:
                    SheetDataResult

                Raises:
                    WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 429, 500, 503).
        """

        def _fetch(_cursor: str | None) -> httpx.Response:
            return self._client.request(
                "GET",
                self._api,
                "/spreadsheets/{spreadsheetId}/sheets/{sheetId}/sheetdata",
                path_params={
                    "spreadsheetId": spreadsheet_id,
                    "sheetId": sheet_id,
                },
                query_params={
                    "$cellrange": cellrange,
                    "$maxcellsperpage": maxcellsperpage,
                    "$fields": fields,
                    "$next": _cursor,
                },
                timeout=timeout,
            )

        _body_result = paginate_all(_fetch, extract_next_link, "data")
        return SheetDataResult.model_validate(_body_result)

    async def get_sheet_data_async(
        self,
        *,
        spreadsheet_id: str,
        sheet_id: str,
        cellrange: Optional[str] = None,
        maxcellsperpage: Optional[int] = 50000,
        fields: Optional[str] = None,
        timeout: Optional[float] = None,
    ) -> SheetDataResult:
        """Retrieve data from a sheet (async)

                Retrieve data from a range in a sheet. Includes the value & formatting
                of cells, visibility of columns and cells, merged ranges, etc.
                Limit the results to particular fields by providing a comma-separated
                list of paths, rooted at the `data` object.
                Example: $fields=cells.calculatedValue,cells.formats.valueFormat <br
                /><br /> Note: This endpoint is rate-limited. You may experience rates
                as low as 600 requests per minute.  This rate is shared across your
                workspace. When you encounter a 429, examine the `Retry-After`  header
                and retry after that many seconds.

                Args:
                    spreadsheet_id: The unique identifier of the spreadsheet
                    sheet_id: The unique identifier of the sheet
                    cellrange: The range to query. If not provided, the entire sheet will be queried.
        A1 style representation of a cell or range. A range my be unbounded in any/all directions by leaving off the corresponding column or row.

                    maxcellsperpage: The maximum number of cells to retrieve. The default is 50000. The maximum allowed value is 50000.
                    fields: A restricted set of fields for a given resource.
                    timeout: Override the default request timeout (seconds).

                Returns:
                    SheetDataResult

                Raises:
                    WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 429, 500, 503).
        """

        async def _fetch(_cursor: str | None) -> httpx.Response:
            return await self._client.request_async(
                "GET",
                self._api,
                "/spreadsheets/{spreadsheetId}/sheets/{sheetId}/sheetdata",
                path_params={
                    "spreadsheetId": spreadsheet_id,
                    "sheetId": sheet_id,
                },
                query_params={
                    "$cellrange": cellrange,
                    "$maxcellsperpage": maxcellsperpage,
                    "$fields": fields,
                    "$next": _cursor,
                },
                timeout=timeout,
            )

        _body_result = await paginate_all_async(_fetch, extract_next_link, "data")
        return SheetDataResult.model_validate(_body_result)

    def update_sheet(
        self,
        *,
        spreadsheet_id: str,
        sheet_id: str,
        apply_borders: Optional[SheetUpdateApplyBorders] = None,
        apply_formats: Optional[SheetUpdateApplyFormats] = None,
        clear_borders: Optional[SheetUpdateClearBorders] = None,
        clear_formats: Optional[SheetUpdateClearFormats] = None,
        delete_columns: Optional[SheetUpdateDeleteColumns] = None,
        delete_rows: Optional[SheetUpdateDeleteRows] = None,
        edit_cells: Optional[SheetUpdateEditCells] = None,
        edit_range: Optional[SheetUpdateEditRange] = None,
        hide_columns: Optional[SheetUpdateHideColumns] = None,
        hide_rows: Optional[SheetUpdateHideRows] = None,
        insert_columns: Optional[SheetUpdateInsertColumns] = None,
        insert_rows: Optional[SheetUpdateInsertRows] = None,
        merge_ranges: Optional[SheetUpdateMergeRanges] = None,
        resize_columns: Optional[SheetUpdateResizeColumns] = None,
        resize_columns_to_fit: Optional[SheetUpdateResizeColumnsToFit] = None,
        resize_rows: Optional[SheetUpdateResizeRows] = None,
        resize_rows_to_fit: Optional[SheetUpdateResizeRowsToFit] = None,
        unhide_columns: Optional[SheetUpdateUnhideColumns] = None,
        unhide_rows: Optional[SheetUpdateUnhideRows] = None,
        unmerge_ranges: Optional[SheetUpdateUnmergeRanges] = None,
        timeout: Optional[float] = None,
    ) -> httpx.Response:
        """Update sheet content

        Asynchronously submits a [SheetUpdate](ref:spreadsheets#sheetupdate) to
        a [sheet](ref:spreadsheets#sheet). Each
        [SheetUpdate](ref:spreadsheets#sheetupdate) can have only one update
        field set per request. <br /><br /> Note: This endpoint is rate-limited.
        You may experience rates as low as 60 requests per minute.  This rate is
        shared across your workspace. When you encounter a 429, examine the
        `Retry-After`  header and retry after that many seconds.

        Args:
            spreadsheet_id: The unique identifier of the spreadsheet
            sheet_id: The unique identifier of the sheet
            apply_borders:
            apply_formats:
            clear_borders:
            clear_formats:
            delete_columns:
            delete_rows:
            edit_cells:
            edit_range:
            hide_columns:
            hide_rows:
            insert_columns:
            insert_rows:
            merge_ranges:
            resize_columns:
            resize_columns_to_fit:
            resize_rows:
            resize_rows_to_fit:
            unhide_columns:
            unhide_rows:
            unmerge_ranges:
            timeout: Override the default request timeout (seconds).

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 429, 500, 503).

        Note:
            This is a long-running operation (HTTP 202). Use
            ``client.wait(response).result()`` to poll until completion.
        """
        _body: dict[str, Any] = {}
        if apply_borders is not None:
            _body["applyBorders"] = apply_borders
        if apply_formats is not None:
            _body["applyFormats"] = apply_formats
        if clear_borders is not None:
            _body["clearBorders"] = clear_borders
        if clear_formats is not None:
            _body["clearFormats"] = clear_formats
        if delete_columns is not None:
            _body["deleteColumns"] = delete_columns
        if delete_rows is not None:
            _body["deleteRows"] = delete_rows
        if edit_cells is not None:
            _body["editCells"] = edit_cells
        if edit_range is not None:
            _body["editRange"] = edit_range
        if hide_columns is not None:
            _body["hideColumns"] = hide_columns
        if hide_rows is not None:
            _body["hideRows"] = hide_rows
        if insert_columns is not None:
            _body["insertColumns"] = insert_columns
        if insert_rows is not None:
            _body["insertRows"] = insert_rows
        if merge_ranges is not None:
            _body["mergeRanges"] = merge_ranges
        if resize_columns is not None:
            _body["resizeColumns"] = resize_columns
        if resize_columns_to_fit is not None:
            _body["resizeColumnsToFit"] = resize_columns_to_fit
        if resize_rows is not None:
            _body["resizeRows"] = resize_rows
        if resize_rows_to_fit is not None:
            _body["resizeRowsToFit"] = resize_rows_to_fit
        if unhide_columns is not None:
            _body["unhideColumns"] = unhide_columns
        if unhide_rows is not None:
            _body["unhideRows"] = unhide_rows
        if unmerge_ranges is not None:
            _body["unmergeRanges"] = unmerge_ranges
        return self._client.request(
            "POST",
            self._api,
            "/spreadsheets/{spreadsheetId}/sheets/{sheetId}/update",
            path_params={
                "spreadsheetId": spreadsheet_id,
                "sheetId": sheet_id,
            },
            json_body=_body or None,
            timeout=timeout,
        )

    async def update_sheet_async(
        self,
        *,
        spreadsheet_id: str,
        sheet_id: str,
        apply_borders: Optional[SheetUpdateApplyBorders] = None,
        apply_formats: Optional[SheetUpdateApplyFormats] = None,
        clear_borders: Optional[SheetUpdateClearBorders] = None,
        clear_formats: Optional[SheetUpdateClearFormats] = None,
        delete_columns: Optional[SheetUpdateDeleteColumns] = None,
        delete_rows: Optional[SheetUpdateDeleteRows] = None,
        edit_cells: Optional[SheetUpdateEditCells] = None,
        edit_range: Optional[SheetUpdateEditRange] = None,
        hide_columns: Optional[SheetUpdateHideColumns] = None,
        hide_rows: Optional[SheetUpdateHideRows] = None,
        insert_columns: Optional[SheetUpdateInsertColumns] = None,
        insert_rows: Optional[SheetUpdateInsertRows] = None,
        merge_ranges: Optional[SheetUpdateMergeRanges] = None,
        resize_columns: Optional[SheetUpdateResizeColumns] = None,
        resize_columns_to_fit: Optional[SheetUpdateResizeColumnsToFit] = None,
        resize_rows: Optional[SheetUpdateResizeRows] = None,
        resize_rows_to_fit: Optional[SheetUpdateResizeRowsToFit] = None,
        unhide_columns: Optional[SheetUpdateUnhideColumns] = None,
        unhide_rows: Optional[SheetUpdateUnhideRows] = None,
        unmerge_ranges: Optional[SheetUpdateUnmergeRanges] = None,
        timeout: Optional[float] = None,
    ) -> httpx.Response:
        """Update sheet content (async)

        Asynchronously submits a [SheetUpdate](ref:spreadsheets#sheetupdate) to
        a [sheet](ref:spreadsheets#sheet). Each
        [SheetUpdate](ref:spreadsheets#sheetupdate) can have only one update
        field set per request. <br /><br /> Note: This endpoint is rate-limited.
        You may experience rates as low as 60 requests per minute.  This rate is
        shared across your workspace. When you encounter a 429, examine the
        `Retry-After`  header and retry after that many seconds.

        Args:
            spreadsheet_id: The unique identifier of the spreadsheet
            sheet_id: The unique identifier of the sheet
            apply_borders:
            apply_formats:
            clear_borders:
            clear_formats:
            delete_columns:
            delete_rows:
            edit_cells:
            edit_range:
            hide_columns:
            hide_rows:
            insert_columns:
            insert_rows:
            merge_ranges:
            resize_columns:
            resize_columns_to_fit:
            resize_rows:
            resize_rows_to_fit:
            unhide_columns:
            unhide_rows:
            unmerge_ranges:
            timeout: Override the default request timeout (seconds).

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 429, 500, 503).

        Note:
            This is a long-running operation (HTTP 202). Use
            ``await client.wait(response).result_async()`` to poll until completion.
        """
        _body: dict[str, Any] = {}
        if apply_borders is not None:
            _body["applyBorders"] = apply_borders
        if apply_formats is not None:
            _body["applyFormats"] = apply_formats
        if clear_borders is not None:
            _body["clearBorders"] = clear_borders
        if clear_formats is not None:
            _body["clearFormats"] = clear_formats
        if delete_columns is not None:
            _body["deleteColumns"] = delete_columns
        if delete_rows is not None:
            _body["deleteRows"] = delete_rows
        if edit_cells is not None:
            _body["editCells"] = edit_cells
        if edit_range is not None:
            _body["editRange"] = edit_range
        if hide_columns is not None:
            _body["hideColumns"] = hide_columns
        if hide_rows is not None:
            _body["hideRows"] = hide_rows
        if insert_columns is not None:
            _body["insertColumns"] = insert_columns
        if insert_rows is not None:
            _body["insertRows"] = insert_rows
        if merge_ranges is not None:
            _body["mergeRanges"] = merge_ranges
        if resize_columns is not None:
            _body["resizeColumns"] = resize_columns
        if resize_columns_to_fit is not None:
            _body["resizeColumnsToFit"] = resize_columns_to_fit
        if resize_rows is not None:
            _body["resizeRows"] = resize_rows
        if resize_rows_to_fit is not None:
            _body["resizeRowsToFit"] = resize_rows_to_fit
        if unhide_columns is not None:
            _body["unhideColumns"] = unhide_columns
        if unhide_rows is not None:
            _body["unhideRows"] = unhide_rows
        if unmerge_ranges is not None:
            _body["unmergeRanges"] = unmerge_ranges
        return await self._client.request_async(
            "POST",
            self._api,
            "/spreadsheets/{spreadsheetId}/sheets/{sheetId}/update",
            path_params={
                "spreadsheetId": spreadsheet_id,
                "sheetId": sheet_id,
            },
            json_body=_body or None,
            timeout=timeout,
        )

    def update_values_by_range(
        self,
        *,
        spreadsheet_id: str,
        sheet_id: str,
        range: str,
        range_: Optional[str] = None,
        values: Optional[list[list[dict[str, Any]]]] = None,
        timeout: Optional[float] = None,
    ) -> httpx.Response:
        """Update values in a range

        Overwrites all values in a range with new values. The provided range
        must not exceed the specified range. If the provided range of values is
        *smaller* than the specified range, it clears all cells in the range
        **and** those not covered by the range values. Rows of values in the
        provided range must be of equal length. An empty range of values is
        valid and may be used to clear a range.
        To indicate that a cell's value shouldn't be replaced, use the special
        cell value `null`.
        When you add a value to a cell, it uses Ones scale regardless of the
        cell's scale formatting.

        Args:
            spreadsheet_id: The unique identifier of the spreadsheet
            sheet_id: The unique identifier of the sheet
            range: The range of values, in A1-style notation
            range_: The range of values, in A1-style notation.
            values: A row-major ordered multidimensional array of cell values.
            timeout: Override the default request timeout (seconds).

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 429, 500, 503).

        Note:
            This is a long-running operation (HTTP 202). Use
            ``client.wait(response).result()`` to poll until completion.
        """
        _body: dict[str, Any] = {}
        if range_ is not None:
            _body["range"] = range_
        if values is not None:
            _body["values"] = values
        return self._client.request(
            "PUT",
            self._api,
            "/spreadsheets/{spreadsheetId}/sheets/{sheetId}/values/{range}",
            path_params={
                "spreadsheetId": spreadsheet_id,
                "sheetId": sheet_id,
                "range": range,
            },
            json_body=_body or None,
            timeout=timeout,
        )

    async def update_values_by_range_async(
        self,
        *,
        spreadsheet_id: str,
        sheet_id: str,
        range: str,
        range_: Optional[str] = None,
        values: Optional[list[list[dict[str, Any]]]] = None,
        timeout: Optional[float] = None,
    ) -> httpx.Response:
        """Update values in a range (async)

        Overwrites all values in a range with new values. The provided range
        must not exceed the specified range. If the provided range of values is
        *smaller* than the specified range, it clears all cells in the range
        **and** those not covered by the range values. Rows of values in the
        provided range must be of equal length. An empty range of values is
        valid and may be used to clear a range.
        To indicate that a cell's value shouldn't be replaced, use the special
        cell value `null`.
        When you add a value to a cell, it uses Ones scale regardless of the
        cell's scale formatting.

        Args:
            spreadsheet_id: The unique identifier of the spreadsheet
            sheet_id: The unique identifier of the sheet
            range: The range of values, in A1-style notation
            range_: The range of values, in A1-style notation.
            values: A row-major ordered multidimensional array of cell values.
            timeout: Override the default request timeout (seconds).

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 429, 500, 503).

        Note:
            This is a long-running operation (HTTP 202). Use
            ``await client.wait(response).result_async()`` to poll until completion.
        """
        _body: dict[str, Any] = {}
        if range_ is not None:
            _body["range"] = range_
        if values is not None:
            _body["values"] = values
        return await self._client.request_async(
            "PUT",
            self._api,
            "/spreadsheets/{spreadsheetId}/sheets/{sheetId}/values/{range}",
            path_params={
                "spreadsheetId": spreadsheet_id,
                "sheetId": sheet_id,
                "range": range,
            },
            json_body=_body or None,
            timeout=timeout,
        )

    def get_values_by_range(
        self,
        *,
        spreadsheet_id: str,
        sheet_id: str,
        range: str,
        maxcellsperpage: Optional[int] = 50000,
        valuestyle: Optional[Literal["raw", "calculated"]] = "calculated",
        timeout: Optional[float] = None,
    ) -> RangeValuesListResult:
        """Retrieve a list of range values

        Returns the paginated values for a specified range.
        When you retrieve values from a range, Ones scale is used regardless of
        the cell's scale formatting.

        Args:
            spreadsheet_id: The unique identifier of the spreadsheet
            sheet_id: The unique identifier of the sheet
            range: The range of values, in A1-style notation
            maxcellsperpage: The maximum number of cells to retrieve. The default is 50000. The maximum allowed value is 50000.
            valuestyle: Whether to retrieve `raw` or `calculated` cell values. For example, if a cell's value is `=1+1`, `raw` retrieves the value `=1+1`, while `calculated` retrieves `2`.
            timeout: Override the default request timeout (seconds).

        Returns:
            RangeValuesListResult

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 429, 500, 503).
        """

        def _fetch(_cursor: str | None) -> httpx.Response:
            return self._client.request(
                "GET",
                self._api,
                "/spreadsheets/{spreadsheetId}/sheets/{sheetId}/values/{range}",
                path_params={
                    "spreadsheetId": spreadsheet_id,
                    "sheetId": sheet_id,
                    "range": range,
                },
                query_params={
                    "$maxcellsperpage": maxcellsperpage,
                    "$valuestyle": valuestyle,
                    "$next": _cursor,
                },
                timeout=timeout,
            )

        _body_result = paginate_all(_fetch, extract_next_link, "data")
        return RangeValuesListResult.model_validate(_body_result)

    async def get_values_by_range_async(
        self,
        *,
        spreadsheet_id: str,
        sheet_id: str,
        range: str,
        maxcellsperpage: Optional[int] = 50000,
        valuestyle: Optional[Literal["raw", "calculated"]] = "calculated",
        timeout: Optional[float] = None,
    ) -> RangeValuesListResult:
        """Retrieve a list of range values (async)

        Returns the paginated values for a specified range.
        When you retrieve values from a range, Ones scale is used regardless of
        the cell's scale formatting.

        Args:
            spreadsheet_id: The unique identifier of the spreadsheet
            sheet_id: The unique identifier of the sheet
            range: The range of values, in A1-style notation
            maxcellsperpage: The maximum number of cells to retrieve. The default is 50000. The maximum allowed value is 50000.
            valuestyle: Whether to retrieve `raw` or `calculated` cell values. For example, if a cell's value is `=1+1`, `raw` retrieves the value `=1+1`, while `calculated` retrieves `2`.
            timeout: Override the default request timeout (seconds).

        Returns:
            RangeValuesListResult

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 429, 500, 503).
        """

        async def _fetch(_cursor: str | None) -> httpx.Response:
            return await self._client.request_async(
                "GET",
                self._api,
                "/spreadsheets/{spreadsheetId}/sheets/{sheetId}/values/{range}",
                path_params={
                    "spreadsheetId": spreadsheet_id,
                    "sheetId": sheet_id,
                    "range": range,
                },
                query_params={
                    "$maxcellsperpage": maxcellsperpage,
                    "$valuestyle": valuestyle,
                    "$next": _cursor,
                },
                timeout=timeout,
            )

        _body_result = await paginate_all_async(_fetch, extract_next_link, "data")
        return RangeValuesListResult.model_validate(_body_result)
