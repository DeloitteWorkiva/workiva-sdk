"""Platform API â€” content namespace.

Auto-generated by codegen. Do not edit manually.
"""

from __future__ import annotations

from typing import Any, Literal, Optional

import httpx

from workiva._constants import _API
from workiva._operations._base import BaseNamespace
from workiva._pagination import (
    extract_next_link,
    paginate_all,
    paginate_all_async,
)
from workiva.models.platform import (
    Anchor,
    AnchorExtensionsListResult,
    AnchorsListResult,
    CellRange,
    ChangeSourceRange,
    ColumnPropertiesListResult,
    CreateDestinationRangeLink,
    CreateSourceRangeLink,
    DeleteColumns,
    DeleteRows,
    DestinationLink,
    DrawingElementListResult,
    DuplicateTable,
    Image,
    ImageUploadResponse,
    InsertColumns,
    InsertRows,
    MoveColumns,
    MoveRows,
    ParagraphsListResult,
    RangeLink,
    RangeLinkListResult,
    RemoveDestinationRangeLink,
    RemoveSourceRangeLink,
    RichTextSelection,
    RowPropertiesListResult,
    StyleGuide,
    StyleGuideImportResponse,
    TableCellsEdit,
    TableCellsResult,
    TableLinksEdit,
    TableProperties,
    TextEdit,
    TextLinkEdit,
)

__all__ = ["Content"]


class Content(BaseNamespace):
    """Content operations."""

    _api: _API = _API.PLATFORM

    def get_anchor_by_id(
        self,
        *,
        anchor_id: str,
        revision: Optional[str] = None,
        timeout: Optional[float] = None,
    ) -> Anchor:
        """Retrieve an anchor by ID

        Returns an [`Anchor`](ref:content#anchor) given its id.

        Args:
            anchor_id: The unique identifier of the anchor
            revision: Returns resources at a specific revision
            timeout: Override the default request timeout (seconds).

        Returns:
            Anchor

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 429, 500, 503).
        """
        response = self._client.request(
            "GET",
            self._api,
            "/content/anchors/{anchorId}",
            path_params={
                "anchorId": anchor_id,
            },
            query_params={
                "$revision": revision,
            },
            timeout=timeout,
        )
        return Anchor.model_validate(response.json())

    async def get_anchor_by_id_async(
        self,
        *,
        anchor_id: str,
        revision: Optional[str] = None,
        timeout: Optional[float] = None,
    ) -> Anchor:
        """Retrieve an anchor by ID (async)

        Returns an [`Anchor`](ref:content#anchor) given its id.

        Args:
            anchor_id: The unique identifier of the anchor
            revision: Returns resources at a specific revision
            timeout: Override the default request timeout (seconds).

        Returns:
            Anchor

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 429, 500, 503).
        """
        response = await self._client.request_async(
            "GET",
            self._api,
            "/content/anchors/{anchorId}",
            path_params={
                "anchorId": anchor_id,
            },
            query_params={
                "$revision": revision,
            },
            timeout=timeout,
        )
        return Anchor.model_validate(response.json())

    def get_destination_link_by_id(
        self,
        *,
        destination_link_id: str,
        revision: Optional[str] = None,
        timeout: Optional[float] = None,
    ) -> DestinationLink:
        """Retrieve a destination link by id

        Returns a [`DestinationLink`](ref:content#destinationlink) given its id

        Args:
            destination_link_id: The unique identifier of the destination link
            revision: Returns resources at a specific revision
            timeout: Override the default request timeout (seconds).

        Returns:
            DestinationLink

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 429, 500, 503).
        """
        response = self._client.request(
            "GET",
            self._api,
            "/content/destinationLinks/{destinationLinkId}",
            path_params={
                "destinationLinkId": destination_link_id,
            },
            query_params={
                "$revision": revision,
            },
            timeout=timeout,
        )
        return DestinationLink.model_validate(response.json())

    async def get_destination_link_by_id_async(
        self,
        *,
        destination_link_id: str,
        revision: Optional[str] = None,
        timeout: Optional[float] = None,
    ) -> DestinationLink:
        """Retrieve a destination link by id (async)

        Returns a [`DestinationLink`](ref:content#destinationlink) given its id

        Args:
            destination_link_id: The unique identifier of the destination link
            revision: Returns resources at a specific revision
            timeout: Override the default request timeout (seconds).

        Returns:
            DestinationLink

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 429, 500, 503).
        """
        response = await self._client.request_async(
            "GET",
            self._api,
            "/content/destinationLinks/{destinationLinkId}",
            path_params={
                "destinationLinkId": destination_link_id,
            },
            query_params={
                "$revision": revision,
            },
            timeout=timeout,
        )
        return DestinationLink.model_validate(response.json())

    def destination_link_source_conversion(
        self,
        *,
        destination_link_id: str,
        timeout: Optional[float] = None,
    ) -> httpx.Response:
        """Initiate a destination link conversion

        Converts a destination link into a source link. The previous source, if
        any, will be converted into a destination link.

        Responses include a `Location` header, which indicates where to poll for
        results. For more details on long-running
        job polling, see [Operations endpoint](ref:getoperationbyid). When the
        source conversion
        completes, its status will be `completed`, and the response body
        includes a `resourceURL`. For more details on the `resourceURL`
        see [operation results
        endpoint](ref:getdestinationlinksourceconversionresults).
        For more details, see [Authentication
        documentation](ref:authentication).

        Args:
            destination_link_id: The unique identifier of the destination link
            timeout: Override the default request timeout (seconds).

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 429, 500, 503).

        Note:
            This is a long-running operation (HTTP 202). Use
            ``client.wait(response).result()`` to poll until completion.
        """
        return self._client.request(
            "POST",
            self._api,
            "/content/destinationLinks/{destinationLinkId}/sourceConversion",
            path_params={
                "destinationLinkId": destination_link_id,
            },
            timeout=timeout,
        )

    async def destination_link_source_conversion_async(
        self,
        *,
        destination_link_id: str,
        timeout: Optional[float] = None,
    ) -> httpx.Response:
        """Initiate a destination link conversion (async)

        Converts a destination link into a source link. The previous source, if
        any, will be converted into a destination link.

        Responses include a `Location` header, which indicates where to poll for
        results. For more details on long-running
        job polling, see [Operations endpoint](ref:getoperationbyid). When the
        source conversion
        completes, its status will be `completed`, and the response body
        includes a `resourceURL`. For more details on the `resourceURL`
        see [operation results
        endpoint](ref:getdestinationlinksourceconversionresults).
        For more details, see [Authentication
        documentation](ref:authentication).

        Args:
            destination_link_id: The unique identifier of the destination link
            timeout: Override the default request timeout (seconds).

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 429, 500, 503).

        Note:
            This is a long-running operation (HTTP 202). Use
            ``await client.wait(response).result_async()`` to poll until completion.
        """
        return await self._client.request_async(
            "POST",
            self._api,
            "/content/destinationLinks/{destinationLinkId}/sourceConversion",
            path_params={
                "destinationLinkId": destination_link_id,
            },
            timeout=timeout,
        )

    def get_drawing_elements_by_id(
        self,
        *,
        drawing_id: str,
        revision: Optional[str] = None,
        maxpagesize: Optional[int] = 1000,
        timeout: Optional[float] = None,
    ) -> DrawingElementListResult:
        """Retrieve drawing elements by id

        Returns a
        [`DrawingElementListResult`](ref:content#drawingelementlistresult) given
        its id

        Args:
            drawing_id: The unique identifier of a drawing
            revision: Returns resources at a specific revision
            maxpagesize: The maximum number of results to retrieve
            timeout: Override the default request timeout (seconds).

        Returns:
            DrawingElementListResult

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 429, 500, 503).
        """

        def _fetch(_cursor: str | None) -> httpx.Response:
            return self._client.request(
                "GET",
                self._api,
                "/content/drawings/{drawingId}/elements",
                path_params={
                    "drawingId": drawing_id,
                },
                query_params={
                    "$revision": revision,
                    "$maxpagesize": maxpagesize,
                    "$next": _cursor,
                },
                timeout=timeout,
            )

        _body_result = paginate_all(_fetch, extract_next_link, "data")
        return DrawingElementListResult.model_validate(_body_result)

    async def get_drawing_elements_by_id_async(
        self,
        *,
        drawing_id: str,
        revision: Optional[str] = None,
        maxpagesize: Optional[int] = 1000,
        timeout: Optional[float] = None,
    ) -> DrawingElementListResult:
        """Retrieve drawing elements by id (async)

        Returns a
        [`DrawingElementListResult`](ref:content#drawingelementlistresult) given
        its id

        Args:
            drawing_id: The unique identifier of a drawing
            revision: Returns resources at a specific revision
            maxpagesize: The maximum number of results to retrieve
            timeout: Override the default request timeout (seconds).

        Returns:
            DrawingElementListResult

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 429, 500, 503).
        """

        async def _fetch(_cursor: str | None) -> httpx.Response:
            return await self._client.request_async(
                "GET",
                self._api,
                "/content/drawings/{drawingId}/elements",
                path_params={
                    "drawingId": drawing_id,
                },
                query_params={
                    "$revision": revision,
                    "$maxpagesize": maxpagesize,
                    "$next": _cursor,
                },
                timeout=timeout,
            )

        _body_result = await paginate_all_async(_fetch, extract_next_link, "data")
        return DrawingElementListResult.model_validate(_body_result)

    def get_drawing_anchors(
        self,
        *,
        drawing_id: str,
        maxpagesize: Optional[int] = 1000,
        revision: Optional[str] = None,
        timeout: Optional[float] = None,
    ) -> AnchorsListResult:
        """Retrieve a list of drawing anchors

        Returns an [`AnchorsListResult`](ref:content#anchorslistresult) for a
        given drawingId.

        Args:
            drawing_id: The unique identifier of a drawing
            maxpagesize: The maximum number of results to retrieve
            revision: Returns resources at a specific revision
            timeout: Override the default request timeout (seconds).

        Returns:
            AnchorsListResult

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 429, 500, 503).
        """

        def _fetch(_cursor: str | None) -> httpx.Response:
            return self._client.request(
                "GET",
                self._api,
                "/content/drawings/{drawingId}/anchors",
                path_params={
                    "drawingId": drawing_id,
                },
                query_params={
                    "$maxpagesize": maxpagesize,
                    "$revision": revision,
                    "$next": _cursor,
                },
                timeout=timeout,
            )

        _body_result = paginate_all(_fetch, extract_next_link, "data")
        return AnchorsListResult.model_validate(_body_result)

    async def get_drawing_anchors_async(
        self,
        *,
        drawing_id: str,
        maxpagesize: Optional[int] = 1000,
        revision: Optional[str] = None,
        timeout: Optional[float] = None,
    ) -> AnchorsListResult:
        """Retrieve a list of drawing anchors (async)

        Returns an [`AnchorsListResult`](ref:content#anchorslistresult) for a
        given drawingId.

        Args:
            drawing_id: The unique identifier of a drawing
            maxpagesize: The maximum number of results to retrieve
            revision: Returns resources at a specific revision
            timeout: Override the default request timeout (seconds).

        Returns:
            AnchorsListResult

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 429, 500, 503).
        """

        async def _fetch(_cursor: str | None) -> httpx.Response:
            return await self._client.request_async(
                "GET",
                self._api,
                "/content/drawings/{drawingId}/anchors",
                path_params={
                    "drawingId": drawing_id,
                },
                query_params={
                    "$maxpagesize": maxpagesize,
                    "$revision": revision,
                    "$next": _cursor,
                },
                timeout=timeout,
            )

        _body_result = await paginate_all_async(_fetch, extract_next_link, "data")
        return AnchorsListResult.model_validate(_body_result)

    def get_drawing_anchor_by_id(
        self,
        *,
        drawing_id: str,
        anchor_id: str,
        revision: Optional[str] = None,
        timeout: Optional[float] = None,
    ) -> Anchor:
        """Retrieve a drawing anchor by ID

        Returns an [`Anchor`](ref:content#anchor) given its id.

        Args:
            drawing_id: The unique identifier of a drawing
            anchor_id: The unique identifier of the anchor
            revision: Returns resources at a specific revision
            timeout: Override the default request timeout (seconds).

        Returns:
            Anchor

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 429, 500, 503).
        """
        response = self._client.request(
            "GET",
            self._api,
            "/content/drawings/{drawingId}/anchors/{anchorId}",
            path_params={
                "drawingId": drawing_id,
                "anchorId": anchor_id,
            },
            query_params={
                "$revision": revision,
            },
            timeout=timeout,
        )
        return Anchor.model_validate(response.json())

    async def get_drawing_anchor_by_id_async(
        self,
        *,
        drawing_id: str,
        anchor_id: str,
        revision: Optional[str] = None,
        timeout: Optional[float] = None,
    ) -> Anchor:
        """Retrieve a drawing anchor by ID (async)

        Returns an [`Anchor`](ref:content#anchor) given its id.

        Args:
            drawing_id: The unique identifier of a drawing
            anchor_id: The unique identifier of the anchor
            revision: Returns resources at a specific revision
            timeout: Override the default request timeout (seconds).

        Returns:
            Anchor

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 429, 500, 503).
        """
        response = await self._client.request_async(
            "GET",
            self._api,
            "/content/drawings/{drawingId}/anchors/{anchorId}",
            path_params={
                "drawingId": drawing_id,
                "anchorId": anchor_id,
            },
            query_params={
                "$revision": revision,
            },
            timeout=timeout,
        )
        return Anchor.model_validate(response.json())

    def get_drawing_anchor_extensions(
        self,
        *,
        drawing_id: str,
        anchor_id: str,
        maxpagesize: Optional[int] = 1000,
        revision: Optional[str] = None,
        timeout: Optional[float] = None,
    ) -> AnchorExtensionsListResult:
        """Retrieve a list of drawing anchor extensions

        Returns a paginated list of
        [`AnchorExtensions`](ref:content#anchorextension) for a given anchorId.

        Args:
            drawing_id: The unique identifier of a drawing
            anchor_id: The unique identifier of the anchor
            maxpagesize: The maximum number of results to retrieve
            revision: Returns resources at a specific revision
            timeout: Override the default request timeout (seconds).

        Returns:
            AnchorExtensionsListResult

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 429, 500, 503).
        """

        def _fetch(_cursor: str | None) -> httpx.Response:
            return self._client.request(
                "GET",
                self._api,
                "/content/drawings/{drawingId}/anchors/{anchorId}/extensions",
                path_params={
                    "drawingId": drawing_id,
                    "anchorId": anchor_id,
                },
                query_params={
                    "$maxpagesize": maxpagesize,
                    "$revision": revision,
                    "$next": _cursor,
                },
                timeout=timeout,
            )

        _body_result = paginate_all(_fetch, extract_next_link, "data")
        return AnchorExtensionsListResult.model_validate(_body_result)

    async def get_drawing_anchor_extensions_async(
        self,
        *,
        drawing_id: str,
        anchor_id: str,
        maxpagesize: Optional[int] = 1000,
        revision: Optional[str] = None,
        timeout: Optional[float] = None,
    ) -> AnchorExtensionsListResult:
        """Retrieve a list of drawing anchor extensions (async)

        Returns a paginated list of
        [`AnchorExtensions`](ref:content#anchorextension) for a given anchorId.

        Args:
            drawing_id: The unique identifier of a drawing
            anchor_id: The unique identifier of the anchor
            maxpagesize: The maximum number of results to retrieve
            revision: Returns resources at a specific revision
            timeout: Override the default request timeout (seconds).

        Returns:
            AnchorExtensionsListResult

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 429, 500, 503).
        """

        async def _fetch(_cursor: str | None) -> httpx.Response:
            return await self._client.request_async(
                "GET",
                self._api,
                "/content/drawings/{drawingId}/anchors/{anchorId}/extensions",
                path_params={
                    "drawingId": drawing_id,
                    "anchorId": anchor_id,
                },
                query_params={
                    "$maxpagesize": maxpagesize,
                    "$revision": revision,
                    "$next": _cursor,
                },
                timeout=timeout,
            )

        _body_result = await paginate_all_async(_fetch, extract_next_link, "data")
        return AnchorExtensionsListResult.model_validate(_body_result)

    def image_upload(
        self,
        *,
        file_name: str,
        timeout: Optional[float] = None,
    ) -> ImageUploadResponse:
        """Initiate upload of an image

        Retrieves a URL that can be used to upload an image, and an operationId
        to track the image upload progress. Once uploaded, the image can be
        inserted in content.

        Image uploads must conform to the following constraints:

        - An image must be uploaded once per usage in content.
        - Image uploads must complete within ten minutes.
        - The file size of the uploaded image must 75 MB or smaller.
        - The total number of pixels in the uploaded image must be 50 Megapixels
        or smaller.
        - The image must be inserted in content within 24 hours or it will be
        removed.

        Responses include an `uploadUrl` which indicates where to upload the
        image. To upload the file,
        perform a PUT against the `uploadUrl` with the same authentication
        credentials and flow as the import request.
        For more details, see [Authentication
        documentation](ref:authentication). The response will also include
        a `Location` header, which indicates where to poll for results. For more
        details on long-running job polling, see
        [Operations endpoint](ref:getoperationbyid). When the upload completes,
        its status will be
        `completed`, and the response body includes a `resourceURL`.

        Args:
            file_name: The name for the new image.
            timeout: Override the default request timeout (seconds).

        Returns:
            ImageUploadResponse

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 429, 500, 503).
        """
        _body: dict[str, Any] = {}
        if file_name is not None:
            _body["fileName"] = file_name
        response = self._client.request(
            "POST",
            self._api,
            "/content/images/upload",
            json_body=_body or None,
            timeout=timeout,
        )
        return ImageUploadResponse.model_validate(response.json())

    async def image_upload_async(
        self,
        *,
        file_name: str,
        timeout: Optional[float] = None,
    ) -> ImageUploadResponse:
        """Initiate upload of an image (async)

        Retrieves a URL that can be used to upload an image, and an operationId
        to track the image upload progress. Once uploaded, the image can be
        inserted in content.

        Image uploads must conform to the following constraints:

        - An image must be uploaded once per usage in content.
        - Image uploads must complete within ten minutes.
        - The file size of the uploaded image must 75 MB or smaller.
        - The total number of pixels in the uploaded image must be 50 Megapixels
        or smaller.
        - The image must be inserted in content within 24 hours or it will be
        removed.

        Responses include an `uploadUrl` which indicates where to upload the
        image. To upload the file,
        perform a PUT against the `uploadUrl` with the same authentication
        credentials and flow as the import request.
        For more details, see [Authentication
        documentation](ref:authentication). The response will also include
        a `Location` header, which indicates where to poll for results. For more
        details on long-running job polling, see
        [Operations endpoint](ref:getoperationbyid). When the upload completes,
        its status will be
        `completed`, and the response body includes a `resourceURL`.

        Args:
            file_name: The name for the new image.
            timeout: Override the default request timeout (seconds).

        Returns:
            ImageUploadResponse

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 429, 500, 503).
        """
        _body: dict[str, Any] = {}
        if file_name is not None:
            _body["fileName"] = file_name
        response = await self._client.request_async(
            "POST",
            self._api,
            "/content/images/upload",
            json_body=_body or None,
            timeout=timeout,
        )
        return ImageUploadResponse.model_validate(response.json())

    def get_image_by_id(
        self,
        *,
        image_id: str,
        timeout: Optional[float] = None,
    ) -> Image:
        """Retrieve an image by id

        Returns a [`Image`](ref:content#image) given its id

        Args:
            image_id: The unique identifier of the image
            timeout: Override the default request timeout (seconds).

        Returns:
            Image

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 429, 500, 503).
        """
        response = self._client.request(
            "GET",
            self._api,
            "/content/images/{imageId}",
            path_params={
                "imageId": image_id,
            },
            timeout=timeout,
        )
        return Image.model_validate(response.json())

    async def get_image_by_id_async(
        self,
        *,
        image_id: str,
        timeout: Optional[float] = None,
    ) -> Image:
        """Retrieve an image by id (async)

        Returns a [`Image`](ref:content#image) given its id

        Args:
            image_id: The unique identifier of the image
            timeout: Override the default request timeout (seconds).

        Returns:
            Image

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 429, 500, 503).
        """
        response = await self._client.request_async(
            "GET",
            self._api,
            "/content/images/{imageId}",
            path_params={
                "imageId": image_id,
            },
            timeout=timeout,
        )
        return Image.model_validate(response.json())

    def get_rich_text_anchors(
        self,
        *,
        rich_text_id: str,
        maxpagesize: Optional[int] = 1000,
        revision: Optional[str] = None,
        timeout: Optional[float] = None,
    ) -> AnchorsListResult:
        """Retrieve a list of rich text anchors

        Returns an [`AnchorsListResult`](ref:content#anchorslistresult) for a
        given richTextId.

        Args:
            rich_text_id: The unique identifier of the rich text content
            maxpagesize: The maximum number of results to retrieve
            revision: Returns resources at a specific revision
            timeout: Override the default request timeout (seconds).

        Returns:
            AnchorsListResult

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 429, 500, 503).
        """

        def _fetch(_cursor: str | None) -> httpx.Response:
            return self._client.request(
                "GET",
                self._api,
                "/content/richText/{richTextId}/anchors",
                path_params={
                    "richTextId": rich_text_id,
                },
                query_params={
                    "$maxpagesize": maxpagesize,
                    "$revision": revision,
                    "$next": _cursor,
                },
                timeout=timeout,
            )

        _body_result = paginate_all(_fetch, extract_next_link, "data")
        return AnchorsListResult.model_validate(_body_result)

    async def get_rich_text_anchors_async(
        self,
        *,
        rich_text_id: str,
        maxpagesize: Optional[int] = 1000,
        revision: Optional[str] = None,
        timeout: Optional[float] = None,
    ) -> AnchorsListResult:
        """Retrieve a list of rich text anchors (async)

        Returns an [`AnchorsListResult`](ref:content#anchorslistresult) for a
        given richTextId.

        Args:
            rich_text_id: The unique identifier of the rich text content
            maxpagesize: The maximum number of results to retrieve
            revision: Returns resources at a specific revision
            timeout: Override the default request timeout (seconds).

        Returns:
            AnchorsListResult

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 429, 500, 503).
        """

        async def _fetch(_cursor: str | None) -> httpx.Response:
            return await self._client.request_async(
                "GET",
                self._api,
                "/content/richText/{richTextId}/anchors",
                path_params={
                    "richTextId": rich_text_id,
                },
                query_params={
                    "$maxpagesize": maxpagesize,
                    "$revision": revision,
                    "$next": _cursor,
                },
                timeout=timeout,
            )

        _body_result = await paginate_all_async(_fetch, extract_next_link, "data")
        return AnchorsListResult.model_validate(_body_result)

    def rich_text_anchor_creation(
        self,
        *,
        rich_text_id: str,
        revision: str,
        selection: RichTextSelection,
        type_: str,
        timeout: Optional[float] = None,
    ) -> httpx.Response:
        """Initiate creation of a new rich text anchor

        Create a new [`Anchor`](ref:content#anchor) using a
        [`RichTextAnchorCreation`](ref:content#richtextanchorcreation) request.
        This is a long running operation.

        Responses include a `Location` header, which indicates where to poll for
        results. For more details on long-running job polling, see
        [Operations endpoint](ref:getoperationbyid).
        When the creation completes, its status will be `completed`, and the
        response
        body includes a `resourceURL`. To GET the new rich text anchor, perform
        a GET
        on the `resourceURL` with the same authentication credentials and flow
        as the
        initial request. For more details, see
        [Authentication documentation](ref:authentication).

        Args:
            rich_text_id: The unique identifier of the rich text content
            revision: Identifies a unique revision of content.
            selection:
            type_:
            timeout: Override the default request timeout (seconds).

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 429, 500, 503).

        Note:
            This is a long-running operation (HTTP 202). Use
            ``client.wait(response).result()`` to poll until completion.
        """
        _body: dict[str, Any] = {}
        if revision is not None:
            _body["revision"] = revision
        if selection is not None:
            _body["selection"] = selection
        if type_ is not None:
            _body["type"] = type_
        return self._client.request(
            "POST",
            self._api,
            "/content/richText/{richTextId}/anchors/creation",
            path_params={
                "richTextId": rich_text_id,
            },
            json_body=_body or None,
            timeout=timeout,
        )

    async def rich_text_anchor_creation_async(
        self,
        *,
        rich_text_id: str,
        revision: str,
        selection: RichTextSelection,
        type_: str,
        timeout: Optional[float] = None,
    ) -> httpx.Response:
        """Initiate creation of a new rich text anchor (async)

        Create a new [`Anchor`](ref:content#anchor) using a
        [`RichTextAnchorCreation`](ref:content#richtextanchorcreation) request.
        This is a long running operation.

        Responses include a `Location` header, which indicates where to poll for
        results. For more details on long-running job polling, see
        [Operations endpoint](ref:getoperationbyid).
        When the creation completes, its status will be `completed`, and the
        response
        body includes a `resourceURL`. To GET the new rich text anchor, perform
        a GET
        on the `resourceURL` with the same authentication credentials and flow
        as the
        initial request. For more details, see
        [Authentication documentation](ref:authentication).

        Args:
            rich_text_id: The unique identifier of the rich text content
            revision: Identifies a unique revision of content.
            selection:
            type_:
            timeout: Override the default request timeout (seconds).

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 429, 500, 503).

        Note:
            This is a long-running operation (HTTP 202). Use
            ``await client.wait(response).result_async()`` to poll until completion.
        """
        _body: dict[str, Any] = {}
        if revision is not None:
            _body["revision"] = revision
        if selection is not None:
            _body["selection"] = selection
        if type_ is not None:
            _body["type"] = type_
        return await self._client.request_async(
            "POST",
            self._api,
            "/content/richText/{richTextId}/anchors/creation",
            path_params={
                "richTextId": rich_text_id,
            },
            json_body=_body or None,
            timeout=timeout,
        )

    def get_rich_text_anchor_by_id(
        self,
        *,
        rich_text_id: str,
        anchor_id: str,
        revision: Optional[str] = None,
        timeout: Optional[float] = None,
    ) -> Anchor:
        """Retrieve a rich text anchor by id

        Returns an [`Anchor`](ref:content#anchor) given its id.

        Args:
            rich_text_id: The unique identifier of the rich text content
            anchor_id: The unique identifier of the anchor
            revision: Returns resources at a specific revision
            timeout: Override the default request timeout (seconds).

        Returns:
            Anchor

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 429, 500, 503).
        """
        response = self._client.request(
            "GET",
            self._api,
            "/content/richText/{richTextId}/anchors/{anchorId}",
            path_params={
                "richTextId": rich_text_id,
                "anchorId": anchor_id,
            },
            query_params={
                "$revision": revision,
            },
            timeout=timeout,
        )
        return Anchor.model_validate(response.json())

    async def get_rich_text_anchor_by_id_async(
        self,
        *,
        rich_text_id: str,
        anchor_id: str,
        revision: Optional[str] = None,
        timeout: Optional[float] = None,
    ) -> Anchor:
        """Retrieve a rich text anchor by id (async)

        Returns an [`Anchor`](ref:content#anchor) given its id.

        Args:
            rich_text_id: The unique identifier of the rich text content
            anchor_id: The unique identifier of the anchor
            revision: Returns resources at a specific revision
            timeout: Override the default request timeout (seconds).

        Returns:
            Anchor

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 429, 500, 503).
        """
        response = await self._client.request_async(
            "GET",
            self._api,
            "/content/richText/{richTextId}/anchors/{anchorId}",
            path_params={
                "richTextId": rich_text_id,
                "anchorId": anchor_id,
            },
            query_params={
                "$revision": revision,
            },
            timeout=timeout,
        )
        return Anchor.model_validate(response.json())

    def get_rich_text_anchor_extensions(
        self,
        *,
        rich_text_id: str,
        anchor_id: str,
        maxpagesize: Optional[int] = 1000,
        revision: Optional[str] = None,
        timeout: Optional[float] = None,
    ) -> AnchorExtensionsListResult:
        """Retrieve a list of rich text anchor extensions

        Returns a paginated list of
        [`AnchorExtensions`](ref:content#anchorextension) for a given anchorId.

        Args:
            rich_text_id: The unique identifier of the rich text content
            anchor_id: The unique identifier of the anchor
            maxpagesize: The maximum number of results to retrieve
            revision: Returns resources at a specific revision
            timeout: Override the default request timeout (seconds).

        Returns:
            AnchorExtensionsListResult

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 429, 500, 503).
        """

        def _fetch(_cursor: str | None) -> httpx.Response:
            return self._client.request(
                "GET",
                self._api,
                "/content/richText/{richTextId}/anchors/{anchorId}/extensions",
                path_params={
                    "richTextId": rich_text_id,
                    "anchorId": anchor_id,
                },
                query_params={
                    "$maxpagesize": maxpagesize,
                    "$revision": revision,
                    "$next": _cursor,
                },
                timeout=timeout,
            )

        _body_result = paginate_all(_fetch, extract_next_link, "data")
        return AnchorExtensionsListResult.model_validate(_body_result)

    async def get_rich_text_anchor_extensions_async(
        self,
        *,
        rich_text_id: str,
        anchor_id: str,
        maxpagesize: Optional[int] = 1000,
        revision: Optional[str] = None,
        timeout: Optional[float] = None,
    ) -> AnchorExtensionsListResult:
        """Retrieve a list of rich text anchor extensions (async)

        Returns a paginated list of
        [`AnchorExtensions`](ref:content#anchorextension) for a given anchorId.

        Args:
            rich_text_id: The unique identifier of the rich text content
            anchor_id: The unique identifier of the anchor
            maxpagesize: The maximum number of results to retrieve
            revision: Returns resources at a specific revision
            timeout: Override the default request timeout (seconds).

        Returns:
            AnchorExtensionsListResult

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 429, 500, 503).
        """

        async def _fetch(_cursor: str | None) -> httpx.Response:
            return await self._client.request_async(
                "GET",
                self._api,
                "/content/richText/{richTextId}/anchors/{anchorId}/extensions",
                path_params={
                    "richTextId": rich_text_id,
                    "anchorId": anchor_id,
                },
                query_params={
                    "$maxpagesize": maxpagesize,
                    "$revision": revision,
                    "$next": _cursor,
                },
                timeout=timeout,
            )

        _body_result = await paginate_all_async(_fetch, extract_next_link, "data")
        return AnchorExtensionsListResult.model_validate(_body_result)

    def rich_text_duplication_edit(
        self,
        *,
        rich_text_id: str,
        type_: Literal["duplicateTable"],
        duplicate_table: Optional[DuplicateTable] = None,
        revision: Optional[str] = None,
        timeout: Optional[float] = None,
    ) -> httpx.Response:
        """Initiate duplication edits to rich text

        Sends a [`RichTextDuplicationEdit`](ref:content#richtextduplicationedit)
        to perform on the rich text.
        The optional revision property can be used to identify a stable version
        of the text to use for selections. The latest revision is used if not
        specified.
        This is a long running operation. Responses include a `Location` header,
        which indicates where to poll for results. For more details on long-
        running job polling, see [Operations endpoint](ref:getoperationbyid).
        The `resourceUrl` field will be populated with a link to the [Rich Text
        Duplication Edit Results
        endpoint](ref:getrichtextduplicationeditresults) to retrieve the IDs of
        the new resources.

        Args:
            rich_text_id: The unique identifier of the rich text content
            type_: The type of rich text duplication edit.
            duplicate_table:
            revision:
            timeout: Override the default request timeout (seconds).

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 429, 500, 503).

        Note:
            This is a long-running operation (HTTP 202). Use
            ``client.wait(response).result()`` to poll until completion.
        """
        _body: dict[str, Any] = {}
        if type_ is not None:
            _body["type"] = type_
        if duplicate_table is not None:
            _body["duplicateTable"] = duplicate_table
        if revision is not None:
            _body["revision"] = revision
        return self._client.request(
            "POST",
            self._api,
            "/content/richText/{richTextId}/duplication/edit",
            path_params={
                "richTextId": rich_text_id,
            },
            json_body=_body or None,
            timeout=timeout,
        )

    async def rich_text_duplication_edit_async(
        self,
        *,
        rich_text_id: str,
        type_: Literal["duplicateTable"],
        duplicate_table: Optional[DuplicateTable] = None,
        revision: Optional[str] = None,
        timeout: Optional[float] = None,
    ) -> httpx.Response:
        """Initiate duplication edits to rich text (async)

        Sends a [`RichTextDuplicationEdit`](ref:content#richtextduplicationedit)
        to perform on the rich text.
        The optional revision property can be used to identify a stable version
        of the text to use for selections. The latest revision is used if not
        specified.
        This is a long running operation. Responses include a `Location` header,
        which indicates where to poll for results. For more details on long-
        running job polling, see [Operations endpoint](ref:getoperationbyid).
        The `resourceUrl` field will be populated with a link to the [Rich Text
        Duplication Edit Results
        endpoint](ref:getrichtextduplicationeditresults) to retrieve the IDs of
        the new resources.

        Args:
            rich_text_id: The unique identifier of the rich text content
            type_: The type of rich text duplication edit.
            duplicate_table:
            revision:
            timeout: Override the default request timeout (seconds).

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 429, 500, 503).

        Note:
            This is a long-running operation (HTTP 202). Use
            ``await client.wait(response).result_async()`` to poll until completion.
        """
        _body: dict[str, Any] = {}
        if type_ is not None:
            _body["type"] = type_
        if duplicate_table is not None:
            _body["duplicateTable"] = duplicate_table
        if revision is not None:
            _body["revision"] = revision
        return await self._client.request_async(
            "POST",
            self._api,
            "/content/richText/{richTextId}/duplication/edit",
            path_params={
                "richTextId": rich_text_id,
            },
            json_body=_body or None,
            timeout=timeout,
        )

    def rich_text_batch_edit(
        self,
        *,
        rich_text_id: str,
        data: list[TextEdit],
        islolate_edits: Optional[bool] = None,
        revision: Optional[str] = None,
        timeout: Optional[float] = None,
    ) -> httpx.Response:
        """Initiate edits to rich text

        Sends a [`RichTextBatchEdit`](ref:content#richtextbatchedit) to perform
        as a batch on the rich text.
        The optional revision property can be used to identify a stable version
        of the text to use for selections. The latest revision is used if not
        specified.
        This is a long running operation. Responses include a `Location` header,
        which indicates where to poll for results. For more details on long-
        running job polling, see [Operations endpoint](ref:getoperationbyid).
        If the batch edit creates any new resources such as embedded tables, the
        `resourceUrl` field will be populated with a link to the [Rich Text
        Batch Edit Results endpoint](ref:getrichtextbatcheditresults) to
        retrieve the IDs of the new resources.

        Args:
            rich_text_id: The unique identifier of the rich text content
            data: The edits to apply to the rich text.
            islolate_edits: Whether the edits in a batch should be isolated from one-another. The edits will still be applied in order, but subsequent edits are unaffected by the previous edits in the same batch. For example, if one edit inserts some content, the next edits will act as if the content doesn't exist yet. Or if an edit deletes some content, the next edits will act as if the content is still there. This mode makes it easier to apply many edits on existing content because you don't need to manually keep track of how the previous edits have moved the content. For example, if you want to replace all instances of one word with another it will be easier to do this with isolated edits.

            revision:
            timeout: Override the default request timeout (seconds).

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 429, 500, 503).

        Note:
            This is a long-running operation (HTTP 202). Use
            ``client.wait(response).result()`` to poll until completion.
        """
        _body: dict[str, Any] = {}
        if data is not None:
            _body["data"] = data
        if islolate_edits is not None:
            _body["islolateEdits"] = islolate_edits
        if revision is not None:
            _body["revision"] = revision
        return self._client.request(
            "POST",
            self._api,
            "/content/richText/{richTextId}/edit",
            path_params={
                "richTextId": rich_text_id,
            },
            json_body=_body or None,
            timeout=timeout,
        )

    async def rich_text_batch_edit_async(
        self,
        *,
        rich_text_id: str,
        data: list[TextEdit],
        islolate_edits: Optional[bool] = None,
        revision: Optional[str] = None,
        timeout: Optional[float] = None,
    ) -> httpx.Response:
        """Initiate edits to rich text (async)

        Sends a [`RichTextBatchEdit`](ref:content#richtextbatchedit) to perform
        as a batch on the rich text.
        The optional revision property can be used to identify a stable version
        of the text to use for selections. The latest revision is used if not
        specified.
        This is a long running operation. Responses include a `Location` header,
        which indicates where to poll for results. For more details on long-
        running job polling, see [Operations endpoint](ref:getoperationbyid).
        If the batch edit creates any new resources such as embedded tables, the
        `resourceUrl` field will be populated with a link to the [Rich Text
        Batch Edit Results endpoint](ref:getrichtextbatcheditresults) to
        retrieve the IDs of the new resources.

        Args:
            rich_text_id: The unique identifier of the rich text content
            data: The edits to apply to the rich text.
            islolate_edits: Whether the edits in a batch should be isolated from one-another. The edits will still be applied in order, but subsequent edits are unaffected by the previous edits in the same batch. For example, if one edit inserts some content, the next edits will act as if the content doesn't exist yet. Or if an edit deletes some content, the next edits will act as if the content is still there. This mode makes it easier to apply many edits on existing content because you don't need to manually keep track of how the previous edits have moved the content. For example, if you want to replace all instances of one word with another it will be easier to do this with isolated edits.

            revision:
            timeout: Override the default request timeout (seconds).

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 429, 500, 503).

        Note:
            This is a long-running operation (HTTP 202). Use
            ``await client.wait(response).result_async()`` to poll until completion.
        """
        _body: dict[str, Any] = {}
        if data is not None:
            _body["data"] = data
        if islolate_edits is not None:
            _body["islolateEdits"] = islolate_edits
        if revision is not None:
            _body["revision"] = revision
        return await self._client.request_async(
            "POST",
            self._api,
            "/content/richText/{richTextId}/edit",
            path_params={
                "richTextId": rich_text_id,
            },
            json_body=_body or None,
            timeout=timeout,
        )

    def rich_text_links_batch_edit(
        self,
        *,
        rich_text_id: str,
        data: list[TextLinkEdit],
        isolate_edits: Optional[bool] = None,
        revision: Optional[str] = None,
        timeout: Optional[float] = None,
    ) -> httpx.Response:
        """Initiate edits to rich text links

        Sends a [`RichTextLinksBatchEdit`](ref:content#richtextlinksbatchedit)
        to perform as a batch on the rich text.
        The optional revision property can be used to identify a stable version
        of the text to use for selections. The latest revision is used if not
        specified.
        This is a long running operation. Responses include a `Location` header,
        which indicates where to poll for results. For more details on long-
        running job polling, see [Operations endpoint](ref:getoperationbyid).
        If the batch edit creates any new resources, such as destination links,
        the `resourceUrl` field will be populated with a link to the [Rich Text
        Links Batch Edit Results endpoint](ref:getrichtextlinksbatcheditresults)
        to retrieve the IDs of the new resources.

        Args:
            rich_text_id: The unique identifier of the rich text content
            data: The link edits to apply to rich text.
            isolate_edits: Whether the edits in a batch should be isolated from one-another. The edits will still be applied in order, but subsequent edits are unaffected by the previous edits in the same batch. For example, if one edit inserts some content, the next edits will act as if the content doesn't exist yet. Or if an edit deletes some content, the next edits will act as if the content is still there. This mode makes it easier to apply many edits on existing content because you don't need to manually keep track of how the previous edits have moved the content. For example, if you want to replace all instances of one word with another it will be easier to do this with isolated edits.

            revision:
            timeout: Override the default request timeout (seconds).

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 429, 500, 503).

        Note:
            This is a long-running operation (HTTP 202). Use
            ``client.wait(response).result()`` to poll until completion.
        """
        _body: dict[str, Any] = {}
        if data is not None:
            _body["data"] = data
        if isolate_edits is not None:
            _body["isolateEdits"] = isolate_edits
        if revision is not None:
            _body["revision"] = revision
        return self._client.request(
            "POST",
            self._api,
            "/content/richText/{richTextId}/links/edit",
            path_params={
                "richTextId": rich_text_id,
            },
            json_body=_body or None,
            timeout=timeout,
        )

    async def rich_text_links_batch_edit_async(
        self,
        *,
        rich_text_id: str,
        data: list[TextLinkEdit],
        isolate_edits: Optional[bool] = None,
        revision: Optional[str] = None,
        timeout: Optional[float] = None,
    ) -> httpx.Response:
        """Initiate edits to rich text links (async)

        Sends a [`RichTextLinksBatchEdit`](ref:content#richtextlinksbatchedit)
        to perform as a batch on the rich text.
        The optional revision property can be used to identify a stable version
        of the text to use for selections. The latest revision is used if not
        specified.
        This is a long running operation. Responses include a `Location` header,
        which indicates where to poll for results. For more details on long-
        running job polling, see [Operations endpoint](ref:getoperationbyid).
        If the batch edit creates any new resources, such as destination links,
        the `resourceUrl` field will be populated with a link to the [Rich Text
        Links Batch Edit Results endpoint](ref:getrichtextlinksbatcheditresults)
        to retrieve the IDs of the new resources.

        Args:
            rich_text_id: The unique identifier of the rich text content
            data: The link edits to apply to rich text.
            isolate_edits: Whether the edits in a batch should be isolated from one-another. The edits will still be applied in order, but subsequent edits are unaffected by the previous edits in the same batch. For example, if one edit inserts some content, the next edits will act as if the content doesn't exist yet. Or if an edit deletes some content, the next edits will act as if the content is still there. This mode makes it easier to apply many edits on existing content because you don't need to manually keep track of how the previous edits have moved the content. For example, if you want to replace all instances of one word with another it will be easier to do this with isolated edits.

            revision:
            timeout: Override the default request timeout (seconds).

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 429, 500, 503).

        Note:
            This is a long-running operation (HTTP 202). Use
            ``await client.wait(response).result_async()`` to poll until completion.
        """
        _body: dict[str, Any] = {}
        if data is not None:
            _body["data"] = data
        if isolate_edits is not None:
            _body["isolateEdits"] = isolate_edits
        if revision is not None:
            _body["revision"] = revision
        return await self._client.request_async(
            "POST",
            self._api,
            "/content/richText/{richTextId}/links/edit",
            path_params={
                "richTextId": rich_text_id,
            },
            json_body=_body or None,
            timeout=timeout,
        )

    def get_rich_text_paragraphs(
        self,
        *,
        rich_text_id: str,
        maxpagesize: Optional[int] = 1000,
        revision: Optional[str] = None,
        timeout: Optional[float] = None,
    ) -> ParagraphsListResult:
        """Retrieve rich text paragraphs

        Returns a [`ParagraphsListResult`](ref:content#paragraphslistresult) for
        a rich text object, given its id.

        Args:
            rich_text_id: The unique identifier of the rich text content
            maxpagesize: The maximum number of results to retrieve
            revision: Returns resources at a specific revision
            timeout: Override the default request timeout (seconds).

        Returns:
            ParagraphsListResult

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 429, 500, 503).
        """

        def _fetch(_cursor: str | None) -> httpx.Response:
            return self._client.request(
                "GET",
                self._api,
                "/content/richText/{richTextId}/paragraphs",
                path_params={
                    "richTextId": rich_text_id,
                },
                query_params={
                    "$maxpagesize": maxpagesize,
                    "$revision": revision,
                    "$next": _cursor,
                },
                timeout=timeout,
            )

        _body_result = paginate_all(_fetch, extract_next_link, "data")
        return ParagraphsListResult.model_validate(_body_result)

    async def get_rich_text_paragraphs_async(
        self,
        *,
        rich_text_id: str,
        maxpagesize: Optional[int] = 1000,
        revision: Optional[str] = None,
        timeout: Optional[float] = None,
    ) -> ParagraphsListResult:
        """Retrieve rich text paragraphs (async)

        Returns a [`ParagraphsListResult`](ref:content#paragraphslistresult) for
        a rich text object, given its id.

        Args:
            rich_text_id: The unique identifier of the rich text content
            maxpagesize: The maximum number of results to retrieve
            revision: Returns resources at a specific revision
            timeout: Override the default request timeout (seconds).

        Returns:
            ParagraphsListResult

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 429, 500, 503).
        """

        async def _fetch(_cursor: str | None) -> httpx.Response:
            return await self._client.request_async(
                "GET",
                self._api,
                "/content/richText/{richTextId}/paragraphs",
                path_params={
                    "richTextId": rich_text_id,
                },
                query_params={
                    "$maxpagesize": maxpagesize,
                    "$revision": revision,
                    "$next": _cursor,
                },
                timeout=timeout,
            )

        _body_result = await paginate_all_async(_fetch, extract_next_link, "data")
        return ParagraphsListResult.model_validate(_body_result)

    def get_style_guide_by_id(
        self,
        *,
        style_guide_id: str,
        revision: Optional[str] = None,
        timeout: Optional[float] = None,
    ) -> StyleGuide:
        """Retrieve a style guide by id

        Returns the [`StyleGuide`](ref:content#styleguide) populated with the
        text styles, list styles, etc. The revision will ensure a static
        content.

        Args:
            style_guide_id: The unique identifier of the style guide
            revision: Returns resources at a specific revision
            timeout: Override the default request timeout (seconds).

        Returns:
            StyleGuide

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 429, 500, 503).
        """
        response = self._client.request(
            "GET",
            self._api,
            "/content/styleGuides/{styleGuideId}",
            path_params={
                "styleGuideId": style_guide_id,
            },
            query_params={
                "$revision": revision,
            },
            timeout=timeout,
        )
        return StyleGuide.model_validate(response.json())

    async def get_style_guide_by_id_async(
        self,
        *,
        style_guide_id: str,
        revision: Optional[str] = None,
        timeout: Optional[float] = None,
    ) -> StyleGuide:
        """Retrieve a style guide by id (async)

        Returns the [`StyleGuide`](ref:content#styleguide) populated with the
        text styles, list styles, etc. The revision will ensure a static
        content.

        Args:
            style_guide_id: The unique identifier of the style guide
            revision: Returns resources at a specific revision
            timeout: Override the default request timeout (seconds).

        Returns:
            StyleGuide

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 429, 500, 503).
        """
        response = await self._client.request_async(
            "GET",
            self._api,
            "/content/styleGuides/{styleGuideId}",
            path_params={
                "styleGuideId": style_guide_id,
            },
            query_params={
                "$revision": revision,
            },
            timeout=timeout,
        )
        return StyleGuide.model_validate(response.json())

    def style_guide_export(
        self,
        *,
        style_guide_id: str,
        revision: Optional[str] = None,
        timeout: Optional[float] = None,
    ) -> httpx.Response:
        """Initiate a style guide export

        Export the style guide with the given identifier. Options are
        specified using a
        [StyleGuideExport](ref:content#styleguideexport) object.

        Responses include a `Location` header, which indicates where to poll for
        results. For more details on long-running job polling, see
        [Operations endpoint](ref:getoperationbyid).
        When the export completes, its status will be `completed`, and the
        response
        body includes a `resourceURL`. To GET the exported style guide, perform
        a GET
        on the `resourceURL` with the same authentication credentials and flow
        as the
        initial request. For more details, see
        [Authentication documentation](ref:authentication).

        Args:
            style_guide_id: The unique identifier of the style guide
            revision: The revision of the style guide to export
            timeout: Override the default request timeout (seconds).

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 429, 500, 503).

        Note:
            This is a long-running operation (HTTP 202). Use
            ``client.wait(response).result()`` to poll until completion.
        """
        _body: dict[str, Any] = {}
        if revision is not None:
            _body["revision"] = revision
        return self._client.request(
            "POST",
            self._api,
            "/content/styleGuides/{styleGuideId}/export",
            path_params={
                "styleGuideId": style_guide_id,
            },
            json_body=_body or None,
            timeout=timeout,
        )

    async def style_guide_export_async(
        self,
        *,
        style_guide_id: str,
        revision: Optional[str] = None,
        timeout: Optional[float] = None,
    ) -> httpx.Response:
        """Initiate a style guide export (async)

        Export the style guide with the given identifier. Options are
        specified using a
        [StyleGuideExport](ref:content#styleguideexport) object.

        Responses include a `Location` header, which indicates where to poll for
        results. For more details on long-running job polling, see
        [Operations endpoint](ref:getoperationbyid).
        When the export completes, its status will be `completed`, and the
        response
        body includes a `resourceURL`. To GET the exported style guide, perform
        a GET
        on the `resourceURL` with the same authentication credentials and flow
        as the
        initial request. For more details, see
        [Authentication documentation](ref:authentication).

        Args:
            style_guide_id: The unique identifier of the style guide
            revision: The revision of the style guide to export
            timeout: Override the default request timeout (seconds).

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 429, 500, 503).

        Note:
            This is a long-running operation (HTTP 202). Use
            ``await client.wait(response).result_async()`` to poll until completion.
        """
        _body: dict[str, Any] = {}
        if revision is not None:
            _body["revision"] = revision
        return await self._client.request_async(
            "POST",
            self._api,
            "/content/styleGuides/{styleGuideId}/export",
            path_params={
                "styleGuideId": style_guide_id,
            },
            json_body=_body or None,
            timeout=timeout,
        )

    def style_guide_import(
        self,
        *,
        style_guide_id: str,
        timeout: Optional[float] = None,
    ) -> StyleGuideImportResponse:
        """Initiate import of a style guide

        Imports a style guide to the given identifier. This operation will
        replace the current style guide.

        Responses include an `uploadUrl` which indicates where to upload the
        style guide import. To upload the file,
        perform a PUT against the `uploadUrl` with the same authentication
        credentials and flow as the import request.
        For more details, see [Authentication
        documentation](ref:authentication). The response will also include
        a `Location` header, which indicates where to poll for results. For more
        details on long-running job polling, see
        [Operations endpoint](ref:getoperationbyid). When the upload completes,
        its status will be
        `completed`, and the response body includes a `resourceURL`. To GET the
        style guide, perform a GET
        on the `resourceURL` with the same authentication credentials and flow
        as the initial request.

        Args:
            style_guide_id: The unique identifier of the style guide
            timeout: Override the default request timeout (seconds).

        Returns:
            StyleGuideImportResponse

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 429, 500, 503).
        """
        response = self._client.request(
            "POST",
            self._api,
            "/content/styleGuides/{styleGuideId}/import",
            path_params={
                "styleGuideId": style_guide_id,
            },
            timeout=timeout,
        )
        return StyleGuideImportResponse.model_validate(response.json())

    async def style_guide_import_async(
        self,
        *,
        style_guide_id: str,
        timeout: Optional[float] = None,
    ) -> StyleGuideImportResponse:
        """Initiate import of a style guide (async)

        Imports a style guide to the given identifier. This operation will
        replace the current style guide.

        Responses include an `uploadUrl` which indicates where to upload the
        style guide import. To upload the file,
        perform a PUT against the `uploadUrl` with the same authentication
        credentials and flow as the import request.
        For more details, see [Authentication
        documentation](ref:authentication). The response will also include
        a `Location` header, which indicates where to poll for results. For more
        details on long-running job polling, see
        [Operations endpoint](ref:getoperationbyid). When the upload completes,
        its status will be
        `completed`, and the response body includes a `resourceURL`. To GET the
        style guide, perform a GET
        on the `resourceURL` with the same authentication credentials and flow
        as the initial request.

        Args:
            style_guide_id: The unique identifier of the style guide
            timeout: Override the default request timeout (seconds).

        Returns:
            StyleGuideImportResponse

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 429, 500, 503).
        """
        response = await self._client.request_async(
            "POST",
            self._api,
            "/content/styleGuides/{styleGuideId}/import",
            path_params={
                "styleGuideId": style_guide_id,
            },
            timeout=timeout,
        )
        return StyleGuideImportResponse.model_validate(response.json())

    def get_table_anchors(
        self,
        *,
        table_id: str,
        maxpagesize: Optional[int] = 1000,
        revision: Optional[str] = None,
        timeout: Optional[float] = None,
    ) -> AnchorsListResult:
        """Retrieve a list of table anchors

        Returns an [`AnchorsListResult`](ref:content#anchorslistresult) given
        tableId.

        Args:
            table_id: The unique identifier for the table
            maxpagesize: The maximum number of results to retrieve
            revision: Returns resources at a specific revision
            timeout: Override the default request timeout (seconds).

        Returns:
            AnchorsListResult

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 429, 500, 503).
        """

        def _fetch(_cursor: str | None) -> httpx.Response:
            return self._client.request(
                "GET",
                self._api,
                "/content/tables/{tableId}/anchors",
                path_params={
                    "tableId": table_id,
                },
                query_params={
                    "$maxpagesize": maxpagesize,
                    "$revision": revision,
                    "$next": _cursor,
                },
                timeout=timeout,
            )

        _body_result = paginate_all(_fetch, extract_next_link, "data")
        return AnchorsListResult.model_validate(_body_result)

    async def get_table_anchors_async(
        self,
        *,
        table_id: str,
        maxpagesize: Optional[int] = 1000,
        revision: Optional[str] = None,
        timeout: Optional[float] = None,
    ) -> AnchorsListResult:
        """Retrieve a list of table anchors (async)

        Returns an [`AnchorsListResult`](ref:content#anchorslistresult) given
        tableId.

        Args:
            table_id: The unique identifier for the table
            maxpagesize: The maximum number of results to retrieve
            revision: Returns resources at a specific revision
            timeout: Override the default request timeout (seconds).

        Returns:
            AnchorsListResult

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 429, 500, 503).
        """

        async def _fetch(_cursor: str | None) -> httpx.Response:
            return await self._client.request_async(
                "GET",
                self._api,
                "/content/tables/{tableId}/anchors",
                path_params={
                    "tableId": table_id,
                },
                query_params={
                    "$maxpagesize": maxpagesize,
                    "$revision": revision,
                    "$next": _cursor,
                },
                timeout=timeout,
            )

        _body_result = await paginate_all_async(_fetch, extract_next_link, "data")
        return AnchorsListResult.model_validate(_body_result)

    def table_anchor_creation(
        self,
        *,
        table_id: str,
        range: CellRange,
        revision: str,
        timeout: Optional[float] = None,
    ) -> httpx.Response:
        """Initiate creation of a new table anchor

        Create a new [`Anchor`](ref:content#anchor) using a
        [`TableAnchorCreation`](ref:content#tableanchorcreation) request. This
        is a long running operation.

        Responses include a `Location` header, which indicates where to poll for
        results. For more details on long-running job polling, see
        [Operations endpoint](ref:getoperationbyid).
        When the creation completes, its status will be `completed`, and the
        response
        body includes a `resourceURL`. To GET the new table anchor, perform a
        GET
        on the `resourceURL` with the same authentication credentials and flow
        as the
        initial request. For more details, see
        [Authentication documentation](ref:authentication).

        Args:
            table_id: The unique identifier for the table
            range:
            revision: Revision string value
            timeout: Override the default request timeout (seconds).

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 429, 500, 503).

        Note:
            This is a long-running operation (HTTP 202). Use
            ``client.wait(response).result()`` to poll until completion.
        """
        _body: dict[str, Any] = {}
        if range is not None:
            _body["range"] = range
        if revision is not None:
            _body["revision"] = revision
        return self._client.request(
            "POST",
            self._api,
            "/content/tables/{tableId}/anchors/creation",
            path_params={
                "tableId": table_id,
            },
            json_body=_body or None,
            timeout=timeout,
        )

    async def table_anchor_creation_async(
        self,
        *,
        table_id: str,
        range: CellRange,
        revision: str,
        timeout: Optional[float] = None,
    ) -> httpx.Response:
        """Initiate creation of a new table anchor (async)

        Create a new [`Anchor`](ref:content#anchor) using a
        [`TableAnchorCreation`](ref:content#tableanchorcreation) request. This
        is a long running operation.

        Responses include a `Location` header, which indicates where to poll for
        results. For more details on long-running job polling, see
        [Operations endpoint](ref:getoperationbyid).
        When the creation completes, its status will be `completed`, and the
        response
        body includes a `resourceURL`. To GET the new table anchor, perform a
        GET
        on the `resourceURL` with the same authentication credentials and flow
        as the
        initial request. For more details, see
        [Authentication documentation](ref:authentication).

        Args:
            table_id: The unique identifier for the table
            range:
            revision: Revision string value
            timeout: Override the default request timeout (seconds).

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 429, 500, 503).

        Note:
            This is a long-running operation (HTTP 202). Use
            ``await client.wait(response).result_async()`` to poll until completion.
        """
        _body: dict[str, Any] = {}
        if range is not None:
            _body["range"] = range
        if revision is not None:
            _body["revision"] = revision
        return await self._client.request_async(
            "POST",
            self._api,
            "/content/tables/{tableId}/anchors/creation",
            path_params={
                "tableId": table_id,
            },
            json_body=_body or None,
            timeout=timeout,
        )

    def get_table_anchor_by_id(
        self,
        *,
        table_id: str,
        anchor_id: str,
        revision: Optional[str] = None,
        timeout: Optional[float] = None,
    ) -> Anchor:
        """Retrieve a table anchor by ID

        Returns an [`Anchor`](ref:content#anchor) given its id.

        Args:
            table_id: The unique identifier for the table
            anchor_id: The unique identifier of the anchor
            revision: Returns resources at a specific revision
            timeout: Override the default request timeout (seconds).

        Returns:
            Anchor

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 429, 500, 503).
        """
        response = self._client.request(
            "GET",
            self._api,
            "/content/tables/{tableId}/anchors/{anchorId}",
            path_params={
                "tableId": table_id,
                "anchorId": anchor_id,
            },
            query_params={
                "$revision": revision,
            },
            timeout=timeout,
        )
        return Anchor.model_validate(response.json())

    async def get_table_anchor_by_id_async(
        self,
        *,
        table_id: str,
        anchor_id: str,
        revision: Optional[str] = None,
        timeout: Optional[float] = None,
    ) -> Anchor:
        """Retrieve a table anchor by ID (async)

        Returns an [`Anchor`](ref:content#anchor) given its id.

        Args:
            table_id: The unique identifier for the table
            anchor_id: The unique identifier of the anchor
            revision: Returns resources at a specific revision
            timeout: Override the default request timeout (seconds).

        Returns:
            Anchor

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 429, 500, 503).
        """
        response = await self._client.request_async(
            "GET",
            self._api,
            "/content/tables/{tableId}/anchors/{anchorId}",
            path_params={
                "tableId": table_id,
                "anchorId": anchor_id,
            },
            query_params={
                "$revision": revision,
            },
            timeout=timeout,
        )
        return Anchor.model_validate(response.json())

    def get_table_anchor_extensions(
        self,
        *,
        table_id: str,
        anchor_id: str,
        maxpagesize: Optional[int] = 1000,
        revision: Optional[str] = None,
        timeout: Optional[float] = None,
    ) -> AnchorExtensionsListResult:
        """Retrieve a list of table anchor extensions

        Returns a paginated list of
        [`AnchorExtensions`](ref:content#anchorextension) for a given anchorId.

        Args:
            table_id: The unique identifier for the table
            anchor_id: The unique identifier of the anchor
            maxpagesize: The maximum number of results to retrieve
            revision: Returns resources at a specific revision
            timeout: Override the default request timeout (seconds).

        Returns:
            AnchorExtensionsListResult

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 429, 500, 503).
        """

        def _fetch(_cursor: str | None) -> httpx.Response:
            return self._client.request(
                "GET",
                self._api,
                "/content/tables/{tableId}/anchors/{anchorId}/extensions",
                path_params={
                    "tableId": table_id,
                    "anchorId": anchor_id,
                },
                query_params={
                    "$maxpagesize": maxpagesize,
                    "$revision": revision,
                    "$next": _cursor,
                },
                timeout=timeout,
            )

        _body_result = paginate_all(_fetch, extract_next_link, "data")
        return AnchorExtensionsListResult.model_validate(_body_result)

    async def get_table_anchor_extensions_async(
        self,
        *,
        table_id: str,
        anchor_id: str,
        maxpagesize: Optional[int] = 1000,
        revision: Optional[str] = None,
        timeout: Optional[float] = None,
    ) -> AnchorExtensionsListResult:
        """Retrieve a list of table anchor extensions (async)

        Returns a paginated list of
        [`AnchorExtensions`](ref:content#anchorextension) for a given anchorId.

        Args:
            table_id: The unique identifier for the table
            anchor_id: The unique identifier of the anchor
            maxpagesize: The maximum number of results to retrieve
            revision: Returns resources at a specific revision
            timeout: Override the default request timeout (seconds).

        Returns:
            AnchorExtensionsListResult

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 429, 500, 503).
        """

        async def _fetch(_cursor: str | None) -> httpx.Response:
            return await self._client.request_async(
                "GET",
                self._api,
                "/content/tables/{tableId}/anchors/{anchorId}/extensions",
                path_params={
                    "tableId": table_id,
                    "anchorId": anchor_id,
                },
                query_params={
                    "$maxpagesize": maxpagesize,
                    "$revision": revision,
                    "$next": _cursor,
                },
                timeout=timeout,
            )

        _body_result = await paginate_all_async(_fetch, extract_next_link, "data")
        return AnchorExtensionsListResult.model_validate(_body_result)

    def get_table_cells(
        self,
        *,
        table_id: str,
        revision: Optional[str] = None,
        maxcellsperpage: Optional[int] = 50000,
        start_row: Optional[int] = None,
        stop_row: Optional[int] = None,
        start_column: Optional[int] = None,
        stop_column: Optional[int] = None,
        timeout: Optional[float] = None,
    ) -> TableCellsResult:
        """Retrieve table cell content

        Returns a [`TableCellsResult`](ref:content#tablecellsresult) for a given
        tableId.

        Args:
            table_id: The unique identifier for the table
            revision: Returns resources at a specific revision
            maxcellsperpage: The maximum number of cells to retrieve. The default is 50000. The maximum allowed value is 50000.
            start_row: The inclusive start row of the range of cells to retrieve. If this parameter is omitted, then the range will be unbounded in this direction.
            stop_row: The inclusive stop row of the range of cells to retrieve. If this parameter is omitted, then the range will be unbounded in this direction.
            start_column: The inclusive start column of the range of cells to retrieve. If this parameter is omitted, then the range will be unbounded in this direction.
            stop_column: The inclusive stop column of the range of cells to retrieve. If this parameter is omitted, then the range will be unbounded in this direction.
            timeout: Override the default request timeout (seconds).

        Returns:
            TableCellsResult

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 429, 500, 503).
        """

        def _fetch(_cursor: str | None) -> httpx.Response:
            return self._client.request(
                "GET",
                self._api,
                "/content/tables/{tableId}/cells",
                path_params={
                    "tableId": table_id,
                },
                query_params={
                    "$revision": revision,
                    "$maxcellsperpage": maxcellsperpage,
                    "startRow": start_row,
                    "stopRow": stop_row,
                    "startColumn": start_column,
                    "stopColumn": stop_column,
                    "$next": _cursor,
                },
                timeout=timeout,
            )

        _body_result = paginate_all(_fetch, extract_next_link, "data")
        return TableCellsResult.model_validate(_body_result)

    async def get_table_cells_async(
        self,
        *,
        table_id: str,
        revision: Optional[str] = None,
        maxcellsperpage: Optional[int] = 50000,
        start_row: Optional[int] = None,
        stop_row: Optional[int] = None,
        start_column: Optional[int] = None,
        stop_column: Optional[int] = None,
        timeout: Optional[float] = None,
    ) -> TableCellsResult:
        """Retrieve table cell content (async)

        Returns a [`TableCellsResult`](ref:content#tablecellsresult) for a given
        tableId.

        Args:
            table_id: The unique identifier for the table
            revision: Returns resources at a specific revision
            maxcellsperpage: The maximum number of cells to retrieve. The default is 50000. The maximum allowed value is 50000.
            start_row: The inclusive start row of the range of cells to retrieve. If this parameter is omitted, then the range will be unbounded in this direction.
            stop_row: The inclusive stop row of the range of cells to retrieve. If this parameter is omitted, then the range will be unbounded in this direction.
            start_column: The inclusive start column of the range of cells to retrieve. If this parameter is omitted, then the range will be unbounded in this direction.
            stop_column: The inclusive stop column of the range of cells to retrieve. If this parameter is omitted, then the range will be unbounded in this direction.
            timeout: Override the default request timeout (seconds).

        Returns:
            TableCellsResult

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 429, 500, 503).
        """

        async def _fetch(_cursor: str | None) -> httpx.Response:
            return await self._client.request_async(
                "GET",
                self._api,
                "/content/tables/{tableId}/cells",
                path_params={
                    "tableId": table_id,
                },
                query_params={
                    "$revision": revision,
                    "$maxcellsperpage": maxcellsperpage,
                    "startRow": start_row,
                    "stopRow": stop_row,
                    "startColumn": start_column,
                    "stopColumn": stop_column,
                    "$next": _cursor,
                },
                timeout=timeout,
            )

        _body_result = await paginate_all_async(_fetch, extract_next_link, "data")
        return TableCellsResult.model_validate(_body_result)

    def table_cells_batch_edit(
        self,
        *,
        table_id: str,
        data: list[TableCellsEdit],
        locked_cell_edit_mode: Optional[str] = None,
        revision: Optional[str] = None,
        timeout: Optional[float] = None,
    ) -> httpx.Response:
        """Initiate edits to table cells

        Sends a [`TableCellsBatchEdit`](ref:content#tablecellsbatchedit) to
        perform on the cells in a table.

        The optional revision property can be used to identify a stable cell
        location in the table. The latest revision is used if not specified.

        Responses include a `Location` header, which indicates where to poll for
        results. For more details on long-running job polling, see[ Operations
        endpoint ](ref:getoperationbyid). When the creation completes, its
        status will be `completed`, and the response\nbody includes a
        `resourceURL`.\n"

        Args:
            table_id: The unique identifier for the table
            data: The edits to apply to table cells.
            locked_cell_edit_mode:
            revision: Identifies the version of the table to apply the edits to. Defaults to the latest revision if not specified.

            timeout: Override the default request timeout (seconds).

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 429, 500, 503).

        Note:
            This is a long-running operation (HTTP 202). Use
            ``client.wait(response).result()`` to poll until completion.
        """
        _body: dict[str, Any] = {}
        if data is not None:
            _body["data"] = data
        if locked_cell_edit_mode is not None:
            _body["lockedCellEditMode"] = locked_cell_edit_mode
        if revision is not None:
            _body["revision"] = revision
        return self._client.request(
            "POST",
            self._api,
            "/content/tables/{tableId}/cells/edit",
            path_params={
                "tableId": table_id,
            },
            json_body=_body or None,
            timeout=timeout,
        )

    async def table_cells_batch_edit_async(
        self,
        *,
        table_id: str,
        data: list[TableCellsEdit],
        locked_cell_edit_mode: Optional[str] = None,
        revision: Optional[str] = None,
        timeout: Optional[float] = None,
    ) -> httpx.Response:
        """Initiate edits to table cells (async)

        Sends a [`TableCellsBatchEdit`](ref:content#tablecellsbatchedit) to
        perform on the cells in a table.

        The optional revision property can be used to identify a stable cell
        location in the table. The latest revision is used if not specified.

        Responses include a `Location` header, which indicates where to poll for
        results. For more details on long-running job polling, see[ Operations
        endpoint ](ref:getoperationbyid). When the creation completes, its
        status will be `completed`, and the response\nbody includes a
        `resourceURL`.\n"

        Args:
            table_id: The unique identifier for the table
            data: The edits to apply to table cells.
            locked_cell_edit_mode:
            revision: Identifies the version of the table to apply the edits to. Defaults to the latest revision if not specified.

            timeout: Override the default request timeout (seconds).

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 429, 500, 503).

        Note:
            This is a long-running operation (HTTP 202). Use
            ``await client.wait(response).result_async()`` to poll until completion.
        """
        _body: dict[str, Any] = {}
        if data is not None:
            _body["data"] = data
        if locked_cell_edit_mode is not None:
            _body["lockedCellEditMode"] = locked_cell_edit_mode
        if revision is not None:
            _body["revision"] = revision
        return await self._client.request_async(
            "POST",
            self._api,
            "/content/tables/{tableId}/cells/edit",
            path_params={
                "tableId": table_id,
            },
            json_body=_body or None,
            timeout=timeout,
        )

    def get_column_properties(
        self,
        *,
        table_id: str,
        revision: Optional[str] = None,
        maxpagesize: Optional[int] = 1000,
        start_column: Optional[int] = None,
        stop_column: Optional[int] = None,
        timeout: Optional[float] = None,
    ) -> ColumnPropertiesListResult:
        """Retrieve table column properties

        Returns a
        [`ColumnPropertiesListResult`](ref:content#columnpropertieslistresult)
        for a table

        Args:
            table_id: The unique identifier for the table
            revision: Returns resources at a specific revision
            maxpagesize: The maximum number of results to retrieve
            start_column: The inclusive start column of the range of cells to retrieve. If this parameter is omitted, then the range will be unbounded in this direction.
            stop_column: The inclusive stop column of the range of cells to retrieve. If this parameter is omitted, then the range will be unbounded in this direction.
            timeout: Override the default request timeout (seconds).

        Returns:
            ColumnPropertiesListResult

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 429, 500, 503).
        """

        def _fetch(_cursor: str | None) -> httpx.Response:
            return self._client.request(
                "GET",
                self._api,
                "/content/tables/{tableId}/properties/columns",
                path_params={
                    "tableId": table_id,
                },
                query_params={
                    "$revision": revision,
                    "$maxpagesize": maxpagesize,
                    "startColumn": start_column,
                    "stopColumn": stop_column,
                    "$next": _cursor,
                },
                timeout=timeout,
            )

        _body_result = paginate_all(_fetch, extract_next_link, "data")
        return ColumnPropertiesListResult.model_validate(_body_result)

    async def get_column_properties_async(
        self,
        *,
        table_id: str,
        revision: Optional[str] = None,
        maxpagesize: Optional[int] = 1000,
        start_column: Optional[int] = None,
        stop_column: Optional[int] = None,
        timeout: Optional[float] = None,
    ) -> ColumnPropertiesListResult:
        """Retrieve table column properties (async)

        Returns a
        [`ColumnPropertiesListResult`](ref:content#columnpropertieslistresult)
        for a table

        Args:
            table_id: The unique identifier for the table
            revision: Returns resources at a specific revision
            maxpagesize: The maximum number of results to retrieve
            start_column: The inclusive start column of the range of cells to retrieve. If this parameter is omitted, then the range will be unbounded in this direction.
            stop_column: The inclusive stop column of the range of cells to retrieve. If this parameter is omitted, then the range will be unbounded in this direction.
            timeout: Override the default request timeout (seconds).

        Returns:
            ColumnPropertiesListResult

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 429, 500, 503).
        """

        async def _fetch(_cursor: str | None) -> httpx.Response:
            return await self._client.request_async(
                "GET",
                self._api,
                "/content/tables/{tableId}/properties/columns",
                path_params={
                    "tableId": table_id,
                },
                query_params={
                    "$revision": revision,
                    "$maxpagesize": maxpagesize,
                    "startColumn": start_column,
                    "stopColumn": stop_column,
                    "$next": _cursor,
                },
                timeout=timeout,
            )

        _body_result = await paginate_all_async(_fetch, extract_next_link, "data")
        return ColumnPropertiesListResult.model_validate(_body_result)

    def table_edit(
        self,
        *,
        table_id: str,
        type_: Literal[
            "deleteColumns", "deleteRows", "moveColumns", "moveRows", "insertColumns", "insertRows"
        ],
        delete_columns: Optional[DeleteColumns] = None,
        delete_rows: Optional[DeleteRows] = None,
        insert_columns: Optional[InsertColumns] = None,
        insert_rows: Optional[InsertRows] = None,
        move_columns: Optional[MoveColumns] = None,
        move_rows: Optional[MoveRows] = None,
        timeout: Optional[float] = None,
    ) -> httpx.Response:
        """Initiate edit to a table

        Sends a single [`TableEdit`](ref:content#tableedit) to perform on the
        table.

        Responses include a `Location` header, which indicates where to poll for
        results. For more details on long-running job polling, see
        [ Operations endpoint ](ref:getoperationbyid). When the creation
        completes, its status will be `completed`, and the response
        body includes a `resourceURL`.

        Args:
            table_id: The unique identifier for the table
            type_: The type of edit operation to perform on the table
            delete_columns:
            delete_rows:
            insert_columns:
            insert_rows:
            move_columns:
            move_rows:
            timeout: Override the default request timeout (seconds).

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 429, 500, 503).

        Note:
            This is a long-running operation (HTTP 202). Use
            ``client.wait(response).result()`` to poll until completion.
        """
        _body: dict[str, Any] = {}
        if type_ is not None:
            _body["type"] = type_
        if delete_columns is not None:
            _body["deleteColumns"] = delete_columns
        if delete_rows is not None:
            _body["deleteRows"] = delete_rows
        if insert_columns is not None:
            _body["insertColumns"] = insert_columns
        if insert_rows is not None:
            _body["insertRows"] = insert_rows
        if move_columns is not None:
            _body["moveColumns"] = move_columns
        if move_rows is not None:
            _body["moveRows"] = move_rows
        return self._client.request(
            "POST",
            self._api,
            "/content/tables/{tableId}/edit",
            path_params={
                "tableId": table_id,
            },
            json_body=_body or None,
            timeout=timeout,
        )

    async def table_edit_async(
        self,
        *,
        table_id: str,
        type_: Literal[
            "deleteColumns", "deleteRows", "moveColumns", "moveRows", "insertColumns", "insertRows"
        ],
        delete_columns: Optional[DeleteColumns] = None,
        delete_rows: Optional[DeleteRows] = None,
        insert_columns: Optional[InsertColumns] = None,
        insert_rows: Optional[InsertRows] = None,
        move_columns: Optional[MoveColumns] = None,
        move_rows: Optional[MoveRows] = None,
        timeout: Optional[float] = None,
    ) -> httpx.Response:
        """Initiate edit to a table (async)

        Sends a single [`TableEdit`](ref:content#tableedit) to perform on the
        table.

        Responses include a `Location` header, which indicates where to poll for
        results. For more details on long-running job polling, see
        [ Operations endpoint ](ref:getoperationbyid). When the creation
        completes, its status will be `completed`, and the response
        body includes a `resourceURL`.

        Args:
            table_id: The unique identifier for the table
            type_: The type of edit operation to perform on the table
            delete_columns:
            delete_rows:
            insert_columns:
            insert_rows:
            move_columns:
            move_rows:
            timeout: Override the default request timeout (seconds).

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 429, 500, 503).

        Note:
            This is a long-running operation (HTTP 202). Use
            ``await client.wait(response).result_async()`` to poll until completion.
        """
        _body: dict[str, Any] = {}
        if type_ is not None:
            _body["type"] = type_
        if delete_columns is not None:
            _body["deleteColumns"] = delete_columns
        if delete_rows is not None:
            _body["deleteRows"] = delete_rows
        if insert_columns is not None:
            _body["insertColumns"] = insert_columns
        if insert_rows is not None:
            _body["insertRows"] = insert_rows
        if move_columns is not None:
            _body["moveColumns"] = move_columns
        if move_rows is not None:
            _body["moveRows"] = move_rows
        return await self._client.request_async(
            "POST",
            self._api,
            "/content/tables/{tableId}/edit",
            path_params={
                "tableId": table_id,
            },
            json_body=_body or None,
            timeout=timeout,
        )

    def table_filters_reapplication(
        self,
        *,
        table_id: str,
        force_hide_footnotes: Optional[bool] = None,
        timeout: Optional[float] = None,
    ) -> httpx.Response:
        """Reapply filters to the table

        Performs a
        [`TableFiltersReapplication`](ref:content#tablefiltersreapplication) on
        the specified table.
        This endpoint is used to refresh the table's filters based on the latest
        state or configuration changes.
        The filters are reapplied in the context of the table's current data
        state.
        This is a long running operation. Responses include a `Location` header,
        which indicates where to poll for results. For more details on
        long-running job polling, see [Operations
        endpoint](ref:getoperationbyid).

        Args:
            table_id: The unique identifier for the table
            force_hide_footnotes: Whether the filter should be reapplied if doing so would cause footnotes to be hidden.
            timeout: Override the default request timeout (seconds).

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 429, 500, 503).

        Note:
            This is a long-running operation (HTTP 202). Use
            ``client.wait(response).result()`` to poll until completion.
        """
        _body: dict[str, Any] = {}
        if force_hide_footnotes is not None:
            _body["forceHideFootnotes"] = force_hide_footnotes
        return self._client.request(
            "POST",
            self._api,
            "/content/tables/{tableId}/filters/reapplication",
            path_params={
                "tableId": table_id,
            },
            json_body=_body or None,
            timeout=timeout,
        )

    async def table_filters_reapplication_async(
        self,
        *,
        table_id: str,
        force_hide_footnotes: Optional[bool] = None,
        timeout: Optional[float] = None,
    ) -> httpx.Response:
        """Reapply filters to the table (async)

        Performs a
        [`TableFiltersReapplication`](ref:content#tablefiltersreapplication) on
        the specified table.
        This endpoint is used to refresh the table's filters based on the latest
        state or configuration changes.
        The filters are reapplied in the context of the table's current data
        state.
        This is a long running operation. Responses include a `Location` header,
        which indicates where to poll for results. For more details on
        long-running job polling, see [Operations
        endpoint](ref:getoperationbyid).

        Args:
            table_id: The unique identifier for the table
            force_hide_footnotes: Whether the filter should be reapplied if doing so would cause footnotes to be hidden.
            timeout: Override the default request timeout (seconds).

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 429, 500, 503).

        Note:
            This is a long-running operation (HTTP 202). Use
            ``await client.wait(response).result_async()`` to poll until completion.
        """
        _body: dict[str, Any] = {}
        if force_hide_footnotes is not None:
            _body["forceHideFootnotes"] = force_hide_footnotes
        return await self._client.request_async(
            "POST",
            self._api,
            "/content/tables/{tableId}/filters/reapplication",
            path_params={
                "tableId": table_id,
            },
            json_body=_body or None,
            timeout=timeout,
        )

    def table_links_batch_edit(
        self,
        *,
        table_id: str,
        data: list[TableLinksEdit],
        locked_cell_edit_mode: Optional[str] = None,
        revision: Optional[str] = None,
        timeout: Optional[float] = None,
    ) -> httpx.Response:
        """Initiate edit to table links

        Sends a [`TableLinksBatchEdit`](ref:content#tablelinksbatchedit) to
        perform on the links in a table.

        The optional revision property can be used to identify a stable cell
        location in the table. The latest revision is used if not specified.

        If the edit creates any new resources, such as destination links, the
        `resourceUrl` field will be populated with a link to the [Table Links
        Edit Results endpoint](ref:gettablelinkseditresults) to retrieve the IDs
        of the new resources.

        Args:
            table_id: The unique identifier for the table
            data: The edits to apply to the table.
            locked_cell_edit_mode:
            revision: Identifies the version of the table to apply the edits to. Defaults to the latest revision if not specified.

            timeout: Override the default request timeout (seconds).

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 429, 500, 503).

        Note:
            This is a long-running operation (HTTP 202). Use
            ``client.wait(response).result()`` to poll until completion.
        """
        _body: dict[str, Any] = {}
        if data is not None:
            _body["data"] = data
        if locked_cell_edit_mode is not None:
            _body["lockedCellEditMode"] = locked_cell_edit_mode
        if revision is not None:
            _body["revision"] = revision
        return self._client.request(
            "POST",
            self._api,
            "/content/tables/{tableId}/links/edit",
            path_params={
                "tableId": table_id,
            },
            json_body=_body or None,
            timeout=timeout,
        )

    async def table_links_batch_edit_async(
        self,
        *,
        table_id: str,
        data: list[TableLinksEdit],
        locked_cell_edit_mode: Optional[str] = None,
        revision: Optional[str] = None,
        timeout: Optional[float] = None,
    ) -> httpx.Response:
        """Initiate edit to table links (async)

        Sends a [`TableLinksBatchEdit`](ref:content#tablelinksbatchedit) to
        perform on the links in a table.

        The optional revision property can be used to identify a stable cell
        location in the table. The latest revision is used if not specified.

        If the edit creates any new resources, such as destination links, the
        `resourceUrl` field will be populated with a link to the [Table Links
        Edit Results endpoint](ref:gettablelinkseditresults) to retrieve the IDs
        of the new resources.

        Args:
            table_id: The unique identifier for the table
            data: The edits to apply to the table.
            locked_cell_edit_mode:
            revision: Identifies the version of the table to apply the edits to. Defaults to the latest revision if not specified.

            timeout: Override the default request timeout (seconds).

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 429, 500, 503).

        Note:
            This is a long-running operation (HTTP 202). Use
            ``await client.wait(response).result_async()`` to poll until completion.
        """
        _body: dict[str, Any] = {}
        if data is not None:
            _body["data"] = data
        if locked_cell_edit_mode is not None:
            _body["lockedCellEditMode"] = locked_cell_edit_mode
        if revision is not None:
            _body["revision"] = revision
        return await self._client.request_async(
            "POST",
            self._api,
            "/content/tables/{tableId}/links/edit",
            path_params={
                "tableId": table_id,
            },
            json_body=_body or None,
            timeout=timeout,
        )

    def get_range_links(
        self,
        *,
        table_id: str,
        maxpagesize: Optional[int] = 1000,
        revision: Optional[str] = None,
        timeout: Optional[float] = None,
    ) -> RangeLinkListResult:
        """Retrieve a list of range links

        Returns a [`RangeLinkListResult`](ref:content#rangelinklistresult) for a
        given tableId.

        Args:
            table_id: The unique identifier for the table
            maxpagesize: The maximum number of results to retrieve
            revision: Returns resources at a specific revision
            timeout: Override the default request timeout (seconds).

        Returns:
            RangeLinkListResult

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 429, 500, 503).
        """

        def _fetch(_cursor: str | None) -> httpx.Response:
            return self._client.request(
                "GET",
                self._api,
                "/content/tables/{tableId}/rangeLinks",
                path_params={
                    "tableId": table_id,
                },
                query_params={
                    "$maxpagesize": maxpagesize,
                    "$revision": revision,
                    "$next": _cursor,
                },
                timeout=timeout,
            )

        _body_result = paginate_all(_fetch, extract_next_link, "data")
        return RangeLinkListResult.model_validate(_body_result)

    async def get_range_links_async(
        self,
        *,
        table_id: str,
        maxpagesize: Optional[int] = 1000,
        revision: Optional[str] = None,
        timeout: Optional[float] = None,
    ) -> RangeLinkListResult:
        """Retrieve a list of range links (async)

        Returns a [`RangeLinkListResult`](ref:content#rangelinklistresult) for a
        given tableId.

        Args:
            table_id: The unique identifier for the table
            maxpagesize: The maximum number of results to retrieve
            revision: Returns resources at a specific revision
            timeout: Override the default request timeout (seconds).

        Returns:
            RangeLinkListResult

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 429, 500, 503).
        """

        async def _fetch(_cursor: str | None) -> httpx.Response:
            return await self._client.request_async(
                "GET",
                self._api,
                "/content/tables/{tableId}/rangeLinks",
                path_params={
                    "tableId": table_id,
                },
                query_params={
                    "$maxpagesize": maxpagesize,
                    "$revision": revision,
                    "$next": _cursor,
                },
                timeout=timeout,
            )

        _body_result = await paginate_all_async(_fetch, extract_next_link, "data")
        return RangeLinkListResult.model_validate(_body_result)

    def get_range_link_by_id(
        self,
        *,
        table_id: str,
        range_link_id: str,
        revision: Optional[str] = None,
        timeout: Optional[float] = None,
    ) -> RangeLink:
        """Retrieve a range link by id

        Returns a [`RangeLink`](ref:content#rangelink) given its id

        Args:
            table_id: The unique identifier for the table
            range_link_id: The unique identifier of a range link.
            revision: Returns resources at a specific revision
            timeout: Override the default request timeout (seconds).

        Returns:
            RangeLink

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 429, 500, 503).
        """
        response = self._client.request(
            "GET",
            self._api,
            "/content/tables/{tableId}/rangeLinks/{rangeLinkId}",
            path_params={
                "tableId": table_id,
                "rangeLinkId": range_link_id,
            },
            query_params={
                "$revision": revision,
            },
            timeout=timeout,
        )
        return RangeLink.model_validate(response.json())

    async def get_range_link_by_id_async(
        self,
        *,
        table_id: str,
        range_link_id: str,
        revision: Optional[str] = None,
        timeout: Optional[float] = None,
    ) -> RangeLink:
        """Retrieve a range link by id (async)

        Returns a [`RangeLink`](ref:content#rangelink) given its id

        Args:
            table_id: The unique identifier for the table
            range_link_id: The unique identifier of a range link.
            revision: Returns resources at a specific revision
            timeout: Override the default request timeout (seconds).

        Returns:
            RangeLink

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 429, 500, 503).
        """
        response = await self._client.request_async(
            "GET",
            self._api,
            "/content/tables/{tableId}/rangeLinks/{rangeLinkId}",
            path_params={
                "tableId": table_id,
                "rangeLinkId": range_link_id,
            },
            query_params={
                "$revision": revision,
            },
            timeout=timeout,
        )
        return RangeLink.model_validate(response.json())

    def get_range_link_destinations(
        self,
        *,
        table_id: str,
        range_link_id: str,
        maxpagesize: Optional[int] = 1000,
        revision: Optional[str] = None,
        timeout: Optional[float] = None,
    ) -> RangeLinkListResult:
        """Retrieve range link destinations for a source

        Returns a [`RangeLinkListResult`](ref:content#rangelinklistresult) of
        destinations for a given source range link.

        Args:
            table_id: The unique identifier for the table
            range_link_id: The unique identifier of a range link.
            maxpagesize: The maximum number of results to retrieve
            revision: Returns resources at a specific revision
            timeout: Override the default request timeout (seconds).

        Returns:
            RangeLinkListResult

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 429, 500, 503).
        """

        def _fetch(_cursor: str | None) -> httpx.Response:
            return self._client.request(
                "GET",
                self._api,
                "/content/tables/{tableId}/rangeLinks/{rangeLinkId}/destinations",
                path_params={
                    "tableId": table_id,
                    "rangeLinkId": range_link_id,
                },
                query_params={
                    "$maxpagesize": maxpagesize,
                    "$revision": revision,
                    "$next": _cursor,
                },
                timeout=timeout,
            )

        _body_result = paginate_all(_fetch, extract_next_link, "data")
        return RangeLinkListResult.model_validate(_body_result)

    async def get_range_link_destinations_async(
        self,
        *,
        table_id: str,
        range_link_id: str,
        maxpagesize: Optional[int] = 1000,
        revision: Optional[str] = None,
        timeout: Optional[float] = None,
    ) -> RangeLinkListResult:
        """Retrieve range link destinations for a source (async)

        Returns a [`RangeLinkListResult`](ref:content#rangelinklistresult) of
        destinations for a given source range link.

        Args:
            table_id: The unique identifier for the table
            range_link_id: The unique identifier of a range link.
            maxpagesize: The maximum number of results to retrieve
            revision: Returns resources at a specific revision
            timeout: Override the default request timeout (seconds).

        Returns:
            RangeLinkListResult

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 429, 500, 503).
        """

        async def _fetch(_cursor: str | None) -> httpx.Response:
            return await self._client.request_async(
                "GET",
                self._api,
                "/content/tables/{tableId}/rangeLinks/{rangeLinkId}/destinations",
                path_params={
                    "tableId": table_id,
                    "rangeLinkId": range_link_id,
                },
                query_params={
                    "$maxpagesize": maxpagesize,
                    "$revision": revision,
                    "$next": _cursor,
                },
                timeout=timeout,
            )

        _body_result = await paginate_all_async(_fetch, extract_next_link, "data")
        return RangeLinkListResult.model_validate(_body_result)

    def table_range_links_edit(
        self,
        *,
        table_id: str,
        type_: Literal[
            "createSource",
            "createDestination",
            "removeSource",
            "removeDestination",
            "changeSourceRange",
        ],
        change_source_range: Optional[ChangeSourceRange] = None,
        create_destination: Optional[CreateDestinationRangeLink] = None,
        create_source: Optional[CreateSourceRangeLink] = None,
        remove_destination: Optional[RemoveDestinationRangeLink] = None,
        remove_source: Optional[RemoveSourceRangeLink] = None,
        timeout: Optional[float] = None,
    ) -> httpx.Response:
        """Initiate range links edits on a table

        Sends a [`RangeLinkEdit`](ref:content#rangelinkedit) to perform on the
        range links in a table.
        This is a long running operation. Responses include a `Location` header,
        which indicates where to poll for results. For more details on long-
        running job polling, see [Operations endpoint](ref:getoperationbyid).

        Args:
            table_id: The unique identifier for the table
            type_: The type of the table range links edit
            change_source_range:
            create_destination:
            create_source:
            remove_destination:
            remove_source:
            timeout: Override the default request timeout (seconds).

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 429, 500, 503).

        Note:
            This is a long-running operation (HTTP 202). Use
            ``client.wait(response).result()`` to poll until completion.
        """
        _body: dict[str, Any] = {}
        if type_ is not None:
            _body["type"] = type_
        if change_source_range is not None:
            _body["changeSourceRange"] = change_source_range
        if create_destination is not None:
            _body["createDestination"] = create_destination
        if create_source is not None:
            _body["createSource"] = create_source
        if remove_destination is not None:
            _body["removeDestination"] = remove_destination
        if remove_source is not None:
            _body["removeSource"] = remove_source
        return self._client.request(
            "POST",
            self._api,
            "/content/tables/{tableId}/rangeLinks/edit",
            path_params={
                "tableId": table_id,
            },
            json_body=_body or None,
            timeout=timeout,
        )

    async def table_range_links_edit_async(
        self,
        *,
        table_id: str,
        type_: Literal[
            "createSource",
            "createDestination",
            "removeSource",
            "removeDestination",
            "changeSourceRange",
        ],
        change_source_range: Optional[ChangeSourceRange] = None,
        create_destination: Optional[CreateDestinationRangeLink] = None,
        create_source: Optional[CreateSourceRangeLink] = None,
        remove_destination: Optional[RemoveDestinationRangeLink] = None,
        remove_source: Optional[RemoveSourceRangeLink] = None,
        timeout: Optional[float] = None,
    ) -> httpx.Response:
        """Initiate range links edits on a table (async)

        Sends a [`RangeLinkEdit`](ref:content#rangelinkedit) to perform on the
        range links in a table.
        This is a long running operation. Responses include a `Location` header,
        which indicates where to poll for results. For more details on long-
        running job polling, see [Operations endpoint](ref:getoperationbyid).

        Args:
            table_id: The unique identifier for the table
            type_: The type of the table range links edit
            change_source_range:
            create_destination:
            create_source:
            remove_destination:
            remove_source:
            timeout: Override the default request timeout (seconds).

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 429, 500, 503).

        Note:
            This is a long-running operation (HTTP 202). Use
            ``await client.wait(response).result_async()`` to poll until completion.
        """
        _body: dict[str, Any] = {}
        if type_ is not None:
            _body["type"] = type_
        if change_source_range is not None:
            _body["changeSourceRange"] = change_source_range
        if create_destination is not None:
            _body["createDestination"] = create_destination
        if create_source is not None:
            _body["createSource"] = create_source
        if remove_destination is not None:
            _body["removeDestination"] = remove_destination
        if remove_source is not None:
            _body["removeSource"] = remove_source
        return await self._client.request_async(
            "POST",
            self._api,
            "/content/tables/{tableId}/rangeLinks/edit",
            path_params={
                "tableId": table_id,
            },
            json_body=_body or None,
            timeout=timeout,
        )

    def get_table_properties(
        self,
        *,
        table_id: str,
        revision: Optional[str] = None,
        timeout: Optional[float] = None,
    ) -> TableProperties:
        """Retrieve a table's properties by id

        Returns a [`TableProperties`](ref:content#tableproperties) for a table

        Args:
            table_id: The unique identifier for the table
            revision: Returns resources at a specific revision
            timeout: Override the default request timeout (seconds).

        Returns:
            TableProperties

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 429, 500, 503).
        """
        response = self._client.request(
            "GET",
            self._api,
            "/content/tables/{tableId}/properties",
            path_params={
                "tableId": table_id,
            },
            query_params={
                "$revision": revision,
            },
            timeout=timeout,
        )
        return TableProperties.model_validate(response.json())

    async def get_table_properties_async(
        self,
        *,
        table_id: str,
        revision: Optional[str] = None,
        timeout: Optional[float] = None,
    ) -> TableProperties:
        """Retrieve a table's properties by id (async)

        Returns a [`TableProperties`](ref:content#tableproperties) for a table

        Args:
            table_id: The unique identifier for the table
            revision: Returns resources at a specific revision
            timeout: Override the default request timeout (seconds).

        Returns:
            TableProperties

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 429, 500, 503).
        """
        response = await self._client.request_async(
            "GET",
            self._api,
            "/content/tables/{tableId}/properties",
            path_params={
                "tableId": table_id,
            },
            query_params={
                "$revision": revision,
            },
            timeout=timeout,
        )
        return TableProperties.model_validate(response.json())

    def partially_update_table_properties(
        self,
        *,
        table_id: str,
        body: list[Any],
        timeout: Optional[float] = None,
    ) -> httpx.Response:
        """Partially update a table's properties

        Partially updates a table's properties given its ID.

        This is a long running operation. Responses include a `Location` header,
        which indicates where to poll for results.
        For more details on long-running job polling, see [Operations
        endpoint](ref:getoperationbyid).

        ### Options
        | Path               | PATCH Operations Supported |
        |--------------------|----------------------------|
        | `/name`            | `replace`                  |
        | `/resizeRowsToFit` | `replace`                  |
        | `/lock`            | `replace`                  |

        Args:
            table_id: The unique identifier for the table
            body: Request body.
            timeout: Override the default request timeout (seconds).

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 429, 500, 503).

        Note:
            This is a long-running operation (HTTP 202). Use
            ``client.wait(response).result()`` to poll until completion.
        """
        return self._client.request(
            "PATCH",
            self._api,
            "/content/tables/{tableId}/properties",
            path_params={
                "tableId": table_id,
            },
            json_body=body,
            timeout=timeout,
        )

    async def partially_update_table_properties_async(
        self,
        *,
        table_id: str,
        body: list[Any],
        timeout: Optional[float] = None,
    ) -> httpx.Response:
        """Partially update a table's properties (async)

        Partially updates a table's properties given its ID.

        This is a long running operation. Responses include a `Location` header,
        which indicates where to poll for results.
        For more details on long-running job polling, see [Operations
        endpoint](ref:getoperationbyid).

        ### Options
        | Path               | PATCH Operations Supported |
        |--------------------|----------------------------|
        | `/name`            | `replace`                  |
        | `/resizeRowsToFit` | `replace`                  |
        | `/lock`            | `replace`                  |

        Args:
            table_id: The unique identifier for the table
            body: Request body.
            timeout: Override the default request timeout (seconds).

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 429, 500, 503).

        Note:
            This is a long-running operation (HTTP 202). Use
            ``await client.wait(response).result_async()`` to poll until completion.
        """
        return await self._client.request_async(
            "PATCH",
            self._api,
            "/content/tables/{tableId}/properties",
            path_params={
                "tableId": table_id,
            },
            json_body=body,
            timeout=timeout,
        )

    def get_row_properties(
        self,
        *,
        table_id: str,
        revision: Optional[str] = None,
        maxpagesize: Optional[int] = 1000,
        start_row: Optional[int] = None,
        stop_row: Optional[int] = None,
        timeout: Optional[float] = None,
    ) -> RowPropertiesListResult:
        """Retrieve table row properties

        Returns a
        [`RowPropertiesListResult`](ref:content#rowpropertieslistresult) for a
        table

        Args:
            table_id: The unique identifier for the table
            revision: Returns resources at a specific revision
            maxpagesize: The maximum number of results to retrieve
            start_row: The inclusive start row of the range of cells to retrieve. If this parameter is omitted, then the range will be unbounded in this direction.
            stop_row: The inclusive stop row of the range of cells to retrieve. If this parameter is omitted, then the range will be unbounded in this direction.
            timeout: Override the default request timeout (seconds).

        Returns:
            RowPropertiesListResult

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 429, 500, 503).
        """

        def _fetch(_cursor: str | None) -> httpx.Response:
            return self._client.request(
                "GET",
                self._api,
                "/content/tables/{tableId}/properties/rows",
                path_params={
                    "tableId": table_id,
                },
                query_params={
                    "$revision": revision,
                    "$maxpagesize": maxpagesize,
                    "startRow": start_row,
                    "stopRow": stop_row,
                    "$next": _cursor,
                },
                timeout=timeout,
            )

        _body_result = paginate_all(_fetch, extract_next_link, "data")
        return RowPropertiesListResult.model_validate(_body_result)

    async def get_row_properties_async(
        self,
        *,
        table_id: str,
        revision: Optional[str] = None,
        maxpagesize: Optional[int] = 1000,
        start_row: Optional[int] = None,
        stop_row: Optional[int] = None,
        timeout: Optional[float] = None,
    ) -> RowPropertiesListResult:
        """Retrieve table row properties (async)

        Returns a
        [`RowPropertiesListResult`](ref:content#rowpropertieslistresult) for a
        table

        Args:
            table_id: The unique identifier for the table
            revision: Returns resources at a specific revision
            maxpagesize: The maximum number of results to retrieve
            start_row: The inclusive start row of the range of cells to retrieve. If this parameter is omitted, then the range will be unbounded in this direction.
            stop_row: The inclusive stop row of the range of cells to retrieve. If this parameter is omitted, then the range will be unbounded in this direction.
            timeout: Override the default request timeout (seconds).

        Returns:
            RowPropertiesListResult

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 429, 500, 503).
        """

        async def _fetch(_cursor: str | None) -> httpx.Response:
            return await self._client.request_async(
                "GET",
                self._api,
                "/content/tables/{tableId}/properties/rows",
                path_params={
                    "tableId": table_id,
                },
                query_params={
                    "$revision": revision,
                    "$maxpagesize": maxpagesize,
                    "startRow": start_row,
                    "stopRow": stop_row,
                    "$next": _cursor,
                },
                timeout=timeout,
            )

        _body_result = await paginate_all_async(_fetch, extract_next_link, "data")
        return RowPropertiesListResult.model_validate(_body_result)
