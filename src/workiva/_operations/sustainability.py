"""Platform API â€” sustainability namespace.

Auto-generated by codegen. Do not edit manually.
"""

from __future__ import annotations

from typing import Any, Literal, Optional

import httpx

from workiva._constants import _API
from workiva._operations._base import BaseNamespace
from workiva._pagination import (
    extract_next_link,
    paginate_all,
    paginate_all_async,
)
from workiva.models.platform import (
    Dimension,
    DimensionsListResult,
    DimensionValue,
    FrameworkReference,
    Metric,
    MetricsListResult,
    MetricValue,
    MetricValuesListResult,
    Program,
    ProgramsListResult,
    ResourcePermission,
    ResourcePermissionsListResult,
    Tag,
    Topic,
    TopicsListResult,
)

__all__ = ["Sustainability"]


class Sustainability(BaseNamespace):
    """Sustainability operations."""

    _api: _API = _API.PLATFORM

    def get_programs(
        self,
        *,
        maxpagesize: Optional[int] = 1000,
        order_by: Optional[str] = None,
        filter_: Optional[str] = None,
        timeout: Optional[float] = None,
    ) -> ProgramsListResult:
        """Retrieve a list of programs

        Returns a paginated list of [programs](ref:sustainability#program).

        Args:
            maxpagesize: The maximum number of results to retrieve
            order_by: One or more comma-separated expressions to indicate the order in which to sort the results.
            filter_: The properties to filter the results by.
            timeout: Override the default request timeout (seconds).

        Returns:
            ProgramsListResult

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 429, 500, 503).
        """

        def _fetch(_cursor: str | None) -> httpx.Response:
            return self._client.request(
                "GET",
                self._api,
                "/programs",
                query_params={
                    "$maxpagesize": maxpagesize,
                    "$orderBy": order_by,
                    "$filter": filter_,
                    "$next": _cursor,
                },
                timeout=timeout,
            )

        _body_result = paginate_all(_fetch, extract_next_link, "data")
        return ProgramsListResult.model_validate(_body_result)

    async def get_programs_async(
        self,
        *,
        maxpagesize: Optional[int] = 1000,
        order_by: Optional[str] = None,
        filter_: Optional[str] = None,
        timeout: Optional[float] = None,
    ) -> ProgramsListResult:
        """Retrieve a list of programs (async)

        Returns a paginated list of [programs](ref:sustainability#program).

        Args:
            maxpagesize: The maximum number of results to retrieve
            order_by: One or more comma-separated expressions to indicate the order in which to sort the results.
            filter_: The properties to filter the results by.
            timeout: Override the default request timeout (seconds).

        Returns:
            ProgramsListResult

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 429, 500, 503).
        """

        async def _fetch(_cursor: str | None) -> httpx.Response:
            return await self._client.request_async(
                "GET",
                self._api,
                "/programs",
                query_params={
                    "$maxpagesize": maxpagesize,
                    "$orderBy": order_by,
                    "$filter": filter_,
                    "$next": _cursor,
                },
                timeout=timeout,
            )

        _body_result = await paginate_all_async(_fetch, extract_next_link, "data")
        return ProgramsListResult.model_validate(_body_result)

    def create_program(
        self,
        *,
        name: Optional[str] = None,
        timeout: Optional[float] = None,
    ) -> Program:
        """Create a new program

        Creates a new [program](ref:sustainability#program).

        Args:
            name: The name of the program. Must be unique within the workspace.
            timeout: Override the default request timeout (seconds).

        Returns:
            Program

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 429, 500, 503).
        """
        _body: dict[str, Any] = {}
        if name is not None:
            _body["name"] = name
        response = self._client.request(
            "POST",
            self._api,
            "/programs",
            json_body=_body or None,
            timeout=timeout,
        )
        return Program.model_validate(response.json())

    async def create_program_async(
        self,
        *,
        name: Optional[str] = None,
        timeout: Optional[float] = None,
    ) -> Program:
        """Create a new program (async)

        Creates a new [program](ref:sustainability#program).

        Args:
            name: The name of the program. Must be unique within the workspace.
            timeout: Override the default request timeout (seconds).

        Returns:
            Program

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 429, 500, 503).
        """
        _body: dict[str, Any] = {}
        if name is not None:
            _body["name"] = name
        response = await self._client.request_async(
            "POST",
            self._api,
            "/programs",
            json_body=_body or None,
            timeout=timeout,
        )
        return Program.model_validate(response.json())

    def get_program_by_id(
        self,
        *,
        program_id: str,
        timeout: Optional[float] = None,
    ) -> Program:
        """Retrieve a single program

        Retrieves a [program](ref:sustainability#program) given its ID

        Args:
            program_id: The unique identifier of the program
            timeout: Override the default request timeout (seconds).

        Returns:
            Program

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 429, 500, 503).
        """
        response = self._client.request(
            "GET",
            self._api,
            "/programs/{programId}",
            path_params={
                "programId": program_id,
            },
            timeout=timeout,
        )
        return Program.model_validate(response.json())

    async def get_program_by_id_async(
        self,
        *,
        program_id: str,
        timeout: Optional[float] = None,
    ) -> Program:
        """Retrieve a single program (async)

        Retrieves a [program](ref:sustainability#program) given its ID

        Args:
            program_id: The unique identifier of the program
            timeout: Override the default request timeout (seconds).

        Returns:
            Program

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 429, 500, 503).
        """
        response = await self._client.request_async(
            "GET",
            self._api,
            "/programs/{programId}",
            path_params={
                "programId": program_id,
            },
            timeout=timeout,
        )
        return Program.model_validate(response.json())

    def partially_update_program_by_id(
        self,
        *,
        program_id: str,
        body: list[Any],
        timeout: Optional[float] = None,
    ) -> Program:
        """Partially update a single program

        Partially updates the properties of a
        [program](ref:sustainability#program). Only one property may be updated
        at a time.
        ### Options
        |Path|PATCH Operations Supported|
        |---|---|
        |`/name`|`replace`, `test`|

        Args:
            program_id: The unique identifier of the program
            body: Request body.
            timeout: Override the default request timeout (seconds).

        Returns:
            Program

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 429, 500, 503).
        """
        response = self._client.request(
            "PATCH",
            self._api,
            "/programs/{programId}",
            path_params={
                "programId": program_id,
            },
            json_body=body,
            timeout=timeout,
        )
        return Program.model_validate(response.json())

    async def partially_update_program_by_id_async(
        self,
        *,
        program_id: str,
        body: list[Any],
        timeout: Optional[float] = None,
    ) -> Program:
        """Partially update a single program (async)

        Partially updates the properties of a
        [program](ref:sustainability#program). Only one property may be updated
        at a time.
        ### Options
        |Path|PATCH Operations Supported|
        |---|---|
        |`/name`|`replace`, `test`|

        Args:
            program_id: The unique identifier of the program
            body: Request body.
            timeout: Override the default request timeout (seconds).

        Returns:
            Program

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 429, 500, 503).
        """
        response = await self._client.request_async(
            "PATCH",
            self._api,
            "/programs/{programId}",
            path_params={
                "programId": program_id,
            },
            json_body=body,
            timeout=timeout,
        )
        return Program.model_validate(response.json())

    def get_dimensions(
        self,
        *,
        program_id: str,
        maxpagesize: Optional[int] = 1000,
        filter_: Optional[str] = None,
        order_by: Optional[str] = None,
        timeout: Optional[float] = None,
    ) -> DimensionsListResult:
        """Retrieve a list of dimensions

        Returns a paginated list of [dimensions](ref:sustainability#dimension).

        Args:
            program_id: The unique identifier of the program
            maxpagesize: The maximum number of results to retrieve
            filter_: The properties to filter the results by.
            order_by: One or more comma-separated expressions to indicate the order in which to sort the results.
            timeout: Override the default request timeout (seconds).

        Returns:
            DimensionsListResult

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 429, 500, 503).
        """

        def _fetch(_cursor: str | None) -> httpx.Response:
            return self._client.request(
                "GET",
                self._api,
                "/programs/{programId}/dimensions",
                path_params={
                    "programId": program_id,
                },
                query_params={
                    "$maxpagesize": maxpagesize,
                    "$filter": filter_,
                    "$orderBy": order_by,
                    "$next": _cursor,
                },
                timeout=timeout,
            )

        _body_result = paginate_all(_fetch, extract_next_link, "data")
        return DimensionsListResult.model_validate(_body_result)

    async def get_dimensions_async(
        self,
        *,
        program_id: str,
        maxpagesize: Optional[int] = 1000,
        filter_: Optional[str] = None,
        order_by: Optional[str] = None,
        timeout: Optional[float] = None,
    ) -> DimensionsListResult:
        """Retrieve a list of dimensions (async)

        Returns a paginated list of [dimensions](ref:sustainability#dimension).

        Args:
            program_id: The unique identifier of the program
            maxpagesize: The maximum number of results to retrieve
            filter_: The properties to filter the results by.
            order_by: One or more comma-separated expressions to indicate the order in which to sort the results.
            timeout: Override the default request timeout (seconds).

        Returns:
            DimensionsListResult

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 429, 500, 503).
        """

        async def _fetch(_cursor: str | None) -> httpx.Response:
            return await self._client.request_async(
                "GET",
                self._api,
                "/programs/{programId}/dimensions",
                path_params={
                    "programId": program_id,
                },
                query_params={
                    "$maxpagesize": maxpagesize,
                    "$filter": filter_,
                    "$orderBy": order_by,
                    "$next": _cursor,
                },
                timeout=timeout,
            )

        _body_result = await paginate_all_async(_fetch, extract_next_link, "data")
        return DimensionsListResult.model_validate(_body_result)

    def create_dimension(
        self,
        *,
        program_id: str,
        active: Optional[bool] = None,
        name: Optional[str] = None,
        values: Optional[list[DimensionValue]] = None,
        timeout: Optional[float] = None,
    ) -> Dimension:
        """Create a new dimension

        Creates a new [dimension](ref:sustainability#dimension).

        Args:
            program_id: The unique identifier of the program
            active: Indicates whether the dimension is available for use in new metrics
            name: The name of the dimension, representing a specific category or grouping.
            values: A list of values associated with this dimension, requiring at least one and limited to a maximum of 1500. This list is populated when retrieving an individual dimension and is null when listing dimensions.

            timeout: Override the default request timeout (seconds).

        Returns:
            Dimension

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 429, 500, 503).
        """
        _body: dict[str, Any] = {}
        if active is not None:
            _body["active"] = active
        if name is not None:
            _body["name"] = name
        if values is not None:
            _body["values"] = values
        response = self._client.request(
            "POST",
            self._api,
            "/programs/{programId}/dimensions",
            path_params={
                "programId": program_id,
            },
            json_body=_body or None,
            timeout=timeout,
        )
        return Dimension.model_validate(response.json())

    async def create_dimension_async(
        self,
        *,
        program_id: str,
        active: Optional[bool] = None,
        name: Optional[str] = None,
        values: Optional[list[DimensionValue]] = None,
        timeout: Optional[float] = None,
    ) -> Dimension:
        """Create a new dimension (async)

        Creates a new [dimension](ref:sustainability#dimension).

        Args:
            program_id: The unique identifier of the program
            active: Indicates whether the dimension is available for use in new metrics
            name: The name of the dimension, representing a specific category or grouping.
            values: A list of values associated with this dimension, requiring at least one and limited to a maximum of 1500. This list is populated when retrieving an individual dimension and is null when listing dimensions.

            timeout: Override the default request timeout (seconds).

        Returns:
            Dimension

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 429, 500, 503).
        """
        _body: dict[str, Any] = {}
        if active is not None:
            _body["active"] = active
        if name is not None:
            _body["name"] = name
        if values is not None:
            _body["values"] = values
        response = await self._client.request_async(
            "POST",
            self._api,
            "/programs/{programId}/dimensions",
            path_params={
                "programId": program_id,
            },
            json_body=_body or None,
            timeout=timeout,
        )
        return Dimension.model_validate(response.json())

    def get_dimension_by_id(
        self,
        *,
        program_id: str,
        dimension_id: str,
        timeout: Optional[float] = None,
    ) -> Dimension:
        """Retrieve a single dimension

        Retrieves a [dimension](ref:sustainability#dimension) given its ID

        Args:
            program_id: The unique identifier of the program
            dimension_id: The unique identifier of the dimension
            timeout: Override the default request timeout (seconds).

        Returns:
            Dimension

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 429, 500, 503).
        """
        response = self._client.request(
            "GET",
            self._api,
            "/programs/{programId}/dimensions/{dimensionId}",
            path_params={
                "programId": program_id,
                "dimensionId": dimension_id,
            },
            timeout=timeout,
        )
        return Dimension.model_validate(response.json())

    async def get_dimension_by_id_async(
        self,
        *,
        program_id: str,
        dimension_id: str,
        timeout: Optional[float] = None,
    ) -> Dimension:
        """Retrieve a single dimension (async)

        Retrieves a [dimension](ref:sustainability#dimension) given its ID

        Args:
            program_id: The unique identifier of the program
            dimension_id: The unique identifier of the dimension
            timeout: Override the default request timeout (seconds).

        Returns:
            Dimension

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 429, 500, 503).
        """
        response = await self._client.request_async(
            "GET",
            self._api,
            "/programs/{programId}/dimensions/{dimensionId}",
            path_params={
                "programId": program_id,
                "dimensionId": dimension_id,
            },
            timeout=timeout,
        )
        return Dimension.model_validate(response.json())

    def partially_update_dimension_by_id(
        self,
        *,
        program_id: str,
        dimension_id: str,
        body: list[Any],
        timeout: Optional[float] = None,
    ) -> Dimension:
        """Partially update a single dimension

        Partially updates the properties of a
        [dimension](ref:sustainability#dimension). Only one property may be
        updated at a time.
        ### Options
        |Path|PATCH Operations Supported|
        |---|---|
        |`/active`|`replace`, `test`|
        |`/name`|`replace`, `test`|
        |`/values`|`replace`, `test`|

        Args:
            program_id: The unique identifier of the program
            dimension_id: The unique identifier of the dimension
            body: Request body.
            timeout: Override the default request timeout (seconds).

        Returns:
            Dimension

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 429, 500, 503).
        """
        response = self._client.request(
            "PATCH",
            self._api,
            "/programs/{programId}/dimensions/{dimensionId}",
            path_params={
                "programId": program_id,
                "dimensionId": dimension_id,
            },
            json_body=body,
            timeout=timeout,
        )
        return Dimension.model_validate(response.json())

    async def partially_update_dimension_by_id_async(
        self,
        *,
        program_id: str,
        dimension_id: str,
        body: list[Any],
        timeout: Optional[float] = None,
    ) -> Dimension:
        """Partially update a single dimension (async)

        Partially updates the properties of a
        [dimension](ref:sustainability#dimension). Only one property may be
        updated at a time.
        ### Options
        |Path|PATCH Operations Supported|
        |---|---|
        |`/active`|`replace`, `test`|
        |`/name`|`replace`, `test`|
        |`/values`|`replace`, `test`|

        Args:
            program_id: The unique identifier of the program
            dimension_id: The unique identifier of the dimension
            body: Request body.
            timeout: Override the default request timeout (seconds).

        Returns:
            Dimension

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 429, 500, 503).
        """
        response = await self._client.request_async(
            "PATCH",
            self._api,
            "/programs/{programId}/dimensions/{dimensionId}",
            path_params={
                "programId": program_id,
                "dimensionId": dimension_id,
            },
            json_body=body,
            timeout=timeout,
        )
        return Dimension.model_validate(response.json())

    def get_metrics(
        self,
        *,
        program_id: str,
        maxpagesize: Optional[int] = 1000,
        order_by: Optional[str] = None,
        filter_: Optional[str] = None,
        timeout: Optional[float] = None,
    ) -> MetricsListResult:
        """Retrieve a list of metrics

        Returns a paginated list of [Metrics](ref:sustainability#metric).

        Args:
            program_id: The unique identifier of the program
            maxpagesize: The maximum number of results to retrieve
            order_by: One or more comma-separated expressions to indicate the order in which to sort the results.
            filter_: The properties to filter the results by.
            timeout: Override the default request timeout (seconds).

        Returns:
            MetricsListResult

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 429, 500, 503).
        """

        def _fetch(_cursor: str | None) -> httpx.Response:
            return self._client.request(
                "GET",
                self._api,
                "/programs/{programId}/metrics",
                path_params={
                    "programId": program_id,
                },
                query_params={
                    "$maxpagesize": maxpagesize,
                    "$orderBy": order_by,
                    "$filter": filter_,
                    "$next": _cursor,
                },
                timeout=timeout,
            )

        _body_result = paginate_all(_fetch, extract_next_link, "data")
        return MetricsListResult.model_validate(_body_result)

    async def get_metrics_async(
        self,
        *,
        program_id: str,
        maxpagesize: Optional[int] = 1000,
        order_by: Optional[str] = None,
        filter_: Optional[str] = None,
        timeout: Optional[float] = None,
    ) -> MetricsListResult:
        """Retrieve a list of metrics (async)

        Returns a paginated list of [Metrics](ref:sustainability#metric).

        Args:
            program_id: The unique identifier of the program
            maxpagesize: The maximum number of results to retrieve
            order_by: One or more comma-separated expressions to indicate the order in which to sort the results.
            filter_: The properties to filter the results by.
            timeout: Override the default request timeout (seconds).

        Returns:
            MetricsListResult

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 429, 500, 503).
        """

        async def _fetch(_cursor: str | None) -> httpx.Response:
            return await self._client.request_async(
                "GET",
                self._api,
                "/programs/{programId}/metrics",
                path_params={
                    "programId": program_id,
                },
                query_params={
                    "$maxpagesize": maxpagesize,
                    "$orderBy": order_by,
                    "$filter": filter_,
                    "$next": _cursor,
                },
                timeout=timeout,
            )

        _body_result = await paginate_all_async(_fetch, extract_next_link, "data")
        return MetricsListResult.model_validate(_body_result)

    def create_metric(
        self,
        *,
        program_id: str,
        allowed_dimensions: Optional[list[str]] = None,
        code: Optional[int] = None,
        data_type: Optional[Literal["text", "number", "date", "currency", "percent"]] = None,
        description: Optional[str] = None,
        framework_references: Optional[list[FrameworkReference]] = None,
        id_: Optional[str] = None,
        index: Optional[int] = None,
        name: Optional[str] = None,
        require_notes: Optional[bool] = None,
        require_supporting_attachments: Optional[bool] = None,
        tags: Optional[list[Tag]] = None,
        topic: Optional[str] = None,
        unit: Optional[str] = None,
        timeout: Optional[float] = None,
    ) -> Metric:
        """Create a new metric

                Creates a new [metric](ref:sustainability#metric).

                Args:
                    program_id: The unique identifier of the program
                    allowed_dimensions: A list of dimension ids that may be used when creating values for this metric.
                    code: An optional user-specified metric code as an integer greater than 0, unique to each metric.
        If not provided, the system assigns the next available integer.

                    data_type: Used to specify the type of data for a metric.
                    description: An optional description of the metric, explaining its purpose and main aspects, up to 32767 characters.
                    framework_references: A list of framework/standard references or other related content, up to 20 references.
                    id_: The unique UUID identifier of the metric.
                    index: The index in the outline. If unset, the metric will be ordered last.
                    name: The name of the metric, up to 300 characters.
                    require_notes: Indicates whether notes are required for this metric.
                    require_supporting_attachments: Indicates whether supporting attachments are required for this metric.
                    tags: A collection of tags associated with the metric. A metric can have up to 20 tags.
                    topic: The unique UUID identifier of the parent topic.
                    unit: The unit of measurement for the metric, up to 300 characters.
                    timeout: Override the default request timeout (seconds).

                Returns:
                    Metric

                Raises:
                    WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 429, 500, 503).
        """
        _body: dict[str, Any] = {}
        if allowed_dimensions is not None:
            _body["allowedDimensions"] = allowed_dimensions
        if code is not None:
            _body["code"] = code
        if data_type is not None:
            _body["dataType"] = data_type
        if description is not None:
            _body["description"] = description
        if framework_references is not None:
            _body["frameworkReferences"] = framework_references
        if id_ is not None:
            _body["id"] = id_
        if index is not None:
            _body["index"] = index
        if name is not None:
            _body["name"] = name
        if require_notes is not None:
            _body["requireNotes"] = require_notes
        if require_supporting_attachments is not None:
            _body["requireSupportingAttachments"] = require_supporting_attachments
        if tags is not None:
            _body["tags"] = tags
        if topic is not None:
            _body["topic"] = topic
        if unit is not None:
            _body["unit"] = unit
        response = self._client.request(
            "POST",
            self._api,
            "/programs/{programId}/metrics",
            path_params={
                "programId": program_id,
            },
            json_body=_body or None,
            timeout=timeout,
        )
        return Metric.model_validate(response.json())

    async def create_metric_async(
        self,
        *,
        program_id: str,
        allowed_dimensions: Optional[list[str]] = None,
        code: Optional[int] = None,
        data_type: Optional[Literal["text", "number", "date", "currency", "percent"]] = None,
        description: Optional[str] = None,
        framework_references: Optional[list[FrameworkReference]] = None,
        id_: Optional[str] = None,
        index: Optional[int] = None,
        name: Optional[str] = None,
        require_notes: Optional[bool] = None,
        require_supporting_attachments: Optional[bool] = None,
        tags: Optional[list[Tag]] = None,
        topic: Optional[str] = None,
        unit: Optional[str] = None,
        timeout: Optional[float] = None,
    ) -> Metric:
        """Create a new metric (async)

                Creates a new [metric](ref:sustainability#metric).

                Args:
                    program_id: The unique identifier of the program
                    allowed_dimensions: A list of dimension ids that may be used when creating values for this metric.
                    code: An optional user-specified metric code as an integer greater than 0, unique to each metric.
        If not provided, the system assigns the next available integer.

                    data_type: Used to specify the type of data for a metric.
                    description: An optional description of the metric, explaining its purpose and main aspects, up to 32767 characters.
                    framework_references: A list of framework/standard references or other related content, up to 20 references.
                    id_: The unique UUID identifier of the metric.
                    index: The index in the outline. If unset, the metric will be ordered last.
                    name: The name of the metric, up to 300 characters.
                    require_notes: Indicates whether notes are required for this metric.
                    require_supporting_attachments: Indicates whether supporting attachments are required for this metric.
                    tags: A collection of tags associated with the metric. A metric can have up to 20 tags.
                    topic: The unique UUID identifier of the parent topic.
                    unit: The unit of measurement for the metric, up to 300 characters.
                    timeout: Override the default request timeout (seconds).

                Returns:
                    Metric

                Raises:
                    WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 429, 500, 503).
        """
        _body: dict[str, Any] = {}
        if allowed_dimensions is not None:
            _body["allowedDimensions"] = allowed_dimensions
        if code is not None:
            _body["code"] = code
        if data_type is not None:
            _body["dataType"] = data_type
        if description is not None:
            _body["description"] = description
        if framework_references is not None:
            _body["frameworkReferences"] = framework_references
        if id_ is not None:
            _body["id"] = id_
        if index is not None:
            _body["index"] = index
        if name is not None:
            _body["name"] = name
        if require_notes is not None:
            _body["requireNotes"] = require_notes
        if require_supporting_attachments is not None:
            _body["requireSupportingAttachments"] = require_supporting_attachments
        if tags is not None:
            _body["tags"] = tags
        if topic is not None:
            _body["topic"] = topic
        if unit is not None:
            _body["unit"] = unit
        response = await self._client.request_async(
            "POST",
            self._api,
            "/programs/{programId}/metrics",
            path_params={
                "programId": program_id,
            },
            json_body=_body or None,
            timeout=timeout,
        )
        return Metric.model_validate(response.json())

    def delete_metric_by_id(
        self,
        *,
        program_id: str,
        metric_id: str,
        timeout: Optional[float] = None,
    ) -> httpx.Response:
        """Delete a single metric

        Deletes a [metric](ref:sustainability#metric) given its ID

        Args:
            program_id: The unique identifier of the program
            metric_id: The unique identifier of the metric
            timeout: Override the default request timeout (seconds).

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 429, 500, 503).
        """
        return self._client.request(
            "DELETE",
            self._api,
            "/programs/{programId}/metrics/{metricId}",
            path_params={
                "programId": program_id,
                "metricId": metric_id,
            },
            timeout=timeout,
        )

    async def delete_metric_by_id_async(
        self,
        *,
        program_id: str,
        metric_id: str,
        timeout: Optional[float] = None,
    ) -> httpx.Response:
        """Delete a single metric (async)

        Deletes a [metric](ref:sustainability#metric) given its ID

        Args:
            program_id: The unique identifier of the program
            metric_id: The unique identifier of the metric
            timeout: Override the default request timeout (seconds).

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 429, 500, 503).
        """
        return await self._client.request_async(
            "DELETE",
            self._api,
            "/programs/{programId}/metrics/{metricId}",
            path_params={
                "programId": program_id,
                "metricId": metric_id,
            },
            timeout=timeout,
        )

    def get_metric_by_id(
        self,
        *,
        program_id: str,
        metric_id: str,
        timeout: Optional[float] = None,
    ) -> Metric:
        """Retrieve a single metric

        Retrieves a [`Metric`](ref:sustainability#metric) given its ID

        Args:
            program_id: The unique identifier of the program
            metric_id: The unique identifier of the metric
            timeout: Override the default request timeout (seconds).

        Returns:
            Metric

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 429, 500, 503).
        """
        response = self._client.request(
            "GET",
            self._api,
            "/programs/{programId}/metrics/{metricId}",
            path_params={
                "programId": program_id,
                "metricId": metric_id,
            },
            timeout=timeout,
        )
        return Metric.model_validate(response.json())

    async def get_metric_by_id_async(
        self,
        *,
        program_id: str,
        metric_id: str,
        timeout: Optional[float] = None,
    ) -> Metric:
        """Retrieve a single metric (async)

        Retrieves a [`Metric`](ref:sustainability#metric) given its ID

        Args:
            program_id: The unique identifier of the program
            metric_id: The unique identifier of the metric
            timeout: Override the default request timeout (seconds).

        Returns:
            Metric

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 429, 500, 503).
        """
        response = await self._client.request_async(
            "GET",
            self._api,
            "/programs/{programId}/metrics/{metricId}",
            path_params={
                "programId": program_id,
                "metricId": metric_id,
            },
            timeout=timeout,
        )
        return Metric.model_validate(response.json())

    def partially_update_metric_by_id(
        self,
        *,
        program_id: str,
        metric_id: str,
        body: list[Any],
        timeout: Optional[float] = None,
    ) -> Metric:
        """Partially update a single metric

        Partially updates the properties of a
        [metric](ref:sustainability#metric). Only one property may be updated at
        a time.
        ### Options
        |Path|PATCH Operations Supported|
        |---|---|
        |`/datatype`|`replace`|
        |`/description`|`replace`, `test`|
        |`/index`|`replace`, `test`|
        |`/name`|`replace`, `test`|
        |`/requireNotes`|`replace`, `test`|
        |`/requireSupportingAttachments`|`replace`, `test`|
        |`/topic`|`replace`, `test`|
        |`/unit`|`replace`, `test`|

        Args:
            program_id: The unique identifier of the program
            metric_id: The unique identifier of the metric
            body: Request body.
            timeout: Override the default request timeout (seconds).

        Returns:
            Metric

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 429, 500, 503).
        """
        response = self._client.request(
            "PATCH",
            self._api,
            "/programs/{programId}/metrics/{metricId}",
            path_params={
                "programId": program_id,
                "metricId": metric_id,
            },
            json_body=body,
            timeout=timeout,
        )
        return Metric.model_validate(response.json())

    async def partially_update_metric_by_id_async(
        self,
        *,
        program_id: str,
        metric_id: str,
        body: list[Any],
        timeout: Optional[float] = None,
    ) -> Metric:
        """Partially update a single metric (async)

        Partially updates the properties of a
        [metric](ref:sustainability#metric). Only one property may be updated at
        a time.
        ### Options
        |Path|PATCH Operations Supported|
        |---|---|
        |`/datatype`|`replace`|
        |`/description`|`replace`, `test`|
        |`/index`|`replace`, `test`|
        |`/name`|`replace`, `test`|
        |`/requireNotes`|`replace`, `test`|
        |`/requireSupportingAttachments`|`replace`, `test`|
        |`/topic`|`replace`, `test`|
        |`/unit`|`replace`, `test`|

        Args:
            program_id: The unique identifier of the program
            metric_id: The unique identifier of the metric
            body: Request body.
            timeout: Override the default request timeout (seconds).

        Returns:
            Metric

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 429, 500, 503).
        """
        response = await self._client.request_async(
            "PATCH",
            self._api,
            "/programs/{programId}/metrics/{metricId}",
            path_params={
                "programId": program_id,
                "metricId": metric_id,
            },
            json_body=body,
            timeout=timeout,
        )
        return Metric.model_validate(response.json())

    def get_values(
        self,
        *,
        program_id: str,
        metric_id: str,
        maxpagesize: Optional[int] = 1000,
        filter_: Optional[str] = None,
        order_by: Optional[str] = None,
        timeout: Optional[float] = None,
    ) -> MetricValuesListResult:
        """Retrieve a list of metric values

        Returns a paginated list of [metric
        Values](ref:sustainability#metricvalue)

        Args:
            program_id: The unique identifier of the program
            metric_id: The unique identifier of the metric
            maxpagesize: The maximum number of results to retrieve
            filter_: The properties to filter the results by.
            order_by: One or more comma-separated expressions to indicate the order in which to sort the results.
            timeout: Override the default request timeout (seconds).

        Returns:
            MetricValuesListResult

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 429, 500, 503).
        """

        def _fetch(_cursor: str | None) -> httpx.Response:
            return self._client.request(
                "GET",
                self._api,
                "/programs/{programId}/metrics/{metricId}/values",
                path_params={
                    "programId": program_id,
                    "metricId": metric_id,
                },
                query_params={
                    "$maxpagesize": maxpagesize,
                    "$filter": filter_,
                    "$orderBy": order_by,
                    "$next": _cursor,
                },
                timeout=timeout,
            )

        _body_result = paginate_all(_fetch, extract_next_link, "data")
        return MetricValuesListResult.model_validate(_body_result)

    async def get_values_async(
        self,
        *,
        program_id: str,
        metric_id: str,
        maxpagesize: Optional[int] = 1000,
        filter_: Optional[str] = None,
        order_by: Optional[str] = None,
        timeout: Optional[float] = None,
    ) -> MetricValuesListResult:
        """Retrieve a list of metric values (async)

        Returns a paginated list of [metric
        Values](ref:sustainability#metricvalue)

        Args:
            program_id: The unique identifier of the program
            metric_id: The unique identifier of the metric
            maxpagesize: The maximum number of results to retrieve
            filter_: The properties to filter the results by.
            order_by: One or more comma-separated expressions to indicate the order in which to sort the results.
            timeout: Override the default request timeout (seconds).

        Returns:
            MetricValuesListResult

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 429, 500, 503).
        """

        async def _fetch(_cursor: str | None) -> httpx.Response:
            return await self._client.request_async(
                "GET",
                self._api,
                "/programs/{programId}/metrics/{metricId}/values",
                path_params={
                    "programId": program_id,
                    "metricId": metric_id,
                },
                query_params={
                    "$maxpagesize": maxpagesize,
                    "$filter": filter_,
                    "$orderBy": order_by,
                    "$next": _cursor,
                },
                timeout=timeout,
            )

        _body_result = await paginate_all_async(_fetch, extract_next_link, "data")
        return MetricValuesListResult.model_validate(_body_result)

    def create_value(
        self,
        *,
        program_id: str,
        metric_id: str,
        coordinates: Optional[dict[str, Any]] = None,
        data_source: Optional[dict[str, Any]] = None,
        fields_to_clear: Optional[list[str]] = None,
        id_: Optional[str] = None,
        notes: Optional[str] = None,
        reporting_period: Optional[dict[str, Any]] = None,
        status: Optional[
            Literal[
                "notStarted",
                "notSent",
                "inProgress",
                "sentForApproval",
                "returned",
                "complete",
                "error",
            ]
        ] = None,
        task: Optional[str] = None,
        value: Optional[str] = None,
        timeout: Optional[float] = None,
    ) -> MetricValue:
        """Create a new metric value

                Creates a new [metric value](ref:sustainability#metricvalue)

                Args:
                    program_id: The unique identifier of the program
                    metric_id: The unique identifier of the metric
                    coordinates: A mapping of dimension ids to dimension value ids for the value.
        The maximum number of key-value dimension pairs is limited to 3.

                    data_source: Represents the source of the value, which can be a Workiva spreadsheet or table cell or a Workiva document text region.
        Only one of the connection types can be specified.

                    fields_to_clear: List of fields to clear.
                    id_: The unique UUID identifier of the metric value.
                    notes: Optional notes for the value, with a maximum length of 32,767 characters.
                    reporting_period: Defines the reporting period for a value.
                    status: Represents the current status of a metric value.
        The status can only be set to `complete` if it's currently `notStarted`,
        and it can be reset to `notStarted` if it's `complete`.

                    task: The id of the task that corresponds to the metric value, which can be used to fetch the task/modify details via the tasking api
                    value: The string representation of the metric value. The value can be up to 32,767 characters.
                    timeout: Override the default request timeout (seconds).

                Returns:
                    MetricValue

                Raises:
                    WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 429, 500, 503).
        """
        _body: dict[str, Any] = {}
        if coordinates is not None:
            _body["coordinates"] = coordinates
        if data_source is not None:
            _body["dataSource"] = data_source
        if fields_to_clear is not None:
            _body["fieldsToClear"] = fields_to_clear
        if id_ is not None:
            _body["id"] = id_
        if notes is not None:
            _body["notes"] = notes
        if reporting_period is not None:
            _body["reportingPeriod"] = reporting_period
        if status is not None:
            _body["status"] = status
        if task is not None:
            _body["task"] = task
        if value is not None:
            _body["value"] = value
        response = self._client.request(
            "POST",
            self._api,
            "/programs/{programId}/metrics/{metricId}/values",
            path_params={
                "programId": program_id,
                "metricId": metric_id,
            },
            json_body=_body or None,
            timeout=timeout,
        )
        return MetricValue.model_validate(response.json())

    async def create_value_async(
        self,
        *,
        program_id: str,
        metric_id: str,
        coordinates: Optional[dict[str, Any]] = None,
        data_source: Optional[dict[str, Any]] = None,
        fields_to_clear: Optional[list[str]] = None,
        id_: Optional[str] = None,
        notes: Optional[str] = None,
        reporting_period: Optional[dict[str, Any]] = None,
        status: Optional[
            Literal[
                "notStarted",
                "notSent",
                "inProgress",
                "sentForApproval",
                "returned",
                "complete",
                "error",
            ]
        ] = None,
        task: Optional[str] = None,
        value: Optional[str] = None,
        timeout: Optional[float] = None,
    ) -> MetricValue:
        """Create a new metric value (async)

                Creates a new [metric value](ref:sustainability#metricvalue)

                Args:
                    program_id: The unique identifier of the program
                    metric_id: The unique identifier of the metric
                    coordinates: A mapping of dimension ids to dimension value ids for the value.
        The maximum number of key-value dimension pairs is limited to 3.

                    data_source: Represents the source of the value, which can be a Workiva spreadsheet or table cell or a Workiva document text region.
        Only one of the connection types can be specified.

                    fields_to_clear: List of fields to clear.
                    id_: The unique UUID identifier of the metric value.
                    notes: Optional notes for the value, with a maximum length of 32,767 characters.
                    reporting_period: Defines the reporting period for a value.
                    status: Represents the current status of a metric value.
        The status can only be set to `complete` if it's currently `notStarted`,
        and it can be reset to `notStarted` if it's `complete`.

                    task: The id of the task that corresponds to the metric value, which can be used to fetch the task/modify details via the tasking api
                    value: The string representation of the metric value. The value can be up to 32,767 characters.
                    timeout: Override the default request timeout (seconds).

                Returns:
                    MetricValue

                Raises:
                    WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 429, 500, 503).
        """
        _body: dict[str, Any] = {}
        if coordinates is not None:
            _body["coordinates"] = coordinates
        if data_source is not None:
            _body["dataSource"] = data_source
        if fields_to_clear is not None:
            _body["fieldsToClear"] = fields_to_clear
        if id_ is not None:
            _body["id"] = id_
        if notes is not None:
            _body["notes"] = notes
        if reporting_period is not None:
            _body["reportingPeriod"] = reporting_period
        if status is not None:
            _body["status"] = status
        if task is not None:
            _body["task"] = task
        if value is not None:
            _body["value"] = value
        response = await self._client.request_async(
            "POST",
            self._api,
            "/programs/{programId}/metrics/{metricId}/values",
            path_params={
                "programId": program_id,
                "metricId": metric_id,
            },
            json_body=_body or None,
            timeout=timeout,
        )
        return MetricValue.model_validate(response.json())

    def delete_metric_value_by_id(
        self,
        *,
        program_id: str,
        metric_id: str,
        metric_value_id: str,
        timeout: Optional[float] = None,
    ) -> httpx.Response:
        """Delete a single metric value

        Deletes a [metric value](ref:sustainability#metricvalue) value given its
        ID

        Args:
            program_id: The unique identifier of the program
            metric_id: The unique identifier of the metric
            metric_value_id: The unique identifier of the value
            timeout: Override the default request timeout (seconds).

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 429, 500, 503).
        """
        return self._client.request(
            "DELETE",
            self._api,
            "/programs/{programId}/metrics/{metricId}/values/{metricValueId}",
            path_params={
                "programId": program_id,
                "metricId": metric_id,
                "metricValueId": metric_value_id,
            },
            timeout=timeout,
        )

    async def delete_metric_value_by_id_async(
        self,
        *,
        program_id: str,
        metric_id: str,
        metric_value_id: str,
        timeout: Optional[float] = None,
    ) -> httpx.Response:
        """Delete a single metric value (async)

        Deletes a [metric value](ref:sustainability#metricvalue) value given its
        ID

        Args:
            program_id: The unique identifier of the program
            metric_id: The unique identifier of the metric
            metric_value_id: The unique identifier of the value
            timeout: Override the default request timeout (seconds).

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 429, 500, 503).
        """
        return await self._client.request_async(
            "DELETE",
            self._api,
            "/programs/{programId}/metrics/{metricId}/values/{metricValueId}",
            path_params={
                "programId": program_id,
                "metricId": metric_id,
                "metricValueId": metric_value_id,
            },
            timeout=timeout,
        )

    def get_metric_value_by_id(
        self,
        *,
        program_id: str,
        metric_id: str,
        metric_value_id: str,
        timeout: Optional[float] = None,
    ) -> MetricValue:
        """Retrieve a single metric value

        Retrieves a [metric value](ref:sustainability#metricvalue) value given
        its ID

        Args:
            program_id: The unique identifier of the program
            metric_id: The unique identifier of the metric
            metric_value_id: The unique identifier of the value
            timeout: Override the default request timeout (seconds).

        Returns:
            MetricValue

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 429, 500, 503).
        """
        response = self._client.request(
            "GET",
            self._api,
            "/programs/{programId}/metrics/{metricId}/values/{metricValueId}",
            path_params={
                "programId": program_id,
                "metricId": metric_id,
                "metricValueId": metric_value_id,
            },
            timeout=timeout,
        )
        return MetricValue.model_validate(response.json())

    async def get_metric_value_by_id_async(
        self,
        *,
        program_id: str,
        metric_id: str,
        metric_value_id: str,
        timeout: Optional[float] = None,
    ) -> MetricValue:
        """Retrieve a single metric value (async)

        Retrieves a [metric value](ref:sustainability#metricvalue) value given
        its ID

        Args:
            program_id: The unique identifier of the program
            metric_id: The unique identifier of the metric
            metric_value_id: The unique identifier of the value
            timeout: Override the default request timeout (seconds).

        Returns:
            MetricValue

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 429, 500, 503).
        """
        response = await self._client.request_async(
            "GET",
            self._api,
            "/programs/{programId}/metrics/{metricId}/values/{metricValueId}",
            path_params={
                "programId": program_id,
                "metricId": metric_id,
                "metricValueId": metric_value_id,
            },
            timeout=timeout,
        )
        return MetricValue.model_validate(response.json())

    def partially_update_metric_value_by_id(
        self,
        *,
        program_id: str,
        metric_id: str,
        metric_value_id: str,
        body: list[Any],
        timeout: Optional[float] = None,
    ) -> MetricValue:
        """Partially update a single metric value

        Partially updates the properties of a [metric
        value](ref:sustainability#metricvalue) value. Only one property may be
        updated at a time.
        ### Options
        |Path|PATCH Operations Supported|
        |---|---|
        |`/notes`|`replace`, `test`|
        |`/value`|`replace`, `test`|

        Args:
            program_id: The unique identifier of the program
            metric_id: The unique identifier of the metric
            metric_value_id: The unique identifier of the value
            body: Request body.
            timeout: Override the default request timeout (seconds).

        Returns:
            MetricValue

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 429, 500, 503).
        """
        response = self._client.request(
            "PATCH",
            self._api,
            "/programs/{programId}/metrics/{metricId}/values/{metricValueId}",
            path_params={
                "programId": program_id,
                "metricId": metric_id,
                "metricValueId": metric_value_id,
            },
            json_body=body,
            timeout=timeout,
        )
        return MetricValue.model_validate(response.json())

    async def partially_update_metric_value_by_id_async(
        self,
        *,
        program_id: str,
        metric_id: str,
        metric_value_id: str,
        body: list[Any],
        timeout: Optional[float] = None,
    ) -> MetricValue:
        """Partially update a single metric value (async)

        Partially updates the properties of a [metric
        value](ref:sustainability#metricvalue) value. Only one property may be
        updated at a time.
        ### Options
        |Path|PATCH Operations Supported|
        |---|---|
        |`/notes`|`replace`, `test`|
        |`/value`|`replace`, `test`|

        Args:
            program_id: The unique identifier of the program
            metric_id: The unique identifier of the metric
            metric_value_id: The unique identifier of the value
            body: Request body.
            timeout: Override the default request timeout (seconds).

        Returns:
            MetricValue

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 429, 500, 503).
        """
        response = await self._client.request_async(
            "PATCH",
            self._api,
            "/programs/{programId}/metrics/{metricId}/values/{metricValueId}",
            path_params={
                "programId": program_id,
                "metricId": metric_id,
                "metricValueId": metric_value_id,
            },
            json_body=body,
            timeout=timeout,
        )
        return MetricValue.model_validate(response.json())

    def batch_deletion_metric_values(
        self,
        *,
        program_id: str,
        metric_id: str,
        data: Optional[list[dict[str, Any]]] = None,
        timeout: Optional[float] = None,
    ) -> httpx.Response:
        """Initiate a batch deletion of metric values

        Batch delete the given metric values.

        For each value, provide either the id or both the reportingPeriod and
        coordinates (if any).
        If both are provided, the given id will be used.

        Args:
            program_id: The unique identifier of the program
            metric_id: The unique identifier of the metric
            data:
            timeout: Override the default request timeout (seconds).

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 429, 500, 503).
        """
        _body: dict[str, Any] = {}
        if data is not None:
            _body["data"] = data
        return self._client.request(
            "POST",
            self._api,
            "/programs/{programId}/metrics/{metricId}/values/batchDeletion",
            path_params={
                "programId": program_id,
                "metricId": metric_id,
            },
            json_body=_body or None,
            timeout=timeout,
        )

    async def batch_deletion_metric_values_async(
        self,
        *,
        program_id: str,
        metric_id: str,
        data: Optional[list[dict[str, Any]]] = None,
        timeout: Optional[float] = None,
    ) -> httpx.Response:
        """Initiate a batch deletion of metric values (async)

        Batch delete the given metric values.

        For each value, provide either the id or both the reportingPeriod and
        coordinates (if any).
        If both are provided, the given id will be used.

        Args:
            program_id: The unique identifier of the program
            metric_id: The unique identifier of the metric
            data:
            timeout: Override the default request timeout (seconds).

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 429, 500, 503).
        """
        _body: dict[str, Any] = {}
        if data is not None:
            _body["data"] = data
        return await self._client.request_async(
            "POST",
            self._api,
            "/programs/{programId}/metrics/{metricId}/values/batchDeletion",
            path_params={
                "programId": program_id,
                "metricId": metric_id,
            },
            json_body=_body or None,
            timeout=timeout,
        )

    def batch_upsertion_metric_values(
        self,
        *,
        program_id: str,
        metric_id: str,
        data: Optional[list[MetricValue]] = None,
        timeout: Optional[float] = None,
    ) -> httpx.Response:
        """Initiate a batch upsertion of metric values

        Batch upsert values for the given metric. The payload is limited to
        10MB; break it into multiple requests if necessary.

        For each value, provide either the id or both the reportingPeriod and
        coordinates (if any).
        If both are provided, the given id will be used.

        The API will validate the request and return a 202 Accepted status.
        However, the operation will be processed asynchronously, so the values
        may take some time to appear in the system.
        Poll the location provided in the Location header to check the status of
        the operation.

        If any of the values fail to be processed, no changes will be stored in
        the system.

        Args:
            program_id: The unique identifier of the program
            metric_id: The unique identifier of the metric
            data: An array of metric values, each representing a metric value data record belonging to a specific metric.
            timeout: Override the default request timeout (seconds).

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 429, 500, 503).

        Note:
            This is a long-running operation (HTTP 202). Use
            ``client.wait(response).result()`` to poll until completion.
        """
        _body: dict[str, Any] = {}
        if data is not None:
            _body["data"] = data
        return self._client.request(
            "POST",
            self._api,
            "/programs/{programId}/metrics/{metricId}/values/batchUpsertion",
            path_params={
                "programId": program_id,
                "metricId": metric_id,
            },
            json_body=_body or None,
            timeout=timeout,
        )

    async def batch_upsertion_metric_values_async(
        self,
        *,
        program_id: str,
        metric_id: str,
        data: Optional[list[MetricValue]] = None,
        timeout: Optional[float] = None,
    ) -> httpx.Response:
        """Initiate a batch upsertion of metric values (async)

        Batch upsert values for the given metric. The payload is limited to
        10MB; break it into multiple requests if necessary.

        For each value, provide either the id or both the reportingPeriod and
        coordinates (if any).
        If both are provided, the given id will be used.

        The API will validate the request and return a 202 Accepted status.
        However, the operation will be processed asynchronously, so the values
        may take some time to appear in the system.
        Poll the location provided in the Location header to check the status of
        the operation.

        If any of the values fail to be processed, no changes will be stored in
        the system.

        Args:
            program_id: The unique identifier of the program
            metric_id: The unique identifier of the metric
            data: An array of metric values, each representing a metric value data record belonging to a specific metric.
            timeout: Override the default request timeout (seconds).

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 429, 500, 503).

        Note:
            This is a long-running operation (HTTP 202). Use
            ``await client.wait(response).result_async()`` to poll until completion.
        """
        _body: dict[str, Any] = {}
        if data is not None:
            _body["data"] = data
        return await self._client.request_async(
            "POST",
            self._api,
            "/programs/{programId}/metrics/{metricId}/values/batchUpsertion",
            path_params={
                "programId": program_id,
                "metricId": metric_id,
            },
            json_body=_body or None,
            timeout=timeout,
        )

    def get_program_permissions(
        self,
        *,
        program_id: str,
        filter_: Optional[str] = None,
        maxpagesize: Optional[int] = 1000,
        timeout: Optional[float] = None,
    ) -> ResourcePermissionsListResult:
        """Retrieve permissions for a program

        Retrieves a paginated list of permissions for a given Sustainability
        Program

        Args:
            program_id: The unique identifier of the program
            filter_: The properties to filter the results by.
            maxpagesize: The maximum number of results to retrieve
            timeout: Override the default request timeout (seconds).

        Returns:
            ResourcePermissionsListResult

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 429, 500, 503).
        """

        def _fetch(_cursor: str | None) -> httpx.Response:
            return self._client.request(
                "GET",
                self._api,
                "/programs/{programId}/permissions",
                path_params={
                    "programId": program_id,
                },
                query_params={
                    "$filter": filter_,
                    "$maxpagesize": maxpagesize,
                    "$next": _cursor,
                },
                timeout=timeout,
            )

        _body_result = paginate_all(_fetch, extract_next_link, "data")
        return ResourcePermissionsListResult.model_validate(_body_result)

    async def get_program_permissions_async(
        self,
        *,
        program_id: str,
        filter_: Optional[str] = None,
        maxpagesize: Optional[int] = 1000,
        timeout: Optional[float] = None,
    ) -> ResourcePermissionsListResult:
        """Retrieve permissions for a program (async)

        Retrieves a paginated list of permissions for a given Sustainability
        Program

        Args:
            program_id: The unique identifier of the program
            filter_: The properties to filter the results by.
            maxpagesize: The maximum number of results to retrieve
            timeout: Override the default request timeout (seconds).

        Returns:
            ResourcePermissionsListResult

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 429, 500, 503).
        """

        async def _fetch(_cursor: str | None) -> httpx.Response:
            return await self._client.request_async(
                "GET",
                self._api,
                "/programs/{programId}/permissions",
                path_params={
                    "programId": program_id,
                },
                query_params={
                    "$filter": filter_,
                    "$maxpagesize": maxpagesize,
                    "$next": _cursor,
                },
                timeout=timeout,
            )

        _body_result = await paginate_all_async(_fetch, extract_next_link, "data")
        return ResourcePermissionsListResult.model_validate(_body_result)

    def program_permissions_modification(
        self,
        *,
        program_id: str,
        to_assign: Optional[list[ResourcePermission]] = None,
        to_revoke: Optional[list[ResourcePermission]] = None,
        timeout: Optional[float] = None,
    ) -> httpx.Response:
        """Modify permissions on a program

        Assign and/or revoke permissions on a Sustainability Program. If any
        modification in a request fails, all modifications on that request fail.
        <br /><br /> _To modify an existing permission, the existing permission
        must first be  explicitly revoked. Then, the new permission needs to be
        assigned. This  can be done in a single request by sending `toAssign`
        and `toRevoke` in  the request body._

        Args:
            program_id: The unique identifier of the program
            to_assign: The list of permissions to be assigned to the resource
            to_revoke: The list of permissions to be revoked from the resource
            timeout: Override the default request timeout (seconds).

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 429, 500, 503).
        """
        _body: dict[str, Any] = {}
        if to_assign is not None:
            _body["toAssign"] = to_assign
        if to_revoke is not None:
            _body["toRevoke"] = to_revoke
        return self._client.request(
            "POST",
            self._api,
            "/programs/{programId}/permissions/modification",
            path_params={
                "programId": program_id,
            },
            json_body=_body or None,
            timeout=timeout,
        )

    async def program_permissions_modification_async(
        self,
        *,
        program_id: str,
        to_assign: Optional[list[ResourcePermission]] = None,
        to_revoke: Optional[list[ResourcePermission]] = None,
        timeout: Optional[float] = None,
    ) -> httpx.Response:
        """Modify permissions on a program (async)

        Assign and/or revoke permissions on a Sustainability Program. If any
        modification in a request fails, all modifications on that request fail.
        <br /><br /> _To modify an existing permission, the existing permission
        must first be  explicitly revoked. Then, the new permission needs to be
        assigned. This  can be done in a single request by sending `toAssign`
        and `toRevoke` in  the request body._

        Args:
            program_id: The unique identifier of the program
            to_assign: The list of permissions to be assigned to the resource
            to_revoke: The list of permissions to be revoked from the resource
            timeout: Override the default request timeout (seconds).

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 429, 500, 503).
        """
        _body: dict[str, Any] = {}
        if to_assign is not None:
            _body["toAssign"] = to_assign
        if to_revoke is not None:
            _body["toRevoke"] = to_revoke
        return await self._client.request_async(
            "POST",
            self._api,
            "/programs/{programId}/permissions/modification",
            path_params={
                "programId": program_id,
            },
            json_body=_body or None,
            timeout=timeout,
        )

    def get_topics(
        self,
        *,
        program_id: str,
        maxpagesize: Optional[int] = 1000,
        filter_: Optional[str] = None,
        order_by: Optional[str] = None,
        timeout: Optional[float] = None,
    ) -> TopicsListResult:
        """Retrieve a list of topics

        Returns a paginated list of [topics](ref:sustainability#topic).

        Args:
            program_id: The unique identifier of the program
            maxpagesize: The maximum number of results to retrieve
            filter_: The properties to filter the results by.
            order_by: One or more comma-separated expressions to indicate the order in which to sort the results.
            timeout: Override the default request timeout (seconds).

        Returns:
            TopicsListResult

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 429, 500, 503).
        """

        def _fetch(_cursor: str | None) -> httpx.Response:
            return self._client.request(
                "GET",
                self._api,
                "/programs/{programId}/topics",
                path_params={
                    "programId": program_id,
                },
                query_params={
                    "$maxpagesize": maxpagesize,
                    "$filter": filter_,
                    "$orderBy": order_by,
                    "$next": _cursor,
                },
                timeout=timeout,
            )

        _body_result = paginate_all(_fetch, extract_next_link, "data")
        return TopicsListResult.model_validate(_body_result)

    async def get_topics_async(
        self,
        *,
        program_id: str,
        maxpagesize: Optional[int] = 1000,
        filter_: Optional[str] = None,
        order_by: Optional[str] = None,
        timeout: Optional[float] = None,
    ) -> TopicsListResult:
        """Retrieve a list of topics (async)

        Returns a paginated list of [topics](ref:sustainability#topic).

        Args:
            program_id: The unique identifier of the program
            maxpagesize: The maximum number of results to retrieve
            filter_: The properties to filter the results by.
            order_by: One or more comma-separated expressions to indicate the order in which to sort the results.
            timeout: Override the default request timeout (seconds).

        Returns:
            TopicsListResult

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 429, 500, 503).
        """

        async def _fetch(_cursor: str | None) -> httpx.Response:
            return await self._client.request_async(
                "GET",
                self._api,
                "/programs/{programId}/topics",
                path_params={
                    "programId": program_id,
                },
                query_params={
                    "$maxpagesize": maxpagesize,
                    "$filter": filter_,
                    "$orderBy": order_by,
                    "$next": _cursor,
                },
                timeout=timeout,
            )

        _body_result = await paginate_all_async(_fetch, extract_next_link, "data")
        return TopicsListResult.model_validate(_body_result)

    def create_topic(
        self,
        *,
        program_id: str,
        name: str,
        index: Optional[int] = None,
        parent: Optional[str] = None,
        timeout: Optional[float] = None,
    ) -> Topic:
        """Create a new topic

        Creates a new [topic](ref:sustainability#topic).

        Args:
            program_id: The unique identifier of the program
            name: The name of the topic, up to 300 characters.
            index: The index in the outline. If unset, the topic will be ordered last.
            parent: The unique UUID identifier of the parent topic, if this topic is a subtopic. This field can be null for top-level topics.
            timeout: Override the default request timeout (seconds).

        Returns:
            Topic

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 429, 500, 503).
        """
        _body: dict[str, Any] = {}
        if name is not None:
            _body["name"] = name
        if index is not None:
            _body["index"] = index
        if parent is not None:
            _body["parent"] = parent
        response = self._client.request(
            "POST",
            self._api,
            "/programs/{programId}/topics",
            path_params={
                "programId": program_id,
            },
            json_body=_body or None,
            timeout=timeout,
        )
        return Topic.model_validate(response.json())

    async def create_topic_async(
        self,
        *,
        program_id: str,
        name: str,
        index: Optional[int] = None,
        parent: Optional[str] = None,
        timeout: Optional[float] = None,
    ) -> Topic:
        """Create a new topic (async)

        Creates a new [topic](ref:sustainability#topic).

        Args:
            program_id: The unique identifier of the program
            name: The name of the topic, up to 300 characters.
            index: The index in the outline. If unset, the topic will be ordered last.
            parent: The unique UUID identifier of the parent topic, if this topic is a subtopic. This field can be null for top-level topics.
            timeout: Override the default request timeout (seconds).

        Returns:
            Topic

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 429, 500, 503).
        """
        _body: dict[str, Any] = {}
        if name is not None:
            _body["name"] = name
        if index is not None:
            _body["index"] = index
        if parent is not None:
            _body["parent"] = parent
        response = await self._client.request_async(
            "POST",
            self._api,
            "/programs/{programId}/topics",
            path_params={
                "programId": program_id,
            },
            json_body=_body or None,
            timeout=timeout,
        )
        return Topic.model_validate(response.json())

    def delete_topic_by_id(
        self,
        *,
        program_id: str,
        topic_id: str,
        timeout: Optional[float] = None,
    ) -> httpx.Response:
        """Delete a single topic

        Deletes a [topic](ref:sustainability#topic) given its ID

        Args:
            program_id: The unique identifier of the program
            topic_id: The unique identifier of the topic
            timeout: Override the default request timeout (seconds).

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 429, 500, 503).
        """
        return self._client.request(
            "DELETE",
            self._api,
            "/programs/{programId}/topics/{topicId}",
            path_params={
                "programId": program_id,
                "topicId": topic_id,
            },
            timeout=timeout,
        )

    async def delete_topic_by_id_async(
        self,
        *,
        program_id: str,
        topic_id: str,
        timeout: Optional[float] = None,
    ) -> httpx.Response:
        """Delete a single topic (async)

        Deletes a [topic](ref:sustainability#topic) given its ID

        Args:
            program_id: The unique identifier of the program
            topic_id: The unique identifier of the topic
            timeout: Override the default request timeout (seconds).

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 429, 500, 503).
        """
        return await self._client.request_async(
            "DELETE",
            self._api,
            "/programs/{programId}/topics/{topicId}",
            path_params={
                "programId": program_id,
                "topicId": topic_id,
            },
            timeout=timeout,
        )

    def get_topic_by_id(
        self,
        *,
        program_id: str,
        topic_id: str,
        timeout: Optional[float] = None,
    ) -> Topic:
        """Retrieve a single topic

        Retrieves a [topic](ref:sustainability#topic) given its ID

        Args:
            program_id: The unique identifier of the program
            topic_id: The unique identifier of the topic
            timeout: Override the default request timeout (seconds).

        Returns:
            Topic

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 429, 500, 503).
        """
        response = self._client.request(
            "GET",
            self._api,
            "/programs/{programId}/topics/{topicId}",
            path_params={
                "programId": program_id,
                "topicId": topic_id,
            },
            timeout=timeout,
        )
        return Topic.model_validate(response.json())

    async def get_topic_by_id_async(
        self,
        *,
        program_id: str,
        topic_id: str,
        timeout: Optional[float] = None,
    ) -> Topic:
        """Retrieve a single topic (async)

        Retrieves a [topic](ref:sustainability#topic) given its ID

        Args:
            program_id: The unique identifier of the program
            topic_id: The unique identifier of the topic
            timeout: Override the default request timeout (seconds).

        Returns:
            Topic

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 429, 500, 503).
        """
        response = await self._client.request_async(
            "GET",
            self._api,
            "/programs/{programId}/topics/{topicId}",
            path_params={
                "programId": program_id,
                "topicId": topic_id,
            },
            timeout=timeout,
        )
        return Topic.model_validate(response.json())

    def partially_update_topic_by_id(
        self,
        *,
        program_id: str,
        topic_id: str,
        body: list[Any],
        timeout: Optional[float] = None,
    ) -> Topic:
        """Partially update a single topic

        Partially updates the properties of a [topic](ref:sustainability#topic).
        Only one property may be updated at a time.
        ### Options
        |Path|PATCH Operations Supported|
        |---|---|
        |`/index`|`replace`, `test`|
        |`/name`|`replace`, `test`|
        |`/parent`|`replace`, `test`|

        Args:
            program_id: The unique identifier of the program
            topic_id: The unique identifier of the topic
            body: Request body.
            timeout: Override the default request timeout (seconds).

        Returns:
            Topic

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 429, 500, 503).
        """
        response = self._client.request(
            "PATCH",
            self._api,
            "/programs/{programId}/topics/{topicId}",
            path_params={
                "programId": program_id,
                "topicId": topic_id,
            },
            json_body=body,
            timeout=timeout,
        )
        return Topic.model_validate(response.json())

    async def partially_update_topic_by_id_async(
        self,
        *,
        program_id: str,
        topic_id: str,
        body: list[Any],
        timeout: Optional[float] = None,
    ) -> Topic:
        """Partially update a single topic (async)

        Partially updates the properties of a [topic](ref:sustainability#topic).
        Only one property may be updated at a time.
        ### Options
        |Path|PATCH Operations Supported|
        |---|---|
        |`/index`|`replace`, `test`|
        |`/name`|`replace`, `test`|
        |`/parent`|`replace`, `test`|

        Args:
            program_id: The unique identifier of the program
            topic_id: The unique identifier of the topic
            body: Request body.
            timeout: Override the default request timeout (seconds).

        Returns:
            Topic

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 429, 500, 503).
        """
        response = await self._client.request_async(
            "PATCH",
            self._api,
            "/programs/{programId}/topics/{topicId}",
            path_params={
                "programId": program_id,
                "topicId": topic_id,
            },
            json_body=body,
            timeout=timeout,
        )
        return Topic.model_validate(response.json())
