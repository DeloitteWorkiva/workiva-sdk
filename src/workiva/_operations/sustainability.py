"""Platform API â€” sustainability namespace.

Auto-generated by codegen. Do not edit manually.
"""

from __future__ import annotations

from typing import Any, Optional

import httpx

from workiva._constants import _API
from workiva._operations._base import BaseNamespace
from workiva.models.platform import (
    Dimension,
    Metric,
    MetricValue,
    MetricValueIdentifier,
    MetricValueUpsertion,
    Program,
    ResourcePermissionsModification,
    Topic,
)


class Sustainability(BaseNamespace):
    """Sustainability operations."""

    _api: _API = _API.PLATFORM

    def create_program(
        self,
        *,
        body: Program,
        timeout: Optional[float] = None,
    ) -> httpx.Response:
        """Create a new program

        Creates a new [program](ref:sustainability#program).
        """
        return self._client.request(
            "POST",
            self._api,
            "/programs",
            json_body=body,
            timeout=timeout,
        )

    async def create_program_async(
        self,
        *,
        body: Program,
        timeout: Optional[float] = None,
    ) -> httpx.Response:
        """Create a new program (async)

        Creates a new [program](ref:sustainability#program).
        """
        return await self._client.request_async(
            "POST",
            self._api,
            "/programs",
            json_body=body,
            timeout=timeout,
        )

    def get_programs(
        self,
        *,
        maxpagesize: Optional[int] = 1000,
        next_: Optional[str] = None,
        order_by: Optional[str] = None,
        filter_: Optional[str] = None,
        timeout: Optional[float] = None,
    ) -> httpx.Response:
        """Retrieve a list of programs

        Returns a paginated list of [programs](ref:sustainability#program).
        """
        return self._client.request(
            "GET",
            self._api,
            "/programs",
            query_params={
                "$maxpagesize": maxpagesize,
                "$next": next_,
                "$orderBy": order_by,
                "$filter": filter_,
            },
            timeout=timeout,
        )

    async def get_programs_async(
        self,
        *,
        maxpagesize: Optional[int] = 1000,
        next_: Optional[str] = None,
        order_by: Optional[str] = None,
        filter_: Optional[str] = None,
        timeout: Optional[float] = None,
    ) -> httpx.Response:
        """Retrieve a list of programs (async)

        Returns a paginated list of [programs](ref:sustainability#program).
        """
        return await self._client.request_async(
            "GET",
            self._api,
            "/programs",
            query_params={
                "$maxpagesize": maxpagesize,
                "$next": next_,
                "$orderBy": order_by,
                "$filter": filter_,
            },
            timeout=timeout,
        )

    def get_program_by_id(
        self,
        *,
        program_id: str,
        timeout: Optional[float] = None,
    ) -> httpx.Response:
        """Retrieve a single program

        Retrieves a [program](ref:sustainability#program) given its ID
        """
        return self._client.request(
            "GET",
            self._api,
            "/programs/{programId}",
            path_params={
                "programId": program_id,
            },
            timeout=timeout,
        )

    async def get_program_by_id_async(
        self,
        *,
        program_id: str,
        timeout: Optional[float] = None,
    ) -> httpx.Response:
        """Retrieve a single program (async)

        Retrieves a [program](ref:sustainability#program) given its ID
        """
        return await self._client.request_async(
            "GET",
            self._api,
            "/programs/{programId}",
            path_params={
                "programId": program_id,
            },
            timeout=timeout,
        )

    def partially_update_program_by_id(
        self,
        *,
        program_id: str,
        body: list[Any],
        timeout: Optional[float] = None,
    ) -> httpx.Response:
        """Partially update a single program

        Partially updates the properties of a
        [program](ref:sustainability#program). Only one property may be updated
        at a time.
        ### Options
        |Path|PATCH Operations Supported|
        |---|---|
        |`/name`|`replace`, `test`|
        """
        return self._client.request(
            "PATCH",
            self._api,
            "/programs/{programId}",
            path_params={
                "programId": program_id,
            },
            json_body=body,
            timeout=timeout,
        )

    async def partially_update_program_by_id_async(
        self,
        *,
        program_id: str,
        body: list[Any],
        timeout: Optional[float] = None,
    ) -> httpx.Response:
        """Partially update a single program (async)

        Partially updates the properties of a
        [program](ref:sustainability#program). Only one property may be updated
        at a time.
        ### Options
        |Path|PATCH Operations Supported|
        |---|---|
        |`/name`|`replace`, `test`|
        """
        return await self._client.request_async(
            "PATCH",
            self._api,
            "/programs/{programId}",
            path_params={
                "programId": program_id,
            },
            json_body=body,
            timeout=timeout,
        )

    def create_dimension(
        self,
        *,
        program_id: str,
        body: Dimension,
        timeout: Optional[float] = None,
    ) -> httpx.Response:
        """Create a new dimension

        Creates a new [dimension](ref:sustainability#dimension).
        """
        return self._client.request(
            "POST",
            self._api,
            "/programs/{programId}/dimensions",
            path_params={
                "programId": program_id,
            },
            json_body=body,
            timeout=timeout,
        )

    async def create_dimension_async(
        self,
        *,
        program_id: str,
        body: Dimension,
        timeout: Optional[float] = None,
    ) -> httpx.Response:
        """Create a new dimension (async)

        Creates a new [dimension](ref:sustainability#dimension).
        """
        return await self._client.request_async(
            "POST",
            self._api,
            "/programs/{programId}/dimensions",
            path_params={
                "programId": program_id,
            },
            json_body=body,
            timeout=timeout,
        )

    def get_dimensions(
        self,
        *,
        program_id: str,
        maxpagesize: Optional[int] = 1000,
        next_: Optional[str] = None,
        filter_: Optional[str] = None,
        order_by: Optional[str] = None,
        timeout: Optional[float] = None,
    ) -> httpx.Response:
        """Retrieve a list of dimensions

        Returns a paginated list of [dimensions](ref:sustainability#dimension).
        """
        return self._client.request(
            "GET",
            self._api,
            "/programs/{programId}/dimensions",
            path_params={
                "programId": program_id,
            },
            query_params={
                "$maxpagesize": maxpagesize,
                "$next": next_,
                "$filter": filter_,
                "$orderBy": order_by,
            },
            timeout=timeout,
        )

    async def get_dimensions_async(
        self,
        *,
        program_id: str,
        maxpagesize: Optional[int] = 1000,
        next_: Optional[str] = None,
        filter_: Optional[str] = None,
        order_by: Optional[str] = None,
        timeout: Optional[float] = None,
    ) -> httpx.Response:
        """Retrieve a list of dimensions (async)

        Returns a paginated list of [dimensions](ref:sustainability#dimension).
        """
        return await self._client.request_async(
            "GET",
            self._api,
            "/programs/{programId}/dimensions",
            path_params={
                "programId": program_id,
            },
            query_params={
                "$maxpagesize": maxpagesize,
                "$next": next_,
                "$filter": filter_,
                "$orderBy": order_by,
            },
            timeout=timeout,
        )

    def get_dimension_by_id(
        self,
        *,
        program_id: str,
        dimension_id: str,
        timeout: Optional[float] = None,
    ) -> httpx.Response:
        """Retrieve a single dimension

        Retrieves a [dimension](ref:sustainability#dimension) given its ID
        """
        return self._client.request(
            "GET",
            self._api,
            "/programs/{programId}/dimensions/{dimensionId}",
            path_params={
                "programId": program_id,
                "dimensionId": dimension_id,
            },
            timeout=timeout,
        )

    async def get_dimension_by_id_async(
        self,
        *,
        program_id: str,
        dimension_id: str,
        timeout: Optional[float] = None,
    ) -> httpx.Response:
        """Retrieve a single dimension (async)

        Retrieves a [dimension](ref:sustainability#dimension) given its ID
        """
        return await self._client.request_async(
            "GET",
            self._api,
            "/programs/{programId}/dimensions/{dimensionId}",
            path_params={
                "programId": program_id,
                "dimensionId": dimension_id,
            },
            timeout=timeout,
        )

    def partially_update_dimension_by_id(
        self,
        *,
        program_id: str,
        dimension_id: str,
        body: list[Any],
        timeout: Optional[float] = None,
    ) -> httpx.Response:
        """Partially update a single dimension

        Partially updates the properties of a
        [dimension](ref:sustainability#dimension). Only one property may be
        updated at a time.
        ### Options
        |Path|PATCH Operations Supported|
        |---|---|
        |`/active`|`replace`, `test`|
        |`/name`|`replace`, `test`|
        |`/values`|`replace`, `test`|
        """
        return self._client.request(
            "PATCH",
            self._api,
            "/programs/{programId}/dimensions/{dimensionId}",
            path_params={
                "programId": program_id,
                "dimensionId": dimension_id,
            },
            json_body=body,
            timeout=timeout,
        )

    async def partially_update_dimension_by_id_async(
        self,
        *,
        program_id: str,
        dimension_id: str,
        body: list[Any],
        timeout: Optional[float] = None,
    ) -> httpx.Response:
        """Partially update a single dimension (async)

        Partially updates the properties of a
        [dimension](ref:sustainability#dimension). Only one property may be
        updated at a time.
        ### Options
        |Path|PATCH Operations Supported|
        |---|---|
        |`/active`|`replace`, `test`|
        |`/name`|`replace`, `test`|
        |`/values`|`replace`, `test`|
        """
        return await self._client.request_async(
            "PATCH",
            self._api,
            "/programs/{programId}/dimensions/{dimensionId}",
            path_params={
                "programId": program_id,
                "dimensionId": dimension_id,
            },
            json_body=body,
            timeout=timeout,
        )

    def create_metric(
        self,
        *,
        program_id: str,
        body: Metric,
        timeout: Optional[float] = None,
    ) -> httpx.Response:
        """Create a new metric

        Creates a new [metric](ref:sustainability#metric).
        """
        return self._client.request(
            "POST",
            self._api,
            "/programs/{programId}/metrics",
            path_params={
                "programId": program_id,
            },
            json_body=body,
            timeout=timeout,
        )

    async def create_metric_async(
        self,
        *,
        program_id: str,
        body: Metric,
        timeout: Optional[float] = None,
    ) -> httpx.Response:
        """Create a new metric (async)

        Creates a new [metric](ref:sustainability#metric).
        """
        return await self._client.request_async(
            "POST",
            self._api,
            "/programs/{programId}/metrics",
            path_params={
                "programId": program_id,
            },
            json_body=body,
            timeout=timeout,
        )

    def get_metrics(
        self,
        *,
        program_id: str,
        maxpagesize: Optional[int] = 1000,
        next_: Optional[str] = None,
        order_by: Optional[str] = None,
        filter_: Optional[str] = None,
        timeout: Optional[float] = None,
    ) -> httpx.Response:
        """Retrieve a list of metrics

        Returns a paginated list of [Metrics](ref:sustainability#metric).
        """
        return self._client.request(
            "GET",
            self._api,
            "/programs/{programId}/metrics",
            path_params={
                "programId": program_id,
            },
            query_params={
                "$maxpagesize": maxpagesize,
                "$next": next_,
                "$orderBy": order_by,
                "$filter": filter_,
            },
            timeout=timeout,
        )

    async def get_metrics_async(
        self,
        *,
        program_id: str,
        maxpagesize: Optional[int] = 1000,
        next_: Optional[str] = None,
        order_by: Optional[str] = None,
        filter_: Optional[str] = None,
        timeout: Optional[float] = None,
    ) -> httpx.Response:
        """Retrieve a list of metrics (async)

        Returns a paginated list of [Metrics](ref:sustainability#metric).
        """
        return await self._client.request_async(
            "GET",
            self._api,
            "/programs/{programId}/metrics",
            path_params={
                "programId": program_id,
            },
            query_params={
                "$maxpagesize": maxpagesize,
                "$next": next_,
                "$orderBy": order_by,
                "$filter": filter_,
            },
            timeout=timeout,
        )

    def get_metric_by_id(
        self,
        *,
        program_id: str,
        metric_id: str,
        timeout: Optional[float] = None,
    ) -> httpx.Response:
        """Retrieve a single metric

        Retrieves a [`Metric`](ref:sustainability#metric) given its ID
        """
        return self._client.request(
            "GET",
            self._api,
            "/programs/{programId}/metrics/{metricId}",
            path_params={
                "programId": program_id,
                "metricId": metric_id,
            },
            timeout=timeout,
        )

    async def get_metric_by_id_async(
        self,
        *,
        program_id: str,
        metric_id: str,
        timeout: Optional[float] = None,
    ) -> httpx.Response:
        """Retrieve a single metric (async)

        Retrieves a [`Metric`](ref:sustainability#metric) given its ID
        """
        return await self._client.request_async(
            "GET",
            self._api,
            "/programs/{programId}/metrics/{metricId}",
            path_params={
                "programId": program_id,
                "metricId": metric_id,
            },
            timeout=timeout,
        )

    def delete_metric_by_id(
        self,
        *,
        program_id: str,
        metric_id: str,
        timeout: Optional[float] = None,
    ) -> httpx.Response:
        """Delete a single metric

        Deletes a [metric](ref:sustainability#metric) given its ID
        """
        return self._client.request(
            "DELETE",
            self._api,
            "/programs/{programId}/metrics/{metricId}",
            path_params={
                "programId": program_id,
                "metricId": metric_id,
            },
            timeout=timeout,
        )

    async def delete_metric_by_id_async(
        self,
        *,
        program_id: str,
        metric_id: str,
        timeout: Optional[float] = None,
    ) -> httpx.Response:
        """Delete a single metric (async)

        Deletes a [metric](ref:sustainability#metric) given its ID
        """
        return await self._client.request_async(
            "DELETE",
            self._api,
            "/programs/{programId}/metrics/{metricId}",
            path_params={
                "programId": program_id,
                "metricId": metric_id,
            },
            timeout=timeout,
        )

    def partially_update_metric_by_id(
        self,
        *,
        program_id: str,
        metric_id: str,
        body: list[Any],
        timeout: Optional[float] = None,
    ) -> httpx.Response:
        """Partially update a single metric

        Partially updates the properties of a
        [metric](ref:sustainability#metric). Only one property may be updated at
        a time.
        ### Options
        |Path|PATCH Operations Supported|
        |---|---|
        |`/datatype`|`replace`|
        |`/description`|`replace`, `test`|
        |`/index`|`replace`, `test`|
        |`/name`|`replace`, `test`|
        |`/requireNotes`|`replace`, `test`|
        |`/requireSupportingAttachments`|`replace`, `test`|
        |`/topic`|`replace`, `test`|
        |`/unit`|`replace`, `test`|
        """
        return self._client.request(
            "PATCH",
            self._api,
            "/programs/{programId}/metrics/{metricId}",
            path_params={
                "programId": program_id,
                "metricId": metric_id,
            },
            json_body=body,
            timeout=timeout,
        )

    async def partially_update_metric_by_id_async(
        self,
        *,
        program_id: str,
        metric_id: str,
        body: list[Any],
        timeout: Optional[float] = None,
    ) -> httpx.Response:
        """Partially update a single metric (async)

        Partially updates the properties of a
        [metric](ref:sustainability#metric). Only one property may be updated at
        a time.
        ### Options
        |Path|PATCH Operations Supported|
        |---|---|
        |`/datatype`|`replace`|
        |`/description`|`replace`, `test`|
        |`/index`|`replace`, `test`|
        |`/name`|`replace`, `test`|
        |`/requireNotes`|`replace`, `test`|
        |`/requireSupportingAttachments`|`replace`, `test`|
        |`/topic`|`replace`, `test`|
        |`/unit`|`replace`, `test`|
        """
        return await self._client.request_async(
            "PATCH",
            self._api,
            "/programs/{programId}/metrics/{metricId}",
            path_params={
                "programId": program_id,
                "metricId": metric_id,
            },
            json_body=body,
            timeout=timeout,
        )

    def create_value(
        self,
        *,
        program_id: str,
        metric_id: str,
        body: MetricValue,
        timeout: Optional[float] = None,
    ) -> httpx.Response:
        """Create a new metric value

        Creates a new [metric value](ref:sustainability#metricvalue)
        """
        return self._client.request(
            "POST",
            self._api,
            "/programs/{programId}/metrics/{metricId}/values",
            path_params={
                "programId": program_id,
                "metricId": metric_id,
            },
            json_body=body,
            timeout=timeout,
        )

    async def create_value_async(
        self,
        *,
        program_id: str,
        metric_id: str,
        body: MetricValue,
        timeout: Optional[float] = None,
    ) -> httpx.Response:
        """Create a new metric value (async)

        Creates a new [metric value](ref:sustainability#metricvalue)
        """
        return await self._client.request_async(
            "POST",
            self._api,
            "/programs/{programId}/metrics/{metricId}/values",
            path_params={
                "programId": program_id,
                "metricId": metric_id,
            },
            json_body=body,
            timeout=timeout,
        )

    def get_values(
        self,
        *,
        program_id: str,
        metric_id: str,
        maxpagesize: Optional[int] = 1000,
        next_: Optional[str] = None,
        filter_: Optional[str] = None,
        order_by: Optional[str] = None,
        timeout: Optional[float] = None,
    ) -> httpx.Response:
        """Retrieve a list of metric values

        Returns a paginated list of [metric
        Values](ref:sustainability#metricvalue)
        """
        return self._client.request(
            "GET",
            self._api,
            "/programs/{programId}/metrics/{metricId}/values",
            path_params={
                "programId": program_id,
                "metricId": metric_id,
            },
            query_params={
                "$maxpagesize": maxpagesize,
                "$next": next_,
                "$filter": filter_,
                "$orderBy": order_by,
            },
            timeout=timeout,
        )

    async def get_values_async(
        self,
        *,
        program_id: str,
        metric_id: str,
        maxpagesize: Optional[int] = 1000,
        next_: Optional[str] = None,
        filter_: Optional[str] = None,
        order_by: Optional[str] = None,
        timeout: Optional[float] = None,
    ) -> httpx.Response:
        """Retrieve a list of metric values (async)

        Returns a paginated list of [metric
        Values](ref:sustainability#metricvalue)
        """
        return await self._client.request_async(
            "GET",
            self._api,
            "/programs/{programId}/metrics/{metricId}/values",
            path_params={
                "programId": program_id,
                "metricId": metric_id,
            },
            query_params={
                "$maxpagesize": maxpagesize,
                "$next": next_,
                "$filter": filter_,
                "$orderBy": order_by,
            },
            timeout=timeout,
        )

    def get_metric_value_by_id(
        self,
        *,
        program_id: str,
        metric_id: str,
        metric_value_id: str,
        timeout: Optional[float] = None,
    ) -> httpx.Response:
        """Retrieve a single metric value

        Retrieves a [metric value](ref:sustainability#metricvalue) value given
        its ID
        """
        return self._client.request(
            "GET",
            self._api,
            "/programs/{programId}/metrics/{metricId}/values/{metricValueId}",
            path_params={
                "programId": program_id,
                "metricId": metric_id,
                "metricValueId": metric_value_id,
            },
            timeout=timeout,
        )

    async def get_metric_value_by_id_async(
        self,
        *,
        program_id: str,
        metric_id: str,
        metric_value_id: str,
        timeout: Optional[float] = None,
    ) -> httpx.Response:
        """Retrieve a single metric value (async)

        Retrieves a [metric value](ref:sustainability#metricvalue) value given
        its ID
        """
        return await self._client.request_async(
            "GET",
            self._api,
            "/programs/{programId}/metrics/{metricId}/values/{metricValueId}",
            path_params={
                "programId": program_id,
                "metricId": metric_id,
                "metricValueId": metric_value_id,
            },
            timeout=timeout,
        )

    def delete_metric_value_by_id(
        self,
        *,
        program_id: str,
        metric_id: str,
        metric_value_id: str,
        timeout: Optional[float] = None,
    ) -> httpx.Response:
        """Delete a single metric value

        Deletes a [metric value](ref:sustainability#metricvalue) value given its
        ID
        """
        return self._client.request(
            "DELETE",
            self._api,
            "/programs/{programId}/metrics/{metricId}/values/{metricValueId}",
            path_params={
                "programId": program_id,
                "metricId": metric_id,
                "metricValueId": metric_value_id,
            },
            timeout=timeout,
        )

    async def delete_metric_value_by_id_async(
        self,
        *,
        program_id: str,
        metric_id: str,
        metric_value_id: str,
        timeout: Optional[float] = None,
    ) -> httpx.Response:
        """Delete a single metric value (async)

        Deletes a [metric value](ref:sustainability#metricvalue) value given its
        ID
        """
        return await self._client.request_async(
            "DELETE",
            self._api,
            "/programs/{programId}/metrics/{metricId}/values/{metricValueId}",
            path_params={
                "programId": program_id,
                "metricId": metric_id,
                "metricValueId": metric_value_id,
            },
            timeout=timeout,
        )

    def partially_update_metric_value_by_id(
        self,
        *,
        program_id: str,
        metric_id: str,
        metric_value_id: str,
        body: list[Any],
        timeout: Optional[float] = None,
    ) -> httpx.Response:
        """Partially update a single metric value

        Partially updates the properties of a [metric
        value](ref:sustainability#metricvalue) value. Only one property may be
        updated at a time.
        ### Options
        |Path|PATCH Operations Supported|
        |---|---|
        |`/notes`|`replace`, `test`|
        |`/value`|`replace`, `test`|
        """
        return self._client.request(
            "PATCH",
            self._api,
            "/programs/{programId}/metrics/{metricId}/values/{metricValueId}",
            path_params={
                "programId": program_id,
                "metricId": metric_id,
                "metricValueId": metric_value_id,
            },
            json_body=body,
            timeout=timeout,
        )

    async def partially_update_metric_value_by_id_async(
        self,
        *,
        program_id: str,
        metric_id: str,
        metric_value_id: str,
        body: list[Any],
        timeout: Optional[float] = None,
    ) -> httpx.Response:
        """Partially update a single metric value (async)

        Partially updates the properties of a [metric
        value](ref:sustainability#metricvalue) value. Only one property may be
        updated at a time.
        ### Options
        |Path|PATCH Operations Supported|
        |---|---|
        |`/notes`|`replace`, `test`|
        |`/value`|`replace`, `test`|
        """
        return await self._client.request_async(
            "PATCH",
            self._api,
            "/programs/{programId}/metrics/{metricId}/values/{metricValueId}",
            path_params={
                "programId": program_id,
                "metricId": metric_id,
                "metricValueId": metric_value_id,
            },
            json_body=body,
            timeout=timeout,
        )

    def batch_deletion_metric_values(
        self,
        *,
        program_id: str,
        metric_id: str,
        body: MetricValueIdentifier,
        timeout: Optional[float] = None,
    ) -> httpx.Response:
        """Initiate a batch deletion of metric values

        Batch delete the given metric values.

        For each value, provide either the id or both the reportingPeriod and
        coordinates (if any).
        If both are provided, the given id will be used.
        """
        return self._client.request(
            "POST",
            self._api,
            "/programs/{programId}/metrics/{metricId}/values/batchDeletion",
            path_params={
                "programId": program_id,
                "metricId": metric_id,
            },
            json_body=body,
            timeout=timeout,
        )

    async def batch_deletion_metric_values_async(
        self,
        *,
        program_id: str,
        metric_id: str,
        body: MetricValueIdentifier,
        timeout: Optional[float] = None,
    ) -> httpx.Response:
        """Initiate a batch deletion of metric values (async)

        Batch delete the given metric values.

        For each value, provide either the id or both the reportingPeriod and
        coordinates (if any).
        If both are provided, the given id will be used.
        """
        return await self._client.request_async(
            "POST",
            self._api,
            "/programs/{programId}/metrics/{metricId}/values/batchDeletion",
            path_params={
                "programId": program_id,
                "metricId": metric_id,
            },
            json_body=body,
            timeout=timeout,
        )

    def batch_upsertion_metric_values(
        self,
        *,
        program_id: str,
        metric_id: str,
        body: MetricValueUpsertion,
        timeout: Optional[float] = None,
    ) -> httpx.Response:
        """Initiate a batch upsertion of metric values

        Batch upsert values for the given metric. The payload is limited to
        10MB; break it into multiple requests if necessary.

        For each value, provide either the id or both the reportingPeriod and
        coordinates (if any).
        If both are provided, the given id will be used.

        The API will validate the request and return a 202 Accepted status.
        However, the operation will be processed asynchronously, so the values
        may take some time to appear in the system.
        Poll the location provided in the Location header to check the status of
        the operation.

        If any of the values fail to be processed, no changes will be stored in
        the system.
        """
        return self._client.request(
            "POST",
            self._api,
            "/programs/{programId}/metrics/{metricId}/values/batchUpsertion",
            path_params={
                "programId": program_id,
                "metricId": metric_id,
            },
            json_body=body,
            timeout=timeout,
        )

    async def batch_upsertion_metric_values_async(
        self,
        *,
        program_id: str,
        metric_id: str,
        body: MetricValueUpsertion,
        timeout: Optional[float] = None,
    ) -> httpx.Response:
        """Initiate a batch upsertion of metric values (async)

        Batch upsert values for the given metric. The payload is limited to
        10MB; break it into multiple requests if necessary.

        For each value, provide either the id or both the reportingPeriod and
        coordinates (if any).
        If both are provided, the given id will be used.

        The API will validate the request and return a 202 Accepted status.
        However, the operation will be processed asynchronously, so the values
        may take some time to appear in the system.
        Poll the location provided in the Location header to check the status of
        the operation.

        If any of the values fail to be processed, no changes will be stored in
        the system.
        """
        return await self._client.request_async(
            "POST",
            self._api,
            "/programs/{programId}/metrics/{metricId}/values/batchUpsertion",
            path_params={
                "programId": program_id,
                "metricId": metric_id,
            },
            json_body=body,
            timeout=timeout,
        )

    def get_program_permissions(
        self,
        *,
        program_id: str,
        filter_: Optional[str] = None,
        maxpagesize: Optional[int] = 1000,
        next_: Optional[str] = None,
        timeout: Optional[float] = None,
    ) -> httpx.Response:
        """Retrieve permissions for a program

        Retrieves a paginated list of permissions for a given Sustainability
        Program
        """
        return self._client.request(
            "GET",
            self._api,
            "/programs/{programId}/permissions",
            path_params={
                "programId": program_id,
            },
            query_params={
                "$filter": filter_,
                "$maxpagesize": maxpagesize,
                "$next": next_,
            },
            timeout=timeout,
        )

    async def get_program_permissions_async(
        self,
        *,
        program_id: str,
        filter_: Optional[str] = None,
        maxpagesize: Optional[int] = 1000,
        next_: Optional[str] = None,
        timeout: Optional[float] = None,
    ) -> httpx.Response:
        """Retrieve permissions for a program (async)

        Retrieves a paginated list of permissions for a given Sustainability
        Program
        """
        return await self._client.request_async(
            "GET",
            self._api,
            "/programs/{programId}/permissions",
            path_params={
                "programId": program_id,
            },
            query_params={
                "$filter": filter_,
                "$maxpagesize": maxpagesize,
                "$next": next_,
            },
            timeout=timeout,
        )

    def program_permissions_modification(
        self,
        *,
        program_id: str,
        body: ResourcePermissionsModification,
        timeout: Optional[float] = None,
    ) -> httpx.Response:
        """Modify permissions on a program

        Assign and/or revoke permissions on a Sustainability Program. If any
        modification in a request fails, all modifications on that request fail.
        <br /><br /> _To modify an existing permission, the existing permission
        must first be  explicitly revoked. Then, the new permission needs to be
        assigned. This  can be done in a single request by sending `toAssign`
        and `toRevoke` in  the request body._
        """
        return self._client.request(
            "POST",
            self._api,
            "/programs/{programId}/permissions/modification",
            path_params={
                "programId": program_id,
            },
            json_body=body,
            timeout=timeout,
        )

    async def program_permissions_modification_async(
        self,
        *,
        program_id: str,
        body: ResourcePermissionsModification,
        timeout: Optional[float] = None,
    ) -> httpx.Response:
        """Modify permissions on a program (async)

        Assign and/or revoke permissions on a Sustainability Program. If any
        modification in a request fails, all modifications on that request fail.
        <br /><br /> _To modify an existing permission, the existing permission
        must first be  explicitly revoked. Then, the new permission needs to be
        assigned. This  can be done in a single request by sending `toAssign`
        and `toRevoke` in  the request body._
        """
        return await self._client.request_async(
            "POST",
            self._api,
            "/programs/{programId}/permissions/modification",
            path_params={
                "programId": program_id,
            },
            json_body=body,
            timeout=timeout,
        )

    def create_topic(
        self,
        *,
        program_id: str,
        body: Topic,
        timeout: Optional[float] = None,
    ) -> httpx.Response:
        """Create a new topic

        Creates a new [topic](ref:sustainability#topic).
        """
        return self._client.request(
            "POST",
            self._api,
            "/programs/{programId}/topics",
            path_params={
                "programId": program_id,
            },
            json_body=body,
            timeout=timeout,
        )

    async def create_topic_async(
        self,
        *,
        program_id: str,
        body: Topic,
        timeout: Optional[float] = None,
    ) -> httpx.Response:
        """Create a new topic (async)

        Creates a new [topic](ref:sustainability#topic).
        """
        return await self._client.request_async(
            "POST",
            self._api,
            "/programs/{programId}/topics",
            path_params={
                "programId": program_id,
            },
            json_body=body,
            timeout=timeout,
        )

    def get_topics(
        self,
        *,
        program_id: str,
        maxpagesize: Optional[int] = 1000,
        next_: Optional[str] = None,
        filter_: Optional[str] = None,
        order_by: Optional[str] = None,
        timeout: Optional[float] = None,
    ) -> httpx.Response:
        """Retrieve a list of topics

        Returns a paginated list of [topics](ref:sustainability#topic).
        """
        return self._client.request(
            "GET",
            self._api,
            "/programs/{programId}/topics",
            path_params={
                "programId": program_id,
            },
            query_params={
                "$maxpagesize": maxpagesize,
                "$next": next_,
                "$filter": filter_,
                "$orderBy": order_by,
            },
            timeout=timeout,
        )

    async def get_topics_async(
        self,
        *,
        program_id: str,
        maxpagesize: Optional[int] = 1000,
        next_: Optional[str] = None,
        filter_: Optional[str] = None,
        order_by: Optional[str] = None,
        timeout: Optional[float] = None,
    ) -> httpx.Response:
        """Retrieve a list of topics (async)

        Returns a paginated list of [topics](ref:sustainability#topic).
        """
        return await self._client.request_async(
            "GET",
            self._api,
            "/programs/{programId}/topics",
            path_params={
                "programId": program_id,
            },
            query_params={
                "$maxpagesize": maxpagesize,
                "$next": next_,
                "$filter": filter_,
                "$orderBy": order_by,
            },
            timeout=timeout,
        )

    def get_topic_by_id(
        self,
        *,
        program_id: str,
        topic_id: str,
        timeout: Optional[float] = None,
    ) -> httpx.Response:
        """Retrieve a single topic

        Retrieves a [topic](ref:sustainability#topic) given its ID
        """
        return self._client.request(
            "GET",
            self._api,
            "/programs/{programId}/topics/{topicId}",
            path_params={
                "programId": program_id,
                "topicId": topic_id,
            },
            timeout=timeout,
        )

    async def get_topic_by_id_async(
        self,
        *,
        program_id: str,
        topic_id: str,
        timeout: Optional[float] = None,
    ) -> httpx.Response:
        """Retrieve a single topic (async)

        Retrieves a [topic](ref:sustainability#topic) given its ID
        """
        return await self._client.request_async(
            "GET",
            self._api,
            "/programs/{programId}/topics/{topicId}",
            path_params={
                "programId": program_id,
                "topicId": topic_id,
            },
            timeout=timeout,
        )

    def delete_topic_by_id(
        self,
        *,
        program_id: str,
        topic_id: str,
        timeout: Optional[float] = None,
    ) -> httpx.Response:
        """Delete a single topic

        Deletes a [topic](ref:sustainability#topic) given its ID
        """
        return self._client.request(
            "DELETE",
            self._api,
            "/programs/{programId}/topics/{topicId}",
            path_params={
                "programId": program_id,
                "topicId": topic_id,
            },
            timeout=timeout,
        )

    async def delete_topic_by_id_async(
        self,
        *,
        program_id: str,
        topic_id: str,
        timeout: Optional[float] = None,
    ) -> httpx.Response:
        """Delete a single topic (async)

        Deletes a [topic](ref:sustainability#topic) given its ID
        """
        return await self._client.request_async(
            "DELETE",
            self._api,
            "/programs/{programId}/topics/{topicId}",
            path_params={
                "programId": program_id,
                "topicId": topic_id,
            },
            timeout=timeout,
        )

    def partially_update_topic_by_id(
        self,
        *,
        program_id: str,
        topic_id: str,
        body: list[Any],
        timeout: Optional[float] = None,
    ) -> httpx.Response:
        """Partially update a single topic

        Partially updates the properties of a [topic](ref:sustainability#topic).
        Only one property may be updated at a time.
        ### Options
        |Path|PATCH Operations Supported|
        |---|---|
        |`/index`|`replace`, `test`|
        |`/name`|`replace`, `test`|
        |`/parent`|`replace`, `test`|
        """
        return self._client.request(
            "PATCH",
            self._api,
            "/programs/{programId}/topics/{topicId}",
            path_params={
                "programId": program_id,
                "topicId": topic_id,
            },
            json_body=body,
            timeout=timeout,
        )

    async def partially_update_topic_by_id_async(
        self,
        *,
        program_id: str,
        topic_id: str,
        body: list[Any],
        timeout: Optional[float] = None,
    ) -> httpx.Response:
        """Partially update a single topic (async)

        Partially updates the properties of a [topic](ref:sustainability#topic).
        Only one property may be updated at a time.
        ### Options
        |Path|PATCH Operations Supported|
        |---|---|
        |`/index`|`replace`, `test`|
        |`/name`|`replace`, `test`|
        |`/parent`|`replace`, `test`|
        """
        return await self._client.request_async(
            "PATCH",
            self._api,
            "/programs/{programId}/topics/{topicId}",
            path_params={
                "programId": program_id,
                "topicId": topic_id,
            },
            json_body=body,
            timeout=timeout,
        )
