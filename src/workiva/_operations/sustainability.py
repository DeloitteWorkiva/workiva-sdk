"""Platform API â€” sustainability namespace.

Auto-generated by codegen. Do not edit manually.
"""

from __future__ import annotations

from typing import Any, Optional

import httpx

from workiva._constants import _API
from workiva._operations._base import BaseNamespace
from workiva._pagination import (
    extract_next_link,
    paginate_all,
    paginate_all_async,
)
from workiva.models.platform import (
    Dimension,
    DimensionsListResult,
    Metric,
    MetricsListResult,
    MetricValue,
    MetricValueIdentifier,
    MetricValuesListResult,
    MetricValueUpsertion,
    Program,
    ProgramsListResult,
    ResourcePermissionsListResult,
    ResourcePermissionsModification,
    Topic,
    TopicsListResult,
)

__all__ = ["Sustainability"]


class Sustainability(BaseNamespace):
    """Sustainability operations."""

    _api: _API = _API.PLATFORM

    def get_programs(
        self,
        *,
        maxpagesize: Optional[int] = 1000,
        order_by: Optional[str] = None,
        filter_: Optional[str] = None,
        timeout: Optional[float] = None,
    ) -> ProgramsListResult:
        """Retrieve a list of programs

        Returns a paginated list of [programs](ref:sustainability#program).

        Args:
            maxpagesize: The maximum number of results to retrieve
            order_by: One or more comma-separated expressions to indicate the order in which to sort the results.
            filter_: The properties to filter the results by.
            timeout: Override the default request timeout (seconds).

        Returns:
            ProgramsListResult

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 429, 500, 503).
        """

        def _fetch(_cursor: str | None) -> httpx.Response:
            return self._client.request(
                "GET",
                self._api,
                "/programs",
                query_params={
                    "$maxpagesize": maxpagesize,
                    "$orderBy": order_by,
                    "$filter": filter_,
                    "$next": _cursor,
                },
                timeout=timeout,
            )

        _body = paginate_all(_fetch, extract_next_link, "data")
        return ProgramsListResult.model_validate(_body)

    async def get_programs_async(
        self,
        *,
        maxpagesize: Optional[int] = 1000,
        order_by: Optional[str] = None,
        filter_: Optional[str] = None,
        timeout: Optional[float] = None,
    ) -> ProgramsListResult:
        """Retrieve a list of programs (async)

        Returns a paginated list of [programs](ref:sustainability#program).

        Args:
            maxpagesize: The maximum number of results to retrieve
            order_by: One or more comma-separated expressions to indicate the order in which to sort the results.
            filter_: The properties to filter the results by.
            timeout: Override the default request timeout (seconds).

        Returns:
            ProgramsListResult

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 429, 500, 503).
        """

        async def _fetch(_cursor: str | None) -> httpx.Response:
            return await self._client.request_async(
                "GET",
                self._api,
                "/programs",
                query_params={
                    "$maxpagesize": maxpagesize,
                    "$orderBy": order_by,
                    "$filter": filter_,
                    "$next": _cursor,
                },
                timeout=timeout,
            )

        _body = await paginate_all_async(_fetch, extract_next_link, "data")
        return ProgramsListResult.model_validate(_body)

    def create_program(
        self,
        *,
        body: Program,
        timeout: Optional[float] = None,
    ) -> Program:
        """Create a new program

        Creates a new [program](ref:sustainability#program).

        Returns:
            Program

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 429, 500, 503).
        """
        response = self._client.request(
            "POST",
            self._api,
            "/programs",
            json_body=body,
            timeout=timeout,
        )
        return Program.model_validate(response.json())

    async def create_program_async(
        self,
        *,
        body: Program,
        timeout: Optional[float] = None,
    ) -> Program:
        """Create a new program (async)

        Creates a new [program](ref:sustainability#program).

        Returns:
            Program

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 429, 500, 503).
        """
        response = await self._client.request_async(
            "POST",
            self._api,
            "/programs",
            json_body=body,
            timeout=timeout,
        )
        return Program.model_validate(response.json())

    def partially_update_program_by_id(
        self,
        *,
        program_id: str,
        body: list[Any],
        timeout: Optional[float] = None,
    ) -> Program:
        """Partially update a single program

        Partially updates the properties of a
        [program](ref:sustainability#program). Only one property may be updated
        at a time.
        ### Options
        |Path|PATCH Operations Supported|
        |---|---|
        |`/name`|`replace`, `test`|

        Args:
            program_id: The unique identifier of the program
            body: Request body.
            timeout: Override the default request timeout (seconds).

        Returns:
            Program

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 429, 500, 503).
        """
        response = self._client.request(
            "PATCH",
            self._api,
            "/programs/{programId}",
            path_params={
                "programId": program_id,
            },
            json_body=body,
            timeout=timeout,
        )
        return Program.model_validate(response.json())

    async def partially_update_program_by_id_async(
        self,
        *,
        program_id: str,
        body: list[Any],
        timeout: Optional[float] = None,
    ) -> Program:
        """Partially update a single program (async)

        Partially updates the properties of a
        [program](ref:sustainability#program). Only one property may be updated
        at a time.
        ### Options
        |Path|PATCH Operations Supported|
        |---|---|
        |`/name`|`replace`, `test`|

        Args:
            program_id: The unique identifier of the program
            body: Request body.
            timeout: Override the default request timeout (seconds).

        Returns:
            Program

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 429, 500, 503).
        """
        response = await self._client.request_async(
            "PATCH",
            self._api,
            "/programs/{programId}",
            path_params={
                "programId": program_id,
            },
            json_body=body,
            timeout=timeout,
        )
        return Program.model_validate(response.json())

    def get_program_by_id(
        self,
        *,
        program_id: str,
        timeout: Optional[float] = None,
    ) -> Program:
        """Retrieve a single program

        Retrieves a [program](ref:sustainability#program) given its ID

        Args:
            program_id: The unique identifier of the program
            timeout: Override the default request timeout (seconds).

        Returns:
            Program

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 429, 500, 503).
        """
        response = self._client.request(
            "GET",
            self._api,
            "/programs/{programId}",
            path_params={
                "programId": program_id,
            },
            timeout=timeout,
        )
        return Program.model_validate(response.json())

    async def get_program_by_id_async(
        self,
        *,
        program_id: str,
        timeout: Optional[float] = None,
    ) -> Program:
        """Retrieve a single program (async)

        Retrieves a [program](ref:sustainability#program) given its ID

        Args:
            program_id: The unique identifier of the program
            timeout: Override the default request timeout (seconds).

        Returns:
            Program

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 429, 500, 503).
        """
        response = await self._client.request_async(
            "GET",
            self._api,
            "/programs/{programId}",
            path_params={
                "programId": program_id,
            },
            timeout=timeout,
        )
        return Program.model_validate(response.json())

    def get_dimensions(
        self,
        *,
        program_id: str,
        maxpagesize: Optional[int] = 1000,
        filter_: Optional[str] = None,
        order_by: Optional[str] = None,
        timeout: Optional[float] = None,
    ) -> DimensionsListResult:
        """Retrieve a list of dimensions

        Returns a paginated list of [dimensions](ref:sustainability#dimension).

        Args:
            program_id: The unique identifier of the program
            maxpagesize: The maximum number of results to retrieve
            filter_: The properties to filter the results by.
            order_by: One or more comma-separated expressions to indicate the order in which to sort the results.
            timeout: Override the default request timeout (seconds).

        Returns:
            DimensionsListResult

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 429, 500, 503).
        """

        def _fetch(_cursor: str | None) -> httpx.Response:
            return self._client.request(
                "GET",
                self._api,
                "/programs/{programId}/dimensions",
                path_params={
                    "programId": program_id,
                },
                query_params={
                    "$maxpagesize": maxpagesize,
                    "$filter": filter_,
                    "$orderBy": order_by,
                    "$next": _cursor,
                },
                timeout=timeout,
            )

        _body = paginate_all(_fetch, extract_next_link, "data")
        return DimensionsListResult.model_validate(_body)

    async def get_dimensions_async(
        self,
        *,
        program_id: str,
        maxpagesize: Optional[int] = 1000,
        filter_: Optional[str] = None,
        order_by: Optional[str] = None,
        timeout: Optional[float] = None,
    ) -> DimensionsListResult:
        """Retrieve a list of dimensions (async)

        Returns a paginated list of [dimensions](ref:sustainability#dimension).

        Args:
            program_id: The unique identifier of the program
            maxpagesize: The maximum number of results to retrieve
            filter_: The properties to filter the results by.
            order_by: One or more comma-separated expressions to indicate the order in which to sort the results.
            timeout: Override the default request timeout (seconds).

        Returns:
            DimensionsListResult

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 429, 500, 503).
        """

        async def _fetch(_cursor: str | None) -> httpx.Response:
            return await self._client.request_async(
                "GET",
                self._api,
                "/programs/{programId}/dimensions",
                path_params={
                    "programId": program_id,
                },
                query_params={
                    "$maxpagesize": maxpagesize,
                    "$filter": filter_,
                    "$orderBy": order_by,
                    "$next": _cursor,
                },
                timeout=timeout,
            )

        _body = await paginate_all_async(_fetch, extract_next_link, "data")
        return DimensionsListResult.model_validate(_body)

    def create_dimension(
        self,
        *,
        program_id: str,
        body: Dimension,
        timeout: Optional[float] = None,
    ) -> Dimension:
        """Create a new dimension

        Creates a new [dimension](ref:sustainability#dimension).

        Args:
            program_id: The unique identifier of the program
            body: Request body.
            timeout: Override the default request timeout (seconds).

        Returns:
            Dimension

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 429, 500, 503).
        """
        response = self._client.request(
            "POST",
            self._api,
            "/programs/{programId}/dimensions",
            path_params={
                "programId": program_id,
            },
            json_body=body,
            timeout=timeout,
        )
        return Dimension.model_validate(response.json())

    async def create_dimension_async(
        self,
        *,
        program_id: str,
        body: Dimension,
        timeout: Optional[float] = None,
    ) -> Dimension:
        """Create a new dimension (async)

        Creates a new [dimension](ref:sustainability#dimension).

        Args:
            program_id: The unique identifier of the program
            body: Request body.
            timeout: Override the default request timeout (seconds).

        Returns:
            Dimension

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 429, 500, 503).
        """
        response = await self._client.request_async(
            "POST",
            self._api,
            "/programs/{programId}/dimensions",
            path_params={
                "programId": program_id,
            },
            json_body=body,
            timeout=timeout,
        )
        return Dimension.model_validate(response.json())

    def partially_update_dimension_by_id(
        self,
        *,
        program_id: str,
        dimension_id: str,
        body: list[Any],
        timeout: Optional[float] = None,
    ) -> Dimension:
        """Partially update a single dimension

        Partially updates the properties of a
        [dimension](ref:sustainability#dimension). Only one property may be
        updated at a time.
        ### Options
        |Path|PATCH Operations Supported|
        |---|---|
        |`/active`|`replace`, `test`|
        |`/name`|`replace`, `test`|
        |`/values`|`replace`, `test`|

        Args:
            program_id: The unique identifier of the program
            dimension_id: The unique identifier of the dimension
            body: Request body.
            timeout: Override the default request timeout (seconds).

        Returns:
            Dimension

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 429, 500, 503).
        """
        response = self._client.request(
            "PATCH",
            self._api,
            "/programs/{programId}/dimensions/{dimensionId}",
            path_params={
                "programId": program_id,
                "dimensionId": dimension_id,
            },
            json_body=body,
            timeout=timeout,
        )
        return Dimension.model_validate(response.json())

    async def partially_update_dimension_by_id_async(
        self,
        *,
        program_id: str,
        dimension_id: str,
        body: list[Any],
        timeout: Optional[float] = None,
    ) -> Dimension:
        """Partially update a single dimension (async)

        Partially updates the properties of a
        [dimension](ref:sustainability#dimension). Only one property may be
        updated at a time.
        ### Options
        |Path|PATCH Operations Supported|
        |---|---|
        |`/active`|`replace`, `test`|
        |`/name`|`replace`, `test`|
        |`/values`|`replace`, `test`|

        Args:
            program_id: The unique identifier of the program
            dimension_id: The unique identifier of the dimension
            body: Request body.
            timeout: Override the default request timeout (seconds).

        Returns:
            Dimension

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 429, 500, 503).
        """
        response = await self._client.request_async(
            "PATCH",
            self._api,
            "/programs/{programId}/dimensions/{dimensionId}",
            path_params={
                "programId": program_id,
                "dimensionId": dimension_id,
            },
            json_body=body,
            timeout=timeout,
        )
        return Dimension.model_validate(response.json())

    def get_dimension_by_id(
        self,
        *,
        program_id: str,
        dimension_id: str,
        timeout: Optional[float] = None,
    ) -> Dimension:
        """Retrieve a single dimension

        Retrieves a [dimension](ref:sustainability#dimension) given its ID

        Args:
            program_id: The unique identifier of the program
            dimension_id: The unique identifier of the dimension
            timeout: Override the default request timeout (seconds).

        Returns:
            Dimension

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 429, 500, 503).
        """
        response = self._client.request(
            "GET",
            self._api,
            "/programs/{programId}/dimensions/{dimensionId}",
            path_params={
                "programId": program_id,
                "dimensionId": dimension_id,
            },
            timeout=timeout,
        )
        return Dimension.model_validate(response.json())

    async def get_dimension_by_id_async(
        self,
        *,
        program_id: str,
        dimension_id: str,
        timeout: Optional[float] = None,
    ) -> Dimension:
        """Retrieve a single dimension (async)

        Retrieves a [dimension](ref:sustainability#dimension) given its ID

        Args:
            program_id: The unique identifier of the program
            dimension_id: The unique identifier of the dimension
            timeout: Override the default request timeout (seconds).

        Returns:
            Dimension

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 429, 500, 503).
        """
        response = await self._client.request_async(
            "GET",
            self._api,
            "/programs/{programId}/dimensions/{dimensionId}",
            path_params={
                "programId": program_id,
                "dimensionId": dimension_id,
            },
            timeout=timeout,
        )
        return Dimension.model_validate(response.json())

    def get_metrics(
        self,
        *,
        program_id: str,
        maxpagesize: Optional[int] = 1000,
        order_by: Optional[str] = None,
        filter_: Optional[str] = None,
        timeout: Optional[float] = None,
    ) -> MetricsListResult:
        """Retrieve a list of metrics

        Returns a paginated list of [Metrics](ref:sustainability#metric).

        Args:
            program_id: The unique identifier of the program
            maxpagesize: The maximum number of results to retrieve
            order_by: One or more comma-separated expressions to indicate the order in which to sort the results.
            filter_: The properties to filter the results by.
            timeout: Override the default request timeout (seconds).

        Returns:
            MetricsListResult

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 429, 500, 503).
        """

        def _fetch(_cursor: str | None) -> httpx.Response:
            return self._client.request(
                "GET",
                self._api,
                "/programs/{programId}/metrics",
                path_params={
                    "programId": program_id,
                },
                query_params={
                    "$maxpagesize": maxpagesize,
                    "$orderBy": order_by,
                    "$filter": filter_,
                    "$next": _cursor,
                },
                timeout=timeout,
            )

        _body = paginate_all(_fetch, extract_next_link, "data")
        return MetricsListResult.model_validate(_body)

    async def get_metrics_async(
        self,
        *,
        program_id: str,
        maxpagesize: Optional[int] = 1000,
        order_by: Optional[str] = None,
        filter_: Optional[str] = None,
        timeout: Optional[float] = None,
    ) -> MetricsListResult:
        """Retrieve a list of metrics (async)

        Returns a paginated list of [Metrics](ref:sustainability#metric).

        Args:
            program_id: The unique identifier of the program
            maxpagesize: The maximum number of results to retrieve
            order_by: One or more comma-separated expressions to indicate the order in which to sort the results.
            filter_: The properties to filter the results by.
            timeout: Override the default request timeout (seconds).

        Returns:
            MetricsListResult

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 429, 500, 503).
        """

        async def _fetch(_cursor: str | None) -> httpx.Response:
            return await self._client.request_async(
                "GET",
                self._api,
                "/programs/{programId}/metrics",
                path_params={
                    "programId": program_id,
                },
                query_params={
                    "$maxpagesize": maxpagesize,
                    "$orderBy": order_by,
                    "$filter": filter_,
                    "$next": _cursor,
                },
                timeout=timeout,
            )

        _body = await paginate_all_async(_fetch, extract_next_link, "data")
        return MetricsListResult.model_validate(_body)

    def create_metric(
        self,
        *,
        program_id: str,
        body: Metric,
        timeout: Optional[float] = None,
    ) -> Metric:
        """Create a new metric

        Creates a new [metric](ref:sustainability#metric).

        Args:
            program_id: The unique identifier of the program
            body: Request body.
            timeout: Override the default request timeout (seconds).

        Returns:
            Metric

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 429, 500, 503).
        """
        response = self._client.request(
            "POST",
            self._api,
            "/programs/{programId}/metrics",
            path_params={
                "programId": program_id,
            },
            json_body=body,
            timeout=timeout,
        )
        return Metric.model_validate(response.json())

    async def create_metric_async(
        self,
        *,
        program_id: str,
        body: Metric,
        timeout: Optional[float] = None,
    ) -> Metric:
        """Create a new metric (async)

        Creates a new [metric](ref:sustainability#metric).

        Args:
            program_id: The unique identifier of the program
            body: Request body.
            timeout: Override the default request timeout (seconds).

        Returns:
            Metric

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 429, 500, 503).
        """
        response = await self._client.request_async(
            "POST",
            self._api,
            "/programs/{programId}/metrics",
            path_params={
                "programId": program_id,
            },
            json_body=body,
            timeout=timeout,
        )
        return Metric.model_validate(response.json())

    def partially_update_metric_by_id(
        self,
        *,
        program_id: str,
        metric_id: str,
        body: list[Any],
        timeout: Optional[float] = None,
    ) -> Metric:
        """Partially update a single metric

        Partially updates the properties of a
        [metric](ref:sustainability#metric). Only one property may be updated at
        a time.
        ### Options
        |Path|PATCH Operations Supported|
        |---|---|
        |`/datatype`|`replace`|
        |`/description`|`replace`, `test`|
        |`/index`|`replace`, `test`|
        |`/name`|`replace`, `test`|
        |`/requireNotes`|`replace`, `test`|
        |`/requireSupportingAttachments`|`replace`, `test`|
        |`/topic`|`replace`, `test`|
        |`/unit`|`replace`, `test`|

        Args:
            program_id: The unique identifier of the program
            metric_id: The unique identifier of the metric
            body: Request body.
            timeout: Override the default request timeout (seconds).

        Returns:
            Metric

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 429, 500, 503).
        """
        response = self._client.request(
            "PATCH",
            self._api,
            "/programs/{programId}/metrics/{metricId}",
            path_params={
                "programId": program_id,
                "metricId": metric_id,
            },
            json_body=body,
            timeout=timeout,
        )
        return Metric.model_validate(response.json())

    async def partially_update_metric_by_id_async(
        self,
        *,
        program_id: str,
        metric_id: str,
        body: list[Any],
        timeout: Optional[float] = None,
    ) -> Metric:
        """Partially update a single metric (async)

        Partially updates the properties of a
        [metric](ref:sustainability#metric). Only one property may be updated at
        a time.
        ### Options
        |Path|PATCH Operations Supported|
        |---|---|
        |`/datatype`|`replace`|
        |`/description`|`replace`, `test`|
        |`/index`|`replace`, `test`|
        |`/name`|`replace`, `test`|
        |`/requireNotes`|`replace`, `test`|
        |`/requireSupportingAttachments`|`replace`, `test`|
        |`/topic`|`replace`, `test`|
        |`/unit`|`replace`, `test`|

        Args:
            program_id: The unique identifier of the program
            metric_id: The unique identifier of the metric
            body: Request body.
            timeout: Override the default request timeout (seconds).

        Returns:
            Metric

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 429, 500, 503).
        """
        response = await self._client.request_async(
            "PATCH",
            self._api,
            "/programs/{programId}/metrics/{metricId}",
            path_params={
                "programId": program_id,
                "metricId": metric_id,
            },
            json_body=body,
            timeout=timeout,
        )
        return Metric.model_validate(response.json())

    def get_metric_by_id(
        self,
        *,
        program_id: str,
        metric_id: str,
        timeout: Optional[float] = None,
    ) -> Metric:
        """Retrieve a single metric

        Retrieves a [`Metric`](ref:sustainability#metric) given its ID

        Args:
            program_id: The unique identifier of the program
            metric_id: The unique identifier of the metric
            timeout: Override the default request timeout (seconds).

        Returns:
            Metric

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 429, 500, 503).
        """
        response = self._client.request(
            "GET",
            self._api,
            "/programs/{programId}/metrics/{metricId}",
            path_params={
                "programId": program_id,
                "metricId": metric_id,
            },
            timeout=timeout,
        )
        return Metric.model_validate(response.json())

    async def get_metric_by_id_async(
        self,
        *,
        program_id: str,
        metric_id: str,
        timeout: Optional[float] = None,
    ) -> Metric:
        """Retrieve a single metric (async)

        Retrieves a [`Metric`](ref:sustainability#metric) given its ID

        Args:
            program_id: The unique identifier of the program
            metric_id: The unique identifier of the metric
            timeout: Override the default request timeout (seconds).

        Returns:
            Metric

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 429, 500, 503).
        """
        response = await self._client.request_async(
            "GET",
            self._api,
            "/programs/{programId}/metrics/{metricId}",
            path_params={
                "programId": program_id,
                "metricId": metric_id,
            },
            timeout=timeout,
        )
        return Metric.model_validate(response.json())

    def delete_metric_by_id(
        self,
        *,
        program_id: str,
        metric_id: str,
        timeout: Optional[float] = None,
    ) -> httpx.Response:
        """Delete a single metric

        Deletes a [metric](ref:sustainability#metric) given its ID

        Args:
            program_id: The unique identifier of the program
            metric_id: The unique identifier of the metric
            timeout: Override the default request timeout (seconds).

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 429, 500, 503).
        """
        return self._client.request(
            "DELETE",
            self._api,
            "/programs/{programId}/metrics/{metricId}",
            path_params={
                "programId": program_id,
                "metricId": metric_id,
            },
            timeout=timeout,
        )

    async def delete_metric_by_id_async(
        self,
        *,
        program_id: str,
        metric_id: str,
        timeout: Optional[float] = None,
    ) -> httpx.Response:
        """Delete a single metric (async)

        Deletes a [metric](ref:sustainability#metric) given its ID

        Args:
            program_id: The unique identifier of the program
            metric_id: The unique identifier of the metric
            timeout: Override the default request timeout (seconds).

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 429, 500, 503).
        """
        return await self._client.request_async(
            "DELETE",
            self._api,
            "/programs/{programId}/metrics/{metricId}",
            path_params={
                "programId": program_id,
                "metricId": metric_id,
            },
            timeout=timeout,
        )

    def get_values(
        self,
        *,
        program_id: str,
        metric_id: str,
        maxpagesize: Optional[int] = 1000,
        filter_: Optional[str] = None,
        order_by: Optional[str] = None,
        timeout: Optional[float] = None,
    ) -> MetricValuesListResult:
        """Retrieve a list of metric values

        Returns a paginated list of [metric
        Values](ref:sustainability#metricvalue)

        Args:
            program_id: The unique identifier of the program
            metric_id: The unique identifier of the metric
            maxpagesize: The maximum number of results to retrieve
            filter_: The properties to filter the results by.
            order_by: One or more comma-separated expressions to indicate the order in which to sort the results.
            timeout: Override the default request timeout (seconds).

        Returns:
            MetricValuesListResult

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 429, 500, 503).
        """

        def _fetch(_cursor: str | None) -> httpx.Response:
            return self._client.request(
                "GET",
                self._api,
                "/programs/{programId}/metrics/{metricId}/values",
                path_params={
                    "programId": program_id,
                    "metricId": metric_id,
                },
                query_params={
                    "$maxpagesize": maxpagesize,
                    "$filter": filter_,
                    "$orderBy": order_by,
                    "$next": _cursor,
                },
                timeout=timeout,
            )

        _body = paginate_all(_fetch, extract_next_link, "data")
        return MetricValuesListResult.model_validate(_body)

    async def get_values_async(
        self,
        *,
        program_id: str,
        metric_id: str,
        maxpagesize: Optional[int] = 1000,
        filter_: Optional[str] = None,
        order_by: Optional[str] = None,
        timeout: Optional[float] = None,
    ) -> MetricValuesListResult:
        """Retrieve a list of metric values (async)

        Returns a paginated list of [metric
        Values](ref:sustainability#metricvalue)

        Args:
            program_id: The unique identifier of the program
            metric_id: The unique identifier of the metric
            maxpagesize: The maximum number of results to retrieve
            filter_: The properties to filter the results by.
            order_by: One or more comma-separated expressions to indicate the order in which to sort the results.
            timeout: Override the default request timeout (seconds).

        Returns:
            MetricValuesListResult

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 429, 500, 503).
        """

        async def _fetch(_cursor: str | None) -> httpx.Response:
            return await self._client.request_async(
                "GET",
                self._api,
                "/programs/{programId}/metrics/{metricId}/values",
                path_params={
                    "programId": program_id,
                    "metricId": metric_id,
                },
                query_params={
                    "$maxpagesize": maxpagesize,
                    "$filter": filter_,
                    "$orderBy": order_by,
                    "$next": _cursor,
                },
                timeout=timeout,
            )

        _body = await paginate_all_async(_fetch, extract_next_link, "data")
        return MetricValuesListResult.model_validate(_body)

    def create_value(
        self,
        *,
        program_id: str,
        metric_id: str,
        body: MetricValue,
        timeout: Optional[float] = None,
    ) -> MetricValue:
        """Create a new metric value

        Creates a new [metric value](ref:sustainability#metricvalue)

        Args:
            program_id: The unique identifier of the program
            metric_id: The unique identifier of the metric
            body: Request body.
            timeout: Override the default request timeout (seconds).

        Returns:
            MetricValue

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 429, 500, 503).
        """
        response = self._client.request(
            "POST",
            self._api,
            "/programs/{programId}/metrics/{metricId}/values",
            path_params={
                "programId": program_id,
                "metricId": metric_id,
            },
            json_body=body,
            timeout=timeout,
        )
        return MetricValue.model_validate(response.json())

    async def create_value_async(
        self,
        *,
        program_id: str,
        metric_id: str,
        body: MetricValue,
        timeout: Optional[float] = None,
    ) -> MetricValue:
        """Create a new metric value (async)

        Creates a new [metric value](ref:sustainability#metricvalue)

        Args:
            program_id: The unique identifier of the program
            metric_id: The unique identifier of the metric
            body: Request body.
            timeout: Override the default request timeout (seconds).

        Returns:
            MetricValue

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 429, 500, 503).
        """
        response = await self._client.request_async(
            "POST",
            self._api,
            "/programs/{programId}/metrics/{metricId}/values",
            path_params={
                "programId": program_id,
                "metricId": metric_id,
            },
            json_body=body,
            timeout=timeout,
        )
        return MetricValue.model_validate(response.json())

    def partially_update_metric_value_by_id(
        self,
        *,
        program_id: str,
        metric_id: str,
        metric_value_id: str,
        body: list[Any],
        timeout: Optional[float] = None,
    ) -> MetricValue:
        """Partially update a single metric value

        Partially updates the properties of a [metric
        value](ref:sustainability#metricvalue) value. Only one property may be
        updated at a time.
        ### Options
        |Path|PATCH Operations Supported|
        |---|---|
        |`/notes`|`replace`, `test`|
        |`/value`|`replace`, `test`|

        Args:
            program_id: The unique identifier of the program
            metric_id: The unique identifier of the metric
            metric_value_id: The unique identifier of the value
            body: Request body.
            timeout: Override the default request timeout (seconds).

        Returns:
            MetricValue

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 429, 500, 503).
        """
        response = self._client.request(
            "PATCH",
            self._api,
            "/programs/{programId}/metrics/{metricId}/values/{metricValueId}",
            path_params={
                "programId": program_id,
                "metricId": metric_id,
                "metricValueId": metric_value_id,
            },
            json_body=body,
            timeout=timeout,
        )
        return MetricValue.model_validate(response.json())

    async def partially_update_metric_value_by_id_async(
        self,
        *,
        program_id: str,
        metric_id: str,
        metric_value_id: str,
        body: list[Any],
        timeout: Optional[float] = None,
    ) -> MetricValue:
        """Partially update a single metric value (async)

        Partially updates the properties of a [metric
        value](ref:sustainability#metricvalue) value. Only one property may be
        updated at a time.
        ### Options
        |Path|PATCH Operations Supported|
        |---|---|
        |`/notes`|`replace`, `test`|
        |`/value`|`replace`, `test`|

        Args:
            program_id: The unique identifier of the program
            metric_id: The unique identifier of the metric
            metric_value_id: The unique identifier of the value
            body: Request body.
            timeout: Override the default request timeout (seconds).

        Returns:
            MetricValue

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 429, 500, 503).
        """
        response = await self._client.request_async(
            "PATCH",
            self._api,
            "/programs/{programId}/metrics/{metricId}/values/{metricValueId}",
            path_params={
                "programId": program_id,
                "metricId": metric_id,
                "metricValueId": metric_value_id,
            },
            json_body=body,
            timeout=timeout,
        )
        return MetricValue.model_validate(response.json())

    def get_metric_value_by_id(
        self,
        *,
        program_id: str,
        metric_id: str,
        metric_value_id: str,
        timeout: Optional[float] = None,
    ) -> MetricValue:
        """Retrieve a single metric value

        Retrieves a [metric value](ref:sustainability#metricvalue) value given
        its ID

        Args:
            program_id: The unique identifier of the program
            metric_id: The unique identifier of the metric
            metric_value_id: The unique identifier of the value
            timeout: Override the default request timeout (seconds).

        Returns:
            MetricValue

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 429, 500, 503).
        """
        response = self._client.request(
            "GET",
            self._api,
            "/programs/{programId}/metrics/{metricId}/values/{metricValueId}",
            path_params={
                "programId": program_id,
                "metricId": metric_id,
                "metricValueId": metric_value_id,
            },
            timeout=timeout,
        )
        return MetricValue.model_validate(response.json())

    async def get_metric_value_by_id_async(
        self,
        *,
        program_id: str,
        metric_id: str,
        metric_value_id: str,
        timeout: Optional[float] = None,
    ) -> MetricValue:
        """Retrieve a single metric value (async)

        Retrieves a [metric value](ref:sustainability#metricvalue) value given
        its ID

        Args:
            program_id: The unique identifier of the program
            metric_id: The unique identifier of the metric
            metric_value_id: The unique identifier of the value
            timeout: Override the default request timeout (seconds).

        Returns:
            MetricValue

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 429, 500, 503).
        """
        response = await self._client.request_async(
            "GET",
            self._api,
            "/programs/{programId}/metrics/{metricId}/values/{metricValueId}",
            path_params={
                "programId": program_id,
                "metricId": metric_id,
                "metricValueId": metric_value_id,
            },
            timeout=timeout,
        )
        return MetricValue.model_validate(response.json())

    def delete_metric_value_by_id(
        self,
        *,
        program_id: str,
        metric_id: str,
        metric_value_id: str,
        timeout: Optional[float] = None,
    ) -> httpx.Response:
        """Delete a single metric value

        Deletes a [metric value](ref:sustainability#metricvalue) value given its
        ID

        Args:
            program_id: The unique identifier of the program
            metric_id: The unique identifier of the metric
            metric_value_id: The unique identifier of the value
            timeout: Override the default request timeout (seconds).

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 429, 500, 503).
        """
        return self._client.request(
            "DELETE",
            self._api,
            "/programs/{programId}/metrics/{metricId}/values/{metricValueId}",
            path_params={
                "programId": program_id,
                "metricId": metric_id,
                "metricValueId": metric_value_id,
            },
            timeout=timeout,
        )

    async def delete_metric_value_by_id_async(
        self,
        *,
        program_id: str,
        metric_id: str,
        metric_value_id: str,
        timeout: Optional[float] = None,
    ) -> httpx.Response:
        """Delete a single metric value (async)

        Deletes a [metric value](ref:sustainability#metricvalue) value given its
        ID

        Args:
            program_id: The unique identifier of the program
            metric_id: The unique identifier of the metric
            metric_value_id: The unique identifier of the value
            timeout: Override the default request timeout (seconds).

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 429, 500, 503).
        """
        return await self._client.request_async(
            "DELETE",
            self._api,
            "/programs/{programId}/metrics/{metricId}/values/{metricValueId}",
            path_params={
                "programId": program_id,
                "metricId": metric_id,
                "metricValueId": metric_value_id,
            },
            timeout=timeout,
        )

    def batch_deletion_metric_values(
        self,
        *,
        program_id: str,
        metric_id: str,
        body: MetricValueIdentifier,
        timeout: Optional[float] = None,
    ) -> httpx.Response:
        """Initiate a batch deletion of metric values

        Batch delete the given metric values.

        For each value, provide either the id or both the reportingPeriod and
        coordinates (if any).
        If both are provided, the given id will be used.

        Args:
            program_id: The unique identifier of the program
            metric_id: The unique identifier of the metric
            body: Request body.
            timeout: Override the default request timeout (seconds).

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 429, 500, 503).
        """
        return self._client.request(
            "POST",
            self._api,
            "/programs/{programId}/metrics/{metricId}/values/batchDeletion",
            path_params={
                "programId": program_id,
                "metricId": metric_id,
            },
            json_body=body,
            timeout=timeout,
        )

    async def batch_deletion_metric_values_async(
        self,
        *,
        program_id: str,
        metric_id: str,
        body: MetricValueIdentifier,
        timeout: Optional[float] = None,
    ) -> httpx.Response:
        """Initiate a batch deletion of metric values (async)

        Batch delete the given metric values.

        For each value, provide either the id or both the reportingPeriod and
        coordinates (if any).
        If both are provided, the given id will be used.

        Args:
            program_id: The unique identifier of the program
            metric_id: The unique identifier of the metric
            body: Request body.
            timeout: Override the default request timeout (seconds).

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 429, 500, 503).
        """
        return await self._client.request_async(
            "POST",
            self._api,
            "/programs/{programId}/metrics/{metricId}/values/batchDeletion",
            path_params={
                "programId": program_id,
                "metricId": metric_id,
            },
            json_body=body,
            timeout=timeout,
        )

    def batch_upsertion_metric_values(
        self,
        *,
        program_id: str,
        metric_id: str,
        body: MetricValueUpsertion,
        timeout: Optional[float] = None,
    ) -> httpx.Response:
        """Initiate a batch upsertion of metric values

        Batch upsert values for the given metric. The payload is limited to
        10MB; break it into multiple requests if necessary.

        For each value, provide either the id or both the reportingPeriod and
        coordinates (if any).
        If both are provided, the given id will be used.

        The API will validate the request and return a 202 Accepted status.
        However, the operation will be processed asynchronously, so the values
        may take some time to appear in the system.
        Poll the location provided in the Location header to check the status of
        the operation.

        If any of the values fail to be processed, no changes will be stored in
        the system.

        Args:
            program_id: The unique identifier of the program
            metric_id: The unique identifier of the metric
            body: Request body.
            timeout: Override the default request timeout (seconds).

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 429, 500, 503).

        Note:
            This is a long-running operation (HTTP 202). Use
            ``client.wait(response).result()`` to poll until completion.
        """
        return self._client.request(
            "POST",
            self._api,
            "/programs/{programId}/metrics/{metricId}/values/batchUpsertion",
            path_params={
                "programId": program_id,
                "metricId": metric_id,
            },
            json_body=body,
            timeout=timeout,
        )

    async def batch_upsertion_metric_values_async(
        self,
        *,
        program_id: str,
        metric_id: str,
        body: MetricValueUpsertion,
        timeout: Optional[float] = None,
    ) -> httpx.Response:
        """Initiate a batch upsertion of metric values (async)

        Batch upsert values for the given metric. The payload is limited to
        10MB; break it into multiple requests if necessary.

        For each value, provide either the id or both the reportingPeriod and
        coordinates (if any).
        If both are provided, the given id will be used.

        The API will validate the request and return a 202 Accepted status.
        However, the operation will be processed asynchronously, so the values
        may take some time to appear in the system.
        Poll the location provided in the Location header to check the status of
        the operation.

        If any of the values fail to be processed, no changes will be stored in
        the system.

        Args:
            program_id: The unique identifier of the program
            metric_id: The unique identifier of the metric
            body: Request body.
            timeout: Override the default request timeout (seconds).

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 429, 500, 503).

        Note:
            This is a long-running operation (HTTP 202). Use
            ``await client.wait(response).result_async()`` to poll until completion.
        """
        return await self._client.request_async(
            "POST",
            self._api,
            "/programs/{programId}/metrics/{metricId}/values/batchUpsertion",
            path_params={
                "programId": program_id,
                "metricId": metric_id,
            },
            json_body=body,
            timeout=timeout,
        )

    def get_program_permissions(
        self,
        *,
        program_id: str,
        filter_: Optional[str] = None,
        maxpagesize: Optional[int] = 1000,
        timeout: Optional[float] = None,
    ) -> ResourcePermissionsListResult:
        """Retrieve permissions for a program

        Retrieves a paginated list of permissions for a given Sustainability
        Program

        Args:
            program_id: The unique identifier of the program
            filter_: The properties to filter the results by.
            maxpagesize: The maximum number of results to retrieve
            timeout: Override the default request timeout (seconds).

        Returns:
            ResourcePermissionsListResult

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 429, 500, 503).
        """

        def _fetch(_cursor: str | None) -> httpx.Response:
            return self._client.request(
                "GET",
                self._api,
                "/programs/{programId}/permissions",
                path_params={
                    "programId": program_id,
                },
                query_params={
                    "$filter": filter_,
                    "$maxpagesize": maxpagesize,
                    "$next": _cursor,
                },
                timeout=timeout,
            )

        _body = paginate_all(_fetch, extract_next_link, "data")
        return ResourcePermissionsListResult.model_validate(_body)

    async def get_program_permissions_async(
        self,
        *,
        program_id: str,
        filter_: Optional[str] = None,
        maxpagesize: Optional[int] = 1000,
        timeout: Optional[float] = None,
    ) -> ResourcePermissionsListResult:
        """Retrieve permissions for a program (async)

        Retrieves a paginated list of permissions for a given Sustainability
        Program

        Args:
            program_id: The unique identifier of the program
            filter_: The properties to filter the results by.
            maxpagesize: The maximum number of results to retrieve
            timeout: Override the default request timeout (seconds).

        Returns:
            ResourcePermissionsListResult

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 429, 500, 503).
        """

        async def _fetch(_cursor: str | None) -> httpx.Response:
            return await self._client.request_async(
                "GET",
                self._api,
                "/programs/{programId}/permissions",
                path_params={
                    "programId": program_id,
                },
                query_params={
                    "$filter": filter_,
                    "$maxpagesize": maxpagesize,
                    "$next": _cursor,
                },
                timeout=timeout,
            )

        _body = await paginate_all_async(_fetch, extract_next_link, "data")
        return ResourcePermissionsListResult.model_validate(_body)

    def program_permissions_modification(
        self,
        *,
        program_id: str,
        body: ResourcePermissionsModification,
        timeout: Optional[float] = None,
    ) -> httpx.Response:
        """Modify permissions on a program

        Assign and/or revoke permissions on a Sustainability Program. If any
        modification in a request fails, all modifications on that request fail.
        <br /><br /> _To modify an existing permission, the existing permission
        must first be  explicitly revoked. Then, the new permission needs to be
        assigned. This  can be done in a single request by sending `toAssign`
        and `toRevoke` in  the request body._

        Args:
            program_id: The unique identifier of the program
            body: Request body.
            timeout: Override the default request timeout (seconds).

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 429, 500, 503).
        """
        return self._client.request(
            "POST",
            self._api,
            "/programs/{programId}/permissions/modification",
            path_params={
                "programId": program_id,
            },
            json_body=body,
            timeout=timeout,
        )

    async def program_permissions_modification_async(
        self,
        *,
        program_id: str,
        body: ResourcePermissionsModification,
        timeout: Optional[float] = None,
    ) -> httpx.Response:
        """Modify permissions on a program (async)

        Assign and/or revoke permissions on a Sustainability Program. If any
        modification in a request fails, all modifications on that request fail.
        <br /><br /> _To modify an existing permission, the existing permission
        must first be  explicitly revoked. Then, the new permission needs to be
        assigned. This  can be done in a single request by sending `toAssign`
        and `toRevoke` in  the request body._

        Args:
            program_id: The unique identifier of the program
            body: Request body.
            timeout: Override the default request timeout (seconds).

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 429, 500, 503).
        """
        return await self._client.request_async(
            "POST",
            self._api,
            "/programs/{programId}/permissions/modification",
            path_params={
                "programId": program_id,
            },
            json_body=body,
            timeout=timeout,
        )

    def get_topics(
        self,
        *,
        program_id: str,
        maxpagesize: Optional[int] = 1000,
        filter_: Optional[str] = None,
        order_by: Optional[str] = None,
        timeout: Optional[float] = None,
    ) -> TopicsListResult:
        """Retrieve a list of topics

        Returns a paginated list of [topics](ref:sustainability#topic).

        Args:
            program_id: The unique identifier of the program
            maxpagesize: The maximum number of results to retrieve
            filter_: The properties to filter the results by.
            order_by: One or more comma-separated expressions to indicate the order in which to sort the results.
            timeout: Override the default request timeout (seconds).

        Returns:
            TopicsListResult

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 429, 500, 503).
        """

        def _fetch(_cursor: str | None) -> httpx.Response:
            return self._client.request(
                "GET",
                self._api,
                "/programs/{programId}/topics",
                path_params={
                    "programId": program_id,
                },
                query_params={
                    "$maxpagesize": maxpagesize,
                    "$filter": filter_,
                    "$orderBy": order_by,
                    "$next": _cursor,
                },
                timeout=timeout,
            )

        _body = paginate_all(_fetch, extract_next_link, "data")
        return TopicsListResult.model_validate(_body)

    async def get_topics_async(
        self,
        *,
        program_id: str,
        maxpagesize: Optional[int] = 1000,
        filter_: Optional[str] = None,
        order_by: Optional[str] = None,
        timeout: Optional[float] = None,
    ) -> TopicsListResult:
        """Retrieve a list of topics (async)

        Returns a paginated list of [topics](ref:sustainability#topic).

        Args:
            program_id: The unique identifier of the program
            maxpagesize: The maximum number of results to retrieve
            filter_: The properties to filter the results by.
            order_by: One or more comma-separated expressions to indicate the order in which to sort the results.
            timeout: Override the default request timeout (seconds).

        Returns:
            TopicsListResult

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 429, 500, 503).
        """

        async def _fetch(_cursor: str | None) -> httpx.Response:
            return await self._client.request_async(
                "GET",
                self._api,
                "/programs/{programId}/topics",
                path_params={
                    "programId": program_id,
                },
                query_params={
                    "$maxpagesize": maxpagesize,
                    "$filter": filter_,
                    "$orderBy": order_by,
                    "$next": _cursor,
                },
                timeout=timeout,
            )

        _body = await paginate_all_async(_fetch, extract_next_link, "data")
        return TopicsListResult.model_validate(_body)

    def create_topic(
        self,
        *,
        program_id: str,
        body: Topic,
        timeout: Optional[float] = None,
    ) -> Topic:
        """Create a new topic

        Creates a new [topic](ref:sustainability#topic).

        Args:
            program_id: The unique identifier of the program
            body: Request body.
            timeout: Override the default request timeout (seconds).

        Returns:
            Topic

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 429, 500, 503).
        """
        response = self._client.request(
            "POST",
            self._api,
            "/programs/{programId}/topics",
            path_params={
                "programId": program_id,
            },
            json_body=body,
            timeout=timeout,
        )
        return Topic.model_validate(response.json())

    async def create_topic_async(
        self,
        *,
        program_id: str,
        body: Topic,
        timeout: Optional[float] = None,
    ) -> Topic:
        """Create a new topic (async)

        Creates a new [topic](ref:sustainability#topic).

        Args:
            program_id: The unique identifier of the program
            body: Request body.
            timeout: Override the default request timeout (seconds).

        Returns:
            Topic

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 429, 500, 503).
        """
        response = await self._client.request_async(
            "POST",
            self._api,
            "/programs/{programId}/topics",
            path_params={
                "programId": program_id,
            },
            json_body=body,
            timeout=timeout,
        )
        return Topic.model_validate(response.json())

    def partially_update_topic_by_id(
        self,
        *,
        program_id: str,
        topic_id: str,
        body: list[Any],
        timeout: Optional[float] = None,
    ) -> Topic:
        """Partially update a single topic

        Partially updates the properties of a [topic](ref:sustainability#topic).
        Only one property may be updated at a time.
        ### Options
        |Path|PATCH Operations Supported|
        |---|---|
        |`/index`|`replace`, `test`|
        |`/name`|`replace`, `test`|
        |`/parent`|`replace`, `test`|

        Args:
            program_id: The unique identifier of the program
            topic_id: The unique identifier of the topic
            body: Request body.
            timeout: Override the default request timeout (seconds).

        Returns:
            Topic

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 429, 500, 503).
        """
        response = self._client.request(
            "PATCH",
            self._api,
            "/programs/{programId}/topics/{topicId}",
            path_params={
                "programId": program_id,
                "topicId": topic_id,
            },
            json_body=body,
            timeout=timeout,
        )
        return Topic.model_validate(response.json())

    async def partially_update_topic_by_id_async(
        self,
        *,
        program_id: str,
        topic_id: str,
        body: list[Any],
        timeout: Optional[float] = None,
    ) -> Topic:
        """Partially update a single topic (async)

        Partially updates the properties of a [topic](ref:sustainability#topic).
        Only one property may be updated at a time.
        ### Options
        |Path|PATCH Operations Supported|
        |---|---|
        |`/index`|`replace`, `test`|
        |`/name`|`replace`, `test`|
        |`/parent`|`replace`, `test`|

        Args:
            program_id: The unique identifier of the program
            topic_id: The unique identifier of the topic
            body: Request body.
            timeout: Override the default request timeout (seconds).

        Returns:
            Topic

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 429, 500, 503).
        """
        response = await self._client.request_async(
            "PATCH",
            self._api,
            "/programs/{programId}/topics/{topicId}",
            path_params={
                "programId": program_id,
                "topicId": topic_id,
            },
            json_body=body,
            timeout=timeout,
        )
        return Topic.model_validate(response.json())

    def get_topic_by_id(
        self,
        *,
        program_id: str,
        topic_id: str,
        timeout: Optional[float] = None,
    ) -> Topic:
        """Retrieve a single topic

        Retrieves a [topic](ref:sustainability#topic) given its ID

        Args:
            program_id: The unique identifier of the program
            topic_id: The unique identifier of the topic
            timeout: Override the default request timeout (seconds).

        Returns:
            Topic

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 429, 500, 503).
        """
        response = self._client.request(
            "GET",
            self._api,
            "/programs/{programId}/topics/{topicId}",
            path_params={
                "programId": program_id,
                "topicId": topic_id,
            },
            timeout=timeout,
        )
        return Topic.model_validate(response.json())

    async def get_topic_by_id_async(
        self,
        *,
        program_id: str,
        topic_id: str,
        timeout: Optional[float] = None,
    ) -> Topic:
        """Retrieve a single topic (async)

        Retrieves a [topic](ref:sustainability#topic) given its ID

        Args:
            program_id: The unique identifier of the program
            topic_id: The unique identifier of the topic
            timeout: Override the default request timeout (seconds).

        Returns:
            Topic

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 429, 500, 503).
        """
        response = await self._client.request_async(
            "GET",
            self._api,
            "/programs/{programId}/topics/{topicId}",
            path_params={
                "programId": program_id,
                "topicId": topic_id,
            },
            timeout=timeout,
        )
        return Topic.model_validate(response.json())

    def delete_topic_by_id(
        self,
        *,
        program_id: str,
        topic_id: str,
        timeout: Optional[float] = None,
    ) -> httpx.Response:
        """Delete a single topic

        Deletes a [topic](ref:sustainability#topic) given its ID

        Args:
            program_id: The unique identifier of the program
            topic_id: The unique identifier of the topic
            timeout: Override the default request timeout (seconds).

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 429, 500, 503).
        """
        return self._client.request(
            "DELETE",
            self._api,
            "/programs/{programId}/topics/{topicId}",
            path_params={
                "programId": program_id,
                "topicId": topic_id,
            },
            timeout=timeout,
        )

    async def delete_topic_by_id_async(
        self,
        *,
        program_id: str,
        topic_id: str,
        timeout: Optional[float] = None,
    ) -> httpx.Response:
        """Delete a single topic (async)

        Deletes a [topic](ref:sustainability#topic) given its ID

        Args:
            program_id: The unique identifier of the program
            topic_id: The unique identifier of the topic
            timeout: Override the default request timeout (seconds).

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 429, 500, 503).
        """
        return await self._client.request_async(
            "DELETE",
            self._api,
            "/programs/{programId}/topics/{topicId}",
            path_params={
                "programId": program_id,
                "topicId": topic_id,
            },
            timeout=timeout,
        )
