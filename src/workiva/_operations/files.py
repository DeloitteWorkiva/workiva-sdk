"""Platform API â€” files namespace.

Auto-generated by codegen. Do not edit manually.
"""

from __future__ import annotations

from typing import Any, Literal, Optional

import httpx

from workiva._constants import _API
from workiva._operations._base import BaseNamespace
from workiva._pagination import (
    extract_next_link,
    paginate_all,
    paginate_all_async,
)
from workiva.models.platform import (
    DocumentExport,
    File,
    FileCopyOptions,
    FileImportResponse,
    FileRestoreOptions,
    FilesListResult,
    FileTrashOptions,
    FolderExport,
    PresentationExport,
    ResourcePermission,
    ResourcePermissionsListResult,
    SpreadsheetExport,
    SupportingDocumentImportOptions,
    WorkivaFileImportOptions,
)

__all__ = ["Files"]


class Files(BaseNamespace):
    """Files operations."""

    _api: _API = _API.PLATFORM

    def get_files(
        self,
        *,
        filter_: Optional[str] = None,
        order_by: Optional[str] = None,
        maxpagesize: Optional[int] = 1000,
        timeout: Optional[float] = None,
    ) -> FilesListResult:
        """Retrieve a list of files

        Returns a paginated list of [files](ref:files#file).

        Args:
            filter_: The properties to filter the results by.
            order_by: One or more comma-separated expressions to indicate the order in which to sort the results.
            maxpagesize: The maximum number of results to retrieve
            timeout: Override the default request timeout (seconds).

        Returns:
            FilesListResult

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 429, 500, 503).
        """

        def _fetch(_cursor: str | None) -> httpx.Response:
            return self._client.request(
                "GET",
                self._api,
                "/files",
                query_params={
                    "$filter": filter_,
                    "$orderBy": order_by,
                    "$maxpagesize": maxpagesize,
                    "$next": _cursor,
                },
                timeout=timeout,
            )

        _body_result = paginate_all(_fetch, extract_next_link, "data")
        return FilesListResult.model_validate(_body_result)

    async def get_files_async(
        self,
        *,
        filter_: Optional[str] = None,
        order_by: Optional[str] = None,
        maxpagesize: Optional[int] = 1000,
        timeout: Optional[float] = None,
    ) -> FilesListResult:
        """Retrieve a list of files (async)

        Returns a paginated list of [files](ref:files#file).

        Args:
            filter_: The properties to filter the results by.
            order_by: One or more comma-separated expressions to indicate the order in which to sort the results.
            maxpagesize: The maximum number of results to retrieve
            timeout: Override the default request timeout (seconds).

        Returns:
            FilesListResult

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 429, 500, 503).
        """

        async def _fetch(_cursor: str | None) -> httpx.Response:
            return await self._client.request_async(
                "GET",
                self._api,
                "/files",
                query_params={
                    "$filter": filter_,
                    "$orderBy": order_by,
                    "$maxpagesize": maxpagesize,
                    "$next": _cursor,
                },
                timeout=timeout,
            )

        _body_result = await paginate_all_async(_fetch, extract_next_link, "data")
        return FilesListResult.model_validate(_body_result)

    def create_file(
        self,
        *,
        kind: Optional[
            Literal[
                "Document", "Spreadsheet", "Presentation", "Folder", "Script", "SupportingDocument"
            ]
        ] = None,
        name: Optional[str] = None,
        timeout: Optional[float] = None,
    ) -> File:
        """Create a new file

        Creates a new [file](ref:files#file). Requires name and kind. kind
        must be one of `Document`, `Spreadsheet`, `Presentation`, or `Folder`
        and
        is case-sensitive. Use the `container` attribute to specify the
        container that houses the file, such
        as a folder. If empty, the root folder is the container. Files are
        created
        asynchronously and may not immediately be available on a subsequent
        `GET`.

        ### Examples
        #### Create a new document at the root of the file system
        ```json
        {
          "name": "2019 Year-End Summary",
          "kind": "Document"
        }
        ```

        #### Create a folder within an existing folder
        ```json
        {
          "name": "2019 Year-End Documents",
          "kind": "Folder",
          "container":
        "V0ZFYXRhSW50aXR5IkZvbGRlcjoxSkFGOTZGRjiENDk1Qzk4RjQ4OTgzN0M6ODdDNjZENi"
        }
        ```

        Args:
            kind: Kind of the file
            name: Name of the file
            timeout: Override the default request timeout (seconds).

        Returns:
            File

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 429, 500, 503).
        """
        _body: dict[str, Any] = {}
        if kind is not None:
            _body["kind"] = kind
        if name is not None:
            _body["name"] = name
        response = self._client.request(
            "POST",
            self._api,
            "/files",
            json_body=_body or None,
            timeout=timeout,
        )
        return File.model_validate(response.json())

    async def create_file_async(
        self,
        *,
        kind: Optional[
            Literal[
                "Document", "Spreadsheet", "Presentation", "Folder", "Script", "SupportingDocument"
            ]
        ] = None,
        name: Optional[str] = None,
        timeout: Optional[float] = None,
    ) -> File:
        """Create a new file (async)

        Creates a new [file](ref:files#file). Requires name and kind. kind
        must be one of `Document`, `Spreadsheet`, `Presentation`, or `Folder`
        and
        is case-sensitive. Use the `container` attribute to specify the
        container that houses the file, such
        as a folder. If empty, the root folder is the container. Files are
        created
        asynchronously and may not immediately be available on a subsequent
        `GET`.

        ### Examples
        #### Create a new document at the root of the file system
        ```json
        {
          "name": "2019 Year-End Summary",
          "kind": "Document"
        }
        ```

        #### Create a folder within an existing folder
        ```json
        {
          "name": "2019 Year-End Documents",
          "kind": "Folder",
          "container":
        "V0ZFYXRhSW50aXR5IkZvbGRlcjoxSkFGOTZGRjiENDk1Qzk4RjQ4OTgzN0M6ODdDNjZENi"
        }
        ```

        Args:
            kind: Kind of the file
            name: Name of the file
            timeout: Override the default request timeout (seconds).

        Returns:
            File

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 429, 500, 503).
        """
        _body: dict[str, Any] = {}
        if kind is not None:
            _body["kind"] = kind
        if name is not None:
            _body["name"] = name
        response = await self._client.request_async(
            "POST",
            self._api,
            "/files",
            json_body=_body or None,
            timeout=timeout,
        )
        return File.model_validate(response.json())

    def import_file(
        self,
        *,
        file_name: Optional[str] = None,
        kind: Optional[
            Literal["Document", "Spreadsheet", "Presentation", "Workiva", "SupportingDocument"]
        ] = None,
        supporting_document_import_options: Optional[SupportingDocumentImportOptions] = None,
        workiva_file_import_options: Optional[WorkivaFileImportOptions] = None,
        timeout: Optional[float] = None,
    ) -> FileImportResponse:
        """Initiate a file import

        Import a file for conversion to a Workiva equivalent. This is a long
        running operation.
        Response includes an `uploadUrl` which indicates where to upload the
        file for import. To upload the file, perform a PUT against the
        `uploadUrl` with the same authentication credentials and flow as the
        import request. For more details, see [Authentication
        documentation](ref:authentication).

        Args:
            file_name: The name of the file to import. Supported extensions include .XLSX, .CSV, .DOCX, .PPTX, .VSDX, .TAR.GZ unless importing a SupportingDocument which can have any extension.
            kind: The Workiva file type to upload to. (Document, Spreadsheet, Presentation, Workiva, SupportingDocument)
            supporting_document_import_options:
            workiva_file_import_options:
            timeout: Override the default request timeout (seconds).

        Returns:
            FileImportResponse

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 429, 500, 503).
        """
        _body: dict[str, Any] = {}
        if file_name is not None:
            _body["fileName"] = file_name
        if kind is not None:
            _body["kind"] = kind
        if supporting_document_import_options is not None:
            _body["supportingDocumentImportOptions"] = supporting_document_import_options
        if workiva_file_import_options is not None:
            _body["workivaFileImportOptions"] = workiva_file_import_options
        response = self._client.request(
            "POST",
            self._api,
            "/files/import",
            json_body=_body or None,
            timeout=timeout,
        )
        return FileImportResponse.model_validate(response.json())

    async def import_file_async(
        self,
        *,
        file_name: Optional[str] = None,
        kind: Optional[
            Literal["Document", "Spreadsheet", "Presentation", "Workiva", "SupportingDocument"]
        ] = None,
        supporting_document_import_options: Optional[SupportingDocumentImportOptions] = None,
        workiva_file_import_options: Optional[WorkivaFileImportOptions] = None,
        timeout: Optional[float] = None,
    ) -> FileImportResponse:
        """Initiate a file import (async)

        Import a file for conversion to a Workiva equivalent. This is a long
        running operation.
        Response includes an `uploadUrl` which indicates where to upload the
        file for import. To upload the file, perform a PUT against the
        `uploadUrl` with the same authentication credentials and flow as the
        import request. For more details, see [Authentication
        documentation](ref:authentication).

        Args:
            file_name: The name of the file to import. Supported extensions include .XLSX, .CSV, .DOCX, .PPTX, .VSDX, .TAR.GZ unless importing a SupportingDocument which can have any extension.
            kind: The Workiva file type to upload to. (Document, Spreadsheet, Presentation, Workiva, SupportingDocument)
            supporting_document_import_options:
            workiva_file_import_options:
            timeout: Override the default request timeout (seconds).

        Returns:
            FileImportResponse

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 429, 500, 503).
        """
        _body: dict[str, Any] = {}
        if file_name is not None:
            _body["fileName"] = file_name
        if kind is not None:
            _body["kind"] = kind
        if supporting_document_import_options is not None:
            _body["supportingDocumentImportOptions"] = supporting_document_import_options
        if workiva_file_import_options is not None:
            _body["workivaFileImportOptions"] = workiva_file_import_options
        response = await self._client.request_async(
            "POST",
            self._api,
            "/files/import",
            json_body=_body or None,
            timeout=timeout,
        )
        return FileImportResponse.model_validate(response.json())

    def get_trashed_files(
        self,
        *,
        maxpagesize: Optional[int] = 1000,
        timeout: Optional[float] = None,
    ) -> FilesListResult:
        """Retrieve a list of trashed files

        Returns a paginated list of files that have been trashed.

        Args:
            maxpagesize: The maximum number of results to retrieve
            timeout: Override the default request timeout (seconds).

        Returns:
            FilesListResult

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 429, 500, 503).
        """

        def _fetch(_cursor: str | None) -> httpx.Response:
            return self._client.request(
                "GET",
                self._api,
                "/files/trash",
                query_params={
                    "$maxpagesize": maxpagesize,
                    "$next": _cursor,
                },
                timeout=timeout,
            )

        _body_result = paginate_all(_fetch, extract_next_link, "data")
        return FilesListResult.model_validate(_body_result)

    async def get_trashed_files_async(
        self,
        *,
        maxpagesize: Optional[int] = 1000,
        timeout: Optional[float] = None,
    ) -> FilesListResult:
        """Retrieve a list of trashed files (async)

        Returns a paginated list of files that have been trashed.

        Args:
            maxpagesize: The maximum number of results to retrieve
            timeout: Override the default request timeout (seconds).

        Returns:
            FilesListResult

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 429, 500, 503).
        """

        async def _fetch(_cursor: str | None) -> httpx.Response:
            return await self._client.request_async(
                "GET",
                self._api,
                "/files/trash",
                query_params={
                    "$maxpagesize": maxpagesize,
                    "$next": _cursor,
                },
                timeout=timeout,
            )

        _body_result = await paginate_all_async(_fetch, extract_next_link, "data")
        return FilesListResult.model_validate(_body_result)

    def get_file_by_id(
        self,
        *,
        file_id: str,
        timeout: Optional[float] = None,
    ) -> File:
        """Retrieve a single file

        Retrieves a [file](ref:files#file) given its ID

        Args:
            file_id: The unique identifier of the file
            timeout: Override the default request timeout (seconds).

        Returns:
            File

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 429, 500, 503).
        """
        response = self._client.request(
            "GET",
            self._api,
            "/files/{fileId}",
            path_params={
                "fileId": file_id,
            },
            timeout=timeout,
        )
        return File.model_validate(response.json())

    async def get_file_by_id_async(
        self,
        *,
        file_id: str,
        timeout: Optional[float] = None,
    ) -> File:
        """Retrieve a single file (async)

        Retrieves a [file](ref:files#file) given its ID

        Args:
            file_id: The unique identifier of the file
            timeout: Override the default request timeout (seconds).

        Returns:
            File

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 429, 500, 503).
        """
        response = await self._client.request_async(
            "GET",
            self._api,
            "/files/{fileId}",
            path_params={
                "fileId": file_id,
            },
            timeout=timeout,
        )
        return File.model_validate(response.json())

    def partially_update_file_by_id(
        self,
        *,
        file_id: str,
        body: list[Any],
        timeout: Optional[float] = None,
    ) -> File:
        """Partially update a single file

        Partially updates the properties of a [file](ref:files#file). Only one
        property may be updated at a time.
        Updates are applied asynchronously and may not immediately be reflected
        on a subsequent `GET`.
        ### Options
        |Path|PATCH Operations Supported|
        |---|---|
        |`/container`|`replace`|
        |`/name`|`replace`|

        Args:
            file_id: The unique identifier of the file
            body: Request body.
            timeout: Override the default request timeout (seconds).

        Returns:
            File

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 429, 500, 503).
        """
        response = self._client.request(
            "PATCH",
            self._api,
            "/files/{fileId}",
            path_params={
                "fileId": file_id,
            },
            json_body=body,
            timeout=timeout,
        )
        return File.model_validate(response.json())

    async def partially_update_file_by_id_async(
        self,
        *,
        file_id: str,
        body: list[Any],
        timeout: Optional[float] = None,
    ) -> File:
        """Partially update a single file (async)

        Partially updates the properties of a [file](ref:files#file). Only one
        property may be updated at a time.
        Updates are applied asynchronously and may not immediately be reflected
        on a subsequent `GET`.
        ### Options
        |Path|PATCH Operations Supported|
        |---|---|
        |`/container`|`replace`|
        |`/name`|`replace`|

        Args:
            file_id: The unique identifier of the file
            body: Request body.
            timeout: Override the default request timeout (seconds).

        Returns:
            File

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 429, 500, 503).
        """
        response = await self._client.request_async(
            "PATCH",
            self._api,
            "/files/{fileId}",
            path_params={
                "fileId": file_id,
            },
            json_body=body,
            timeout=timeout,
        )
        return File.model_validate(response.json())

    def copy_file(
        self,
        *,
        file_id: str,
        destination_container: Optional[str] = None,
        options: Optional[FileCopyOptions] = None,
        timeout: Optional[float] = None,
    ) -> httpx.Response:
        """Initiate a file copy

        Copy a file to a new location. This is a long running operation.
        Responses include a `Location` header, which indicates where to poll for
        copy results. For more details on long-running job polling, see
        [Operations endpoint](ref:getoperationbyid).
        Once the operation is completed, the `resourceUrl` field will be
        populated with a link to the   [Retrieve copy file results for a single
        operation endpoint](ref:getcopyfileresults)  to see the results of the
        File Copy Request.

        Args:
            file_id: The unique identifier of the file
            destination_container: The unique id of the destination container to copy to. Omit this field to specify the root container. Specifying an empty string is invalid.
            options:
            timeout: Override the default request timeout (seconds).

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 429, 500, 503).

        Note:
            This is a long-running operation (HTTP 202). Use
            ``client.wait(response).result()`` to poll until completion.
        """
        _body: dict[str, Any] = {}
        if destination_container is not None:
            _body["destinationContainer"] = destination_container
        if options is not None:
            _body["options"] = options
        return self._client.request(
            "POST",
            self._api,
            "/files/{fileId}/copy",
            path_params={
                "fileId": file_id,
            },
            json_body=_body or None,
            timeout=timeout,
        )

    async def copy_file_async(
        self,
        *,
        file_id: str,
        destination_container: Optional[str] = None,
        options: Optional[FileCopyOptions] = None,
        timeout: Optional[float] = None,
    ) -> httpx.Response:
        """Initiate a file copy (async)

        Copy a file to a new location. This is a long running operation.
        Responses include a `Location` header, which indicates where to poll for
        copy results. For more details on long-running job polling, see
        [Operations endpoint](ref:getoperationbyid).
        Once the operation is completed, the `resourceUrl` field will be
        populated with a link to the   [Retrieve copy file results for a single
        operation endpoint](ref:getcopyfileresults)  to see the results of the
        File Copy Request.

        Args:
            file_id: The unique identifier of the file
            destination_container: The unique id of the destination container to copy to. Omit this field to specify the root container. Specifying an empty string is invalid.
            options:
            timeout: Override the default request timeout (seconds).

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 429, 500, 503).

        Note:
            This is a long-running operation (HTTP 202). Use
            ``await client.wait(response).result_async()`` to poll until completion.
        """
        _body: dict[str, Any] = {}
        if destination_container is not None:
            _body["destinationContainer"] = destination_container
        if options is not None:
            _body["options"] = options
        return await self._client.request_async(
            "POST",
            self._api,
            "/files/{fileId}/copy",
            path_params={
                "fileId": file_id,
            },
            json_body=_body or None,
            timeout=timeout,
        )

    def export_file_by_id(
        self,
        *,
        file_id: str,
        document_export: Optional[DocumentExport] = None,
        folder_export: Optional[FolderExport] = None,
        kind: Optional[
            Literal["Document", "Spreadsheet", "Presentation", "SupportingDocument", "Folder"]
        ] = None,
        presentation_export: Optional[PresentationExport] = None,
        spreadsheet_export: Optional[SpreadsheetExport] = None,
        timeout: Optional[float] = None,
    ) -> httpx.Response:
        """Initiate a file export by ID

        Export a file by its unique ID. This is a long running operation.
        Responses include a `Location` header, which indicates where to poll for
        export results. For  more details on long-running job polling, see
        [Operations endpoint](ref:getoperationbyid).
        When the export process is complete, the status of the Operation  will
        change to completed. The `resourceUrl` field of the operation will
        contain  the download url of the exported file. To download the file,
        perform a GET against  the `resourceUrl` with the same authentication
        credentials and flow as the export request.  For more details, see
        Authentication documentation.
        For more on Document, Spreadsheet, and Presentation export options, see
        the following:
        [Documents](https://developers.workiva.com/2026-01-01/platform-
        documentexport),
        [Spreadsheets](https://developers.workiva.com/2026-01-01/platform-
        spreadsheetexport), and
        [Presentations](https://developers.workiva.com/2026-01-01/platform-
        presentationexport).

        Args:
            file_id: The unique identifier of the file
            document_export:
            folder_export:
            kind: Kind (Type) of the file which will be exported.
            presentation_export:
            spreadsheet_export:
            timeout: Override the default request timeout (seconds).

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 429, 500, 503).

        Note:
            This is a long-running operation (HTTP 202). Use
            ``client.wait(response).result()`` to poll until completion.
        """
        _body: dict[str, Any] = {}
        if document_export is not None:
            _body["documentExport"] = document_export
        if folder_export is not None:
            _body["folderExport"] = folder_export
        if kind is not None:
            _body["kind"] = kind
        if presentation_export is not None:
            _body["presentationExport"] = presentation_export
        if spreadsheet_export is not None:
            _body["spreadsheetExport"] = spreadsheet_export
        return self._client.request(
            "POST",
            self._api,
            "/files/{fileId}/export",
            path_params={
                "fileId": file_id,
            },
            json_body=_body or None,
            timeout=timeout,
        )

    async def export_file_by_id_async(
        self,
        *,
        file_id: str,
        document_export: Optional[DocumentExport] = None,
        folder_export: Optional[FolderExport] = None,
        kind: Optional[
            Literal["Document", "Spreadsheet", "Presentation", "SupportingDocument", "Folder"]
        ] = None,
        presentation_export: Optional[PresentationExport] = None,
        spreadsheet_export: Optional[SpreadsheetExport] = None,
        timeout: Optional[float] = None,
    ) -> httpx.Response:
        """Initiate a file export by ID (async)

        Export a file by its unique ID. This is a long running operation.
        Responses include a `Location` header, which indicates where to poll for
        export results. For  more details on long-running job polling, see
        [Operations endpoint](ref:getoperationbyid).
        When the export process is complete, the status of the Operation  will
        change to completed. The `resourceUrl` field of the operation will
        contain  the download url of the exported file. To download the file,
        perform a GET against  the `resourceUrl` with the same authentication
        credentials and flow as the export request.  For more details, see
        Authentication documentation.
        For more on Document, Spreadsheet, and Presentation export options, see
        the following:
        [Documents](https://developers.workiva.com/2026-01-01/platform-
        documentexport),
        [Spreadsheets](https://developers.workiva.com/2026-01-01/platform-
        spreadsheetexport), and
        [Presentations](https://developers.workiva.com/2026-01-01/platform-
        presentationexport).

        Args:
            file_id: The unique identifier of the file
            document_export:
            folder_export:
            kind: Kind (Type) of the file which will be exported.
            presentation_export:
            spreadsheet_export:
            timeout: Override the default request timeout (seconds).

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 429, 500, 503).

        Note:
            This is a long-running operation (HTTP 202). Use
            ``await client.wait(response).result_async()`` to poll until completion.
        """
        _body: dict[str, Any] = {}
        if document_export is not None:
            _body["documentExport"] = document_export
        if folder_export is not None:
            _body["folderExport"] = folder_export
        if kind is not None:
            _body["kind"] = kind
        if presentation_export is not None:
            _body["presentationExport"] = presentation_export
        if spreadsheet_export is not None:
            _body["spreadsheetExport"] = spreadsheet_export
        return await self._client.request_async(
            "POST",
            self._api,
            "/files/{fileId}/export",
            path_params={
                "fileId": file_id,
            },
            json_body=_body or None,
            timeout=timeout,
        )

    def restore_file_by_id(
        self,
        *,
        file_id: str,
        body: FileRestoreOptions,
        timeout: Optional[float] = None,
    ) -> httpx.Response:
        """Initiate restoration of a single file

        Restores a file given its ID. If the file being restored is a Folder,
        its contents will be recursively restored.

        Args:
            file_id: The unique identifier of the file
            body: Request body.
            timeout: Override the default request timeout (seconds).

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 429, 500, 503).

        Note:
            This is a long-running operation (HTTP 202). Use
            ``client.wait(response).result()`` to poll until completion.
        """
        return self._client.request(
            "POST",
            self._api,
            "/files/{fileId}/restore",
            path_params={
                "fileId": file_id,
            },
            json_body=body,
            timeout=timeout,
        )

    async def restore_file_by_id_async(
        self,
        *,
        file_id: str,
        body: FileRestoreOptions,
        timeout: Optional[float] = None,
    ) -> httpx.Response:
        """Initiate restoration of a single file (async)

        Restores a file given its ID. If the file being restored is a Folder,
        its contents will be recursively restored.

        Args:
            file_id: The unique identifier of the file
            body: Request body.
            timeout: Override the default request timeout (seconds).

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 429, 500, 503).

        Note:
            This is a long-running operation (HTTP 202). Use
            ``await client.wait(response).result_async()`` to poll until completion.
        """
        return await self._client.request_async(
            "POST",
            self._api,
            "/files/{fileId}/restore",
            path_params={
                "fileId": file_id,
            },
            json_body=body,
            timeout=timeout,
        )

    def trash_file_by_id(
        self,
        *,
        file_id: str,
        body: FileTrashOptions,
        timeout: Optional[float] = None,
    ) -> httpx.Response:
        """Initiate trash of a single file

        Trashes a file given its ID. If the file being trashed is a Folder, its
        contents will be recursively trashed.

        Args:
            file_id: The unique identifier of the file
            body: Request body.
            timeout: Override the default request timeout (seconds).

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 429, 500, 503).

        Note:
            This is a long-running operation (HTTP 202). Use
            ``client.wait(response).result()`` to poll until completion.
        """
        return self._client.request(
            "POST",
            self._api,
            "/files/{fileId}/trash",
            path_params={
                "fileId": file_id,
            },
            json_body=body,
            timeout=timeout,
        )

    async def trash_file_by_id_async(
        self,
        *,
        file_id: str,
        body: FileTrashOptions,
        timeout: Optional[float] = None,
    ) -> httpx.Response:
        """Initiate trash of a single file (async)

        Trashes a file given its ID. If the file being trashed is a Folder, its
        contents will be recursively trashed.

        Args:
            file_id: The unique identifier of the file
            body: Request body.
            timeout: Override the default request timeout (seconds).

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 429, 500, 503).

        Note:
            This is a long-running operation (HTTP 202). Use
            ``await client.wait(response).result_async()`` to poll until completion.
        """
        return await self._client.request_async(
            "POST",
            self._api,
            "/files/{fileId}/trash",
            path_params={
                "fileId": file_id,
            },
            json_body=body,
            timeout=timeout,
        )

    def get_file_permissions(
        self,
        *,
        file_id: str,
        filter_: Optional[str] = None,
        maxpagesize: Optional[int] = 1000,
        timeout: Optional[float] = None,
    ) -> ResourcePermissionsListResult:
        """Retrieve permissions for a file

        Retrieves a paginated list of permissions for a given file

        Args:
            file_id: The unique identifier of the file
            filter_: The properties to filter the results by.
            maxpagesize: The maximum number of results to retrieve
            timeout: Override the default request timeout (seconds).

        Returns:
            ResourcePermissionsListResult

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 429, 500, 503).
        """

        def _fetch(_cursor: str | None) -> httpx.Response:
            return self._client.request(
                "GET",
                self._api,
                "/files/{fileId}/permissions",
                path_params={
                    "fileId": file_id,
                },
                query_params={
                    "$filter": filter_,
                    "$maxpagesize": maxpagesize,
                    "$next": _cursor,
                },
                timeout=timeout,
            )

        _body_result = paginate_all(_fetch, extract_next_link, "data")
        return ResourcePermissionsListResult.model_validate(_body_result)

    async def get_file_permissions_async(
        self,
        *,
        file_id: str,
        filter_: Optional[str] = None,
        maxpagesize: Optional[int] = 1000,
        timeout: Optional[float] = None,
    ) -> ResourcePermissionsListResult:
        """Retrieve permissions for a file (async)

        Retrieves a paginated list of permissions for a given file

        Args:
            file_id: The unique identifier of the file
            filter_: The properties to filter the results by.
            maxpagesize: The maximum number of results to retrieve
            timeout: Override the default request timeout (seconds).

        Returns:
            ResourcePermissionsListResult

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 429, 500, 503).
        """

        async def _fetch(_cursor: str | None) -> httpx.Response:
            return await self._client.request_async(
                "GET",
                self._api,
                "/files/{fileId}/permissions",
                path_params={
                    "fileId": file_id,
                },
                query_params={
                    "$filter": filter_,
                    "$maxpagesize": maxpagesize,
                    "$next": _cursor,
                },
                timeout=timeout,
            )

        _body_result = await paginate_all_async(_fetch, extract_next_link, "data")
        return ResourcePermissionsListResult.model_validate(_body_result)

    def file_permissions_modification(
        self,
        *,
        file_id: str,
        to_assign: Optional[list[ResourcePermission]] = None,
        to_revoke: Optional[list[ResourcePermission]] = None,
        timeout: Optional[float] = None,
    ) -> httpx.Response:
        """Modify permissions on a file

        Assign and/or revoke permissions on a file. If any modification in a
        request fails, all modifications on that request fail. <br /><br /> _To
        modify an existing permission, the existing permission must first be
        explicitly revoked. Then, the new permission needs to be assigned. This
        can be done in a single request by sending `toAssign` and `toRevoke` in
        the request body._

        Args:
            file_id: The unique identifier of the file
            to_assign: The list of permissions to be assigned to the resource
            to_revoke: The list of permissions to be revoked from the resource
            timeout: Override the default request timeout (seconds).

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 429, 500, 503).
        """
        _body: dict[str, Any] = {}
        if to_assign is not None:
            _body["toAssign"] = to_assign
        if to_revoke is not None:
            _body["toRevoke"] = to_revoke
        return self._client.request(
            "POST",
            self._api,
            "/files/{fileId}/permissions/modification",
            path_params={
                "fileId": file_id,
            },
            json_body=_body or None,
            timeout=timeout,
        )

    async def file_permissions_modification_async(
        self,
        *,
        file_id: str,
        to_assign: Optional[list[ResourcePermission]] = None,
        to_revoke: Optional[list[ResourcePermission]] = None,
        timeout: Optional[float] = None,
    ) -> httpx.Response:
        """Modify permissions on a file (async)

        Assign and/or revoke permissions on a file. If any modification in a
        request fails, all modifications on that request fail. <br /><br /> _To
        modify an existing permission, the existing permission must first be
        explicitly revoked. Then, the new permission needs to be assigned. This
        can be done in a single request by sending `toAssign` and `toRevoke` in
        the request body._

        Args:
            file_id: The unique identifier of the file
            to_assign: The list of permissions to be assigned to the resource
            to_revoke: The list of permissions to be revoked from the resource
            timeout: Override the default request timeout (seconds).

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 429, 500, 503).
        """
        _body: dict[str, Any] = {}
        if to_assign is not None:
            _body["toAssign"] = to_assign
        if to_revoke is not None:
            _body["toRevoke"] = to_revoke
        return await self._client.request_async(
            "POST",
            self._api,
            "/files/{fileId}/permissions/modification",
            path_params={
                "fileId": file_id,
            },
            json_body=_body or None,
            timeout=timeout,
        )
