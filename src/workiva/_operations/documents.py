"""Platform API â€” documents namespace.

Auto-generated by codegen. Do not edit manually.
"""

from __future__ import annotations

from typing import Any, Literal, Optional

import httpx

from workiva._constants import _API
from workiva._operations._base import BaseNamespace
from workiva._pagination import (
    extract_next_link,
    paginate_all,
    paginate_all_async,
)
from workiva.models.platform import (
    Document,
    DocumentsListResult,
    DocumentToDocxOptions,
    DocumentToPdfOptions,
    DocumentToXhtmlOptions,
    MilestoneListResult,
    ResourcePermission,
    ResourcePermissionsListResult,
    Section,
    SectionEdit,
    SectionsListResult,
)

__all__ = ["Documents"]


class Documents(BaseNamespace):
    """Documents operations."""

    _api: _API = _API.PLATFORM

    def get_documents(
        self,
        *,
        filter_: Optional[str] = None,
        order_by: Optional[str] = None,
        maxpagesize: Optional[int] = 1000,
        timeout: Optional[float] = None,
    ) -> DocumentsListResult:
        """Retrieve a list of documents

        Returns a paginated list of [documents](ref:documents#document).

        Args:
            filter_: The properties to filter the results by.
            order_by: One or more comma-separated expressions to indicate the order in which to sort the results.
            maxpagesize: The maximum number of results to retrieve
            timeout: Override the default request timeout (seconds).

        Returns:
            DocumentsListResult

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 429, 500, 503).
        """

        def _fetch(_cursor: str | None) -> httpx.Response:
            return self._client.request(
                "GET",
                self._api,
                "/documents",
                query_params={
                    "$filter": filter_,
                    "$orderBy": order_by,
                    "$maxpagesize": maxpagesize,
                    "$next": _cursor,
                },
                timeout=timeout,
            )

        _body_result = paginate_all(_fetch, extract_next_link, "data")
        return DocumentsListResult.model_validate(_body_result)

    async def get_documents_async(
        self,
        *,
        filter_: Optional[str] = None,
        order_by: Optional[str] = None,
        maxpagesize: Optional[int] = 1000,
        timeout: Optional[float] = None,
    ) -> DocumentsListResult:
        """Retrieve a list of documents (async)

        Returns a paginated list of [documents](ref:documents#document).

        Args:
            filter_: The properties to filter the results by.
            order_by: One or more comma-separated expressions to indicate the order in which to sort the results.
            maxpagesize: The maximum number of results to retrieve
            timeout: Override the default request timeout (seconds).

        Returns:
            DocumentsListResult

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 429, 500, 503).
        """

        async def _fetch(_cursor: str | None) -> httpx.Response:
            return await self._client.request_async(
                "GET",
                self._api,
                "/documents",
                query_params={
                    "$filter": filter_,
                    "$orderBy": order_by,
                    "$maxpagesize": maxpagesize,
                    "$next": _cursor,
                },
                timeout=timeout,
            )

        _body_result = await paginate_all_async(_fetch, extract_next_link, "data")
        return DocumentsListResult.model_validate(_body_result)

    def partially_update_document_by_id(
        self,
        *,
        document_id: str,
        body: list[Any],
        timeout: Optional[float] = None,
    ) -> httpx.Response:
        """Partially update a single document

        Updates the properties of a [document](ref:documents#document).

        This is a long running operation. Responses include a `Location` header,
        which indicates where to poll for results. For more details on long-
        running job polling,
        see [Operations endpoint](ref:getoperationbyid).

        ### Options

        |Path                             |PATCH Operations Supported        |
        |---------------------------------|----------------------------------|
        |`/customFields/<custom field id>`|`add`, `remove`, `replace`, `test`|
        |`/customFieldGroups`             |`add`, `remove`, `replace`, `test`|
        |`/sectionCustomFieldGroups`      |`add`, `remove`, `replace`, `test`|
        |`/lock`                          |`replace`                         |

        ### Examples

        #### Add a custom field value

        ```json
        [
          {
            "op": "add",
            "path": "/customFields/com.workiva.gsr.legal_entity",
            "value": "Workiva"
          }
        ]
        ```

        #### Remove a custom field value

        ```json
        [
          {
            "op": "remove",
            "path": "/customFields/com.workiva.gsr.legal_entity"
          }
        ]
        ```

        #### Replace a custom field value

        ```json
        [
          {
            "op": "replace",
            "path": "/customFields/com.workiva.gsr.legal_entity",
            "value": "Workiva, Inc."
          }
        ]
        ```

        #### Verifying customFieldGroup is empty before replacing the list

        ```json
        [
          {
            "op": "test",
            "path": "/customFieldGroups",
            "value": []
          },
          {
            "op": "replace",
            "path": "/customFieldGroups",
            "value": ["gsr.reporting"]
          }
        ]
        ```

        #### Adding a customFieldGroup to the end of a list

        ```json
        [
          {
            "op": "add",
            "path": "/customFieldGroups/-",
            "value": "gsr.reporting"
          }
        ]
        ```

        Args:
            document_id: The unique identifier of the document
            body: Request body.
            timeout: Override the default request timeout (seconds).

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 429, 500, 503).

        Note:
            This is a long-running operation (HTTP 202). Use
            ``client.wait(response).result()`` to poll until completion.
        """
        return self._client.request(
            "PATCH",
            self._api,
            "/documents/{documentId}",
            path_params={
                "documentId": document_id,
            },
            json_body=body,
            timeout=timeout,
        )

    async def partially_update_document_by_id_async(
        self,
        *,
        document_id: str,
        body: list[Any],
        timeout: Optional[float] = None,
    ) -> httpx.Response:
        """Partially update a single document (async)

        Updates the properties of a [document](ref:documents#document).

        This is a long running operation. Responses include a `Location` header,
        which indicates where to poll for results. For more details on long-
        running job polling,
        see [Operations endpoint](ref:getoperationbyid).

        ### Options

        |Path                             |PATCH Operations Supported        |
        |---------------------------------|----------------------------------|
        |`/customFields/<custom field id>`|`add`, `remove`, `replace`, `test`|
        |`/customFieldGroups`             |`add`, `remove`, `replace`, `test`|
        |`/sectionCustomFieldGroups`      |`add`, `remove`, `replace`, `test`|
        |`/lock`                          |`replace`                         |

        ### Examples

        #### Add a custom field value

        ```json
        [
          {
            "op": "add",
            "path": "/customFields/com.workiva.gsr.legal_entity",
            "value": "Workiva"
          }
        ]
        ```

        #### Remove a custom field value

        ```json
        [
          {
            "op": "remove",
            "path": "/customFields/com.workiva.gsr.legal_entity"
          }
        ]
        ```

        #### Replace a custom field value

        ```json
        [
          {
            "op": "replace",
            "path": "/customFields/com.workiva.gsr.legal_entity",
            "value": "Workiva, Inc."
          }
        ]
        ```

        #### Verifying customFieldGroup is empty before replacing the list

        ```json
        [
          {
            "op": "test",
            "path": "/customFieldGroups",
            "value": []
          },
          {
            "op": "replace",
            "path": "/customFieldGroups",
            "value": ["gsr.reporting"]
          }
        ]
        ```

        #### Adding a customFieldGroup to the end of a list

        ```json
        [
          {
            "op": "add",
            "path": "/customFieldGroups/-",
            "value": "gsr.reporting"
          }
        ]
        ```

        Args:
            document_id: The unique identifier of the document
            body: Request body.
            timeout: Override the default request timeout (seconds).

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 429, 500, 503).

        Note:
            This is a long-running operation (HTTP 202). Use
            ``await client.wait(response).result_async()`` to poll until completion.
        """
        return await self._client.request_async(
            "PATCH",
            self._api,
            "/documents/{documentId}",
            path_params={
                "documentId": document_id,
            },
            json_body=body,
            timeout=timeout,
        )

    def get_document_by_id(
        self,
        *,
        document_id: str,
        expand: Optional[str] = None,
        timeout: Optional[float] = None,
    ) -> Document:
        """Retrieve a single document

        Retrieves a [document](ref:documents#document) given its ID.

        Args:
            document_id: The unique identifier of the document
            expand: Returns related resources inline with the main resource
            timeout: Override the default request timeout (seconds).

        Returns:
            Document

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 429, 500, 503).
        """
        response = self._client.request(
            "GET",
            self._api,
            "/documents/{documentId}",
            path_params={
                "documentId": document_id,
            },
            query_params={
                "$expand": expand,
            },
            timeout=timeout,
        )
        return Document.model_validate(response.json())

    async def get_document_by_id_async(
        self,
        *,
        document_id: str,
        expand: Optional[str] = None,
        timeout: Optional[float] = None,
    ) -> Document:
        """Retrieve a single document (async)

        Retrieves a [document](ref:documents#document) given its ID.

        Args:
            document_id: The unique identifier of the document
            expand: Returns related resources inline with the main resource
            timeout: Override the default request timeout (seconds).

        Returns:
            Document

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 429, 500, 503).
        """
        response = await self._client.request_async(
            "GET",
            self._api,
            "/documents/{documentId}",
            path_params={
                "documentId": document_id,
            },
            query_params={
                "$expand": expand,
            },
            timeout=timeout,
        )
        return Document.model_validate(response.json())

    def document_export(
        self,
        *,
        document_id: str,
        format_: Literal["pdf", "docx", "xhtml"],
        docx_options: Optional[DocumentToDocxOptions] = None,
        pdf_options: Optional[DocumentToPdfOptions] = None,
        sections: Optional[list[str]] = None,
        xhtml_options: Optional[DocumentToXhtmlOptions] = None,
        timeout: Optional[float] = None,
    ) -> httpx.Response:
        """Initiate a document export

        Asynchronously exports a [document](ref:documents#document) as .PDF or
        .DOCX., or .XHTML. Options are specified using a
        [DocumentExport](ref:documents#documentexport) object.
        When exporting XHTML that you plan to edit or modify, use the
        `editableXhtml` option. Otherwise, the export retains fidelity so it
        visually matches the document as it appears in the browser.
        Responses include a `Location` header, which indicates where to poll for
        export results. For more details on long-running job polling, see
        [Operations endpoint](ref:getoperationbyid). When the export completes,
        its status will be `completed`, and the response body includes a
        `resourceURL`. To download the exported file, perform a GET on the
        `resourceURL` with the same authentication credentials and flow as the
        export request. For more details, see [Authentication
        documentation](ref:authentication).

        Args:
            document_id: The unique identifier of the document
            format_: The file format to export the document as.
            docx_options:
            pdf_options:
            sections: The IDs of the sections of the document to export. Omit to export the entire document.
            xhtml_options:
            timeout: Override the default request timeout (seconds).

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 429, 500, 503).

        Note:
            This is a long-running operation (HTTP 202). Use
            ``client.wait(response).result()`` to poll until completion.
        """
        _body: dict[str, Any] = {}
        if format_ is not None:
            _body["format"] = format_
        if docx_options is not None:
            _body["docxOptions"] = docx_options
        if pdf_options is not None:
            _body["pdfOptions"] = pdf_options
        if sections is not None:
            _body["sections"] = sections
        if xhtml_options is not None:
            _body["xhtmlOptions"] = xhtml_options
        return self._client.request(
            "POST",
            self._api,
            "/documents/{documentId}/export",
            path_params={
                "documentId": document_id,
            },
            json_body=_body or None,
            timeout=timeout,
        )

    async def document_export_async(
        self,
        *,
        document_id: str,
        format_: Literal["pdf", "docx", "xhtml"],
        docx_options: Optional[DocumentToDocxOptions] = None,
        pdf_options: Optional[DocumentToPdfOptions] = None,
        sections: Optional[list[str]] = None,
        xhtml_options: Optional[DocumentToXhtmlOptions] = None,
        timeout: Optional[float] = None,
    ) -> httpx.Response:
        """Initiate a document export (async)

        Asynchronously exports a [document](ref:documents#document) as .PDF or
        .DOCX., or .XHTML. Options are specified using a
        [DocumentExport](ref:documents#documentexport) object.
        When exporting XHTML that you plan to edit or modify, use the
        `editableXhtml` option. Otherwise, the export retains fidelity so it
        visually matches the document as it appears in the browser.
        Responses include a `Location` header, which indicates where to poll for
        export results. For more details on long-running job polling, see
        [Operations endpoint](ref:getoperationbyid). When the export completes,
        its status will be `completed`, and the response body includes a
        `resourceURL`. To download the exported file, perform a GET on the
        `resourceURL` with the same authentication credentials and flow as the
        export request. For more details, see [Authentication
        documentation](ref:authentication).

        Args:
            document_id: The unique identifier of the document
            format_: The file format to export the document as.
            docx_options:
            pdf_options:
            sections: The IDs of the sections of the document to export. Omit to export the entire document.
            xhtml_options:
            timeout: Override the default request timeout (seconds).

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 429, 500, 503).

        Note:
            This is a long-running operation (HTTP 202). Use
            ``await client.wait(response).result_async()`` to poll until completion.
        """
        _body: dict[str, Any] = {}
        if format_ is not None:
            _body["format"] = format_
        if docx_options is not None:
            _body["docxOptions"] = docx_options
        if pdf_options is not None:
            _body["pdfOptions"] = pdf_options
        if sections is not None:
            _body["sections"] = sections
        if xhtml_options is not None:
            _body["xhtmlOptions"] = xhtml_options
        return await self._client.request_async(
            "POST",
            self._api,
            "/documents/{documentId}/export",
            path_params={
                "documentId": document_id,
            },
            json_body=_body or None,
            timeout=timeout,
        )

    def document_filters_reapplication(
        self,
        *,
        document_id: str,
        force_hide_footnotes: Optional[bool] = None,
        ignore_non_editable_filters: Optional[bool] = None,
        timeout: Optional[float] = None,
    ) -> httpx.Response:
        """Reapply filters to the document

        Performs a [`DocumentFiltersReapplication`](ref:content#documentfiltersr
        eapplication) on the specified document.
        This endpoint is used to refresh the document's filters based on the
        latest state or configuration changes.
        The filters are reapplied in the context of the document's current data
        state.

        This is a long-running operation. Responses include a `Location` header,
        which indicates where to poll for results.
        For more details on long-running job polling, see [Operations
        endpoint](ref:getoperationbyid).

        Args:
            document_id: The unique identifier of the document
            force_hide_footnotes: Whether filters should be reapplied if doing so would cause footnotes to be hidden.
            ignore_non_editable_filters: Skip filters that cannot be reapplied (due to not having edit permissions or locked sections) instead of returning an error.
            timeout: Override the default request timeout (seconds).

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 429, 500, 503).

        Note:
            This is a long-running operation (HTTP 202). Use
            ``client.wait(response).result()`` to poll until completion.
        """
        _body: dict[str, Any] = {}
        if force_hide_footnotes is not None:
            _body["forceHideFootnotes"] = force_hide_footnotes
        if ignore_non_editable_filters is not None:
            _body["ignoreNonEditableFilters"] = ignore_non_editable_filters
        return self._client.request(
            "POST",
            self._api,
            "/documents/{documentId}/filters/reapplication",
            path_params={
                "documentId": document_id,
            },
            json_body=_body or None,
            timeout=timeout,
        )

    async def document_filters_reapplication_async(
        self,
        *,
        document_id: str,
        force_hide_footnotes: Optional[bool] = None,
        ignore_non_editable_filters: Optional[bool] = None,
        timeout: Optional[float] = None,
    ) -> httpx.Response:
        """Reapply filters to the document (async)

        Performs a [`DocumentFiltersReapplication`](ref:content#documentfiltersr
        eapplication) on the specified document.
        This endpoint is used to refresh the document's filters based on the
        latest state or configuration changes.
        The filters are reapplied in the context of the document's current data
        state.

        This is a long-running operation. Responses include a `Location` header,
        which indicates where to poll for results.
        For more details on long-running job polling, see [Operations
        endpoint](ref:getoperationbyid).

        Args:
            document_id: The unique identifier of the document
            force_hide_footnotes: Whether filters should be reapplied if doing so would cause footnotes to be hidden.
            ignore_non_editable_filters: Skip filters that cannot be reapplied (due to not having edit permissions or locked sections) instead of returning an error.
            timeout: Override the default request timeout (seconds).

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 429, 500, 503).

        Note:
            This is a long-running operation (HTTP 202). Use
            ``await client.wait(response).result_async()`` to poll until completion.
        """
        _body: dict[str, Any] = {}
        if force_hide_footnotes is not None:
            _body["forceHideFootnotes"] = force_hide_footnotes
        if ignore_non_editable_filters is not None:
            _body["ignoreNonEditableFilters"] = ignore_non_editable_filters
        return await self._client.request_async(
            "POST",
            self._api,
            "/documents/{documentId}/filters/reapplication",
            path_params={
                "documentId": document_id,
            },
            json_body=_body or None,
            timeout=timeout,
        )

    def document_links_publication(
        self,
        *,
        document_id: str,
        publish_type: Literal["ownLinks", "allLinks"],
        timeout: Optional[float] = None,
    ) -> httpx.Response:
        """Initiate publication of links in a document

        Publishes the links in a document - either all (as document owner) or
        only one's own. Content at the latest document revision will be used for
        publish.
        The response also includes a `Location` header, which indicates where to
        poll for operation results. For more details on long-running job
        polling, see [Operations endpoint](ref:getoperationbyid).

        Args:
            document_id: The unique identifier of the document
            publish_type: Whether or not all links should be published. When "ownLinks" only links one has last edited are published. When "allLinks" all links in document or presentation are published.

            timeout: Override the default request timeout (seconds).

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 429, 500, 503).

        Note:
            This is a long-running operation (HTTP 202). Use
            ``client.wait(response).result()`` to poll until completion.
        """
        _body: dict[str, Any] = {}
        if publish_type is not None:
            _body["publishType"] = publish_type
        return self._client.request(
            "POST",
            self._api,
            "/documents/{documentId}/links/publication",
            path_params={
                "documentId": document_id,
            },
            json_body=_body or None,
            timeout=timeout,
        )

    async def document_links_publication_async(
        self,
        *,
        document_id: str,
        publish_type: Literal["ownLinks", "allLinks"],
        timeout: Optional[float] = None,
    ) -> httpx.Response:
        """Initiate publication of links in a document (async)

        Publishes the links in a document - either all (as document owner) or
        only one's own. Content at the latest document revision will be used for
        publish.
        The response also includes a `Location` header, which indicates where to
        poll for operation results. For more details on long-running job
        polling, see [Operations endpoint](ref:getoperationbyid).

        Args:
            document_id: The unique identifier of the document
            publish_type: Whether or not all links should be published. When "ownLinks" only links one has last edited are published. When "allLinks" all links in document or presentation are published.

            timeout: Override the default request timeout (seconds).

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 429, 500, 503).

        Note:
            This is a long-running operation (HTTP 202). Use
            ``await client.wait(response).result_async()`` to poll until completion.
        """
        _body: dict[str, Any] = {}
        if publish_type is not None:
            _body["publishType"] = publish_type
        return await self._client.request_async(
            "POST",
            self._api,
            "/documents/{documentId}/links/publication",
            path_params={
                "documentId": document_id,
            },
            json_body=_body or None,
            timeout=timeout,
        )

    def get_document_milestones(
        self,
        *,
        document_id: str,
        timeout: Optional[float] = None,
    ) -> MilestoneListResult:
        """Retrieve a list of milestones for a document

        Returns [MilestoneListResult](ref:milestones#milestonelistresult).

        Args:
            document_id: The unique identifier of the document
            timeout: Override the default request timeout (seconds).

        Returns:
            MilestoneListResult

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 429, 500, 503).
        """

        def _fetch(_cursor: str | None) -> httpx.Response:
            return self._client.request(
                "GET",
                self._api,
                "/documents/{documentId}/milestones",
                path_params={
                    "documentId": document_id,
                },
                query_params={
                    "$next": _cursor,
                },
                timeout=timeout,
            )

        _body_result = paginate_all(_fetch, extract_next_link, "data")
        return MilestoneListResult.model_validate(_body_result)

    async def get_document_milestones_async(
        self,
        *,
        document_id: str,
        timeout: Optional[float] = None,
    ) -> MilestoneListResult:
        """Retrieve a list of milestones for a document (async)

        Returns [MilestoneListResult](ref:milestones#milestonelistresult).

        Args:
            document_id: The unique identifier of the document
            timeout: Override the default request timeout (seconds).

        Returns:
            MilestoneListResult

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 429, 500, 503).
        """

        async def _fetch(_cursor: str | None) -> httpx.Response:
            return await self._client.request_async(
                "GET",
                self._api,
                "/documents/{documentId}/milestones",
                path_params={
                    "documentId": document_id,
                },
                query_params={
                    "$next": _cursor,
                },
                timeout=timeout,
            )

        _body_result = await paginate_all_async(_fetch, extract_next_link, "data")
        return MilestoneListResult.model_validate(_body_result)

    def get_document_permissions(
        self,
        *,
        document_id: str,
        filter_: Optional[str] = None,
        maxpagesize: Optional[int] = 1000,
        timeout: Optional[float] = None,
    ) -> ResourcePermissionsListResult:
        """Retrieve permissions for a document

        Retrieves a paginated list of permissions for a given document

        Args:
            document_id: The unique identifier of the document
            filter_: The properties to filter the results by.
            maxpagesize: The maximum number of results to retrieve
            timeout: Override the default request timeout (seconds).

        Returns:
            ResourcePermissionsListResult

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 429, 500, 503).
        """

        def _fetch(_cursor: str | None) -> httpx.Response:
            return self._client.request(
                "GET",
                self._api,
                "/documents/{documentId}/permissions",
                path_params={
                    "documentId": document_id,
                },
                query_params={
                    "$filter": filter_,
                    "$maxpagesize": maxpagesize,
                    "$next": _cursor,
                },
                timeout=timeout,
            )

        _body_result = paginate_all(_fetch, extract_next_link, "data")
        return ResourcePermissionsListResult.model_validate(_body_result)

    async def get_document_permissions_async(
        self,
        *,
        document_id: str,
        filter_: Optional[str] = None,
        maxpagesize: Optional[int] = 1000,
        timeout: Optional[float] = None,
    ) -> ResourcePermissionsListResult:
        """Retrieve permissions for a document (async)

        Retrieves a paginated list of permissions for a given document

        Args:
            document_id: The unique identifier of the document
            filter_: The properties to filter the results by.
            maxpagesize: The maximum number of results to retrieve
            timeout: Override the default request timeout (seconds).

        Returns:
            ResourcePermissionsListResult

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 429, 500, 503).
        """

        async def _fetch(_cursor: str | None) -> httpx.Response:
            return await self._client.request_async(
                "GET",
                self._api,
                "/documents/{documentId}/permissions",
                path_params={
                    "documentId": document_id,
                },
                query_params={
                    "$filter": filter_,
                    "$maxpagesize": maxpagesize,
                    "$next": _cursor,
                },
                timeout=timeout,
            )

        _body_result = await paginate_all_async(_fetch, extract_next_link, "data")
        return ResourcePermissionsListResult.model_validate(_body_result)

    def document_permissions_modification(
        self,
        *,
        document_id: str,
        to_assign: Optional[list[ResourcePermission]] = None,
        to_revoke: Optional[list[ResourcePermission]] = None,
        timeout: Optional[float] = None,
    ) -> httpx.Response:
        """Modify permissions on a document

        Assign and/or revoke permissions on a document. If any modification in a
        request fails, all modifications on that request fail. <br /><br /> _To
        modify an existing permission, the existing permission must first be
        explicitly revoked. Then, the new permission needs to be assigned. This
        can be done in a single request by sending `toAssign` and `toRevoke` in
        the request body._

        Args:
            document_id: The unique identifier of the document
            to_assign: The list of permissions to be assigned to the resource
            to_revoke: The list of permissions to be revoked from the resource
            timeout: Override the default request timeout (seconds).

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 429, 500, 503).
        """
        _body: dict[str, Any] = {}
        if to_assign is not None:
            _body["toAssign"] = to_assign
        if to_revoke is not None:
            _body["toRevoke"] = to_revoke
        return self._client.request(
            "POST",
            self._api,
            "/documents/{documentId}/permissions/modification",
            path_params={
                "documentId": document_id,
            },
            json_body=_body or None,
            timeout=timeout,
        )

    async def document_permissions_modification_async(
        self,
        *,
        document_id: str,
        to_assign: Optional[list[ResourcePermission]] = None,
        to_revoke: Optional[list[ResourcePermission]] = None,
        timeout: Optional[float] = None,
    ) -> httpx.Response:
        """Modify permissions on a document (async)

        Assign and/or revoke permissions on a document. If any modification in a
        request fails, all modifications on that request fail. <br /><br /> _To
        modify an existing permission, the existing permission must first be
        explicitly revoked. Then, the new permission needs to be assigned. This
        can be done in a single request by sending `toAssign` and `toRevoke` in
        the request body._

        Args:
            document_id: The unique identifier of the document
            to_assign: The list of permissions to be assigned to the resource
            to_revoke: The list of permissions to be revoked from the resource
            timeout: Override the default request timeout (seconds).

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 429, 500, 503).
        """
        _body: dict[str, Any] = {}
        if to_assign is not None:
            _body["toAssign"] = to_assign
        if to_revoke is not None:
            _body["toRevoke"] = to_revoke
        return await self._client.request_async(
            "POST",
            self._api,
            "/documents/{documentId}/permissions/modification",
            path_params={
                "documentId": document_id,
            },
            json_body=_body or None,
            timeout=timeout,
        )

    def create_section(
        self,
        *,
        document_id: str,
        custom_fields: Optional[dict[str, Any]] = None,
        id_: Optional[str] = None,
        index: Optional[int] = None,
        lock: Optional[str] = None,
        name: Optional[str] = None,
        non_printing: Optional[bool] = None,
        parent: Optional[Section] = None,
        timeout: Optional[float] = None,
    ) -> Section:
        """Create a new section in a document

        Creates a new [section](ref:documents#section) in a
        [document](ref:documents#document), given its properties. By default,
        the new section appears at the top-most position.

        Args:
            document_id: The unique identifier of the document
            custom_fields: A map of ids to values representing Custom Fields on the section.

            id_: The unique identifier of the section
            index: The integer index of the section relative to its parent section (or to the document if no parent section). The special value -1 may be used to position a section at the end of its siblings list.
            lock: The type of lock applied to this section, if any. Note this property is not tied to revision and will always reflect the section's current lock state.
            name: The name of the section
            non_printing: Whether or not the section is non-printing
            parent:
            timeout: Override the default request timeout (seconds).

        Returns:
            Section

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 429, 500, 503).
        """
        _body: dict[str, Any] = {}
        if custom_fields is not None:
            _body["customFields"] = custom_fields
        if id_ is not None:
            _body["id"] = id_
        if index is not None:
            _body["index"] = index
        if lock is not None:
            _body["lock"] = lock
        if name is not None:
            _body["name"] = name
        if non_printing is not None:
            _body["nonPrinting"] = non_printing
        if parent is not None:
            _body["parent"] = parent
        response = self._client.request(
            "POST",
            self._api,
            "/documents/{documentId}/sections",
            path_params={
                "documentId": document_id,
            },
            json_body=_body or None,
            timeout=timeout,
        )
        return Section.model_validate(response.json())

    async def create_section_async(
        self,
        *,
        document_id: str,
        custom_fields: Optional[dict[str, Any]] = None,
        id_: Optional[str] = None,
        index: Optional[int] = None,
        lock: Optional[str] = None,
        name: Optional[str] = None,
        non_printing: Optional[bool] = None,
        parent: Optional[Section] = None,
        timeout: Optional[float] = None,
    ) -> Section:
        """Create a new section in a document (async)

        Creates a new [section](ref:documents#section) in a
        [document](ref:documents#document), given its properties. By default,
        the new section appears at the top-most position.

        Args:
            document_id: The unique identifier of the document
            custom_fields: A map of ids to values representing Custom Fields on the section.

            id_: The unique identifier of the section
            index: The integer index of the section relative to its parent section (or to the document if no parent section). The special value -1 may be used to position a section at the end of its siblings list.
            lock: The type of lock applied to this section, if any. Note this property is not tied to revision and will always reflect the section's current lock state.
            name: The name of the section
            non_printing: Whether or not the section is non-printing
            parent:
            timeout: Override the default request timeout (seconds).

        Returns:
            Section

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 429, 500, 503).
        """
        _body: dict[str, Any] = {}
        if custom_fields is not None:
            _body["customFields"] = custom_fields
        if id_ is not None:
            _body["id"] = id_
        if index is not None:
            _body["index"] = index
        if lock is not None:
            _body["lock"] = lock
        if name is not None:
            _body["name"] = name
        if non_printing is not None:
            _body["nonPrinting"] = non_printing
        if parent is not None:
            _body["parent"] = parent
        response = await self._client.request_async(
            "POST",
            self._api,
            "/documents/{documentId}/sections",
            path_params={
                "documentId": document_id,
            },
            json_body=_body or None,
            timeout=timeout,
        )
        return Section.model_validate(response.json())

    def get_sections(
        self,
        *,
        document_id: str,
        revision: Optional[str] = None,
        maxpagesize: Optional[int] = 1000,
        timeout: Optional[float] = None,
    ) -> SectionsListResult:
        """Retrieve a list of sections

        Returns a list of [sections](ref:documents#section).

        Args:
            document_id: The unique identifier of the document
            revision: Returns resources at a specific revision
            maxpagesize: The maximum number of results to retrieve
            timeout: Override the default request timeout (seconds).

        Returns:
            SectionsListResult

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 429, 500, 503).
        """

        def _fetch(_cursor: str | None) -> httpx.Response:
            return self._client.request(
                "GET",
                self._api,
                "/documents/{documentId}/sections",
                path_params={
                    "documentId": document_id,
                },
                query_params={
                    "$revision": revision,
                    "$maxpagesize": maxpagesize,
                    "$next": _cursor,
                },
                timeout=timeout,
            )

        _body_result = paginate_all(_fetch, extract_next_link, "data")
        return SectionsListResult.model_validate(_body_result)

    async def get_sections_async(
        self,
        *,
        document_id: str,
        revision: Optional[str] = None,
        maxpagesize: Optional[int] = 1000,
        timeout: Optional[float] = None,
    ) -> SectionsListResult:
        """Retrieve a list of sections (async)

        Returns a list of [sections](ref:documents#section).

        Args:
            document_id: The unique identifier of the document
            revision: Returns resources at a specific revision
            maxpagesize: The maximum number of results to retrieve
            timeout: Override the default request timeout (seconds).

        Returns:
            SectionsListResult

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 429, 500, 503).
        """

        async def _fetch(_cursor: str | None) -> httpx.Response:
            return await self._client.request_async(
                "GET",
                self._api,
                "/documents/{documentId}/sections",
                path_params={
                    "documentId": document_id,
                },
                query_params={
                    "$revision": revision,
                    "$maxpagesize": maxpagesize,
                    "$next": _cursor,
                },
                timeout=timeout,
            )

        _body_result = await paginate_all_async(_fetch, extract_next_link, "data")
        return SectionsListResult.model_validate(_body_result)

    def partially_update_section_by_id(
        self,
        *,
        document_id: str,
        section_id: str,
        body: list[Any],
        timeout: Optional[float] = None,
    ) -> httpx.Response:
        """Partially update a single section

        Updates the properties of a [section](ref:documents#section).

        This is a long running operation. Responses include a `Location` header,
        which indicates where to poll for results. For more details on long-
        running job polling,
        see [Operations endpoint](ref:getoperationbyid).

        ### Options

        | Path                                     | PATCH Operations Supported
        |
        |------------------------------------------|----------------------------
        --------|
        | `/name`                                  | `replace`
        |
        | `/parent`                                | `replace`
        |
        | `/parent/id`                             | `replace`
        |
        | `/index`                                 | `replace`
        |
        | `/nonPrinting`                           | `replace`
        |
        | `/customFields`                          | `add`, `remove`, `replace`,
        `test` |
        | `/customFields/<customFieldId>`          | `add`, `remove`, `replace`,
        `test` |
        | `/lock`                                  | `replace`
        |
        | `/properties/margins/top`                | `replace`
        |
        | `/properties/margins/bottom`             | `replace`
        |
        | `/properties/margins/right`              | `replace`
        |
        | `/properties/margins/left`               | `replace`
        |
        | `/properties/pageBreakBefore`            | `replace`
        |
        | `/properties/exhibit`                    | `replace`
        |
        | `/properties/edgarKeepTogether`          | `replace`
        |
        | `/properties/pageNumber/reset`           | `replace`
        |
        | `/properties/pageNumber/startAt`         | `replace`
        |
        | `/properties/background/color`           | `replace`
        |
        | `/properties/background/image`           | `replace`
        |
        | `/properties/restartFootnoteNumbering`   | `replace`
        |
        | `/properties/header/alternatingPage`     | `replace`
        |
        | `/properties/header/differentFirstPage`  | `replace`
        |
        | `/properties/header/differentLastPage`   | `replace`
        |
        | `/properties/header/margin/right`        | `replace`
        |
        | `/properties/header/margin/left`         | `replace`
        |
        | `/properties/header/matchSectionMargins` | `replace`
        |
        | `/properties/header/positionFromTop`     | `replace`
        |
        | `/properties/header/sameAsPrevious`      | `replace`
        |
        | `/properties/footer/alternatingPage`     | `replace`
        |
        | `/properties/footer/differentFirstPage`  | `replace`
        |
        | `/properties/footer/differentLastPage`   | `replace`
        |
        | `/properties/footer/margin/right`        | `replace`
        |
        | `/properties/footer/margin/left`         | `replace`
        |
        | `/properties/footer/matchSectionMargins` | `replace`
        |
        | `/properties/footer/positionFromBottom`  | `replace`
        |
        | `/properties/footer/sameAsPrevious`      | `replace`
        |

        ### Examples

        #### Update the name of a section

        ```json
        [
          {
            "op": "replace",
            "path": "/name",
            "value": "Introduction"
          }
        ]
        ```

        #### Update the parent of a section (preserving its index)

        ```json
        [
          {
            "op": "replace",
            "path": "/parent",
            "value": {
              "id": "b9b3ddb587744a27aafda3c9865f1f0a_1"
            }
          }
        ]
        ```

        #### Update the parent of a section (making it the first child)

        ```json
        [
          {
            "op": "replace",
            "path": "/parent",
            "value": {
              "id": "b9b3ddb587744a27aafda3c9865f1f0a_1"
            }
          },
          {
            "op": "replace",
            "path": "/index",
            "value": 0
          }
        ]
        ```

        #### Add a custom field value
        ```json

        [
          {
            "op": "add",
            "path": "/customFields/com.workiva.gsr.legal_entity",
            "value": "Workiva"
          }
        ]
        ```

        #### Remove a custom field value

        ```json
        [
          {
            "op": "remove",
            "path": "/customFields/com.workiva.gsr.legal_entity"
          }
        ]
        ```

        #### Replace a custom field value
        ```json

        [
          {
            "op": "replace",
            "path": "/customFields/com.workiva.gsr.legal_entity",
            "value": "Workiva, Inc."
          }
        ]
        ```

        Args:
            document_id: The unique identifier of the document
            section_id: The unique identifier of the section
            body: Request body.
            timeout: Override the default request timeout (seconds).

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 429, 500, 503).

        Note:
            This is a long-running operation (HTTP 202). Use
            ``client.wait(response).result()`` to poll until completion.
        """
        return self._client.request(
            "PATCH",
            self._api,
            "/documents/{documentId}/sections/{sectionId}",
            path_params={
                "documentId": document_id,
                "sectionId": section_id,
            },
            json_body=body,
            timeout=timeout,
        )

    async def partially_update_section_by_id_async(
        self,
        *,
        document_id: str,
        section_id: str,
        body: list[Any],
        timeout: Optional[float] = None,
    ) -> httpx.Response:
        """Partially update a single section (async)

        Updates the properties of a [section](ref:documents#section).

        This is a long running operation. Responses include a `Location` header,
        which indicates where to poll for results. For more details on long-
        running job polling,
        see [Operations endpoint](ref:getoperationbyid).

        ### Options

        | Path                                     | PATCH Operations Supported
        |
        |------------------------------------------|----------------------------
        --------|
        | `/name`                                  | `replace`
        |
        | `/parent`                                | `replace`
        |
        | `/parent/id`                             | `replace`
        |
        | `/index`                                 | `replace`
        |
        | `/nonPrinting`                           | `replace`
        |
        | `/customFields`                          | `add`, `remove`, `replace`,
        `test` |
        | `/customFields/<customFieldId>`          | `add`, `remove`, `replace`,
        `test` |
        | `/lock`                                  | `replace`
        |
        | `/properties/margins/top`                | `replace`
        |
        | `/properties/margins/bottom`             | `replace`
        |
        | `/properties/margins/right`              | `replace`
        |
        | `/properties/margins/left`               | `replace`
        |
        | `/properties/pageBreakBefore`            | `replace`
        |
        | `/properties/exhibit`                    | `replace`
        |
        | `/properties/edgarKeepTogether`          | `replace`
        |
        | `/properties/pageNumber/reset`           | `replace`
        |
        | `/properties/pageNumber/startAt`         | `replace`
        |
        | `/properties/background/color`           | `replace`
        |
        | `/properties/background/image`           | `replace`
        |
        | `/properties/restartFootnoteNumbering`   | `replace`
        |
        | `/properties/header/alternatingPage`     | `replace`
        |
        | `/properties/header/differentFirstPage`  | `replace`
        |
        | `/properties/header/differentLastPage`   | `replace`
        |
        | `/properties/header/margin/right`        | `replace`
        |
        | `/properties/header/margin/left`         | `replace`
        |
        | `/properties/header/matchSectionMargins` | `replace`
        |
        | `/properties/header/positionFromTop`     | `replace`
        |
        | `/properties/header/sameAsPrevious`      | `replace`
        |
        | `/properties/footer/alternatingPage`     | `replace`
        |
        | `/properties/footer/differentFirstPage`  | `replace`
        |
        | `/properties/footer/differentLastPage`   | `replace`
        |
        | `/properties/footer/margin/right`        | `replace`
        |
        | `/properties/footer/margin/left`         | `replace`
        |
        | `/properties/footer/matchSectionMargins` | `replace`
        |
        | `/properties/footer/positionFromBottom`  | `replace`
        |
        | `/properties/footer/sameAsPrevious`      | `replace`
        |

        ### Examples

        #### Update the name of a section

        ```json
        [
          {
            "op": "replace",
            "path": "/name",
            "value": "Introduction"
          }
        ]
        ```

        #### Update the parent of a section (preserving its index)

        ```json
        [
          {
            "op": "replace",
            "path": "/parent",
            "value": {
              "id": "b9b3ddb587744a27aafda3c9865f1f0a_1"
            }
          }
        ]
        ```

        #### Update the parent of a section (making it the first child)

        ```json
        [
          {
            "op": "replace",
            "path": "/parent",
            "value": {
              "id": "b9b3ddb587744a27aafda3c9865f1f0a_1"
            }
          },
          {
            "op": "replace",
            "path": "/index",
            "value": 0
          }
        ]
        ```

        #### Add a custom field value
        ```json

        [
          {
            "op": "add",
            "path": "/customFields/com.workiva.gsr.legal_entity",
            "value": "Workiva"
          }
        ]
        ```

        #### Remove a custom field value

        ```json
        [
          {
            "op": "remove",
            "path": "/customFields/com.workiva.gsr.legal_entity"
          }
        ]
        ```

        #### Replace a custom field value
        ```json

        [
          {
            "op": "replace",
            "path": "/customFields/com.workiva.gsr.legal_entity",
            "value": "Workiva, Inc."
          }
        ]
        ```

        Args:
            document_id: The unique identifier of the document
            section_id: The unique identifier of the section
            body: Request body.
            timeout: Override the default request timeout (seconds).

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 429, 500, 503).

        Note:
            This is a long-running operation (HTTP 202). Use
            ``await client.wait(response).result_async()`` to poll until completion.
        """
        return await self._client.request_async(
            "PATCH",
            self._api,
            "/documents/{documentId}/sections/{sectionId}",
            path_params={
                "documentId": document_id,
                "sectionId": section_id,
            },
            json_body=body,
            timeout=timeout,
        )

    def delete_section_by_id(
        self,
        *,
        document_id: str,
        section_id: str,
        timeout: Optional[float] = None,
    ) -> httpx.Response:
        """Delete a single section

        Deletes a [section](ref:documents#section) given its ID.

        Args:
            document_id: The unique identifier of the document
            section_id: The unique identifier of the section
            timeout: Override the default request timeout (seconds).

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 429, 500, 503).
        """
        return self._client.request(
            "DELETE",
            self._api,
            "/documents/{documentId}/sections/{sectionId}",
            path_params={
                "documentId": document_id,
                "sectionId": section_id,
            },
            timeout=timeout,
        )

    async def delete_section_by_id_async(
        self,
        *,
        document_id: str,
        section_id: str,
        timeout: Optional[float] = None,
    ) -> httpx.Response:
        """Delete a single section (async)

        Deletes a [section](ref:documents#section) given its ID.

        Args:
            document_id: The unique identifier of the document
            section_id: The unique identifier of the section
            timeout: Override the default request timeout (seconds).

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 429, 500, 503).
        """
        return await self._client.request_async(
            "DELETE",
            self._api,
            "/documents/{documentId}/sections/{sectionId}",
            path_params={
                "documentId": document_id,
                "sectionId": section_id,
            },
            timeout=timeout,
        )

    def get_section_by_id(
        self,
        *,
        document_id: str,
        section_id: str,
        expand: Optional[str] = None,
        revision: Optional[str] = None,
        timeout: Optional[float] = None,
    ) -> Section:
        """Retrieve a single section

        Retrieves a [section](ref:documents#section) given its ID.

        Args:
            document_id: The unique identifier of the document
            section_id: The unique identifier of the section
            expand: Returns related resources inline with the main resource
            revision: Returns resources at a specific revision
            timeout: Override the default request timeout (seconds).

        Returns:
            Section

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 429, 500, 503).
        """
        response = self._client.request(
            "GET",
            self._api,
            "/documents/{documentId}/sections/{sectionId}",
            path_params={
                "documentId": document_id,
                "sectionId": section_id,
            },
            query_params={
                "$expand": expand,
                "$revision": revision,
            },
            timeout=timeout,
        )
        return Section.model_validate(response.json())

    async def get_section_by_id_async(
        self,
        *,
        document_id: str,
        section_id: str,
        expand: Optional[str] = None,
        revision: Optional[str] = None,
        timeout: Optional[float] = None,
    ) -> Section:
        """Retrieve a single section (async)

        Retrieves a [section](ref:documents#section) given its ID.

        Args:
            document_id: The unique identifier of the document
            section_id: The unique identifier of the section
            expand: Returns related resources inline with the main resource
            revision: Returns resources at a specific revision
            timeout: Override the default request timeout (seconds).

        Returns:
            Section

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 429, 500, 503).
        """
        response = await self._client.request_async(
            "GET",
            self._api,
            "/documents/{documentId}/sections/{sectionId}",
            path_params={
                "documentId": document_id,
                "sectionId": section_id,
            },
            query_params={
                "$expand": expand,
                "$revision": revision,
            },
            timeout=timeout,
        )
        return Section.model_validate(response.json())

    def copy_section(
        self,
        *,
        document_id: str,
        section_id: str,
        document: str,
        section_index: Optional[int] = None,
        section_name: Optional[str] = None,
        section_parent: Optional[str] = None,
        timeout: Optional[float] = None,
    ) -> httpx.Response:
        """Copy section

        Asynchronously copies a [section](ref:documents#section) given details
        about the copy's destination within the same or another document.
        Options are specified using a [SectionCopy](ref:documents#sectioncopy)
        object.

        Copies only the section's content â€” not any labels, comments, tasks, or
        formatting from a style guide. Unless otherwise specified, the copy
        appears at the top level of its destination document, with an index of
        0, and with the same name as the original section.

        Args:
            document_id: The unique identifier of the document
            section_id: The unique identifier of the section
            document: The unique identifier of the document to copy a section into
            section_index: The integer index of where within the siblings to place the new section; 0 by default. To place the section at the end of its siblings, use the special value -1.
            section_name: The name of the new section, if different than the source section
            section_parent: The ID of the parent section to copy the section into. To place the section at the top level of the document, use the default null.
            timeout: Override the default request timeout (seconds).

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 429, 500, 503).

        Note:
            This is a long-running operation (HTTP 202). Use
            ``client.wait(response).result()`` to poll until completion.
        """
        _body: dict[str, Any] = {}
        if document is not None:
            _body["document"] = document
        if section_index is not None:
            _body["sectionIndex"] = section_index
        if section_name is not None:
            _body["sectionName"] = section_name
        if section_parent is not None:
            _body["sectionParent"] = section_parent
        return self._client.request(
            "POST",
            self._api,
            "/documents/{documentId}/sections/{sectionId}/copy",
            path_params={
                "documentId": document_id,
                "sectionId": section_id,
            },
            json_body=_body or None,
            timeout=timeout,
        )

    async def copy_section_async(
        self,
        *,
        document_id: str,
        section_id: str,
        document: str,
        section_index: Optional[int] = None,
        section_name: Optional[str] = None,
        section_parent: Optional[str] = None,
        timeout: Optional[float] = None,
    ) -> httpx.Response:
        """Copy section (async)

        Asynchronously copies a [section](ref:documents#section) given details
        about the copy's destination within the same or another document.
        Options are specified using a [SectionCopy](ref:documents#sectioncopy)
        object.

        Copies only the section's content â€” not any labels, comments, tasks, or
        formatting from a style guide. Unless otherwise specified, the copy
        appears at the top level of its destination document, with an index of
        0, and with the same name as the original section.

        Args:
            document_id: The unique identifier of the document
            section_id: The unique identifier of the section
            document: The unique identifier of the document to copy a section into
            section_index: The integer index of where within the siblings to place the new section; 0 by default. To place the section at the end of its siblings, use the special value -1.
            section_name: The name of the new section, if different than the source section
            section_parent: The ID of the parent section to copy the section into. To place the section at the top level of the document, use the default null.
            timeout: Override the default request timeout (seconds).

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 429, 500, 503).

        Note:
            This is a long-running operation (HTTP 202). Use
            ``await client.wait(response).result_async()`` to poll until completion.
        """
        _body: dict[str, Any] = {}
        if document is not None:
            _body["document"] = document
        if section_index is not None:
            _body["sectionIndex"] = section_index
        if section_name is not None:
            _body["sectionName"] = section_name
        if section_parent is not None:
            _body["sectionParent"] = section_parent
        return await self._client.request_async(
            "POST",
            self._api,
            "/documents/{documentId}/sections/{sectionId}/copy",
            path_params={
                "documentId": document_id,
                "sectionId": section_id,
            },
            json_body=_body or None,
            timeout=timeout,
        )

    def edit_sections(
        self,
        *,
        document_id: str,
        data: list[SectionEdit],
        timeout: Optional[float] = None,
    ) -> httpx.Response:
        """Initiate sections edits

        Updates the properties of a collection of
        [sections](ref:documents#section) in a document using
        [SectionsEdits](ref:documents#sectionsedit) request. This is a long
        running operation.
        Responses include a `Location` header, which indicates where to poll for
        results. For more details on long-running job polling, see [Operations
        endpoint](ref:getoperationbyid). When the update completes, its status
        will be `completed`.

        Args:
            document_id: The unique identifier of the document
            data: The collection of edits
            timeout: Override the default request timeout (seconds).

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 429, 500, 503).

        Note:
            This is a long-running operation (HTTP 202). Use
            ``client.wait(response).result()`` to poll until completion.
        """
        _body: dict[str, Any] = {}
        if data is not None:
            _body["data"] = data
        return self._client.request(
            "POST",
            self._api,
            "/documents/{documentId}/sections/edit",
            path_params={
                "documentId": document_id,
            },
            json_body=_body or None,
            timeout=timeout,
        )

    async def edit_sections_async(
        self,
        *,
        document_id: str,
        data: list[SectionEdit],
        timeout: Optional[float] = None,
    ) -> httpx.Response:
        """Initiate sections edits (async)

        Updates the properties of a collection of
        [sections](ref:documents#section) in a document using
        [SectionsEdits](ref:documents#sectionsedit) request. This is a long
        running operation.
        Responses include a `Location` header, which indicates where to poll for
        results. For more details on long-running job polling, see [Operations
        endpoint](ref:getoperationbyid). When the update completes, its status
        will be `completed`.

        Args:
            document_id: The unique identifier of the document
            data: The collection of edits
            timeout: Override the default request timeout (seconds).

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 429, 500, 503).

        Note:
            This is a long-running operation (HTTP 202). Use
            ``await client.wait(response).result_async()`` to poll until completion.
        """
        _body: dict[str, Any] = {}
        if data is not None:
            _body["data"] = data
        return await self._client.request_async(
            "POST",
            self._api,
            "/documents/{documentId}/sections/edit",
            path_params={
                "documentId": document_id,
            },
            json_body=_body or None,
            timeout=timeout,
        )

    def get_section_permissions(
        self,
        *,
        document_id: str,
        section_id: str,
        filter_: Optional[str] = None,
        maxpagesize: Optional[int] = 1000,
        timeout: Optional[float] = None,
    ) -> ResourcePermissionsListResult:
        """Retrieve permissions for a section in a document

        Retrieves a paginated list of permissions for the given section in a
        document

        Args:
            document_id: The unique identifier of the document
            section_id: The unique identifier of the section
            filter_: The properties to filter the results by.
            maxpagesize: The maximum number of results to retrieve
            timeout: Override the default request timeout (seconds).

        Returns:
            ResourcePermissionsListResult

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 429, 500, 503).
        """

        def _fetch(_cursor: str | None) -> httpx.Response:
            return self._client.request(
                "GET",
                self._api,
                "/documents/{documentId}/sections/{sectionId}/permissions",
                path_params={
                    "documentId": document_id,
                    "sectionId": section_id,
                },
                query_params={
                    "$filter": filter_,
                    "$maxpagesize": maxpagesize,
                    "$next": _cursor,
                },
                timeout=timeout,
            )

        _body_result = paginate_all(_fetch, extract_next_link, "data")
        return ResourcePermissionsListResult.model_validate(_body_result)

    async def get_section_permissions_async(
        self,
        *,
        document_id: str,
        section_id: str,
        filter_: Optional[str] = None,
        maxpagesize: Optional[int] = 1000,
        timeout: Optional[float] = None,
    ) -> ResourcePermissionsListResult:
        """Retrieve permissions for a section in a document (async)

        Retrieves a paginated list of permissions for the given section in a
        document

        Args:
            document_id: The unique identifier of the document
            section_id: The unique identifier of the section
            filter_: The properties to filter the results by.
            maxpagesize: The maximum number of results to retrieve
            timeout: Override the default request timeout (seconds).

        Returns:
            ResourcePermissionsListResult

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 429, 500, 503).
        """

        async def _fetch(_cursor: str | None) -> httpx.Response:
            return await self._client.request_async(
                "GET",
                self._api,
                "/documents/{documentId}/sections/{sectionId}/permissions",
                path_params={
                    "documentId": document_id,
                    "sectionId": section_id,
                },
                query_params={
                    "$filter": filter_,
                    "$maxpagesize": maxpagesize,
                    "$next": _cursor,
                },
                timeout=timeout,
            )

        _body_result = await paginate_all_async(_fetch, extract_next_link, "data")
        return ResourcePermissionsListResult.model_validate(_body_result)

    def section_permissions_modification(
        self,
        *,
        document_id: str,
        section_id: str,
        to_assign: Optional[list[ResourcePermission]] = None,
        to_revoke: Optional[list[ResourcePermission]] = None,
        timeout: Optional[float] = None,
    ) -> httpx.Response:
        """Modify permissions on a given section of a document

        Assign and/or revoke permissions on a section. If any modification in a
        request fails, all modifications on that request fail. <br /><br /> _To
        modify an existing permission, the existing permission must first be
        explicitly revoked. Then, the new permission needs to be assigned. This
        can be done in a single request by sending `toAssign` and `toRevoke` in
        the request body._

        Args:
            document_id: The unique identifier of the document
            section_id: The unique identifier of the section
            to_assign: The list of permissions to be assigned to the resource
            to_revoke: The list of permissions to be revoked from the resource
            timeout: Override the default request timeout (seconds).

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 429, 500, 503).
        """
        _body: dict[str, Any] = {}
        if to_assign is not None:
            _body["toAssign"] = to_assign
        if to_revoke is not None:
            _body["toRevoke"] = to_revoke
        return self._client.request(
            "POST",
            self._api,
            "/documents/{documentId}/sections/{sectionId}/permissions/modification",
            path_params={
                "documentId": document_id,
                "sectionId": section_id,
            },
            json_body=_body or None,
            timeout=timeout,
        )

    async def section_permissions_modification_async(
        self,
        *,
        document_id: str,
        section_id: str,
        to_assign: Optional[list[ResourcePermission]] = None,
        to_revoke: Optional[list[ResourcePermission]] = None,
        timeout: Optional[float] = None,
    ) -> httpx.Response:
        """Modify permissions on a given section of a document (async)

        Assign and/or revoke permissions on a section. If any modification in a
        request fails, all modifications on that request fail. <br /><br /> _To
        modify an existing permission, the existing permission must first be
        explicitly revoked. Then, the new permission needs to be assigned. This
        can be done in a single request by sending `toAssign` and `toRevoke` in
        the request body._

        Args:
            document_id: The unique identifier of the document
            section_id: The unique identifier of the section
            to_assign: The list of permissions to be assigned to the resource
            to_revoke: The list of permissions to be revoked from the resource
            timeout: Override the default request timeout (seconds).

        Raises:
            WorkivaAPIError: On API errors (400, 401, 403, 404, 409, 429, 500, 503).
        """
        _body: dict[str, Any] = {}
        if to_assign is not None:
            _body["toAssign"] = to_assign
        if to_revoke is not None:
            _body["toRevoke"] = to_revoke
        return await self._client.request_async(
            "POST",
            self._api,
            "/documents/{documentId}/sections/{sectionId}/permissions/modification",
            path_params={
                "documentId": document_id,
                "sectionId": section_id,
            },
            json_body=_body or None,
            timeout=timeout,
        )
